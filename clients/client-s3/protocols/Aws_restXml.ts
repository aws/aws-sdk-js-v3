import {
  AbortMultipartUploadCommandInput,
  AbortMultipartUploadCommandOutput
} from "../commands/AbortMultipartUploadCommand";
import {
  CompleteMultipartUploadCommandInput,
  CompleteMultipartUploadCommandOutput
} from "../commands/CompleteMultipartUploadCommand";
import {
  CopyObjectCommandInput,
  CopyObjectCommandOutput
} from "../commands/CopyObjectCommand";
import {
  CreateBucketCommandInput,
  CreateBucketCommandOutput
} from "../commands/CreateBucketCommand";
import {
  CreateMultipartUploadCommandInput,
  CreateMultipartUploadCommandOutput
} from "../commands/CreateMultipartUploadCommand";
import {
  DeleteBucketAnalyticsConfigurationCommandInput,
  DeleteBucketAnalyticsConfigurationCommandOutput
} from "../commands/DeleteBucketAnalyticsConfigurationCommand";
import {
  DeleteBucketCommandInput,
  DeleteBucketCommandOutput
} from "../commands/DeleteBucketCommand";
import {
  DeleteBucketCorsCommandInput,
  DeleteBucketCorsCommandOutput
} from "../commands/DeleteBucketCorsCommand";
import {
  DeleteBucketEncryptionCommandInput,
  DeleteBucketEncryptionCommandOutput
} from "../commands/DeleteBucketEncryptionCommand";
import {
  DeleteBucketInventoryConfigurationCommandInput,
  DeleteBucketInventoryConfigurationCommandOutput
} from "../commands/DeleteBucketInventoryConfigurationCommand";
import {
  DeleteBucketLifecycleCommandInput,
  DeleteBucketLifecycleCommandOutput
} from "../commands/DeleteBucketLifecycleCommand";
import {
  DeleteBucketMetricsConfigurationCommandInput,
  DeleteBucketMetricsConfigurationCommandOutput
} from "../commands/DeleteBucketMetricsConfigurationCommand";
import {
  DeleteBucketPolicyCommandInput,
  DeleteBucketPolicyCommandOutput
} from "../commands/DeleteBucketPolicyCommand";
import {
  DeleteBucketReplicationCommandInput,
  DeleteBucketReplicationCommandOutput
} from "../commands/DeleteBucketReplicationCommand";
import {
  DeleteBucketTaggingCommandInput,
  DeleteBucketTaggingCommandOutput
} from "../commands/DeleteBucketTaggingCommand";
import {
  DeleteBucketWebsiteCommandInput,
  DeleteBucketWebsiteCommandOutput
} from "../commands/DeleteBucketWebsiteCommand";
import {
  DeleteObjectCommandInput,
  DeleteObjectCommandOutput
} from "../commands/DeleteObjectCommand";
import {
  DeleteObjectTaggingCommandInput,
  DeleteObjectTaggingCommandOutput
} from "../commands/DeleteObjectTaggingCommand";
import {
  DeleteObjectsCommandInput,
  DeleteObjectsCommandOutput
} from "../commands/DeleteObjectsCommand";
import {
  DeletePublicAccessBlockCommandInput,
  DeletePublicAccessBlockCommandOutput
} from "../commands/DeletePublicAccessBlockCommand";
import {
  GetBucketAccelerateConfigurationCommandInput,
  GetBucketAccelerateConfigurationCommandOutput
} from "../commands/GetBucketAccelerateConfigurationCommand";
import {
  GetBucketAclCommandInput,
  GetBucketAclCommandOutput
} from "../commands/GetBucketAclCommand";
import {
  GetBucketAnalyticsConfigurationCommandInput,
  GetBucketAnalyticsConfigurationCommandOutput
} from "../commands/GetBucketAnalyticsConfigurationCommand";
import {
  GetBucketCorsCommandInput,
  GetBucketCorsCommandOutput
} from "../commands/GetBucketCorsCommand";
import {
  GetBucketEncryptionCommandInput,
  GetBucketEncryptionCommandOutput
} from "../commands/GetBucketEncryptionCommand";
import {
  GetBucketInventoryConfigurationCommandInput,
  GetBucketInventoryConfigurationCommandOutput
} from "../commands/GetBucketInventoryConfigurationCommand";
import {
  GetBucketLifecycleConfigurationCommandInput,
  GetBucketLifecycleConfigurationCommandOutput
} from "../commands/GetBucketLifecycleConfigurationCommand";
import {
  GetBucketLocationCommandInput,
  GetBucketLocationCommandOutput
} from "../commands/GetBucketLocationCommand";
import {
  GetBucketLoggingCommandInput,
  GetBucketLoggingCommandOutput
} from "../commands/GetBucketLoggingCommand";
import {
  GetBucketMetricsConfigurationCommandInput,
  GetBucketMetricsConfigurationCommandOutput
} from "../commands/GetBucketMetricsConfigurationCommand";
import {
  GetBucketNotificationConfigurationCommandInput,
  GetBucketNotificationConfigurationCommandOutput
} from "../commands/GetBucketNotificationConfigurationCommand";
import {
  GetBucketPolicyCommandInput,
  GetBucketPolicyCommandOutput
} from "../commands/GetBucketPolicyCommand";
import {
  GetBucketPolicyStatusCommandInput,
  GetBucketPolicyStatusCommandOutput
} from "../commands/GetBucketPolicyStatusCommand";
import {
  GetBucketReplicationCommandInput,
  GetBucketReplicationCommandOutput
} from "../commands/GetBucketReplicationCommand";
import {
  GetBucketRequestPaymentCommandInput,
  GetBucketRequestPaymentCommandOutput
} from "../commands/GetBucketRequestPaymentCommand";
import {
  GetBucketTaggingCommandInput,
  GetBucketTaggingCommandOutput
} from "../commands/GetBucketTaggingCommand";
import {
  GetBucketVersioningCommandInput,
  GetBucketVersioningCommandOutput
} from "../commands/GetBucketVersioningCommand";
import {
  GetBucketWebsiteCommandInput,
  GetBucketWebsiteCommandOutput
} from "../commands/GetBucketWebsiteCommand";
import {
  GetObjectAclCommandInput,
  GetObjectAclCommandOutput
} from "../commands/GetObjectAclCommand";
import {
  GetObjectCommandInput,
  GetObjectCommandOutput
} from "../commands/GetObjectCommand";
import {
  GetObjectLegalHoldCommandInput,
  GetObjectLegalHoldCommandOutput
} from "../commands/GetObjectLegalHoldCommand";
import {
  GetObjectLockConfigurationCommandInput,
  GetObjectLockConfigurationCommandOutput
} from "../commands/GetObjectLockConfigurationCommand";
import {
  GetObjectRetentionCommandInput,
  GetObjectRetentionCommandOutput
} from "../commands/GetObjectRetentionCommand";
import {
  GetObjectTaggingCommandInput,
  GetObjectTaggingCommandOutput
} from "../commands/GetObjectTaggingCommand";
import {
  GetObjectTorrentCommandInput,
  GetObjectTorrentCommandOutput
} from "../commands/GetObjectTorrentCommand";
import {
  GetPublicAccessBlockCommandInput,
  GetPublicAccessBlockCommandOutput
} from "../commands/GetPublicAccessBlockCommand";
import {
  HeadBucketCommandInput,
  HeadBucketCommandOutput
} from "../commands/HeadBucketCommand";
import {
  HeadObjectCommandInput,
  HeadObjectCommandOutput
} from "../commands/HeadObjectCommand";
import {
  ListBucketAnalyticsConfigurationsCommandInput,
  ListBucketAnalyticsConfigurationsCommandOutput
} from "../commands/ListBucketAnalyticsConfigurationsCommand";
import {
  ListBucketInventoryConfigurationsCommandInput,
  ListBucketInventoryConfigurationsCommandOutput
} from "../commands/ListBucketInventoryConfigurationsCommand";
import {
  ListBucketMetricsConfigurationsCommandInput,
  ListBucketMetricsConfigurationsCommandOutput
} from "../commands/ListBucketMetricsConfigurationsCommand";
import {
  ListBucketsCommandInput,
  ListBucketsCommandOutput
} from "../commands/ListBucketsCommand";
import {
  ListMultipartUploadsCommandInput,
  ListMultipartUploadsCommandOutput
} from "../commands/ListMultipartUploadsCommand";
import {
  ListObjectVersionsCommandInput,
  ListObjectVersionsCommandOutput
} from "../commands/ListObjectVersionsCommand";
import {
  ListObjectsCommandInput,
  ListObjectsCommandOutput
} from "../commands/ListObjectsCommand";
import {
  ListObjectsV2CommandInput,
  ListObjectsV2CommandOutput
} from "../commands/ListObjectsV2Command";
import {
  ListPartsCommandInput,
  ListPartsCommandOutput
} from "../commands/ListPartsCommand";
import {
  PutBucketAccelerateConfigurationCommandInput,
  PutBucketAccelerateConfigurationCommandOutput
} from "../commands/PutBucketAccelerateConfigurationCommand";
import {
  PutBucketAclCommandInput,
  PutBucketAclCommandOutput
} from "../commands/PutBucketAclCommand";
import {
  PutBucketAnalyticsConfigurationCommandInput,
  PutBucketAnalyticsConfigurationCommandOutput
} from "../commands/PutBucketAnalyticsConfigurationCommand";
import {
  PutBucketCorsCommandInput,
  PutBucketCorsCommandOutput
} from "../commands/PutBucketCorsCommand";
import {
  PutBucketEncryptionCommandInput,
  PutBucketEncryptionCommandOutput
} from "../commands/PutBucketEncryptionCommand";
import {
  PutBucketInventoryConfigurationCommandInput,
  PutBucketInventoryConfigurationCommandOutput
} from "../commands/PutBucketInventoryConfigurationCommand";
import {
  PutBucketLifecycleConfigurationCommandInput,
  PutBucketLifecycleConfigurationCommandOutput
} from "../commands/PutBucketLifecycleConfigurationCommand";
import {
  PutBucketLoggingCommandInput,
  PutBucketLoggingCommandOutput
} from "../commands/PutBucketLoggingCommand";
import {
  PutBucketMetricsConfigurationCommandInput,
  PutBucketMetricsConfigurationCommandOutput
} from "../commands/PutBucketMetricsConfigurationCommand";
import {
  PutBucketNotificationConfigurationCommandInput,
  PutBucketNotificationConfigurationCommandOutput
} from "../commands/PutBucketNotificationConfigurationCommand";
import {
  PutBucketPolicyCommandInput,
  PutBucketPolicyCommandOutput
} from "../commands/PutBucketPolicyCommand";
import {
  PutBucketReplicationCommandInput,
  PutBucketReplicationCommandOutput
} from "../commands/PutBucketReplicationCommand";
import {
  PutBucketRequestPaymentCommandInput,
  PutBucketRequestPaymentCommandOutput
} from "../commands/PutBucketRequestPaymentCommand";
import {
  PutBucketTaggingCommandInput,
  PutBucketTaggingCommandOutput
} from "../commands/PutBucketTaggingCommand";
import {
  PutBucketVersioningCommandInput,
  PutBucketVersioningCommandOutput
} from "../commands/PutBucketVersioningCommand";
import {
  PutBucketWebsiteCommandInput,
  PutBucketWebsiteCommandOutput
} from "../commands/PutBucketWebsiteCommand";
import {
  PutObjectAclCommandInput,
  PutObjectAclCommandOutput
} from "../commands/PutObjectAclCommand";
import {
  PutObjectCommandInput,
  PutObjectCommandOutput
} from "../commands/PutObjectCommand";
import {
  PutObjectLegalHoldCommandInput,
  PutObjectLegalHoldCommandOutput
} from "../commands/PutObjectLegalHoldCommand";
import {
  PutObjectLockConfigurationCommandInput,
  PutObjectLockConfigurationCommandOutput
} from "../commands/PutObjectLockConfigurationCommand";
import {
  PutObjectRetentionCommandInput,
  PutObjectRetentionCommandOutput
} from "../commands/PutObjectRetentionCommand";
import {
  PutObjectTaggingCommandInput,
  PutObjectTaggingCommandOutput
} from "../commands/PutObjectTaggingCommand";
import {
  PutPublicAccessBlockCommandInput,
  PutPublicAccessBlockCommandOutput
} from "../commands/PutPublicAccessBlockCommand";
import {
  RestoreObjectCommandInput,
  RestoreObjectCommandOutput
} from "../commands/RestoreObjectCommand";
import {
  SelectObjectContentCommandInput,
  SelectObjectContentCommandOutput
} from "../commands/SelectObjectContentCommand";
import {
  UploadPartCommandInput,
  UploadPartCommandOutput
} from "../commands/UploadPartCommand";
import {
  UploadPartCopyCommandInput,
  UploadPartCopyCommandOutput
} from "../commands/UploadPartCopyCommand";
import {
  AbortIncompleteMultipartUpload,
  AccelerateConfiguration,
  AccessControlPolicy,
  AccessControlTranslation,
  AnalyticsAndOperator,
  AnalyticsConfiguration,
  AnalyticsExportDestination,
  AnalyticsFilter,
  AnalyticsS3BucketDestination,
  Bucket,
  BucketAlreadyExists,
  BucketAlreadyOwnedByYou,
  BucketLifecycleConfiguration,
  BucketLoggingStatus,
  CORSConfiguration,
  CORSRule,
  CSVInput,
  CSVOutput,
  CommonPrefix,
  CompletedMultipartUpload,
  CompletedPart,
  Condition,
  ContinuationEvent,
  CopyObjectResult,
  CopyPartResult,
  CreateBucketConfiguration,
  DefaultRetention,
  Delete,
  DeleteMarkerEntry,
  DeleteMarkerReplication,
  DeletedObject,
  Destination,
  Encryption,
  EncryptionConfiguration,
  EndEvent,
  ErrorDocument,
  Event,
  ExistingObjectReplication,
  FilterRule,
  GlacierJobParameters,
  Grant,
  Grantee,
  IndexDocument,
  Initiator,
  InputSerialization,
  InventoryConfiguration,
  InventoryDestination,
  InventoryEncryption,
  InventoryFilter,
  InventoryOptionalField,
  InventoryS3BucketDestination,
  InventorySchedule,
  JSONInput,
  JSONOutput,
  LambdaFunctionConfiguration,
  LifecycleExpiration,
  LifecycleRule,
  LifecycleRuleAndOperator,
  LifecycleRuleFilter,
  LoggingEnabled,
  MetadataEntry,
  Metrics,
  MetricsAndOperator,
  MetricsConfiguration,
  MetricsFilter,
  MultipartUpload,
  NoSuchBucket,
  NoSuchKey,
  NoSuchUpload,
  NoncurrentVersionExpiration,
  NoncurrentVersionTransition,
  NotificationConfiguration,
  NotificationConfigurationFilter,
  ObjectAlreadyInActiveTierError,
  ObjectIdentifier,
  ObjectLockConfiguration,
  ObjectLockLegalHold,
  ObjectLockRetention,
  ObjectLockRule,
  ObjectNotInActiveTierError,
  ObjectVersion,
  OutputLocation,
  OutputSerialization,
  Owner,
  ParquetInput,
  Part,
  PolicyStatus,
  ProgressEvent,
  PublicAccessBlockConfiguration,
  QueueConfiguration,
  RecordsEvent,
  Redirect,
  RedirectAllRequestsTo,
  ReplicationConfiguration,
  ReplicationRule,
  ReplicationRuleAndOperator,
  ReplicationRuleFilter,
  ReplicationTime,
  ReplicationTimeValue,
  RequestPaymentConfiguration,
  RequestProgress,
  RestoreRequest,
  RoutingRule,
  S3KeyFilter,
  S3Location,
  SSEKMS,
  SSES3,
  ScanRange,
  SelectObjectContentEventStream,
  SelectParameters,
  ServerSideEncryptionByDefault,
  ServerSideEncryptionConfiguration,
  ServerSideEncryptionRule,
  SourceSelectionCriteria,
  SseKmsEncryptedObjects,
  StatsEvent,
  StorageClassAnalysis,
  StorageClassAnalysisDataExport,
  Tag,
  Tagging,
  TargetGrant,
  TopicConfiguration,
  Transition,
  VersioningConfiguration,
  WebsiteConfiguration,
  _Error,
  _Object
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  dateToUtcString as __dateToUtcString,
  extendedEncodeURIComponent as __extendedEncodeURIComponent
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  EventStreamSerdeContext as __EventStreamSerdeContext,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import {
  XmlNode as __XmlNode,
  XmlText as __XmlText
} from "@aws-sdk/xml-builder";
import { parse as xmlParse } from "fast-xml-parser";

export async function serializeAws_restXmlAbortMultipartUploadCommand(
  input: AbortMultipartUploadCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    "x-id": "AbortMultipartUpload"
  };
  if (input.UploadId !== undefined) {
    query["uploadId"] = input.UploadId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlCompleteMultipartUploadCommand(
  input: CompleteMultipartUploadCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {};
  if (input.UploadId !== undefined) {
    query["uploadId"] = input.UploadId;
  }
  let body: any;
  let contents: any;
  if (input.MultipartUpload !== undefined) {
    contents = serializeAws_restXmlCompletedMultipartUpload(
      input.MultipartUpload,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlCopyObjectCommand(
  input: CopyObjectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.ACL !== undefined) {
    headers["x-amz-acl"] = input.ACL;
  }
  if (input.CacheControl !== undefined) {
    headers["Cache-Control"] = input.CacheControl;
  }
  if (input.ContentDisposition !== undefined) {
    headers["Content-Disposition"] = input.ContentDisposition;
  }
  if (input.ContentEncoding !== undefined) {
    headers["Content-Encoding"] = input.ContentEncoding;
  }
  if (input.ContentLanguage !== undefined) {
    headers["Content-Language"] = input.ContentLanguage;
  }
  if (input.ContentType !== undefined) {
    headers["Content-Type"] = input.ContentType;
  }
  if (input.CopySource !== undefined) {
    headers["x-amz-copy-source"] = input.CopySource;
  }
  if (input.CopySourceIfMatch !== undefined) {
    headers["x-amz-copy-source-if-match"] = input.CopySourceIfMatch;
  }
  if (input.CopySourceIfModifiedSince !== undefined) {
    headers["x-amz-copy-source-if-modified-since"] = __dateToUtcString(
      input.CopySourceIfModifiedSince
    ).toString();
  }
  if (input.CopySourceIfNoneMatch !== undefined) {
    headers["x-amz-copy-source-if-none-match"] = input.CopySourceIfNoneMatch;
  }
  if (input.CopySourceIfUnmodifiedSince !== undefined) {
    headers["x-amz-copy-source-if-unmodified-since"] = __dateToUtcString(
      input.CopySourceIfUnmodifiedSince
    ).toString();
  }
  if (input.CopySourceSSECustomerAlgorithm !== undefined) {
    headers["x-amz-copy-source-server-side-encryption-customer-algorithm"] =
      input.CopySourceSSECustomerAlgorithm;
  }
  if (input.CopySourceSSECustomerKey !== undefined) {
    headers["x-amz-copy-source-server-side-encryption-customer-key"] =
      input.CopySourceSSECustomerKey;
  }
  if (input.CopySourceSSECustomerKeyMD5 !== undefined) {
    headers["x-amz-copy-source-server-side-encryption-customer-key-MD5"] =
      input.CopySourceSSECustomerKeyMD5;
  }
  if (input.Expires !== undefined) {
    headers["Expires"] = __dateToUtcString(input.Expires).toString();
  }
  if (input.GrantFullControl !== undefined) {
    headers["x-amz-grant-full-control"] = input.GrantFullControl;
  }
  if (input.GrantRead !== undefined) {
    headers["x-amz-grant-read"] = input.GrantRead;
  }
  if (input.GrantReadACP !== undefined) {
    headers["x-amz-grant-read-acp"] = input.GrantReadACP;
  }
  if (input.GrantWriteACP !== undefined) {
    headers["x-amz-grant-write-acp"] = input.GrantWriteACP;
  }
  if (input.MetadataDirective !== undefined) {
    headers["x-amz-metadata-directive"] = input.MetadataDirective;
  }
  if (input.ObjectLockLegalHoldStatus !== undefined) {
    headers["x-amz-object-lock-legal-hold"] = input.ObjectLockLegalHoldStatus;
  }
  if (input.ObjectLockMode !== undefined) {
    headers["x-amz-object-lock-mode"] = input.ObjectLockMode;
  }
  if (input.ObjectLockRetainUntilDate !== undefined) {
    headers["x-amz-object-lock-retain-until-date"] = (
      input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z"
    ).toString();
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  if (input.SSECustomerAlgorithm !== undefined) {
    headers["x-amz-server-side-encryption-customer-algorithm"] =
      input.SSECustomerAlgorithm;
  }
  if (input.SSECustomerKey !== undefined) {
    headers["x-amz-server-side-encryption-customer-key"] = input.SSECustomerKey;
  }
  if (input.SSECustomerKeyMD5 !== undefined) {
    headers["x-amz-server-side-encryption-customer-key-MD5"] =
      input.SSECustomerKeyMD5;
  }
  if (input.SSEKMSEncryptionContext !== undefined) {
    headers["x-amz-server-side-encryption-context"] =
      input.SSEKMSEncryptionContext;
  }
  if (input.SSEKMSKeyId !== undefined) {
    headers["x-amz-server-side-encryption-aws-kms-key-id"] = input.SSEKMSKeyId;
  }
  if (input.ServerSideEncryption !== undefined) {
    headers["x-amz-server-side-encryption"] = input.ServerSideEncryption;
  }
  if (input.StorageClass !== undefined) {
    headers["x-amz-storage-class"] = input.StorageClass;
  }
  if (input.Tagging !== undefined) {
    headers["x-amz-tagging"] = input.Tagging;
  }
  if (input.TaggingDirective !== undefined) {
    headers["x-amz-tagging-directive"] = input.TaggingDirective;
  }
  if (input.WebsiteRedirectLocation !== undefined) {
    headers["x-amz-website-redirect-location"] = input.WebsiteRedirectLocation;
  }
  if (input.Metadata !== undefined) {
    Object.keys(input.Metadata).forEach(suffix => {
      headers["x-amz-meta-" + suffix] = input.Metadata![suffix];
    });
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    "x-id": "CopyObject"
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlCreateBucketCommand(
  input: CreateBucketCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ACL !== undefined) {
    headers["x-amz-acl"] = input.ACL;
  }
  if (input.GrantFullControl !== undefined) {
    headers["x-amz-grant-full-control"] = input.GrantFullControl;
  }
  if (input.GrantRead !== undefined) {
    headers["x-amz-grant-read"] = input.GrantRead;
  }
  if (input.GrantReadACP !== undefined) {
    headers["x-amz-grant-read-acp"] = input.GrantReadACP;
  }
  if (input.GrantWrite !== undefined) {
    headers["x-amz-grant-write"] = input.GrantWrite;
  }
  if (input.GrantWriteACP !== undefined) {
    headers["x-amz-grant-write-acp"] = input.GrantWriteACP;
  }
  if (input.ObjectLockEnabledForBucket !== undefined) {
    headers[
      "x-amz-bucket-object-lock-enabled"
    ] = input.ObjectLockEnabledForBucket.toString();
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  let body: any;
  let contents: any;
  if (input.CreateBucketConfiguration !== undefined) {
    contents = serializeAws_restXmlCreateBucketConfiguration(
      input.CreateBucketConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlCreateMultipartUploadCommand(
  input: CreateMultipartUploadCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.ACL !== undefined) {
    headers["x-amz-acl"] = input.ACL;
  }
  if (input.CacheControl !== undefined) {
    headers["Cache-Control"] = input.CacheControl;
  }
  if (input.ContentDisposition !== undefined) {
    headers["Content-Disposition"] = input.ContentDisposition;
  }
  if (input.ContentEncoding !== undefined) {
    headers["Content-Encoding"] = input.ContentEncoding;
  }
  if (input.ContentLanguage !== undefined) {
    headers["Content-Language"] = input.ContentLanguage;
  }
  if (input.ContentType !== undefined) {
    headers["Content-Type"] = input.ContentType;
  }
  if (input.Expires !== undefined) {
    headers["Expires"] = __dateToUtcString(input.Expires).toString();
  }
  if (input.GrantFullControl !== undefined) {
    headers["x-amz-grant-full-control"] = input.GrantFullControl;
  }
  if (input.GrantRead !== undefined) {
    headers["x-amz-grant-read"] = input.GrantRead;
  }
  if (input.GrantReadACP !== undefined) {
    headers["x-amz-grant-read-acp"] = input.GrantReadACP;
  }
  if (input.GrantWriteACP !== undefined) {
    headers["x-amz-grant-write-acp"] = input.GrantWriteACP;
  }
  if (input.ObjectLockLegalHoldStatus !== undefined) {
    headers["x-amz-object-lock-legal-hold"] = input.ObjectLockLegalHoldStatus;
  }
  if (input.ObjectLockMode !== undefined) {
    headers["x-amz-object-lock-mode"] = input.ObjectLockMode;
  }
  if (input.ObjectLockRetainUntilDate !== undefined) {
    headers["x-amz-object-lock-retain-until-date"] = (
      input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z"
    ).toString();
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  if (input.SSECustomerAlgorithm !== undefined) {
    headers["x-amz-server-side-encryption-customer-algorithm"] =
      input.SSECustomerAlgorithm;
  }
  if (input.SSECustomerKey !== undefined) {
    headers["x-amz-server-side-encryption-customer-key"] = input.SSECustomerKey;
  }
  if (input.SSECustomerKeyMD5 !== undefined) {
    headers["x-amz-server-side-encryption-customer-key-MD5"] =
      input.SSECustomerKeyMD5;
  }
  if (input.SSEKMSEncryptionContext !== undefined) {
    headers["x-amz-server-side-encryption-context"] =
      input.SSEKMSEncryptionContext;
  }
  if (input.SSEKMSKeyId !== undefined) {
    headers["x-amz-server-side-encryption-aws-kms-key-id"] = input.SSEKMSKeyId;
  }
  if (input.ServerSideEncryption !== undefined) {
    headers["x-amz-server-side-encryption"] = input.ServerSideEncryption;
  }
  if (input.StorageClass !== undefined) {
    headers["x-amz-storage-class"] = input.StorageClass;
  }
  if (input.Tagging !== undefined) {
    headers["x-amz-tagging"] = input.Tagging;
  }
  if (input.WebsiteRedirectLocation !== undefined) {
    headers["x-amz-website-redirect-location"] = input.WebsiteRedirectLocation;
  }
  if (input.Metadata !== undefined) {
    Object.keys(input.Metadata).forEach(suffix => {
      headers["x-amz-meta-" + suffix] = input.Metadata![suffix];
    });
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    uploads: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketCommand(
  input: DeleteBucketCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketAnalyticsConfigurationCommand(
  input: DeleteBucketAnalyticsConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    analytics: ""
  };
  if (input.Id !== undefined) {
    query["id"] = input.Id;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketCorsCommand(
  input: DeleteBucketCorsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    cors: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketEncryptionCommand(
  input: DeleteBucketEncryptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    encryption: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketInventoryConfigurationCommand(
  input: DeleteBucketInventoryConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    inventory: ""
  };
  if (input.Id !== undefined) {
    query["id"] = input.Id;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketLifecycleCommand(
  input: DeleteBucketLifecycleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    lifecycle: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketMetricsConfigurationCommand(
  input: DeleteBucketMetricsConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    metrics: ""
  };
  if (input.Id !== undefined) {
    query["id"] = input.Id;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketPolicyCommand(
  input: DeleteBucketPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    policy: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketReplicationCommand(
  input: DeleteBucketReplicationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    replication: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketTaggingCommand(
  input: DeleteBucketTaggingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    tagging: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteBucketWebsiteCommand(
  input: DeleteBucketWebsiteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    website: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteObjectCommand(
  input: DeleteObjectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.BypassGovernanceRetention !== undefined) {
    headers[
      "x-amz-bypass-governance-retention"
    ] = input.BypassGovernanceRetention.toString();
  }
  if (input.MFA !== undefined) {
    headers["x-amz-mfa"] = input.MFA;
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    "x-id": "DeleteObject"
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteObjectTaggingCommand(
  input: DeleteObjectTaggingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    tagging: ""
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeleteObjectsCommand(
  input: DeleteObjectsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.BypassGovernanceRetention !== undefined) {
    headers[
      "x-amz-bypass-governance-retention"
    ] = input.BypassGovernanceRetention.toString();
  }
  if (input.MFA !== undefined) {
    headers["x-amz-mfa"] = input.MFA;
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    delete: ""
  };
  let body: any;
  let contents: any;
  if (input.Delete !== undefined) {
    contents = serializeAws_restXmlDelete(input.Delete, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlDeletePublicAccessBlockCommand(
  input: DeletePublicAccessBlockCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    publicAccessBlock: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketAccelerateConfigurationCommand(
  input: GetBucketAccelerateConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    accelerate: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketAclCommand(
  input: GetBucketAclCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    acl: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketAnalyticsConfigurationCommand(
  input: GetBucketAnalyticsConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    analytics: "",
    "x-id": "GetBucketAnalyticsConfiguration"
  };
  if (input.Id !== undefined) {
    query["id"] = input.Id;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketCorsCommand(
  input: GetBucketCorsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    cors: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketEncryptionCommand(
  input: GetBucketEncryptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    encryption: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketInventoryConfigurationCommand(
  input: GetBucketInventoryConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    inventory: "",
    "x-id": "GetBucketInventoryConfiguration"
  };
  if (input.Id !== undefined) {
    query["id"] = input.Id;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketLifecycleConfigurationCommand(
  input: GetBucketLifecycleConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    lifecycle: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketLocationCommand(
  input: GetBucketLocationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    location: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketLoggingCommand(
  input: GetBucketLoggingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    logging: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketMetricsConfigurationCommand(
  input: GetBucketMetricsConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    metrics: "",
    "x-id": "GetBucketMetricsConfiguration"
  };
  if (input.Id !== undefined) {
    query["id"] = input.Id;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketNotificationConfigurationCommand(
  input: GetBucketNotificationConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    notification: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketPolicyCommand(
  input: GetBucketPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    policy: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketPolicyStatusCommand(
  input: GetBucketPolicyStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    policyStatus: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketReplicationCommand(
  input: GetBucketReplicationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    replication: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketRequestPaymentCommand(
  input: GetBucketRequestPaymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    requestPayment: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketTaggingCommand(
  input: GetBucketTaggingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    tagging: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketVersioningCommand(
  input: GetBucketVersioningCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    versioning: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetBucketWebsiteCommand(
  input: GetBucketWebsiteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    website: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetObjectCommand(
  input: GetObjectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.IfMatch !== undefined) {
    headers["If-Match"] = input.IfMatch;
  }
  if (input.IfModifiedSince !== undefined) {
    headers["If-Modified-Since"] = __dateToUtcString(
      input.IfModifiedSince
    ).toString();
  }
  if (input.IfNoneMatch !== undefined) {
    headers["If-None-Match"] = input.IfNoneMatch;
  }
  if (input.IfUnmodifiedSince !== undefined) {
    headers["If-Unmodified-Since"] = __dateToUtcString(
      input.IfUnmodifiedSince
    ).toString();
  }
  if (input.Range !== undefined) {
    headers["Range"] = input.Range;
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  if (input.SSECustomerAlgorithm !== undefined) {
    headers["x-amz-server-side-encryption-customer-algorithm"] =
      input.SSECustomerAlgorithm;
  }
  if (input.SSECustomerKey !== undefined) {
    headers["x-amz-server-side-encryption-customer-key"] = input.SSECustomerKey;
  }
  if (input.SSECustomerKeyMD5 !== undefined) {
    headers["x-amz-server-side-encryption-customer-key-MD5"] =
      input.SSECustomerKeyMD5;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    "x-id": "GetObject"
  };
  if (input.PartNumber !== undefined) {
    query["partNumber"] = input.PartNumber.toString();
  }
  if (input.ResponseCacheControl !== undefined) {
    query["response-cache-control"] = input.ResponseCacheControl;
  }
  if (input.ResponseContentDisposition !== undefined) {
    query["response-content-disposition"] = input.ResponseContentDisposition;
  }
  if (input.ResponseContentEncoding !== undefined) {
    query["response-content-encoding"] = input.ResponseContentEncoding;
  }
  if (input.ResponseContentLanguage !== undefined) {
    query["response-content-language"] = input.ResponseContentLanguage;
  }
  if (input.ResponseContentType !== undefined) {
    query["response-content-type"] = input.ResponseContentType;
  }
  if (input.ResponseExpires !== undefined) {
    query["response-expires"] = (
      input.ResponseExpires.toISOString().split(".")[0] + "Z"
    ).toString();
  }
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetObjectAclCommand(
  input: GetObjectAclCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    acl: ""
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetObjectLegalHoldCommand(
  input: GetObjectLegalHoldCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    "legal-hold": ""
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetObjectLockConfigurationCommand(
  input: GetObjectLockConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    "object-lock": ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetObjectRetentionCommand(
  input: GetObjectRetentionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    retention: ""
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetObjectTaggingCommand(
  input: GetObjectTaggingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    tagging: ""
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetObjectTorrentCommand(
  input: GetObjectTorrentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    torrent: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlGetPublicAccessBlockCommand(
  input: GetPublicAccessBlockCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    publicAccessBlock: ""
  };
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlHeadBucketCommand(
  input: HeadBucketCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "HEAD",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlHeadObjectCommand(
  input: HeadObjectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.IfMatch !== undefined) {
    headers["If-Match"] = input.IfMatch;
  }
  if (input.IfModifiedSince !== undefined) {
    headers["If-Modified-Since"] = __dateToUtcString(
      input.IfModifiedSince
    ).toString();
  }
  if (input.IfNoneMatch !== undefined) {
    headers["If-None-Match"] = input.IfNoneMatch;
  }
  if (input.IfUnmodifiedSince !== undefined) {
    headers["If-Unmodified-Since"] = __dateToUtcString(
      input.IfUnmodifiedSince
    ).toString();
  }
  if (input.Range !== undefined) {
    headers["Range"] = input.Range;
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  if (input.SSECustomerAlgorithm !== undefined) {
    headers["x-amz-server-side-encryption-customer-algorithm"] =
      input.SSECustomerAlgorithm;
  }
  if (input.SSECustomerKey !== undefined) {
    headers["x-amz-server-side-encryption-customer-key"] = input.SSECustomerKey;
  }
  if (input.SSECustomerKeyMD5 !== undefined) {
    headers["x-amz-server-side-encryption-customer-key-MD5"] =
      input.SSECustomerKeyMD5;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {};
  if (input.PartNumber !== undefined) {
    query["partNumber"] = input.PartNumber.toString();
  }
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "HEAD",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlListBucketAnalyticsConfigurationsCommand(
  input: ListBucketAnalyticsConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    analytics: "",
    "x-id": "ListBucketAnalyticsConfigurations"
  };
  if (input.ContinuationToken !== undefined) {
    query["continuation-token"] = input.ContinuationToken;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlListBucketInventoryConfigurationsCommand(
  input: ListBucketInventoryConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    inventory: "",
    "x-id": "ListBucketInventoryConfigurations"
  };
  if (input.ContinuationToken !== undefined) {
    query["continuation-token"] = input.ContinuationToken;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlListBucketMetricsConfigurationsCommand(
  input: ListBucketMetricsConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    metrics: "",
    "x-id": "ListBucketMetricsConfigurations"
  };
  if (input.ContinuationToken !== undefined) {
    query["continuation-token"] = input.ContinuationToken;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlListBucketsCommand(
  input: ListBucketsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/";
  let body: any;
  body = "";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlListMultipartUploadsCommand(
  input: ListMultipartUploadsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    uploads: ""
  };
  if (input.Delimiter !== undefined) {
    query["delimiter"] = input.Delimiter;
  }
  if (input.EncodingType !== undefined) {
    query["encoding-type"] = input.EncodingType;
  }
  if (input.KeyMarker !== undefined) {
    query["key-marker"] = input.KeyMarker;
  }
  if (input.MaxUploads !== undefined) {
    query["max-uploads"] = input.MaxUploads.toString();
  }
  if (input.Prefix !== undefined) {
    query["prefix"] = input.Prefix;
  }
  if (input.UploadIdMarker !== undefined) {
    query["upload-id-marker"] = input.UploadIdMarker;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlListObjectVersionsCommand(
  input: ListObjectVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    versions: ""
  };
  if (input.Delimiter !== undefined) {
    query["delimiter"] = input.Delimiter;
  }
  if (input.EncodingType !== undefined) {
    query["encoding-type"] = input.EncodingType;
  }
  if (input.KeyMarker !== undefined) {
    query["key-marker"] = input.KeyMarker;
  }
  if (input.MaxKeys !== undefined) {
    query["max-keys"] = input.MaxKeys.toString();
  }
  if (input.Prefix !== undefined) {
    query["prefix"] = input.Prefix;
  }
  if (input.VersionIdMarker !== undefined) {
    query["version-id-marker"] = input.VersionIdMarker;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlListObjectsCommand(
  input: ListObjectsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {};
  if (input.Delimiter !== undefined) {
    query["delimiter"] = input.Delimiter;
  }
  if (input.EncodingType !== undefined) {
    query["encoding-type"] = input.EncodingType;
  }
  if (input.Marker !== undefined) {
    query["marker"] = input.Marker;
  }
  if (input.MaxKeys !== undefined) {
    query["max-keys"] = input.MaxKeys.toString();
  }
  if (input.Prefix !== undefined) {
    query["prefix"] = input.Prefix;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlListObjectsV2Command(
  input: ListObjectsV2CommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    "list-type": "2"
  };
  if (input.ContinuationToken !== undefined) {
    query["continuation-token"] = input.ContinuationToken;
  }
  if (input.Delimiter !== undefined) {
    query["delimiter"] = input.Delimiter;
  }
  if (input.EncodingType !== undefined) {
    query["encoding-type"] = input.EncodingType;
  }
  if (input.FetchOwner !== undefined) {
    query["fetch-owner"] = input.FetchOwner.toString();
  }
  if (input.MaxKeys !== undefined) {
    query["max-keys"] = input.MaxKeys.toString();
  }
  if (input.Prefix !== undefined) {
    query["prefix"] = input.Prefix;
  }
  if (input.StartAfter !== undefined) {
    query["start-after"] = input.StartAfter;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlListPartsCommand(
  input: ListPartsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    "x-id": "ListParts"
  };
  if (input.MaxParts !== undefined) {
    query["max-parts"] = input.MaxParts.toString();
  }
  if (input.PartNumberMarker !== undefined) {
    query["part-number-marker"] = input.PartNumberMarker.toString();
  }
  if (input.UploadId !== undefined) {
    query["uploadId"] = input.UploadId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketAccelerateConfigurationCommand(
  input: PutBucketAccelerateConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    accelerate: ""
  };
  let body: any;
  let contents: any;
  if (input.AccelerateConfiguration !== undefined) {
    contents = serializeAws_restXmlAccelerateConfiguration(
      input.AccelerateConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketAclCommand(
  input: PutBucketAclCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ACL !== undefined) {
    headers["x-amz-acl"] = input.ACL;
  }
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  if (input.GrantFullControl !== undefined) {
    headers["x-amz-grant-full-control"] = input.GrantFullControl;
  }
  if (input.GrantRead !== undefined) {
    headers["x-amz-grant-read"] = input.GrantRead;
  }
  if (input.GrantReadACP !== undefined) {
    headers["x-amz-grant-read-acp"] = input.GrantReadACP;
  }
  if (input.GrantWrite !== undefined) {
    headers["x-amz-grant-write"] = input.GrantWrite;
  }
  if (input.GrantWriteACP !== undefined) {
    headers["x-amz-grant-write-acp"] = input.GrantWriteACP;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    acl: ""
  };
  let body: any;
  let contents: any;
  if (input.AccessControlPolicy !== undefined) {
    contents = serializeAws_restXmlAccessControlPolicy(
      input.AccessControlPolicy,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketAnalyticsConfigurationCommand(
  input: PutBucketAnalyticsConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    analytics: ""
  };
  if (input.Id !== undefined) {
    query["id"] = input.Id;
  }
  let body: any;
  let contents: any;
  if (input.AnalyticsConfiguration !== undefined) {
    contents = serializeAws_restXmlAnalyticsConfiguration(
      input.AnalyticsConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketCorsCommand(
  input: PutBucketCorsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    cors: ""
  };
  let body: any;
  let contents: any;
  if (input.CORSConfiguration !== undefined) {
    contents = serializeAws_restXmlCORSConfiguration(
      input.CORSConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketEncryptionCommand(
  input: PutBucketEncryptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    encryption: ""
  };
  let body: any;
  let contents: any;
  if (input.ServerSideEncryptionConfiguration !== undefined) {
    contents = serializeAws_restXmlServerSideEncryptionConfiguration(
      input.ServerSideEncryptionConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketInventoryConfigurationCommand(
  input: PutBucketInventoryConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    inventory: ""
  };
  if (input.Id !== undefined) {
    query["id"] = input.Id;
  }
  let body: any;
  let contents: any;
  if (input.InventoryConfiguration !== undefined) {
    contents = serializeAws_restXmlInventoryConfiguration(
      input.InventoryConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketLifecycleConfigurationCommand(
  input: PutBucketLifecycleConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    lifecycle: ""
  };
  let body: any;
  let contents: any;
  if (input.LifecycleConfiguration !== undefined) {
    contents = serializeAws_restXmlBucketLifecycleConfiguration(
      input.LifecycleConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketLoggingCommand(
  input: PutBucketLoggingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    logging: ""
  };
  let body: any;
  let contents: any;
  if (input.BucketLoggingStatus !== undefined) {
    contents = serializeAws_restXmlBucketLoggingStatus(
      input.BucketLoggingStatus,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketMetricsConfigurationCommand(
  input: PutBucketMetricsConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    metrics: ""
  };
  if (input.Id !== undefined) {
    query["id"] = input.Id;
  }
  let body: any;
  let contents: any;
  if (input.MetricsConfiguration !== undefined) {
    contents = serializeAws_restXmlMetricsConfiguration(
      input.MetricsConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketNotificationConfigurationCommand(
  input: PutBucketNotificationConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    notification: ""
  };
  let body: any;
  let contents: any;
  if (input.NotificationConfiguration !== undefined) {
    contents = serializeAws_restXmlNotificationConfiguration(
      input.NotificationConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketPolicyCommand(
  input: PutBucketPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ConfirmRemoveSelfBucketAccess !== undefined) {
    headers[
      "x-amz-confirm-remove-self-bucket-access"
    ] = input.ConfirmRemoveSelfBucketAccess.toString();
  }
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    policy: ""
  };
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("PutBucketPolicyRequest");
  bodyNode.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
  if (input.Policy !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Policy")
        .addChildNode(new __XmlText(input.Policy))
        .withName("Policy")
    );
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketReplicationCommand(
  input: PutBucketReplicationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  if (input.Token !== undefined) {
    headers["x-amz-bucket-object-lock-token"] = input.Token;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    replication: ""
  };
  let body: any;
  let contents: any;
  if (input.ReplicationConfiguration !== undefined) {
    contents = serializeAws_restXmlReplicationConfiguration(
      input.ReplicationConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketRequestPaymentCommand(
  input: PutBucketRequestPaymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    requestPayment: ""
  };
  let body: any;
  let contents: any;
  if (input.RequestPaymentConfiguration !== undefined) {
    contents = serializeAws_restXmlRequestPaymentConfiguration(
      input.RequestPaymentConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketTaggingCommand(
  input: PutBucketTaggingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    tagging: ""
  };
  let body: any;
  let contents: any;
  if (input.Tagging !== undefined) {
    contents = serializeAws_restXmlTagging(input.Tagging, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketVersioningCommand(
  input: PutBucketVersioningCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  if (input.MFA !== undefined) {
    headers["x-amz-mfa"] = input.MFA;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    versioning: ""
  };
  let body: any;
  let contents: any;
  if (input.VersioningConfiguration !== undefined) {
    contents = serializeAws_restXmlVersioningConfiguration(
      input.VersioningConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutBucketWebsiteCommand(
  input: PutBucketWebsiteCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    website: ""
  };
  let body: any;
  let contents: any;
  if (input.WebsiteConfiguration !== undefined) {
    contents = serializeAws_restXmlWebsiteConfiguration(
      input.WebsiteConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutObjectCommand(
  input: PutObjectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/octet-stream";
  if (input.ACL !== undefined) {
    headers["x-amz-acl"] = input.ACL;
  }
  if (input.CacheControl !== undefined) {
    headers["Cache-Control"] = input.CacheControl;
  }
  if (input.ContentDisposition !== undefined) {
    headers["Content-Disposition"] = input.ContentDisposition;
  }
  if (input.ContentEncoding !== undefined) {
    headers["Content-Encoding"] = input.ContentEncoding;
  }
  if (input.ContentLanguage !== undefined) {
    headers["Content-Language"] = input.ContentLanguage;
  }
  if (input.ContentLength !== undefined) {
    headers["Content-Length"] = input.ContentLength.toString();
  }
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  if (input.ContentType !== undefined) {
    headers["Content-Type"] = input.ContentType;
  }
  if (input.Expires !== undefined) {
    headers["Expires"] = __dateToUtcString(input.Expires).toString();
  }
  if (input.GrantFullControl !== undefined) {
    headers["x-amz-grant-full-control"] = input.GrantFullControl;
  }
  if (input.GrantRead !== undefined) {
    headers["x-amz-grant-read"] = input.GrantRead;
  }
  if (input.GrantReadACP !== undefined) {
    headers["x-amz-grant-read-acp"] = input.GrantReadACP;
  }
  if (input.GrantWriteACP !== undefined) {
    headers["x-amz-grant-write-acp"] = input.GrantWriteACP;
  }
  if (input.ObjectLockLegalHoldStatus !== undefined) {
    headers["x-amz-object-lock-legal-hold"] = input.ObjectLockLegalHoldStatus;
  }
  if (input.ObjectLockMode !== undefined) {
    headers["x-amz-object-lock-mode"] = input.ObjectLockMode;
  }
  if (input.ObjectLockRetainUntilDate !== undefined) {
    headers["x-amz-object-lock-retain-until-date"] = (
      input.ObjectLockRetainUntilDate.toISOString().split(".")[0] + "Z"
    ).toString();
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  if (input.SSECustomerAlgorithm !== undefined) {
    headers["x-amz-server-side-encryption-customer-algorithm"] =
      input.SSECustomerAlgorithm;
  }
  if (input.SSECustomerKey !== undefined) {
    headers["x-amz-server-side-encryption-customer-key"] = input.SSECustomerKey;
  }
  if (input.SSECustomerKeyMD5 !== undefined) {
    headers["x-amz-server-side-encryption-customer-key-MD5"] =
      input.SSECustomerKeyMD5;
  }
  if (input.SSEKMSEncryptionContext !== undefined) {
    headers["x-amz-server-side-encryption-context"] =
      input.SSEKMSEncryptionContext;
  }
  if (input.SSEKMSKeyId !== undefined) {
    headers["x-amz-server-side-encryption-aws-kms-key-id"] = input.SSEKMSKeyId;
  }
  if (input.ServerSideEncryption !== undefined) {
    headers["x-amz-server-side-encryption"] = input.ServerSideEncryption;
  }
  if (input.StorageClass !== undefined) {
    headers["x-amz-storage-class"] = input.StorageClass;
  }
  if (input.Tagging !== undefined) {
    headers["x-amz-tagging"] = input.Tagging;
  }
  if (input.WebsiteRedirectLocation !== undefined) {
    headers["x-amz-website-redirect-location"] = input.WebsiteRedirectLocation;
  }
  if (input.Metadata !== undefined) {
    Object.keys(input.Metadata).forEach(suffix => {
      headers["x-amz-meta-" + suffix] = input.Metadata![suffix];
    });
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    "x-id": "PutObject"
  };
  let body: any;
  let contents: any;
  if (input.Body !== undefined) {
    contents = input.Body;
    body = contents;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutObjectAclCommand(
  input: PutObjectAclCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ACL !== undefined) {
    headers["x-amz-acl"] = input.ACL;
  }
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  if (input.GrantFullControl !== undefined) {
    headers["x-amz-grant-full-control"] = input.GrantFullControl;
  }
  if (input.GrantRead !== undefined) {
    headers["x-amz-grant-read"] = input.GrantRead;
  }
  if (input.GrantReadACP !== undefined) {
    headers["x-amz-grant-read-acp"] = input.GrantReadACP;
  }
  if (input.GrantWrite !== undefined) {
    headers["x-amz-grant-write"] = input.GrantWrite;
  }
  if (input.GrantWriteACP !== undefined) {
    headers["x-amz-grant-write-acp"] = input.GrantWriteACP;
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    acl: ""
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  let contents: any;
  if (input.AccessControlPolicy !== undefined) {
    contents = serializeAws_restXmlAccessControlPolicy(
      input.AccessControlPolicy,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutObjectLegalHoldCommand(
  input: PutObjectLegalHoldCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    "legal-hold": ""
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  let contents: any;
  if (input.LegalHold !== undefined) {
    contents = serializeAws_restXmlObjectLockLegalHold(
      input.LegalHold,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutObjectLockConfigurationCommand(
  input: PutObjectLockConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  if (input.Token !== undefined) {
    headers["x-amz-bucket-object-lock-token"] = input.Token;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    "object-lock": ""
  };
  let body: any;
  let contents: any;
  if (input.ObjectLockConfiguration !== undefined) {
    contents = serializeAws_restXmlObjectLockConfiguration(
      input.ObjectLockConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutObjectRetentionCommand(
  input: PutObjectRetentionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.BypassGovernanceRetention !== undefined) {
    headers[
      "x-amz-bypass-governance-retention"
    ] = input.BypassGovernanceRetention.toString();
  }
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    retention: ""
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  let contents: any;
  if (input.Retention !== undefined) {
    contents = serializeAws_restXmlObjectLockRetention(
      input.Retention,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutObjectTaggingCommand(
  input: PutObjectTaggingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    tagging: ""
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  let contents: any;
  if (input.Tagging !== undefined) {
    contents = serializeAws_restXmlTagging(input.Tagging, context);
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlPutPublicAccessBlockCommand(
  input: PutPublicAccessBlockCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  let resolvedPath = "/{Bucket}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  const query: any = {
    publicAccessBlock: ""
  };
  let body: any;
  let contents: any;
  if (input.PublicAccessBlockConfiguration !== undefined) {
    contents = serializeAws_restXmlPublicAccessBlockConfiguration(
      input.PublicAccessBlockConfiguration,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlRestoreObjectCommand(
  input: RestoreObjectCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    restore: ""
  };
  if (input.VersionId !== undefined) {
    query["versionId"] = input.VersionId;
  }
  let body: any;
  let contents: any;
  if (input.RestoreRequest !== undefined) {
    contents = serializeAws_restXmlRestoreRequest(
      input.RestoreRequest,
      context
    );
    body = '<?xml version="1.0" encoding="UTF-8"?>';
    contents.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
    body += contents.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlSelectObjectContentCommand(
  input: SelectObjectContentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  if (input.SSECustomerAlgorithm !== undefined) {
    headers["x-amz-server-side-encryption-customer-algorithm"] =
      input.SSECustomerAlgorithm;
  }
  if (input.SSECustomerKey !== undefined) {
    headers["x-amz-server-side-encryption-customer-key"] = input.SSECustomerKey;
  }
  if (input.SSECustomerKeyMD5 !== undefined) {
    headers["x-amz-server-side-encryption-customer-key-MD5"] =
      input.SSECustomerKeyMD5;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    select: "",
    "select-type": "2"
  };
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("SelectObjectContentRequest");
  bodyNode.addAttribute("xmlns", "http://s3.amazonaws.com/doc/2006-03-01/");
  if (input.Expression !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Expression")
        .addChildNode(new __XmlText(input.Expression))
        .withName("Expression")
    );
  }
  if (input.ExpressionType !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ExpressionType")
        .addChildNode(new __XmlText(input.ExpressionType))
        .withName("ExpressionType")
    );
  }
  if (input.InputSerialization !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlInputSerialization(
        input.InputSerialization,
        context
      ).withName("InputSerialization")
    );
  }
  if (input.OutputSerialization !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlOutputSerialization(
        input.OutputSerialization,
        context
      ).withName("OutputSerialization")
    );
  }
  if (input.RequestProgress !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlRequestProgress(
        input.RequestProgress,
        context
      ).withName("RequestProgress")
    );
  }
  if (input.ScanRange !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlScanRange(input.ScanRange, context).withName(
        "ScanRange"
      )
    );
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlUploadPartCommand(
  input: UploadPartCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/octet-stream";
  if (input.ContentLength !== undefined) {
    headers["Content-Length"] = input.ContentLength.toString();
  }
  if (input.ContentMD5 !== undefined) {
    headers["Content-MD5"] = input.ContentMD5;
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  if (input.SSECustomerAlgorithm !== undefined) {
    headers["x-amz-server-side-encryption-customer-algorithm"] =
      input.SSECustomerAlgorithm;
  }
  if (input.SSECustomerKey !== undefined) {
    headers["x-amz-server-side-encryption-customer-key"] = input.SSECustomerKey;
  }
  if (input.SSECustomerKeyMD5 !== undefined) {
    headers["x-amz-server-side-encryption-customer-key-MD5"] =
      input.SSECustomerKeyMD5;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    "x-id": "UploadPart"
  };
  if (input.PartNumber !== undefined) {
    query["partNumber"] = input.PartNumber.toString();
  }
  if (input.UploadId !== undefined) {
    query["uploadId"] = input.UploadId;
  }
  let body: any;
  let contents: any;
  if (input.Body !== undefined) {
    contents = input.Body;
    body = contents;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restXmlUploadPartCopyCommand(
  input: UploadPartCopyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.CopySource !== undefined) {
    headers["x-amz-copy-source"] = input.CopySource;
  }
  if (input.CopySourceIfMatch !== undefined) {
    headers["x-amz-copy-source-if-match"] = input.CopySourceIfMatch;
  }
  if (input.CopySourceIfModifiedSince !== undefined) {
    headers["x-amz-copy-source-if-modified-since"] = __dateToUtcString(
      input.CopySourceIfModifiedSince
    ).toString();
  }
  if (input.CopySourceIfNoneMatch !== undefined) {
    headers["x-amz-copy-source-if-none-match"] = input.CopySourceIfNoneMatch;
  }
  if (input.CopySourceIfUnmodifiedSince !== undefined) {
    headers["x-amz-copy-source-if-unmodified-since"] = __dateToUtcString(
      input.CopySourceIfUnmodifiedSince
    ).toString();
  }
  if (input.CopySourceRange !== undefined) {
    headers["x-amz-copy-source-range"] = input.CopySourceRange;
  }
  if (input.CopySourceSSECustomerAlgorithm !== undefined) {
    headers["x-amz-copy-source-server-side-encryption-customer-algorithm"] =
      input.CopySourceSSECustomerAlgorithm;
  }
  if (input.CopySourceSSECustomerKey !== undefined) {
    headers["x-amz-copy-source-server-side-encryption-customer-key"] =
      input.CopySourceSSECustomerKey;
  }
  if (input.CopySourceSSECustomerKeyMD5 !== undefined) {
    headers["x-amz-copy-source-server-side-encryption-customer-key-MD5"] =
      input.CopySourceSSECustomerKeyMD5;
  }
  if (input.RequestPayer !== undefined) {
    headers["x-amz-request-payer"] = input.RequestPayer;
  }
  if (input.SSECustomerAlgorithm !== undefined) {
    headers["x-amz-server-side-encryption-customer-algorithm"] =
      input.SSECustomerAlgorithm;
  }
  if (input.SSECustomerKey !== undefined) {
    headers["x-amz-server-side-encryption-customer-key"] = input.SSECustomerKey;
  }
  if (input.SSECustomerKeyMD5 !== undefined) {
    headers["x-amz-server-side-encryption-customer-key-MD5"] =
      input.SSECustomerKeyMD5;
  }
  let resolvedPath = "/{Bucket}/{Key+}";
  if (input.Bucket !== undefined) {
    const labelValue: string = input.Bucket;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Bucket.");
    }
    resolvedPath = resolvedPath.replace(
      "{Bucket}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Bucket.");
  }
  if (input.Key !== undefined) {
    const labelValue: string = input.Key;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Key.");
    }
    resolvedPath = resolvedPath.replace(
      "{Key+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: Key.");
  }
  const query: any = {
    "x-id": "UploadPartCopy"
  };
  if (input.PartNumber !== undefined) {
    query["partNumber"] = input.PartNumber.toString();
  }
  if (input.UploadId !== undefined) {
    query["uploadId"] = input.UploadId;
  }
  let body: any;
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function deserializeAws_restXmlAbortMultipartUploadCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AbortMultipartUploadCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlAbortMultipartUploadCommandError(
      output,
      context
    );
  }
  const contents: AbortMultipartUploadCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AbortMultipartUploadOutput",
    RequestCharged: undefined
  };
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlAbortMultipartUploadCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AbortMultipartUploadCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchUpload":
    case "com.amazonaws.s3#NoSuchUpload":
      response = {
        ...(await deserializeAws_restXmlNoSuchUploadResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCompleteMultipartUploadCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CompleteMultipartUploadCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlCompleteMultipartUploadCommandError(
      output,
      context
    );
  }
  const contents: CompleteMultipartUploadCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CompleteMultipartUploadOutput",
    Bucket: undefined,
    ETag: undefined,
    Expiration: undefined,
    Key: undefined,
    Location: undefined,
    RequestCharged: undefined,
    SSEKMSKeyId: undefined,
    ServerSideEncryption: undefined,
    VersionId: undefined
  };
  if (output.headers["x-amz-expiration"] !== undefined) {
    contents.Expiration = output.headers["x-amz-expiration"];
  }
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  if (
    output.headers["x-amz-server-side-encryption-aws-kms-key-id"] !== undefined
  ) {
    contents.SSEKMSKeyId =
      output.headers["x-amz-server-side-encryption-aws-kms-key-id"];
  }
  if (output.headers["x-amz-server-side-encryption"] !== undefined) {
    contents.ServerSideEncryption =
      output.headers["x-amz-server-side-encryption"];
  }
  if (output.headers["x-amz-version-id"] !== undefined) {
    contents.VersionId = output.headers["x-amz-version-id"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["Bucket"] !== undefined) {
    contents.Bucket = data["Bucket"];
  }
  if (data["ETag"] !== undefined) {
    contents.ETag = data["ETag"];
  }
  if (data["Key"] !== undefined) {
    contents.Key = data["Key"];
  }
  if (data["Location"] !== undefined) {
    contents.Location = data["Location"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCompleteMultipartUploadCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CompleteMultipartUploadCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCopyObjectCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyObjectCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlCopyObjectCommandError(output, context);
  }
  const contents: CopyObjectCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CopyObjectOutput",
    CopyObjectResult: undefined,
    CopySourceVersionId: undefined,
    Expiration: undefined,
    RequestCharged: undefined,
    SSECustomerAlgorithm: undefined,
    SSECustomerKeyMD5: undefined,
    SSEKMSEncryptionContext: undefined,
    SSEKMSKeyId: undefined,
    ServerSideEncryption: undefined,
    VersionId: undefined
  };
  if (output.headers["x-amz-copy-source-version-id"] !== undefined) {
    contents.CopySourceVersionId =
      output.headers["x-amz-copy-source-version-id"];
  }
  if (output.headers["x-amz-expiration"] !== undefined) {
    contents.Expiration = output.headers["x-amz-expiration"];
  }
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-algorithm"] !==
    undefined
  ) {
    contents.SSECustomerAlgorithm =
      output.headers["x-amz-server-side-encryption-customer-algorithm"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-key-md5"] !==
    undefined
  ) {
    contents.SSECustomerKeyMD5 =
      output.headers["x-amz-server-side-encryption-customer-key-md5"];
  }
  if (output.headers["x-amz-server-side-encryption-context"] !== undefined) {
    contents.SSEKMSEncryptionContext =
      output.headers["x-amz-server-side-encryption-context"];
  }
  if (
    output.headers["x-amz-server-side-encryption-aws-kms-key-id"] !== undefined
  ) {
    contents.SSEKMSKeyId =
      output.headers["x-amz-server-side-encryption-aws-kms-key-id"];
  }
  if (output.headers["x-amz-server-side-encryption"] !== undefined) {
    contents.ServerSideEncryption =
      output.headers["x-amz-server-side-encryption"];
  }
  if (output.headers["x-amz-version-id"] !== undefined) {
    contents.VersionId = output.headers["x-amz-version-id"];
  }
  const data: any = await parseBody(output.body, context);
  contents.CopyObjectResult = deserializeAws_restXmlCopyObjectResult(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCopyObjectCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyObjectCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ObjectNotInActiveTierError":
    case "com.amazonaws.s3#ObjectNotInActiveTierError":
      response = {
        ...(await deserializeAws_restXmlObjectNotInActiveTierErrorResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCreateBucketCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBucketCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateBucketCommandError(output, context);
  }
  const contents: CreateBucketCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateBucketOutput",
    Location: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCreateBucketCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBucketCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "BucketAlreadyExists":
    case "com.amazonaws.s3#BucketAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlBucketAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BucketAlreadyOwnedByYou":
    case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
      response = {
        ...(await deserializeAws_restXmlBucketAlreadyOwnedByYouResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCreateMultipartUploadCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMultipartUploadCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateMultipartUploadCommandError(
      output,
      context
    );
  }
  const contents: CreateMultipartUploadCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateMultipartUploadOutput",
    AbortDate: undefined,
    AbortRuleId: undefined,
    Bucket: undefined,
    Key: undefined,
    RequestCharged: undefined,
    SSECustomerAlgorithm: undefined,
    SSECustomerKeyMD5: undefined,
    SSEKMSEncryptionContext: undefined,
    SSEKMSKeyId: undefined,
    ServerSideEncryption: undefined,
    UploadId: undefined
  };
  if (output.headers["x-amz-abort-date"] !== undefined) {
    contents.AbortDate = new Date(output.headers["x-amz-abort-date"]);
  }
  if (output.headers["x-amz-abort-rule-id"] !== undefined) {
    contents.AbortRuleId = output.headers["x-amz-abort-rule-id"];
  }
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-algorithm"] !==
    undefined
  ) {
    contents.SSECustomerAlgorithm =
      output.headers["x-amz-server-side-encryption-customer-algorithm"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-key-md5"] !==
    undefined
  ) {
    contents.SSECustomerKeyMD5 =
      output.headers["x-amz-server-side-encryption-customer-key-md5"];
  }
  if (output.headers["x-amz-server-side-encryption-context"] !== undefined) {
    contents.SSEKMSEncryptionContext =
      output.headers["x-amz-server-side-encryption-context"];
  }
  if (
    output.headers["x-amz-server-side-encryption-aws-kms-key-id"] !== undefined
  ) {
    contents.SSEKMSKeyId =
      output.headers["x-amz-server-side-encryption-aws-kms-key-id"];
  }
  if (output.headers["x-amz-server-side-encryption"] !== undefined) {
    contents.ServerSideEncryption =
      output.headers["x-amz-server-side-encryption"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["Bucket"] !== undefined) {
    contents.Bucket = data["Bucket"];
  }
  if (data["Key"] !== undefined) {
    contents.Key = data["Key"];
  }
  if (data["UploadId"] !== undefined) {
    contents.UploadId = data["UploadId"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCreateMultipartUploadCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMultipartUploadCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketCommandError(output, context);
  }
  const contents: DeleteBucketCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketAnalyticsConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketAnalyticsConfigurationCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketAnalyticsConfigurationCommandError(
      output,
      context
    );
  }
  const contents: DeleteBucketAnalyticsConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketAnalyticsConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketAnalyticsConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketCorsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketCorsCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketCorsCommandError(output, context);
  }
  const contents: DeleteBucketCorsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketCorsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketCorsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketEncryptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketEncryptionCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketEncryptionCommandError(
      output,
      context
    );
  }
  const contents: DeleteBucketEncryptionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketEncryptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketEncryptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketInventoryConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketInventoryConfigurationCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketInventoryConfigurationCommandError(
      output,
      context
    );
  }
  const contents: DeleteBucketInventoryConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketInventoryConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketInventoryConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketLifecycleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketLifecycleCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketLifecycleCommandError(
      output,
      context
    );
  }
  const contents: DeleteBucketLifecycleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketLifecycleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketLifecycleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketMetricsConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketMetricsConfigurationCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketMetricsConfigurationCommandError(
      output,
      context
    );
  }
  const contents: DeleteBucketMetricsConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketMetricsConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketMetricsConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketPolicyCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketPolicyCommandError(
      output,
      context
    );
  }
  const contents: DeleteBucketPolicyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketReplicationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketReplicationCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketReplicationCommandError(
      output,
      context
    );
  }
  const contents: DeleteBucketReplicationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketReplicationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketReplicationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketTaggingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketTaggingCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketTaggingCommandError(
      output,
      context
    );
  }
  const contents: DeleteBucketTaggingCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketTaggingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketTaggingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteBucketWebsiteCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketWebsiteCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteBucketWebsiteCommandError(
      output,
      context
    );
  }
  const contents: DeleteBucketWebsiteCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteBucketWebsiteCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBucketWebsiteCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteObjectCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteObjectCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteObjectCommandError(output, context);
  }
  const contents: DeleteObjectCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteObjectOutput",
    DeleteMarker: undefined,
    RequestCharged: undefined,
    VersionId: undefined
  };
  if (output.headers["x-amz-delete-marker"] !== undefined) {
    contents.DeleteMarker = output.headers["x-amz-delete-marker"] === "true";
  }
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  if (output.headers["x-amz-version-id"] !== undefined) {
    contents.VersionId = output.headers["x-amz-version-id"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteObjectCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteObjectCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteObjectTaggingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteObjectTaggingCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteObjectTaggingCommandError(
      output,
      context
    );
  }
  const contents: DeleteObjectTaggingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteObjectTaggingOutput",
    VersionId: undefined
  };
  if (output.headers["x-amz-version-id"] !== undefined) {
    contents.VersionId = output.headers["x-amz-version-id"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteObjectTaggingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteObjectTaggingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteObjectsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteObjectsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteObjectsCommandError(output, context);
  }
  const contents: DeleteObjectsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteObjectsOutput",
    Deleted: undefined,
    Errors: undefined,
    RequestCharged: undefined
  };
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  const data: any = await parseBody(output.body, context);
  if (data.Deleted === "") {
    contents.Deleted = [];
  }
  if (data["Deleted"] !== undefined) {
    const wrappedItem =
      data["Deleted"] instanceof Array ? data["Deleted"] : [data["Deleted"]];
    contents.Deleted = deserializeAws_restXmlDeletedObjects(
      wrappedItem,
      context
    );
  }
  if (data.Error === "") {
    contents.Errors = [];
  }
  if (data["Error"] !== undefined) {
    const wrappedItem =
      data["Error"] instanceof Array ? data["Error"] : [data["Error"]];
    contents.Errors = deserializeAws_restXmlErrors(wrappedItem, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteObjectsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteObjectsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeletePublicAccessBlockCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePublicAccessBlockCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeletePublicAccessBlockCommandError(
      output,
      context
    );
  }
  const contents: DeletePublicAccessBlockCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeletePublicAccessBlockCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePublicAccessBlockCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketAccelerateConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketAccelerateConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketAccelerateConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetBucketAccelerateConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketAccelerateConfigurationOutput",
    Status: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Status"] !== undefined) {
    contents.Status = data["Status"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketAccelerateConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketAccelerateConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketAclCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketAclCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketAclCommandError(output, context);
  }
  const contents: GetBucketAclCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketAclOutput",
    Grants: undefined,
    Owner: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AccessControlList === "") {
    contents.Grants = [];
  }
  if (
    data["AccessControlList"] !== undefined &&
    data["AccessControlList"]["Grant"] !== undefined
  ) {
    const wrappedItem =
      data["AccessControlList"]["Grant"] instanceof Array
        ? data["AccessControlList"]["Grant"]
        : [data["AccessControlList"]["Grant"]];
    contents.Grants = deserializeAws_restXmlGrants(wrappedItem, context);
  }
  if (data["Owner"] !== undefined) {
    contents.Owner = deserializeAws_restXmlOwner(data["Owner"], context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketAclCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketAclCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketAnalyticsConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketAnalyticsConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketAnalyticsConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetBucketAnalyticsConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketAnalyticsConfigurationOutput",
    AnalyticsConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.AnalyticsConfiguration = deserializeAws_restXmlAnalyticsConfiguration(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketAnalyticsConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketAnalyticsConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketCorsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketCorsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketCorsCommandError(output, context);
  }
  const contents: GetBucketCorsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketCorsOutput",
    CORSRules: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.CORSRule === "") {
    contents.CORSRules = [];
  }
  if (data["CORSRule"] !== undefined) {
    const wrappedItem =
      data["CORSRule"] instanceof Array ? data["CORSRule"] : [data["CORSRule"]];
    contents.CORSRules = deserializeAws_restXmlCORSRules(wrappedItem, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketCorsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketCorsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketEncryptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketEncryptionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketEncryptionCommandError(
      output,
      context
    );
  }
  const contents: GetBucketEncryptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketEncryptionOutput",
    ServerSideEncryptionConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ServerSideEncryptionConfiguration = deserializeAws_restXmlServerSideEncryptionConfiguration(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketEncryptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketEncryptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketInventoryConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketInventoryConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketInventoryConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetBucketInventoryConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketInventoryConfigurationOutput",
    InventoryConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.InventoryConfiguration = deserializeAws_restXmlInventoryConfiguration(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketInventoryConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketInventoryConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketLifecycleConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketLifecycleConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketLifecycleConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetBucketLifecycleConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketLifecycleConfigurationOutput",
    Rules: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Rule === "") {
    contents.Rules = [];
  }
  if (data["Rule"] !== undefined) {
    const wrappedItem =
      data["Rule"] instanceof Array ? data["Rule"] : [data["Rule"]];
    contents.Rules = deserializeAws_restXmlLifecycleRules(wrappedItem, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketLifecycleConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketLifecycleConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketLocationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketLocationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketLocationCommandError(output, context);
  }
  const contents: GetBucketLocationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketLocationOutput",
    LocationConstraint: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["LocationConstraint"] !== undefined) {
    contents.LocationConstraint = data["LocationConstraint"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketLocationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketLocationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketLoggingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketLoggingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketLoggingCommandError(output, context);
  }
  const contents: GetBucketLoggingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketLoggingOutput",
    LoggingEnabled: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["LoggingEnabled"] !== undefined) {
    contents.LoggingEnabled = deserializeAws_restXmlLoggingEnabled(
      data["LoggingEnabled"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketLoggingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketLoggingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketMetricsConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketMetricsConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketMetricsConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetBucketMetricsConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketMetricsConfigurationOutput",
    MetricsConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.MetricsConfiguration = deserializeAws_restXmlMetricsConfiguration(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketMetricsConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketMetricsConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketNotificationConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketNotificationConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketNotificationConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetBucketNotificationConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "NotificationConfiguration",
    LambdaFunctionConfigurations: undefined,
    QueueConfigurations: undefined,
    TopicConfigurations: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.CloudFunctionConfiguration === "") {
    contents.LambdaFunctionConfigurations = [];
  }
  if (data["CloudFunctionConfiguration"] !== undefined) {
    const wrappedItem =
      data["CloudFunctionConfiguration"] instanceof Array
        ? data["CloudFunctionConfiguration"]
        : [data["CloudFunctionConfiguration"]];
    contents.LambdaFunctionConfigurations = deserializeAws_restXmlLambdaFunctionConfigurationList(
      wrappedItem,
      context
    );
  }
  if (data.QueueConfiguration === "") {
    contents.QueueConfigurations = [];
  }
  if (data["QueueConfiguration"] !== undefined) {
    const wrappedItem =
      data["QueueConfiguration"] instanceof Array
        ? data["QueueConfiguration"]
        : [data["QueueConfiguration"]];
    contents.QueueConfigurations = deserializeAws_restXmlQueueConfigurationList(
      wrappedItem,
      context
    );
  }
  if (data.TopicConfiguration === "") {
    contents.TopicConfigurations = [];
  }
  if (data["TopicConfiguration"] !== undefined) {
    const wrappedItem =
      data["TopicConfiguration"] instanceof Array
        ? data["TopicConfiguration"]
        : [data["TopicConfiguration"]];
    contents.TopicConfigurations = deserializeAws_restXmlTopicConfigurationList(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketNotificationConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketNotificationConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketPolicyCommandError(output, context);
  }
  const contents: GetBucketPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketPolicyOutput",
    Policy: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Policy"] !== undefined) {
    contents.Policy = data["Policy"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketPolicyStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketPolicyStatusCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketPolicyStatusCommandError(
      output,
      context
    );
  }
  const contents: GetBucketPolicyStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketPolicyStatusOutput",
    PolicyStatus: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.PolicyStatus = deserializeAws_restXmlPolicyStatus(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketPolicyStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketPolicyStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketReplicationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketReplicationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketReplicationCommandError(
      output,
      context
    );
  }
  const contents: GetBucketReplicationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketReplicationOutput",
    ReplicationConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ReplicationConfiguration = deserializeAws_restXmlReplicationConfiguration(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketReplicationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketReplicationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketRequestPaymentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketRequestPaymentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketRequestPaymentCommandError(
      output,
      context
    );
  }
  const contents: GetBucketRequestPaymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketRequestPaymentOutput",
    Payer: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Payer"] !== undefined) {
    contents.Payer = data["Payer"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketRequestPaymentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketRequestPaymentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketTaggingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketTaggingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketTaggingCommandError(output, context);
  }
  const contents: GetBucketTaggingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketTaggingOutput",
    TagSet: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.TagSet === "") {
    contents.TagSet = [];
  }
  if (data["TagSet"] !== undefined && data["TagSet"]["Tag"] !== undefined) {
    const wrappedItem =
      data["TagSet"]["Tag"] instanceof Array
        ? data["TagSet"]["Tag"]
        : [data["TagSet"]["Tag"]];
    contents.TagSet = deserializeAws_restXmlTagSet(wrappedItem, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketTaggingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketTaggingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketVersioningCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketVersioningCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketVersioningCommandError(
      output,
      context
    );
  }
  const contents: GetBucketVersioningCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketVersioningOutput",
    MFADelete: undefined,
    Status: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["MfaDelete"] !== undefined) {
    contents.MFADelete = data["MfaDelete"];
  }
  if (data["Status"] !== undefined) {
    contents.Status = data["Status"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketVersioningCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketVersioningCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetBucketWebsiteCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketWebsiteCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetBucketWebsiteCommandError(output, context);
  }
  const contents: GetBucketWebsiteCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBucketWebsiteOutput",
    ErrorDocument: undefined,
    IndexDocument: undefined,
    RedirectAllRequestsTo: undefined,
    RoutingRules: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ErrorDocument"] !== undefined) {
    contents.ErrorDocument = deserializeAws_restXmlErrorDocument(
      data["ErrorDocument"],
      context
    );
  }
  if (data["IndexDocument"] !== undefined) {
    contents.IndexDocument = deserializeAws_restXmlIndexDocument(
      data["IndexDocument"],
      context
    );
  }
  if (data["RedirectAllRequestsTo"] !== undefined) {
    contents.RedirectAllRequestsTo = deserializeAws_restXmlRedirectAllRequestsTo(
      data["RedirectAllRequestsTo"],
      context
    );
  }
  if (data.RoutingRules === "") {
    contents.RoutingRules = [];
  }
  if (
    data["RoutingRules"] !== undefined &&
    data["RoutingRules"]["RoutingRule"] !== undefined
  ) {
    const wrappedItem =
      data["RoutingRules"]["RoutingRule"] instanceof Array
        ? data["RoutingRules"]["RoutingRule"]
        : [data["RoutingRules"]["RoutingRule"]];
    contents.RoutingRules = deserializeAws_restXmlRoutingRules(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetBucketWebsiteCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketWebsiteCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetObjectCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetObjectCommandError(output, context);
  }
  const contents: GetObjectCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetObjectOutput",
    AcceptRanges: undefined,
    Body: undefined,
    CacheControl: undefined,
    ContentDisposition: undefined,
    ContentEncoding: undefined,
    ContentLanguage: undefined,
    ContentLength: undefined,
    ContentRange: undefined,
    ContentType: undefined,
    DeleteMarker: undefined,
    ETag: undefined,
    Expiration: undefined,
    Expires: undefined,
    LastModified: undefined,
    Metadata: undefined,
    MissingMeta: undefined,
    ObjectLockLegalHoldStatus: undefined,
    ObjectLockMode: undefined,
    ObjectLockRetainUntilDate: undefined,
    PartsCount: undefined,
    ReplicationStatus: undefined,
    RequestCharged: undefined,
    Restore: undefined,
    SSECustomerAlgorithm: undefined,
    SSECustomerKeyMD5: undefined,
    SSEKMSKeyId: undefined,
    ServerSideEncryption: undefined,
    StorageClass: undefined,
    TagCount: undefined,
    VersionId: undefined,
    WebsiteRedirectLocation: undefined
  };
  if (output.headers["accept-ranges"] !== undefined) {
    contents.AcceptRanges = output.headers["accept-ranges"];
  }
  if (output.headers["cache-control"] !== undefined) {
    contents.CacheControl = output.headers["cache-control"];
  }
  if (output.headers["content-disposition"] !== undefined) {
    contents.ContentDisposition = output.headers["content-disposition"];
  }
  if (output.headers["content-encoding"] !== undefined) {
    contents.ContentEncoding = output.headers["content-encoding"];
  }
  if (output.headers["content-language"] !== undefined) {
    contents.ContentLanguage = output.headers["content-language"];
  }
  if (output.headers["content-length"] !== undefined) {
    contents.ContentLength = parseInt(output.headers["content-length"], 10);
  }
  if (output.headers["content-range"] !== undefined) {
    contents.ContentRange = output.headers["content-range"];
  }
  if (output.headers["content-type"] !== undefined) {
    contents.ContentType = output.headers["content-type"];
  }
  if (output.headers["x-amz-delete-marker"] !== undefined) {
    contents.DeleteMarker = output.headers["x-amz-delete-marker"] === "true";
  }
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["x-amz-expiration"] !== undefined) {
    contents.Expiration = output.headers["x-amz-expiration"];
  }
  if (output.headers["expires"] !== undefined) {
    contents.Expires = new Date(output.headers["expires"]);
  }
  if (output.headers["last-modified"] !== undefined) {
    contents.LastModified = new Date(output.headers["last-modified"]);
  }
  if (output.headers["x-amz-missing-meta"] !== undefined) {
    contents.MissingMeta = parseInt(output.headers["x-amz-missing-meta"], 10);
  }
  if (output.headers["x-amz-object-lock-legal-hold"] !== undefined) {
    contents.ObjectLockLegalHoldStatus =
      output.headers["x-amz-object-lock-legal-hold"];
  }
  if (output.headers["x-amz-object-lock-mode"] !== undefined) {
    contents.ObjectLockMode = output.headers["x-amz-object-lock-mode"];
  }
  if (output.headers["x-amz-object-lock-retain-until-date"] !== undefined) {
    contents.ObjectLockRetainUntilDate = new Date(
      output.headers["x-amz-object-lock-retain-until-date"]
    );
  }
  if (output.headers["x-amz-mp-parts-count"] !== undefined) {
    contents.PartsCount = parseInt(output.headers["x-amz-mp-parts-count"], 10);
  }
  if (output.headers["x-amz-replication-status"] !== undefined) {
    contents.ReplicationStatus = output.headers["x-amz-replication-status"];
  }
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  if (output.headers["x-amz-restore"] !== undefined) {
    contents.Restore = output.headers["x-amz-restore"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-algorithm"] !==
    undefined
  ) {
    contents.SSECustomerAlgorithm =
      output.headers["x-amz-server-side-encryption-customer-algorithm"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-key-md5"] !==
    undefined
  ) {
    contents.SSECustomerKeyMD5 =
      output.headers["x-amz-server-side-encryption-customer-key-md5"];
  }
  if (
    output.headers["x-amz-server-side-encryption-aws-kms-key-id"] !== undefined
  ) {
    contents.SSEKMSKeyId =
      output.headers["x-amz-server-side-encryption-aws-kms-key-id"];
  }
  if (output.headers["x-amz-server-side-encryption"] !== undefined) {
    contents.ServerSideEncryption =
      output.headers["x-amz-server-side-encryption"];
  }
  if (output.headers["x-amz-storage-class"] !== undefined) {
    contents.StorageClass = output.headers["x-amz-storage-class"];
  }
  if (output.headers["x-amz-tagging-count"] !== undefined) {
    contents.TagCount = parseInt(output.headers["x-amz-tagging-count"], 10);
  }
  if (output.headers["x-amz-version-id"] !== undefined) {
    contents.VersionId = output.headers["x-amz-version-id"];
  }
  if (output.headers["x-amz-website-redirect-location"] !== undefined) {
    contents.WebsiteRedirectLocation =
      output.headers["x-amz-website-redirect-location"];
  }
  Object.keys(output.headers).forEach(header => {
    if (contents.Metadata === undefined) {
      contents.Metadata = {};
    }
    if (header.startsWith("x-amz-meta-")) {
      contents.Metadata[header.substring(11)] = output.headers[header];
    }
  });
  const data: any = output.body;
  contents.Body = data;
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetObjectCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchKeyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetObjectAclCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectAclCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetObjectAclCommandError(output, context);
  }
  const contents: GetObjectAclCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetObjectAclOutput",
    Grants: undefined,
    Owner: undefined,
    RequestCharged: undefined
  };
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  const data: any = await parseBody(output.body, context);
  if (data.AccessControlList === "") {
    contents.Grants = [];
  }
  if (
    data["AccessControlList"] !== undefined &&
    data["AccessControlList"]["Grant"] !== undefined
  ) {
    const wrappedItem =
      data["AccessControlList"]["Grant"] instanceof Array
        ? data["AccessControlList"]["Grant"]
        : [data["AccessControlList"]["Grant"]];
    contents.Grants = deserializeAws_restXmlGrants(wrappedItem, context);
  }
  if (data["Owner"] !== undefined) {
    contents.Owner = deserializeAws_restXmlOwner(data["Owner"], context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetObjectAclCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectAclCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchKeyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetObjectLegalHoldCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectLegalHoldCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetObjectLegalHoldCommandError(
      output,
      context
    );
  }
  const contents: GetObjectLegalHoldCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetObjectLegalHoldOutput",
    LegalHold: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.LegalHold = deserializeAws_restXmlObjectLockLegalHold(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetObjectLegalHoldCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectLegalHoldCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetObjectLockConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectLockConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetObjectLockConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetObjectLockConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetObjectLockConfigurationOutput",
    ObjectLockConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.ObjectLockConfiguration = deserializeAws_restXmlObjectLockConfiguration(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetObjectLockConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectLockConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetObjectRetentionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectRetentionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetObjectRetentionCommandError(
      output,
      context
    );
  }
  const contents: GetObjectRetentionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetObjectRetentionOutput",
    Retention: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.Retention = deserializeAws_restXmlObjectLockRetention(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetObjectRetentionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectRetentionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetObjectTaggingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectTaggingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetObjectTaggingCommandError(output, context);
  }
  const contents: GetObjectTaggingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetObjectTaggingOutput",
    TagSet: undefined,
    VersionId: undefined
  };
  if (output.headers["x-amz-version-id"] !== undefined) {
    contents.VersionId = output.headers["x-amz-version-id"];
  }
  const data: any = await parseBody(output.body, context);
  if (data.TagSet === "") {
    contents.TagSet = [];
  }
  if (data["TagSet"] !== undefined && data["TagSet"]["Tag"] !== undefined) {
    const wrappedItem =
      data["TagSet"]["Tag"] instanceof Array
        ? data["TagSet"]["Tag"]
        : [data["TagSet"]["Tag"]];
    contents.TagSet = deserializeAws_restXmlTagSet(wrappedItem, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetObjectTaggingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectTaggingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetObjectTorrentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectTorrentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetObjectTorrentCommandError(output, context);
  }
  const contents: GetObjectTorrentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetObjectTorrentOutput",
    Body: undefined,
    RequestCharged: undefined
  };
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  const data: any = output.body;
  contents.Body = data;
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetObjectTorrentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetObjectTorrentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetPublicAccessBlockCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPublicAccessBlockCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetPublicAccessBlockCommandError(
      output,
      context
    );
  }
  const contents: GetPublicAccessBlockCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPublicAccessBlockOutput",
    PublicAccessBlockConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  contents.PublicAccessBlockConfiguration = deserializeAws_restXmlPublicAccessBlockConfiguration(
    data,
    context
  );
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetPublicAccessBlockCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPublicAccessBlockCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlHeadBucketCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<HeadBucketCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlHeadBucketCommandError(output, context);
  }
  const contents: HeadBucketCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlHeadBucketCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<HeadBucketCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      response = {
        ...(await deserializeAws_restXmlNoSuchBucketResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlHeadObjectCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<HeadObjectCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlHeadObjectCommandError(output, context);
  }
  const contents: HeadObjectCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "HeadObjectOutput",
    AcceptRanges: undefined,
    CacheControl: undefined,
    ContentDisposition: undefined,
    ContentEncoding: undefined,
    ContentLanguage: undefined,
    ContentLength: undefined,
    ContentType: undefined,
    DeleteMarker: undefined,
    ETag: undefined,
    Expiration: undefined,
    Expires: undefined,
    LastModified: undefined,
    Metadata: undefined,
    MissingMeta: undefined,
    ObjectLockLegalHoldStatus: undefined,
    ObjectLockMode: undefined,
    ObjectLockRetainUntilDate: undefined,
    PartsCount: undefined,
    ReplicationStatus: undefined,
    RequestCharged: undefined,
    Restore: undefined,
    SSECustomerAlgorithm: undefined,
    SSECustomerKeyMD5: undefined,
    SSEKMSKeyId: undefined,
    ServerSideEncryption: undefined,
    StorageClass: undefined,
    VersionId: undefined,
    WebsiteRedirectLocation: undefined
  };
  if (output.headers["accept-ranges"] !== undefined) {
    contents.AcceptRanges = output.headers["accept-ranges"];
  }
  if (output.headers["cache-control"] !== undefined) {
    contents.CacheControl = output.headers["cache-control"];
  }
  if (output.headers["content-disposition"] !== undefined) {
    contents.ContentDisposition = output.headers["content-disposition"];
  }
  if (output.headers["content-encoding"] !== undefined) {
    contents.ContentEncoding = output.headers["content-encoding"];
  }
  if (output.headers["content-language"] !== undefined) {
    contents.ContentLanguage = output.headers["content-language"];
  }
  if (output.headers["content-length"] !== undefined) {
    contents.ContentLength = parseInt(output.headers["content-length"], 10);
  }
  if (output.headers["content-type"] !== undefined) {
    contents.ContentType = output.headers["content-type"];
  }
  if (output.headers["x-amz-delete-marker"] !== undefined) {
    contents.DeleteMarker = output.headers["x-amz-delete-marker"] === "true";
  }
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["x-amz-expiration"] !== undefined) {
    contents.Expiration = output.headers["x-amz-expiration"];
  }
  if (output.headers["expires"] !== undefined) {
    contents.Expires = new Date(output.headers["expires"]);
  }
  if (output.headers["last-modified"] !== undefined) {
    contents.LastModified = new Date(output.headers["last-modified"]);
  }
  if (output.headers["x-amz-missing-meta"] !== undefined) {
    contents.MissingMeta = parseInt(output.headers["x-amz-missing-meta"], 10);
  }
  if (output.headers["x-amz-object-lock-legal-hold"] !== undefined) {
    contents.ObjectLockLegalHoldStatus =
      output.headers["x-amz-object-lock-legal-hold"];
  }
  if (output.headers["x-amz-object-lock-mode"] !== undefined) {
    contents.ObjectLockMode = output.headers["x-amz-object-lock-mode"];
  }
  if (output.headers["x-amz-object-lock-retain-until-date"] !== undefined) {
    contents.ObjectLockRetainUntilDate = new Date(
      output.headers["x-amz-object-lock-retain-until-date"]
    );
  }
  if (output.headers["x-amz-mp-parts-count"] !== undefined) {
    contents.PartsCount = parseInt(output.headers["x-amz-mp-parts-count"], 10);
  }
  if (output.headers["x-amz-replication-status"] !== undefined) {
    contents.ReplicationStatus = output.headers["x-amz-replication-status"];
  }
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  if (output.headers["x-amz-restore"] !== undefined) {
    contents.Restore = output.headers["x-amz-restore"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-algorithm"] !==
    undefined
  ) {
    contents.SSECustomerAlgorithm =
      output.headers["x-amz-server-side-encryption-customer-algorithm"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-key-md5"] !==
    undefined
  ) {
    contents.SSECustomerKeyMD5 =
      output.headers["x-amz-server-side-encryption-customer-key-md5"];
  }
  if (
    output.headers["x-amz-server-side-encryption-aws-kms-key-id"] !== undefined
  ) {
    contents.SSEKMSKeyId =
      output.headers["x-amz-server-side-encryption-aws-kms-key-id"];
  }
  if (output.headers["x-amz-server-side-encryption"] !== undefined) {
    contents.ServerSideEncryption =
      output.headers["x-amz-server-side-encryption"];
  }
  if (output.headers["x-amz-storage-class"] !== undefined) {
    contents.StorageClass = output.headers["x-amz-storage-class"];
  }
  if (output.headers["x-amz-version-id"] !== undefined) {
    contents.VersionId = output.headers["x-amz-version-id"];
  }
  if (output.headers["x-amz-website-redirect-location"] !== undefined) {
    contents.WebsiteRedirectLocation =
      output.headers["x-amz-website-redirect-location"];
  }
  Object.keys(output.headers).forEach(header => {
    if (contents.Metadata === undefined) {
      contents.Metadata = {};
    }
    if (header.startsWith("x-amz-meta-")) {
      contents.Metadata[header.substring(11)] = output.headers[header];
    }
  });
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlHeadObjectCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<HeadObjectCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchKeyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListBucketAnalyticsConfigurationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBucketAnalyticsConfigurationsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListBucketAnalyticsConfigurationsCommandError(
      output,
      context
    );
  }
  const contents: ListBucketAnalyticsConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBucketAnalyticsConfigurationsOutput",
    AnalyticsConfigurationList: undefined,
    ContinuationToken: undefined,
    IsTruncated: undefined,
    NextContinuationToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AnalyticsConfiguration === "") {
    contents.AnalyticsConfigurationList = [];
  }
  if (data["AnalyticsConfiguration"] !== undefined) {
    const wrappedItem =
      data["AnalyticsConfiguration"] instanceof Array
        ? data["AnalyticsConfiguration"]
        : [data["AnalyticsConfiguration"]];
    contents.AnalyticsConfigurationList = deserializeAws_restXmlAnalyticsConfigurationList(
      wrappedItem,
      context
    );
  }
  if (data["ContinuationToken"] !== undefined) {
    contents.ContinuationToken = data["ContinuationToken"];
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["NextContinuationToken"] !== undefined) {
    contents.NextContinuationToken = data["NextContinuationToken"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListBucketAnalyticsConfigurationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBucketAnalyticsConfigurationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListBucketInventoryConfigurationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBucketInventoryConfigurationsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListBucketInventoryConfigurationsCommandError(
      output,
      context
    );
  }
  const contents: ListBucketInventoryConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBucketInventoryConfigurationsOutput",
    ContinuationToken: undefined,
    InventoryConfigurationList: undefined,
    IsTruncated: undefined,
    NextContinuationToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ContinuationToken"] !== undefined) {
    contents.ContinuationToken = data["ContinuationToken"];
  }
  if (data.InventoryConfiguration === "") {
    contents.InventoryConfigurationList = [];
  }
  if (data["InventoryConfiguration"] !== undefined) {
    const wrappedItem =
      data["InventoryConfiguration"] instanceof Array
        ? data["InventoryConfiguration"]
        : [data["InventoryConfiguration"]];
    contents.InventoryConfigurationList = deserializeAws_restXmlInventoryConfigurationList(
      wrappedItem,
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["NextContinuationToken"] !== undefined) {
    contents.NextContinuationToken = data["NextContinuationToken"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListBucketInventoryConfigurationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBucketInventoryConfigurationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListBucketMetricsConfigurationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBucketMetricsConfigurationsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListBucketMetricsConfigurationsCommandError(
      output,
      context
    );
  }
  const contents: ListBucketMetricsConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBucketMetricsConfigurationsOutput",
    ContinuationToken: undefined,
    IsTruncated: undefined,
    MetricsConfigurationList: undefined,
    NextContinuationToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ContinuationToken"] !== undefined) {
    contents.ContinuationToken = data["ContinuationToken"];
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data.MetricsConfiguration === "") {
    contents.MetricsConfigurationList = [];
  }
  if (data["MetricsConfiguration"] !== undefined) {
    const wrappedItem =
      data["MetricsConfiguration"] instanceof Array
        ? data["MetricsConfiguration"]
        : [data["MetricsConfiguration"]];
    contents.MetricsConfigurationList = deserializeAws_restXmlMetricsConfigurationList(
      wrappedItem,
      context
    );
  }
  if (data["NextContinuationToken"] !== undefined) {
    contents.NextContinuationToken = data["NextContinuationToken"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListBucketMetricsConfigurationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBucketMetricsConfigurationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListBucketsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBucketsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListBucketsCommandError(output, context);
  }
  const contents: ListBucketsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBucketsOutput",
    Buckets: undefined,
    Owner: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Buckets === "") {
    contents.Buckets = [];
  }
  if (
    data["Buckets"] !== undefined &&
    data["Buckets"]["Bucket"] !== undefined
  ) {
    const wrappedItem =
      data["Buckets"]["Bucket"] instanceof Array
        ? data["Buckets"]["Bucket"]
        : [data["Buckets"]["Bucket"]];
    contents.Buckets = deserializeAws_restXmlBuckets(wrappedItem, context);
  }
  if (data["Owner"] !== undefined) {
    contents.Owner = deserializeAws_restXmlOwner(data["Owner"], context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListBucketsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBucketsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListMultipartUploadsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMultipartUploadsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListMultipartUploadsCommandError(
      output,
      context
    );
  }
  const contents: ListMultipartUploadsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListMultipartUploadsOutput",
    Bucket: undefined,
    CommonPrefixes: undefined,
    Delimiter: undefined,
    EncodingType: undefined,
    IsTruncated: undefined,
    KeyMarker: undefined,
    MaxUploads: undefined,
    NextKeyMarker: undefined,
    NextUploadIdMarker: undefined,
    Prefix: undefined,
    UploadIdMarker: undefined,
    Uploads: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Bucket"] !== undefined) {
    contents.Bucket = data["Bucket"];
  }
  if (data.CommonPrefixes === "") {
    contents.CommonPrefixes = [];
  }
  if (data["CommonPrefixes"] !== undefined) {
    const wrappedItem =
      data["CommonPrefixes"] instanceof Array
        ? data["CommonPrefixes"]
        : [data["CommonPrefixes"]];
    contents.CommonPrefixes = deserializeAws_restXmlCommonPrefixList(
      wrappedItem,
      context
    );
  }
  if (data["Delimiter"] !== undefined) {
    contents.Delimiter = data["Delimiter"];
  }
  if (data["EncodingType"] !== undefined) {
    contents.EncodingType = data["EncodingType"];
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["KeyMarker"] !== undefined) {
    contents.KeyMarker = data["KeyMarker"];
  }
  if (data["MaxUploads"] !== undefined) {
    contents.MaxUploads = parseInt(data["MaxUploads"]);
  }
  if (data["NextKeyMarker"] !== undefined) {
    contents.NextKeyMarker = data["NextKeyMarker"];
  }
  if (data["NextUploadIdMarker"] !== undefined) {
    contents.NextUploadIdMarker = data["NextUploadIdMarker"];
  }
  if (data["Prefix"] !== undefined) {
    contents.Prefix = data["Prefix"];
  }
  if (data["UploadIdMarker"] !== undefined) {
    contents.UploadIdMarker = data["UploadIdMarker"];
  }
  if (data.Upload === "") {
    contents.Uploads = [];
  }
  if (data["Upload"] !== undefined) {
    const wrappedItem =
      data["Upload"] instanceof Array ? data["Upload"] : [data["Upload"]];
    contents.Uploads = deserializeAws_restXmlMultipartUploadList(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListMultipartUploadsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMultipartUploadsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListObjectVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListObjectVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListObjectVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListObjectVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListObjectVersionsOutput",
    CommonPrefixes: undefined,
    DeleteMarkers: undefined,
    Delimiter: undefined,
    EncodingType: undefined,
    IsTruncated: undefined,
    KeyMarker: undefined,
    MaxKeys: undefined,
    Name: undefined,
    NextKeyMarker: undefined,
    NextVersionIdMarker: undefined,
    Prefix: undefined,
    VersionIdMarker: undefined,
    Versions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.CommonPrefixes === "") {
    contents.CommonPrefixes = [];
  }
  if (data["CommonPrefixes"] !== undefined) {
    const wrappedItem =
      data["CommonPrefixes"] instanceof Array
        ? data["CommonPrefixes"]
        : [data["CommonPrefixes"]];
    contents.CommonPrefixes = deserializeAws_restXmlCommonPrefixList(
      wrappedItem,
      context
    );
  }
  if (data.DeleteMarker === "") {
    contents.DeleteMarkers = [];
  }
  if (data["DeleteMarker"] !== undefined) {
    const wrappedItem =
      data["DeleteMarker"] instanceof Array
        ? data["DeleteMarker"]
        : [data["DeleteMarker"]];
    contents.DeleteMarkers = deserializeAws_restXmlDeleteMarkers(
      wrappedItem,
      context
    );
  }
  if (data["Delimiter"] !== undefined) {
    contents.Delimiter = data["Delimiter"];
  }
  if (data["EncodingType"] !== undefined) {
    contents.EncodingType = data["EncodingType"];
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["KeyMarker"] !== undefined) {
    contents.KeyMarker = data["KeyMarker"];
  }
  if (data["MaxKeys"] !== undefined) {
    contents.MaxKeys = parseInt(data["MaxKeys"]);
  }
  if (data["Name"] !== undefined) {
    contents.Name = data["Name"];
  }
  if (data["NextKeyMarker"] !== undefined) {
    contents.NextKeyMarker = data["NextKeyMarker"];
  }
  if (data["NextVersionIdMarker"] !== undefined) {
    contents.NextVersionIdMarker = data["NextVersionIdMarker"];
  }
  if (data["Prefix"] !== undefined) {
    contents.Prefix = data["Prefix"];
  }
  if (data["VersionIdMarker"] !== undefined) {
    contents.VersionIdMarker = data["VersionIdMarker"];
  }
  if (data.Version === "") {
    contents.Versions = [];
  }
  if (data["Version"] !== undefined) {
    const wrappedItem =
      data["Version"] instanceof Array ? data["Version"] : [data["Version"]];
    contents.Versions = deserializeAws_restXmlObjectVersionList(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListObjectVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListObjectVersionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListObjectsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListObjectsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListObjectsCommandError(output, context);
  }
  const contents: ListObjectsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListObjectsOutput",
    CommonPrefixes: undefined,
    Contents: undefined,
    Delimiter: undefined,
    EncodingType: undefined,
    IsTruncated: undefined,
    Marker: undefined,
    MaxKeys: undefined,
    Name: undefined,
    NextMarker: undefined,
    Prefix: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.CommonPrefixes === "") {
    contents.CommonPrefixes = [];
  }
  if (data["CommonPrefixes"] !== undefined) {
    const wrappedItem =
      data["CommonPrefixes"] instanceof Array
        ? data["CommonPrefixes"]
        : [data["CommonPrefixes"]];
    contents.CommonPrefixes = deserializeAws_restXmlCommonPrefixList(
      wrappedItem,
      context
    );
  }
  if (data.Contents === "") {
    contents.Contents = [];
  }
  if (data["Contents"] !== undefined) {
    const wrappedItem =
      data["Contents"] instanceof Array ? data["Contents"] : [data["Contents"]];
    contents.Contents = deserializeAws_restXmlObjectList(wrappedItem, context);
  }
  if (data["Delimiter"] !== undefined) {
    contents.Delimiter = data["Delimiter"];
  }
  if (data["EncodingType"] !== undefined) {
    contents.EncodingType = data["EncodingType"];
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["Marker"] !== undefined) {
    contents.Marker = data["Marker"];
  }
  if (data["MaxKeys"] !== undefined) {
    contents.MaxKeys = parseInt(data["MaxKeys"]);
  }
  if (data["Name"] !== undefined) {
    contents.Name = data["Name"];
  }
  if (data["NextMarker"] !== undefined) {
    contents.NextMarker = data["NextMarker"];
  }
  if (data["Prefix"] !== undefined) {
    contents.Prefix = data["Prefix"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListObjectsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListObjectsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      response = {
        ...(await deserializeAws_restXmlNoSuchBucketResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListObjectsV2Command(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListObjectsV2CommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListObjectsV2CommandError(output, context);
  }
  const contents: ListObjectsV2CommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListObjectsV2Output",
    CommonPrefixes: undefined,
    Contents: undefined,
    ContinuationToken: undefined,
    Delimiter: undefined,
    EncodingType: undefined,
    IsTruncated: undefined,
    KeyCount: undefined,
    MaxKeys: undefined,
    Name: undefined,
    NextContinuationToken: undefined,
    Prefix: undefined,
    StartAfter: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.CommonPrefixes === "") {
    contents.CommonPrefixes = [];
  }
  if (data["CommonPrefixes"] !== undefined) {
    const wrappedItem =
      data["CommonPrefixes"] instanceof Array
        ? data["CommonPrefixes"]
        : [data["CommonPrefixes"]];
    contents.CommonPrefixes = deserializeAws_restXmlCommonPrefixList(
      wrappedItem,
      context
    );
  }
  if (data.Contents === "") {
    contents.Contents = [];
  }
  if (data["Contents"] !== undefined) {
    const wrappedItem =
      data["Contents"] instanceof Array ? data["Contents"] : [data["Contents"]];
    contents.Contents = deserializeAws_restXmlObjectList(wrappedItem, context);
  }
  if (data["ContinuationToken"] !== undefined) {
    contents.ContinuationToken = data["ContinuationToken"];
  }
  if (data["Delimiter"] !== undefined) {
    contents.Delimiter = data["Delimiter"];
  }
  if (data["EncodingType"] !== undefined) {
    contents.EncodingType = data["EncodingType"];
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["KeyCount"] !== undefined) {
    contents.KeyCount = parseInt(data["KeyCount"]);
  }
  if (data["MaxKeys"] !== undefined) {
    contents.MaxKeys = parseInt(data["MaxKeys"]);
  }
  if (data["Name"] !== undefined) {
    contents.Name = data["Name"];
  }
  if (data["NextContinuationToken"] !== undefined) {
    contents.NextContinuationToken = data["NextContinuationToken"];
  }
  if (data["Prefix"] !== undefined) {
    contents.Prefix = data["Prefix"];
  }
  if (data["StartAfter"] !== undefined) {
    contents.StartAfter = data["StartAfter"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListObjectsV2CommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListObjectsV2CommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      response = {
        ...(await deserializeAws_restXmlNoSuchBucketResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListPartsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPartsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListPartsCommandError(output, context);
  }
  const contents: ListPartsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPartsOutput",
    AbortDate: undefined,
    AbortRuleId: undefined,
    Bucket: undefined,
    Initiator: undefined,
    IsTruncated: undefined,
    Key: undefined,
    MaxParts: undefined,
    NextPartNumberMarker: undefined,
    Owner: undefined,
    PartNumberMarker: undefined,
    Parts: undefined,
    RequestCharged: undefined,
    StorageClass: undefined,
    UploadId: undefined
  };
  if (output.headers["x-amz-abort-date"] !== undefined) {
    contents.AbortDate = new Date(output.headers["x-amz-abort-date"]);
  }
  if (output.headers["x-amz-abort-rule-id"] !== undefined) {
    contents.AbortRuleId = output.headers["x-amz-abort-rule-id"];
  }
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["Bucket"] !== undefined) {
    contents.Bucket = data["Bucket"];
  }
  if (data["Initiator"] !== undefined) {
    contents.Initiator = deserializeAws_restXmlInitiator(
      data["Initiator"],
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["Key"] !== undefined) {
    contents.Key = data["Key"];
  }
  if (data["MaxParts"] !== undefined) {
    contents.MaxParts = parseInt(data["MaxParts"]);
  }
  if (data["NextPartNumberMarker"] !== undefined) {
    contents.NextPartNumberMarker = parseInt(data["NextPartNumberMarker"]);
  }
  if (data["Owner"] !== undefined) {
    contents.Owner = deserializeAws_restXmlOwner(data["Owner"], context);
  }
  if (data["PartNumberMarker"] !== undefined) {
    contents.PartNumberMarker = parseInt(data["PartNumberMarker"]);
  }
  if (data.Part === "") {
    contents.Parts = [];
  }
  if (data["Part"] !== undefined) {
    const wrappedItem =
      data["Part"] instanceof Array ? data["Part"] : [data["Part"]];
    contents.Parts = deserializeAws_restXmlParts(wrappedItem, context);
  }
  if (data["StorageClass"] !== undefined) {
    contents.StorageClass = data["StorageClass"];
  }
  if (data["UploadId"] !== undefined) {
    contents.UploadId = data["UploadId"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListPartsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPartsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketAccelerateConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketAccelerateConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketAccelerateConfigurationCommandError(
      output,
      context
    );
  }
  const contents: PutBucketAccelerateConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketAccelerateConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketAccelerateConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketAclCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketAclCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketAclCommandError(output, context);
  }
  const contents: PutBucketAclCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketAclCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketAclCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketAnalyticsConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketAnalyticsConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketAnalyticsConfigurationCommandError(
      output,
      context
    );
  }
  const contents: PutBucketAnalyticsConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketAnalyticsConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketAnalyticsConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketCorsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketCorsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketCorsCommandError(output, context);
  }
  const contents: PutBucketCorsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketCorsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketCorsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketEncryptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketEncryptionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketEncryptionCommandError(
      output,
      context
    );
  }
  const contents: PutBucketEncryptionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketEncryptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketEncryptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketInventoryConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketInventoryConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketInventoryConfigurationCommandError(
      output,
      context
    );
  }
  const contents: PutBucketInventoryConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketInventoryConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketInventoryConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketLifecycleConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketLifecycleConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketLifecycleConfigurationCommandError(
      output,
      context
    );
  }
  const contents: PutBucketLifecycleConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketLifecycleConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketLifecycleConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketLoggingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketLoggingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketLoggingCommandError(output, context);
  }
  const contents: PutBucketLoggingCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketLoggingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketLoggingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketMetricsConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketMetricsConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketMetricsConfigurationCommandError(
      output,
      context
    );
  }
  const contents: PutBucketMetricsConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketMetricsConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketMetricsConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketNotificationConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketNotificationConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketNotificationConfigurationCommandError(
      output,
      context
    );
  }
  const contents: PutBucketNotificationConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketNotificationConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketNotificationConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketPolicyCommandError(output, context);
  }
  const contents: PutBucketPolicyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketReplicationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketReplicationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketReplicationCommandError(
      output,
      context
    );
  }
  const contents: PutBucketReplicationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketReplicationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketReplicationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketRequestPaymentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketRequestPaymentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketRequestPaymentCommandError(
      output,
      context
    );
  }
  const contents: PutBucketRequestPaymentCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketRequestPaymentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketRequestPaymentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketTaggingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketTaggingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketTaggingCommandError(output, context);
  }
  const contents: PutBucketTaggingCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketTaggingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketTaggingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketVersioningCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketVersioningCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketVersioningCommandError(
      output,
      context
    );
  }
  const contents: PutBucketVersioningCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketVersioningCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketVersioningCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutBucketWebsiteCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketWebsiteCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutBucketWebsiteCommandError(output, context);
  }
  const contents: PutBucketWebsiteCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutBucketWebsiteCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutBucketWebsiteCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutObjectCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutObjectCommandError(output, context);
  }
  const contents: PutObjectCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutObjectOutput",
    ETag: undefined,
    Expiration: undefined,
    RequestCharged: undefined,
    SSECustomerAlgorithm: undefined,
    SSECustomerKeyMD5: undefined,
    SSEKMSEncryptionContext: undefined,
    SSEKMSKeyId: undefined,
    ServerSideEncryption: undefined,
    VersionId: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["x-amz-expiration"] !== undefined) {
    contents.Expiration = output.headers["x-amz-expiration"];
  }
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-algorithm"] !==
    undefined
  ) {
    contents.SSECustomerAlgorithm =
      output.headers["x-amz-server-side-encryption-customer-algorithm"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-key-md5"] !==
    undefined
  ) {
    contents.SSECustomerKeyMD5 =
      output.headers["x-amz-server-side-encryption-customer-key-md5"];
  }
  if (output.headers["x-amz-server-side-encryption-context"] !== undefined) {
    contents.SSEKMSEncryptionContext =
      output.headers["x-amz-server-side-encryption-context"];
  }
  if (
    output.headers["x-amz-server-side-encryption-aws-kms-key-id"] !== undefined
  ) {
    contents.SSEKMSKeyId =
      output.headers["x-amz-server-side-encryption-aws-kms-key-id"];
  }
  if (output.headers["x-amz-server-side-encryption"] !== undefined) {
    contents.ServerSideEncryption =
      output.headers["x-amz-server-side-encryption"];
  }
  if (output.headers["x-amz-version-id"] !== undefined) {
    contents.VersionId = output.headers["x-amz-version-id"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutObjectCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutObjectAclCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectAclCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutObjectAclCommandError(output, context);
  }
  const contents: PutObjectAclCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutObjectAclOutput",
    RequestCharged: undefined
  };
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutObjectAclCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectAclCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      response = {
        ...(await deserializeAws_restXmlNoSuchKeyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutObjectLegalHoldCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectLegalHoldCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutObjectLegalHoldCommandError(
      output,
      context
    );
  }
  const contents: PutObjectLegalHoldCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutObjectLegalHoldOutput",
    RequestCharged: undefined
  };
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutObjectLegalHoldCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectLegalHoldCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutObjectLockConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectLockConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutObjectLockConfigurationCommandError(
      output,
      context
    );
  }
  const contents: PutObjectLockConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutObjectLockConfigurationOutput",
    RequestCharged: undefined
  };
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutObjectLockConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectLockConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutObjectRetentionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectRetentionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutObjectRetentionCommandError(
      output,
      context
    );
  }
  const contents: PutObjectRetentionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutObjectRetentionOutput",
    RequestCharged: undefined
  };
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutObjectRetentionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectRetentionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutObjectTaggingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectTaggingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutObjectTaggingCommandError(output, context);
  }
  const contents: PutObjectTaggingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutObjectTaggingOutput",
    VersionId: undefined
  };
  if (output.headers["x-amz-version-id"] !== undefined) {
    contents.VersionId = output.headers["x-amz-version-id"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutObjectTaggingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutObjectTaggingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlPutPublicAccessBlockCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutPublicAccessBlockCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlPutPublicAccessBlockCommandError(
      output,
      context
    );
  }
  const contents: PutPublicAccessBlockCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlPutPublicAccessBlockCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutPublicAccessBlockCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlRestoreObjectCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreObjectCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlRestoreObjectCommandError(output, context);
  }
  const contents: RestoreObjectCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreObjectOutput",
    RequestCharged: undefined,
    RestoreOutputPath: undefined
  };
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  if (output.headers["x-amz-restore-output-path"] !== undefined) {
    contents.RestoreOutputPath = output.headers["x-amz-restore-output-path"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlRestoreObjectCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreObjectCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ObjectAlreadyInActiveTierError":
    case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
      response = {
        ...(await deserializeAws_restXmlObjectAlreadyInActiveTierErrorResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlSelectObjectContentCommand(
  output: __HttpResponse,
  context: __SerdeContext & __EventStreamSerdeContext
): Promise<SelectObjectContentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlSelectObjectContentCommandError(
      output,
      context
    );
  }
  const contents: SelectObjectContentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SelectObjectContentOutput",
    Payload: undefined
  };
  const data: any = context.eventStreamMarshaller.deserialize(
    output.body,
    async event => {
      const eventName = Object.keys(event)[0];
      const eventHeaders = Object.entries(event[eventName].headers).reduce(
        (accummulator, curr) => {
          accummulator[curr[0]] = curr[1].value;
          return accummulator;
        },
        {} as { [key: string]: any }
      );
      const eventMessage = {
        headers: eventHeaders,
        body: event[eventName].body
      };
      const parsedEvent = {
        [eventName]: eventMessage
      };
      return await deserializeAws_restXmlSelectObjectContentEventStream_event(
        parsedEvent,
        context
      );
    }
  );
  contents.Payload = data;
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlSelectObjectContentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SelectObjectContentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlUploadPartCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UploadPartCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUploadPartCommandError(output, context);
  }
  const contents: UploadPartCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UploadPartOutput",
    ETag: undefined,
    RequestCharged: undefined,
    SSECustomerAlgorithm: undefined,
    SSECustomerKeyMD5: undefined,
    SSEKMSKeyId: undefined,
    ServerSideEncryption: undefined
  };
  if (output.headers["etag"] !== undefined) {
    contents.ETag = output.headers["etag"];
  }
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-algorithm"] !==
    undefined
  ) {
    contents.SSECustomerAlgorithm =
      output.headers["x-amz-server-side-encryption-customer-algorithm"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-key-md5"] !==
    undefined
  ) {
    contents.SSECustomerKeyMD5 =
      output.headers["x-amz-server-side-encryption-customer-key-md5"];
  }
  if (
    output.headers["x-amz-server-side-encryption-aws-kms-key-id"] !== undefined
  ) {
    contents.SSEKMSKeyId =
      output.headers["x-amz-server-side-encryption-aws-kms-key-id"];
  }
  if (output.headers["x-amz-server-side-encryption"] !== undefined) {
    contents.ServerSideEncryption =
      output.headers["x-amz-server-side-encryption"];
  }
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlUploadPartCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UploadPartCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlUploadPartCopyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UploadPartCopyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUploadPartCopyCommandError(output, context);
  }
  const contents: UploadPartCopyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UploadPartCopyOutput",
    CopyPartResult: undefined,
    CopySourceVersionId: undefined,
    RequestCharged: undefined,
    SSECustomerAlgorithm: undefined,
    SSECustomerKeyMD5: undefined,
    SSEKMSKeyId: undefined,
    ServerSideEncryption: undefined
  };
  if (output.headers["x-amz-copy-source-version-id"] !== undefined) {
    contents.CopySourceVersionId =
      output.headers["x-amz-copy-source-version-id"];
  }
  if (output.headers["x-amz-request-charged"] !== undefined) {
    contents.RequestCharged = output.headers["x-amz-request-charged"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-algorithm"] !==
    undefined
  ) {
    contents.SSECustomerAlgorithm =
      output.headers["x-amz-server-side-encryption-customer-algorithm"];
  }
  if (
    output.headers["x-amz-server-side-encryption-customer-key-md5"] !==
    undefined
  ) {
    contents.SSECustomerKeyMD5 =
      output.headers["x-amz-server-side-encryption-customer-key-md5"];
  }
  if (
    output.headers["x-amz-server-side-encryption-aws-kms-key-id"] !== undefined
  ) {
    contents.SSEKMSKeyId =
      output.headers["x-amz-server-side-encryption-aws-kms-key-id"];
  }
  if (output.headers["x-amz-server-side-encryption"] !== undefined) {
    contents.ServerSideEncryption =
      output.headers["x-amz-server-side-encryption"];
  }
  const data: any = await parseBody(output.body, context);
  contents.CopyPartResult = deserializeAws_restXmlCopyPartResult(data, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlUploadPartCopyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UploadPartCopyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_restXmlSelectObjectContentEventStream_event = async (
  output: any,
  context: __SerdeContext
): Promise<SelectObjectContentEventStream> => {
  if (output["Cont"] !== undefined) {
    return {
      Cont: await deserializeAws_restXmlContinuationEvent_event(
        output["Cont"],
        context
      )
    };
  }
  if (output["End"] !== undefined) {
    return {
      End: await deserializeAws_restXmlEndEvent_event(output["End"], context)
    };
  }
  if (output["Progress"] !== undefined) {
    return {
      Progress: await deserializeAws_restXmlProgressEvent_event(
        output["Progress"],
        context
      )
    };
  }
  if (output["Records"] !== undefined) {
    return {
      Records: await deserializeAws_restXmlRecordsEvent_event(
        output["Records"],
        context
      )
    };
  }
  if (output["Stats"] !== undefined) {
    return {
      Stats: await deserializeAws_restXmlStatsEvent_event(
        output["Stats"],
        context
      )
    };
  }
  return { $unknown: output };
};
const deserializeAws_restXmlContinuationEvent_event = async (
  output: any,
  context: __SerdeContext
): Promise<ContinuationEvent> => {
  let contents: ContinuationEvent = {} as any;
  return contents;
};
const deserializeAws_restXmlEndEvent_event = async (
  output: any,
  context: __SerdeContext
): Promise<EndEvent> => {
  let contents: EndEvent = {} as any;
  return contents;
};
const deserializeAws_restXmlProgressEvent_event = async (
  output: any,
  context: __SerdeContext
): Promise<ProgressEvent> => {
  let contents: ProgressEvent = {
    __type: "ProgressEvent"
  } as any;
  contents.Details = await parseBody(output.body, context);
  return contents;
};
const deserializeAws_restXmlRecordsEvent_event = async (
  output: any,
  context: __SerdeContext
): Promise<RecordsEvent> => {
  let contents: RecordsEvent = {
    __type: "RecordsEvent"
  } as any;
  contents.Payload = output.body;
  return contents;
};
const deserializeAws_restXmlStatsEvent_event = async (
  output: any,
  context: __SerdeContext
): Promise<StatsEvent> => {
  let contents: StatsEvent = {
    __type: "StatsEvent"
  } as any;
  contents.Details = await parseBody(output.body, context);
  return contents;
};
const deserializeAws_restXmlBucketAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BucketAlreadyExists> => {
  const contents: BucketAlreadyExists = {
    name: "BucketAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput)
  };
  const data: any = parsedOutput.body;
  return contents;
};

const deserializeAws_restXmlBucketAlreadyOwnedByYouResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BucketAlreadyOwnedByYou> => {
  const contents: BucketAlreadyOwnedByYou = {
    name: "BucketAlreadyOwnedByYou",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput)
  };
  const data: any = parsedOutput.body;
  return contents;
};

const deserializeAws_restXmlNoSuchBucketResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchBucket> => {
  const contents: NoSuchBucket = {
    name: "NoSuchBucket",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput)
  };
  const data: any = parsedOutput.body;
  return contents;
};

const deserializeAws_restXmlNoSuchKeyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchKey> => {
  const contents: NoSuchKey = {
    name: "NoSuchKey",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput)
  };
  const data: any = parsedOutput.body;
  return contents;
};

const deserializeAws_restXmlNoSuchUploadResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchUpload> => {
  const contents: NoSuchUpload = {
    name: "NoSuchUpload",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput)
  };
  const data: any = parsedOutput.body;
  return contents;
};

const deserializeAws_restXmlObjectAlreadyInActiveTierErrorResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ObjectAlreadyInActiveTierError> => {
  const contents: ObjectAlreadyInActiveTierError = {
    name: "ObjectAlreadyInActiveTierError",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput)
  };
  const data: any = parsedOutput.body;
  return contents;
};

const deserializeAws_restXmlObjectNotInActiveTierErrorResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ObjectNotInActiveTierError> => {
  const contents: ObjectNotInActiveTierError = {
    name: "ObjectNotInActiveTierError",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput)
  };
  const data: any = parsedOutput.body;
  return contents;
};

const serializeAws_restXmlAbortIncompleteMultipartUpload = (
  input: AbortIncompleteMultipartUpload,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AbortIncompleteMultipartUpload");
  if (input.DaysAfterInitiation !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("DaysAfterInitiation")
        .addChildNode(new __XmlText(String(input.DaysAfterInitiation)))
        .withName("DaysAfterInitiation")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlAccelerateConfiguration = (
  input: AccelerateConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AccelerateConfiguration");
  if (input.Status !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("BucketAccelerateStatus")
        .addChildNode(new __XmlText(input.Status))
        .withName("Status")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlAccessControlPolicy = (
  input: AccessControlPolicy,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AccessControlPolicy");
  if (input.Grants !== undefined) {
    const nodes = serializeAws_restXmlGrants(input.Grants, context);
    const containerNode = new __XmlNode("AccessControlList");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Owner !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlOwner(input.Owner, context).withName("Owner")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlAccessControlTranslation = (
  input: AccessControlTranslation,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AccessControlTranslation");
  if (input.Owner !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("OwnerOverride")
        .addChildNode(new __XmlText(input.Owner))
        .withName("Owner")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlAllowedHeaders = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = new __XmlNode("AllowedHeader").addChildNode(
      new __XmlText(entry)
    );
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlAllowedMethods = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = new __XmlNode("AllowedMethod").addChildNode(
      new __XmlText(entry)
    );
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlAllowedOrigins = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = new __XmlNode("AllowedOrigin").addChildNode(
      new __XmlText(entry)
    );
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlAnalyticsAndOperator = (
  input: AnalyticsAndOperator,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AnalyticsAndOperator");
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.Tags !== undefined) {
    const nodes = serializeAws_restXmlTagSet(input.Tags, context);
    nodes.map((node: any) => {
      node = node.withName("Tag");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlAnalyticsConfiguration = (
  input: AnalyticsConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AnalyticsConfiguration");
  if (input.Filter !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlAnalyticsFilter(input.Filter, context).withName(
        "Filter"
      )
    );
  }
  if (input.Id !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("AnalyticsId")
        .addChildNode(new __XmlText(input.Id))
        .withName("Id")
    );
  }
  if (input.StorageClassAnalysis !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlStorageClassAnalysis(
        input.StorageClassAnalysis,
        context
      ).withName("StorageClassAnalysis")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlAnalyticsExportDestination = (
  input: AnalyticsExportDestination,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AnalyticsExportDestination");
  if (input.S3BucketDestination !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlAnalyticsS3BucketDestination(
        input.S3BucketDestination,
        context
      ).withName("S3BucketDestination")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlAnalyticsFilter = (
  input: AnalyticsFilter,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AnalyticsFilter");
  if (input.And !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlAnalyticsAndOperator(input.And, context).withName(
        "And"
      )
    );
  }
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.Tag !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlTag(input.Tag, context).withName("Tag")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlAnalyticsS3BucketDestination = (
  input: AnalyticsS3BucketDestination,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AnalyticsS3BucketDestination");
  if (input.Bucket !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("BucketName")
        .addChildNode(new __XmlText(input.Bucket))
        .withName("Bucket")
    );
  }
  if (input.BucketAccountId !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("AccountId")
        .addChildNode(new __XmlText(input.BucketAccountId))
        .withName("BucketAccountId")
    );
  }
  if (input.Format !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("AnalyticsS3ExportFileFormat")
        .addChildNode(new __XmlText(input.Format))
        .withName("Format")
    );
  }
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlBucketLifecycleConfiguration = (
  input: BucketLifecycleConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("BucketLifecycleConfiguration");
  if (input.Rules !== undefined) {
    const nodes = serializeAws_restXmlLifecycleRules(input.Rules, context);
    nodes.map((node: any) => {
      node = node.withName("Rule");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlBucketLoggingStatus = (
  input: BucketLoggingStatus,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("BucketLoggingStatus");
  if (input.LoggingEnabled !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlLoggingEnabled(
        input.LoggingEnabled,
        context
      ).withName("LoggingEnabled")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlCORSConfiguration = (
  input: CORSConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CORSConfiguration");
  if (input.CORSRules !== undefined) {
    const nodes = serializeAws_restXmlCORSRules(input.CORSRules, context);
    nodes.map((node: any) => {
      node = node.withName("CORSRule");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlCORSRule = (
  input: CORSRule,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CORSRule");
  if (input.AllowedHeaders !== undefined) {
    const nodes = serializeAws_restXmlAllowedHeaders(
      input.AllowedHeaders,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("AllowedHeader");
      bodyNode.addChildNode(node);
    });
  }
  if (input.AllowedMethods !== undefined) {
    const nodes = serializeAws_restXmlAllowedMethods(
      input.AllowedMethods,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("AllowedMethod");
      bodyNode.addChildNode(node);
    });
  }
  if (input.AllowedOrigins !== undefined) {
    const nodes = serializeAws_restXmlAllowedOrigins(
      input.AllowedOrigins,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("AllowedOrigin");
      bodyNode.addChildNode(node);
    });
  }
  if (input.ExposeHeaders !== undefined) {
    const nodes = serializeAws_restXmlExposeHeaders(
      input.ExposeHeaders,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("ExposeHeader");
      bodyNode.addChildNode(node);
    });
  }
  if (input.MaxAgeSeconds !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("MaxAgeSeconds")
        .addChildNode(new __XmlText(String(input.MaxAgeSeconds)))
        .withName("MaxAgeSeconds")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlCORSRules = (
  input: Array<CORSRule>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlCORSRule(entry, context);
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlCSVInput = (
  input: CSVInput,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CSVInput");
  if (input.AllowQuotedRecordDelimiter !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("AllowQuotedRecordDelimiter")
        .addChildNode(new __XmlText(String(input.AllowQuotedRecordDelimiter)))
        .withName("AllowQuotedRecordDelimiter")
    );
  }
  if (input.Comments !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Comments")
        .addChildNode(new __XmlText(input.Comments))
        .withName("Comments")
    );
  }
  if (input.FieldDelimiter !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("FieldDelimiter")
        .addChildNode(new __XmlText(input.FieldDelimiter))
        .withName("FieldDelimiter")
    );
  }
  if (input.FileHeaderInfo !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("FileHeaderInfo")
        .addChildNode(new __XmlText(input.FileHeaderInfo))
        .withName("FileHeaderInfo")
    );
  }
  if (input.QuoteCharacter !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("QuoteCharacter")
        .addChildNode(new __XmlText(input.QuoteCharacter))
        .withName("QuoteCharacter")
    );
  }
  if (input.QuoteEscapeCharacter !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("QuoteEscapeCharacter")
        .addChildNode(new __XmlText(input.QuoteEscapeCharacter))
        .withName("QuoteEscapeCharacter")
    );
  }
  if (input.RecordDelimiter !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("RecordDelimiter")
        .addChildNode(new __XmlText(input.RecordDelimiter))
        .withName("RecordDelimiter")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlCSVOutput = (
  input: CSVOutput,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CSVOutput");
  if (input.FieldDelimiter !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("FieldDelimiter")
        .addChildNode(new __XmlText(input.FieldDelimiter))
        .withName("FieldDelimiter")
    );
  }
  if (input.QuoteCharacter !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("QuoteCharacter")
        .addChildNode(new __XmlText(input.QuoteCharacter))
        .withName("QuoteCharacter")
    );
  }
  if (input.QuoteEscapeCharacter !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("QuoteEscapeCharacter")
        .addChildNode(new __XmlText(input.QuoteEscapeCharacter))
        .withName("QuoteEscapeCharacter")
    );
  }
  if (input.QuoteFields !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("QuoteFields")
        .addChildNode(new __XmlText(input.QuoteFields))
        .withName("QuoteFields")
    );
  }
  if (input.RecordDelimiter !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("RecordDelimiter")
        .addChildNode(new __XmlText(input.RecordDelimiter))
        .withName("RecordDelimiter")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlCompletedMultipartUpload = (
  input: CompletedMultipartUpload,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CompletedMultipartUpload");
  if (input.Parts !== undefined) {
    const nodes = serializeAws_restXmlCompletedPartList(input.Parts, context);
    nodes.map((node: any) => {
      node = node.withName("Part");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlCompletedPart = (
  input: CompletedPart,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CompletedPart");
  if (input.ETag !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ETag")
        .addChildNode(new __XmlText(input.ETag))
        .withName("ETag")
    );
  }
  if (input.PartNumber !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("PartNumber")
        .addChildNode(new __XmlText(String(input.PartNumber)))
        .withName("PartNumber")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlCompletedPartList = (
  input: Array<CompletedPart>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlCompletedPart(entry, context);
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlCondition = (
  input: Condition,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Condition");
  if (input.HttpErrorCodeReturnedEquals !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("HttpErrorCodeReturnedEquals")
        .addChildNode(new __XmlText(input.HttpErrorCodeReturnedEquals))
        .withName("HttpErrorCodeReturnedEquals")
    );
  }
  if (input.KeyPrefixEquals !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("KeyPrefixEquals")
        .addChildNode(new __XmlText(input.KeyPrefixEquals))
        .withName("KeyPrefixEquals")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlCreateBucketConfiguration = (
  input: CreateBucketConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("CreateBucketConfiguration");
  if (input.LocationConstraint !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("BucketLocationConstraint")
        .addChildNode(new __XmlText(input.LocationConstraint))
        .withName("LocationConstraint")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlDefaultRetention = (
  input: DefaultRetention,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("DefaultRetention");
  if (input.Days !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Days")
        .addChildNode(new __XmlText(String(input.Days)))
        .withName("Days")
    );
  }
  if (input.Mode !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ObjectLockRetentionMode")
        .addChildNode(new __XmlText(input.Mode))
        .withName("Mode")
    );
  }
  if (input.Years !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Years")
        .addChildNode(new __XmlText(String(input.Years)))
        .withName("Years")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlDelete = (
  input: Delete,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Delete");
  if (input.Objects !== undefined) {
    const nodes = serializeAws_restXmlObjectIdentifierList(
      input.Objects,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("Object");
      bodyNode.addChildNode(node);
    });
  }
  if (input.Quiet !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Quiet")
        .addChildNode(new __XmlText(String(input.Quiet)))
        .withName("Quiet")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlDeleteMarkerReplication = (
  input: DeleteMarkerReplication,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("DeleteMarkerReplication");
  if (input.Status !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("DeleteMarkerReplicationStatus")
        .addChildNode(new __XmlText(input.Status))
        .withName("Status")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlDestination = (
  input: Destination,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Destination");
  if (input.AccessControlTranslation !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlAccessControlTranslation(
        input.AccessControlTranslation,
        context
      ).withName("AccessControlTranslation")
    );
  }
  if (input.Account !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("AccountId")
        .addChildNode(new __XmlText(input.Account))
        .withName("Account")
    );
  }
  if (input.Bucket !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("BucketName")
        .addChildNode(new __XmlText(input.Bucket))
        .withName("Bucket")
    );
  }
  if (input.EncryptionConfiguration !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlEncryptionConfiguration(
        input.EncryptionConfiguration,
        context
      ).withName("EncryptionConfiguration")
    );
  }
  if (input.Metrics !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlMetrics(input.Metrics, context).withName("Metrics")
    );
  }
  if (input.ReplicationTime !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlReplicationTime(
        input.ReplicationTime,
        context
      ).withName("ReplicationTime")
    );
  }
  if (input.StorageClass !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("StorageClass")
        .addChildNode(new __XmlText(input.StorageClass))
        .withName("StorageClass")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlEncryption = (
  input: Encryption,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Encryption");
  if (input.EncryptionType !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ServerSideEncryption")
        .addChildNode(new __XmlText(input.EncryptionType))
        .withName("EncryptionType")
    );
  }
  if (input.KMSContext !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("KMSContext")
        .addChildNode(new __XmlText(input.KMSContext))
        .withName("KMSContext")
    );
  }
  if (input.KMSKeyId !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("SSEKMSKeyId")
        .addChildNode(new __XmlText(input.KMSKeyId))
        .withName("KMSKeyId")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlEncryptionConfiguration = (
  input: EncryptionConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("EncryptionConfiguration");
  if (input.ReplicaKmsKeyID !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ReplicaKmsKeyID")
        .addChildNode(new __XmlText(input.ReplicaKmsKeyID))
        .withName("ReplicaKmsKeyID")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlErrorDocument = (
  input: ErrorDocument,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ErrorDocument");
  if (input.Key !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ObjectKey")
        .addChildNode(new __XmlText(input.Key))
        .withName("Key")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlEventList = (
  input: Array<Event | string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = new __XmlNode("Event").addChildNode(new __XmlText(entry));
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlExistingObjectReplication = (
  input: ExistingObjectReplication,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ExistingObjectReplication");
  if (input.Status !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ExistingObjectReplicationStatus")
        .addChildNode(new __XmlText(input.Status))
        .withName("Status")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlExposeHeaders = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = new __XmlNode("ExposeHeader").addChildNode(
      new __XmlText(entry)
    );
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlFilterRule = (
  input: FilterRule,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("FilterRule");
  if (input.Name !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("FilterRuleName")
        .addChildNode(new __XmlText(input.Name))
        .withName("Name")
    );
  }
  if (input.Value !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("FilterRuleValue")
        .addChildNode(new __XmlText(input.Value))
        .withName("Value")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlFilterRuleList = (
  input: Array<FilterRule>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlFilterRule(entry, context);
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlGlacierJobParameters = (
  input: GlacierJobParameters,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("GlacierJobParameters");
  if (input.Tier !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Tier")
        .addChildNode(new __XmlText(input.Tier))
        .withName("Tier")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlGrant = (
  input: Grant,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Grant");
  if (input.Grantee !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlGrantee(input.Grantee, context).withName("Grantee")
    );
  }
  if (input.Permission !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Permission")
        .addChildNode(new __XmlText(input.Permission))
        .withName("Permission")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlGrantee = (
  input: Grantee,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Grantee");
  bodyNode.addAttribute(
    "xmlns:xsi",
    "http://www.w3.org/2001/XMLSchema-instance"
  );
  if (input.DisplayName !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("DisplayName")
        .addChildNode(new __XmlText(input.DisplayName))
        .withName("DisplayName")
    );
  }
  if (input.EmailAddress !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("EmailAddress")
        .addChildNode(new __XmlText(input.EmailAddress))
        .withName("EmailAddress")
    );
  }
  if (input.ID !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ID").addChildNode(new __XmlText(input.ID)).withName("ID")
    );
  }
  if (input.Type !== undefined) {
    bodyNode.addAttribute("xsi:type", input.Type);
  }
  if (input.URI !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("URI")
        .addChildNode(new __XmlText(input.URI))
        .withName("URI")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlGrants = (
  input: Array<Grant>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlGrant(entry, context);
    collectedNodes.push(node.withName("Grant"));
  }
  return collectedNodes;
};

const serializeAws_restXmlIndexDocument = (
  input: IndexDocument,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("IndexDocument");
  if (input.Suffix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Suffix")
        .addChildNode(new __XmlText(input.Suffix))
        .withName("Suffix")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlInputSerialization = (
  input: InputSerialization,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("InputSerialization");
  if (input.CSV !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlCSVInput(input.CSV, context).withName("CSV")
    );
  }
  if (input.CompressionType !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("CompressionType")
        .addChildNode(new __XmlText(input.CompressionType))
        .withName("CompressionType")
    );
  }
  if (input.JSON !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlJSONInput(input.JSON, context).withName("JSON")
    );
  }
  if (input.Parquet !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlParquetInput(input.Parquet, context).withName(
        "Parquet"
      )
    );
  }
  return bodyNode;
};

const serializeAws_restXmlInventoryConfiguration = (
  input: InventoryConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("InventoryConfiguration");
  if (input.Destination !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlInventoryDestination(
        input.Destination,
        context
      ).withName("Destination")
    );
  }
  if (input.Filter !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlInventoryFilter(input.Filter, context).withName(
        "Filter"
      )
    );
  }
  if (input.Id !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("InventoryId")
        .addChildNode(new __XmlText(input.Id))
        .withName("Id")
    );
  }
  if (input.IncludedObjectVersions !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("InventoryIncludedObjectVersions")
        .addChildNode(new __XmlText(input.IncludedObjectVersions))
        .withName("IncludedObjectVersions")
    );
  }
  if (input.IsEnabled !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("IsEnabled")
        .addChildNode(new __XmlText(String(input.IsEnabled)))
        .withName("IsEnabled")
    );
  }
  if (input.OptionalFields !== undefined) {
    const nodes = serializeAws_restXmlInventoryOptionalFields(
      input.OptionalFields,
      context
    );
    const containerNode = new __XmlNode("OptionalFields");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Schedule !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlInventorySchedule(input.Schedule, context).withName(
        "Schedule"
      )
    );
  }
  return bodyNode;
};

const serializeAws_restXmlInventoryDestination = (
  input: InventoryDestination,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("InventoryDestination");
  if (input.S3BucketDestination !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlInventoryS3BucketDestination(
        input.S3BucketDestination,
        context
      ).withName("S3BucketDestination")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlInventoryEncryption = (
  input: InventoryEncryption,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("InventoryEncryption");
  if (input.SSEKMS !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlSSEKMS(input.SSEKMS, context).withName("SSE-KMS")
    );
  }
  if (input.SSES3 !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlSSES3(input.SSES3, context).withName("SSE-S3")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlInventoryFilter = (
  input: InventoryFilter,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("InventoryFilter");
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlInventoryOptionalFields = (
  input: Array<InventoryOptionalField | string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = new __XmlNode("InventoryOptionalField").addChildNode(
      new __XmlText(entry)
    );
    collectedNodes.push(node.withName("Field"));
  }
  return collectedNodes;
};

const serializeAws_restXmlInventoryS3BucketDestination = (
  input: InventoryS3BucketDestination,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("InventoryS3BucketDestination");
  if (input.AccountId !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("AccountId")
        .addChildNode(new __XmlText(input.AccountId))
        .withName("AccountId")
    );
  }
  if (input.Bucket !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("BucketName")
        .addChildNode(new __XmlText(input.Bucket))
        .withName("Bucket")
    );
  }
  if (input.Encryption !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlInventoryEncryption(
        input.Encryption,
        context
      ).withName("Encryption")
    );
  }
  if (input.Format !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("InventoryFormat")
        .addChildNode(new __XmlText(input.Format))
        .withName("Format")
    );
  }
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlInventorySchedule = (
  input: InventorySchedule,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("InventorySchedule");
  if (input.Frequency !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("InventoryFrequency")
        .addChildNode(new __XmlText(input.Frequency))
        .withName("Frequency")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlJSONInput = (
  input: JSONInput,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("JSONInput");
  if (input.Type !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("JSONType")
        .addChildNode(new __XmlText(input.Type))
        .withName("Type")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlJSONOutput = (
  input: JSONOutput,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("JSONOutput");
  if (input.RecordDelimiter !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("RecordDelimiter")
        .addChildNode(new __XmlText(input.RecordDelimiter))
        .withName("RecordDelimiter")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlLambdaFunctionConfiguration = (
  input: LambdaFunctionConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LambdaFunctionConfiguration");
  if (input.Events !== undefined) {
    const nodes = serializeAws_restXmlEventList(input.Events, context);
    nodes.map((node: any) => {
      node = node.withName("Event");
      bodyNode.addChildNode(node);
    });
  }
  if (input.Filter !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlNotificationConfigurationFilter(
        input.Filter,
        context
      ).withName("Filter")
    );
  }
  if (input.Id !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("NotificationId")
        .addChildNode(new __XmlText(input.Id))
        .withName("Id")
    );
  }
  if (input.LambdaFunctionArn !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("LambdaFunctionArn")
        .addChildNode(new __XmlText(input.LambdaFunctionArn))
        .withName("CloudFunction")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlLambdaFunctionConfigurationList = (
  input: Array<LambdaFunctionConfiguration>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlLambdaFunctionConfiguration(
      entry,
      context
    );
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlLifecycleExpiration = (
  input: LifecycleExpiration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LifecycleExpiration");
  if (input.Date !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Date")
        .addChildNode(
          new __XmlText(input.Date.toISOString().split(".")[0] + "Z")
        )
        .withName("Date")
    );
  }
  if (input.Days !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Days")
        .addChildNode(new __XmlText(String(input.Days)))
        .withName("Days")
    );
  }
  if (input.ExpiredObjectDeleteMarker !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ExpiredObjectDeleteMarker")
        .addChildNode(new __XmlText(String(input.ExpiredObjectDeleteMarker)))
        .withName("ExpiredObjectDeleteMarker")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlLifecycleRule = (
  input: LifecycleRule,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LifecycleRule");
  if (input.AbortIncompleteMultipartUpload !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlAbortIncompleteMultipartUpload(
        input.AbortIncompleteMultipartUpload,
        context
      ).withName("AbortIncompleteMultipartUpload")
    );
  }
  if (input.Expiration !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlLifecycleExpiration(
        input.Expiration,
        context
      ).withName("Expiration")
    );
  }
  if (input.Filter !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlLifecycleRuleFilter(input.Filter, context).withName(
        "Filter"
      )
    );
  }
  if (input.ID !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ID").addChildNode(new __XmlText(input.ID)).withName("ID")
    );
  }
  if (input.NoncurrentVersionExpiration !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlNoncurrentVersionExpiration(
        input.NoncurrentVersionExpiration,
        context
      ).withName("NoncurrentVersionExpiration")
    );
  }
  if (input.NoncurrentVersionTransitions !== undefined) {
    const nodes = serializeAws_restXmlNoncurrentVersionTransitionList(
      input.NoncurrentVersionTransitions,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("NoncurrentVersionTransition");
      bodyNode.addChildNode(node);
    });
  }
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.Status !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ExpirationStatus")
        .addChildNode(new __XmlText(input.Status))
        .withName("Status")
    );
  }
  if (input.Transitions !== undefined) {
    const nodes = serializeAws_restXmlTransitionList(
      input.Transitions,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("Transition");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlLifecycleRuleAndOperator = (
  input: LifecycleRuleAndOperator,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LifecycleRuleAndOperator");
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.Tags !== undefined) {
    const nodes = serializeAws_restXmlTagSet(input.Tags, context);
    nodes.map((node: any) => {
      node = node.withName("Tag");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlLifecycleRuleFilter = (
  input: LifecycleRuleFilter,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LifecycleRuleFilter");
  if (input.And !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlLifecycleRuleAndOperator(input.And, context).withName(
        "And"
      )
    );
  }
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.Tag !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlTag(input.Tag, context).withName("Tag")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlLifecycleRules = (
  input: Array<LifecycleRule>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlLifecycleRule(entry, context);
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlLoggingEnabled = (
  input: LoggingEnabled,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("LoggingEnabled");
  if (input.TargetBucket !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("TargetBucket")
        .addChildNode(new __XmlText(input.TargetBucket))
        .withName("TargetBucket")
    );
  }
  if (input.TargetGrants !== undefined) {
    const nodes = serializeAws_restXmlTargetGrants(input.TargetGrants, context);
    const containerNode = new __XmlNode("TargetGrants");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.TargetPrefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("TargetPrefix")
        .addChildNode(new __XmlText(input.TargetPrefix))
        .withName("TargetPrefix")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlMetadataEntry = (
  input: MetadataEntry,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("MetadataEntry");
  if (input.Name !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("MetadataKey")
        .addChildNode(new __XmlText(input.Name))
        .withName("Name")
    );
  }
  if (input.Value !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("MetadataValue")
        .addChildNode(new __XmlText(input.Value))
        .withName("Value")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlMetrics = (
  input: Metrics,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Metrics");
  if (input.EventThreshold !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlReplicationTimeValue(
        input.EventThreshold,
        context
      ).withName("EventThreshold")
    );
  }
  if (input.Status !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("MetricsStatus")
        .addChildNode(new __XmlText(input.Status))
        .withName("Status")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlMetricsAndOperator = (
  input: MetricsAndOperator,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("MetricsAndOperator");
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.Tags !== undefined) {
    const nodes = serializeAws_restXmlTagSet(input.Tags, context);
    nodes.map((node: any) => {
      node = node.withName("Tag");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlMetricsConfiguration = (
  input: MetricsConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("MetricsConfiguration");
  if (input.Filter !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlMetricsFilter(input.Filter, context).withName(
        "Filter"
      )
    );
  }
  if (input.Id !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("MetricsId")
        .addChildNode(new __XmlText(input.Id))
        .withName("Id")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlMetricsFilter = (
  input: MetricsFilter,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("MetricsFilter");
  if (input.And !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlMetricsAndOperator(input.And, context).withName("And")
    );
  }
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.Tag !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlTag(input.Tag, context).withName("Tag")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlNoncurrentVersionExpiration = (
  input: NoncurrentVersionExpiration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("NoncurrentVersionExpiration");
  if (input.NoncurrentDays !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Days")
        .addChildNode(new __XmlText(String(input.NoncurrentDays)))
        .withName("NoncurrentDays")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlNoncurrentVersionTransition = (
  input: NoncurrentVersionTransition,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("NoncurrentVersionTransition");
  if (input.NoncurrentDays !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Days")
        .addChildNode(new __XmlText(String(input.NoncurrentDays)))
        .withName("NoncurrentDays")
    );
  }
  if (input.StorageClass !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("TransitionStorageClass")
        .addChildNode(new __XmlText(input.StorageClass))
        .withName("StorageClass")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlNoncurrentVersionTransitionList = (
  input: Array<NoncurrentVersionTransition>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlNoncurrentVersionTransition(
      entry,
      context
    );
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlNotificationConfiguration = (
  input: NotificationConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("NotificationConfiguration");
  if (input.LambdaFunctionConfigurations !== undefined) {
    const nodes = serializeAws_restXmlLambdaFunctionConfigurationList(
      input.LambdaFunctionConfigurations,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("CloudFunctionConfiguration");
      bodyNode.addChildNode(node);
    });
  }
  if (input.QueueConfigurations !== undefined) {
    const nodes = serializeAws_restXmlQueueConfigurationList(
      input.QueueConfigurations,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("QueueConfiguration");
      bodyNode.addChildNode(node);
    });
  }
  if (input.TopicConfigurations !== undefined) {
    const nodes = serializeAws_restXmlTopicConfigurationList(
      input.TopicConfigurations,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("TopicConfiguration");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlNotificationConfigurationFilter = (
  input: NotificationConfigurationFilter,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("NotificationConfigurationFilter");
  if (input.Key !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlS3KeyFilter(input.Key, context).withName("S3Key")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlObjectIdentifier = (
  input: ObjectIdentifier,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ObjectIdentifier");
  if (input.Key !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ObjectKey")
        .addChildNode(new __XmlText(input.Key))
        .withName("Key")
    );
  }
  if (input.VersionId !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ObjectVersionId")
        .addChildNode(new __XmlText(input.VersionId))
        .withName("VersionId")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlObjectIdentifierList = (
  input: Array<ObjectIdentifier>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlObjectIdentifier(entry, context);
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlObjectLockConfiguration = (
  input: ObjectLockConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ObjectLockConfiguration");
  if (input.ObjectLockEnabled !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ObjectLockEnabled")
        .addChildNode(new __XmlText(input.ObjectLockEnabled))
        .withName("ObjectLockEnabled")
    );
  }
  if (input.Rule !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlObjectLockRule(input.Rule, context).withName("Rule")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlObjectLockLegalHold = (
  input: ObjectLockLegalHold,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ObjectLockLegalHold");
  if (input.Status !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ObjectLockLegalHoldStatus")
        .addChildNode(new __XmlText(input.Status))
        .withName("Status")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlObjectLockRetention = (
  input: ObjectLockRetention,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ObjectLockRetention");
  if (input.Mode !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ObjectLockRetentionMode")
        .addChildNode(new __XmlText(input.Mode))
        .withName("Mode")
    );
  }
  if (input.RetainUntilDate !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Date")
        .addChildNode(
          new __XmlText(input.RetainUntilDate.toISOString().split(".")[0] + "Z")
        )
        .withName("RetainUntilDate")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlObjectLockRule = (
  input: ObjectLockRule,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ObjectLockRule");
  if (input.DefaultRetention !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlDefaultRetention(
        input.DefaultRetention,
        context
      ).withName("DefaultRetention")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlOutputLocation = (
  input: OutputLocation,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("OutputLocation");
  if (input.S3 !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlS3Location(input.S3, context).withName("S3")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlOutputSerialization = (
  input: OutputSerialization,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("OutputSerialization");
  if (input.CSV !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlCSVOutput(input.CSV, context).withName("CSV")
    );
  }
  if (input.JSON !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlJSONOutput(input.JSON, context).withName("JSON")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlOwner = (
  input: Owner,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Owner");
  if (input.DisplayName !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("DisplayName")
        .addChildNode(new __XmlText(input.DisplayName))
        .withName("DisplayName")
    );
  }
  if (input.ID !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ID").addChildNode(new __XmlText(input.ID)).withName("ID")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlParquetInput = (
  input: ParquetInput,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ParquetInput");
  return bodyNode;
};

const serializeAws_restXmlPublicAccessBlockConfiguration = (
  input: PublicAccessBlockConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("PublicAccessBlockConfiguration");
  if (input.BlockPublicAcls !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Setting")
        .addChildNode(new __XmlText(String(input.BlockPublicAcls)))
        .withName("BlockPublicAcls")
    );
  }
  if (input.BlockPublicPolicy !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Setting")
        .addChildNode(new __XmlText(String(input.BlockPublicPolicy)))
        .withName("BlockPublicPolicy")
    );
  }
  if (input.IgnorePublicAcls !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Setting")
        .addChildNode(new __XmlText(String(input.IgnorePublicAcls)))
        .withName("IgnorePublicAcls")
    );
  }
  if (input.RestrictPublicBuckets !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Setting")
        .addChildNode(new __XmlText(String(input.RestrictPublicBuckets)))
        .withName("RestrictPublicBuckets")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlQueueConfiguration = (
  input: QueueConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("QueueConfiguration");
  if (input.Events !== undefined) {
    const nodes = serializeAws_restXmlEventList(input.Events, context);
    nodes.map((node: any) => {
      node = node.withName("Event");
      bodyNode.addChildNode(node);
    });
  }
  if (input.Filter !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlNotificationConfigurationFilter(
        input.Filter,
        context
      ).withName("Filter")
    );
  }
  if (input.Id !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("NotificationId")
        .addChildNode(new __XmlText(input.Id))
        .withName("Id")
    );
  }
  if (input.QueueArn !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("QueueArn")
        .addChildNode(new __XmlText(input.QueueArn))
        .withName("Queue")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlQueueConfigurationList = (
  input: Array<QueueConfiguration>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlQueueConfiguration(entry, context);
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlRedirect = (
  input: Redirect,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Redirect");
  if (input.HostName !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("HostName")
        .addChildNode(new __XmlText(input.HostName))
        .withName("HostName")
    );
  }
  if (input.HttpRedirectCode !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("HttpRedirectCode")
        .addChildNode(new __XmlText(input.HttpRedirectCode))
        .withName("HttpRedirectCode")
    );
  }
  if (input.Protocol !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Protocol")
        .addChildNode(new __XmlText(input.Protocol))
        .withName("Protocol")
    );
  }
  if (input.ReplaceKeyPrefixWith !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ReplaceKeyPrefixWith")
        .addChildNode(new __XmlText(input.ReplaceKeyPrefixWith))
        .withName("ReplaceKeyPrefixWith")
    );
  }
  if (input.ReplaceKeyWith !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ReplaceKeyWith")
        .addChildNode(new __XmlText(input.ReplaceKeyWith))
        .withName("ReplaceKeyWith")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlRedirectAllRequestsTo = (
  input: RedirectAllRequestsTo,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("RedirectAllRequestsTo");
  if (input.HostName !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("HostName")
        .addChildNode(new __XmlText(input.HostName))
        .withName("HostName")
    );
  }
  if (input.Protocol !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Protocol")
        .addChildNode(new __XmlText(input.Protocol))
        .withName("Protocol")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlReplicationConfiguration = (
  input: ReplicationConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ReplicationConfiguration");
  if (input.Role !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Role")
        .addChildNode(new __XmlText(input.Role))
        .withName("Role")
    );
  }
  if (input.Rules !== undefined) {
    const nodes = serializeAws_restXmlReplicationRules(input.Rules, context);
    nodes.map((node: any) => {
      node = node.withName("Rule");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlReplicationRule = (
  input: ReplicationRule,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ReplicationRule");
  if (input.DeleteMarkerReplication !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlDeleteMarkerReplication(
        input.DeleteMarkerReplication,
        context
      ).withName("DeleteMarkerReplication")
    );
  }
  if (input.Destination !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlDestination(input.Destination, context).withName(
        "Destination"
      )
    );
  }
  if (input.ExistingObjectReplication !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlExistingObjectReplication(
        input.ExistingObjectReplication,
        context
      ).withName("ExistingObjectReplication")
    );
  }
  if (input.Filter !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlReplicationRuleFilter(input.Filter, context).withName(
        "Filter"
      )
    );
  }
  if (input.ID !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ID").addChildNode(new __XmlText(input.ID)).withName("ID")
    );
  }
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.Priority !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Priority")
        .addChildNode(new __XmlText(String(input.Priority)))
        .withName("Priority")
    );
  }
  if (input.SourceSelectionCriteria !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlSourceSelectionCriteria(
        input.SourceSelectionCriteria,
        context
      ).withName("SourceSelectionCriteria")
    );
  }
  if (input.Status !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ReplicationRuleStatus")
        .addChildNode(new __XmlText(input.Status))
        .withName("Status")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlReplicationRuleAndOperator = (
  input: ReplicationRuleAndOperator,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ReplicationRuleAndOperator");
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.Tags !== undefined) {
    const nodes = serializeAws_restXmlTagSet(input.Tags, context);
    nodes.map((node: any) => {
      node = node.withName("Tag");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlReplicationRuleFilter = (
  input: ReplicationRuleFilter,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ReplicationRuleFilter");
  if (input.And !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlReplicationRuleAndOperator(
        input.And,
        context
      ).withName("And")
    );
  }
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Prefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.Tag !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlTag(input.Tag, context).withName("Tag")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlReplicationRules = (
  input: Array<ReplicationRule>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlReplicationRule(entry, context);
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlReplicationTime = (
  input: ReplicationTime,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ReplicationTime");
  if (input.Status !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ReplicationTimeStatus")
        .addChildNode(new __XmlText(input.Status))
        .withName("Status")
    );
  }
  if (input.Time !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlReplicationTimeValue(input.Time, context).withName(
        "Time"
      )
    );
  }
  return bodyNode;
};

const serializeAws_restXmlReplicationTimeValue = (
  input: ReplicationTimeValue,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ReplicationTimeValue");
  if (input.Minutes !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Minutes")
        .addChildNode(new __XmlText(String(input.Minutes)))
        .withName("Minutes")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlRequestPaymentConfiguration = (
  input: RequestPaymentConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("RequestPaymentConfiguration");
  if (input.Payer !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Payer")
        .addChildNode(new __XmlText(input.Payer))
        .withName("Payer")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlRequestProgress = (
  input: RequestProgress,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("RequestProgress");
  if (input.Enabled !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("EnableRequestProgress")
        .addChildNode(new __XmlText(String(input.Enabled)))
        .withName("Enabled")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlRestoreRequest = (
  input: RestoreRequest,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("RestoreRequest");
  if (input.Days !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Days")
        .addChildNode(new __XmlText(String(input.Days)))
        .withName("Days")
    );
  }
  if (input.Description !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Description")
        .addChildNode(new __XmlText(input.Description))
        .withName("Description")
    );
  }
  if (input.GlacierJobParameters !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlGlacierJobParameters(
        input.GlacierJobParameters,
        context
      ).withName("GlacierJobParameters")
    );
  }
  if (input.OutputLocation !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlOutputLocation(
        input.OutputLocation,
        context
      ).withName("OutputLocation")
    );
  }
  if (input.SelectParameters !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlSelectParameters(
        input.SelectParameters,
        context
      ).withName("SelectParameters")
    );
  }
  if (input.Tier !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Tier")
        .addChildNode(new __XmlText(input.Tier))
        .withName("Tier")
    );
  }
  if (input.Type !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("RestoreRequestType")
        .addChildNode(new __XmlText(input.Type))
        .withName("Type")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlRoutingRule = (
  input: RoutingRule,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("RoutingRule");
  if (input.Condition !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlCondition(input.Condition, context).withName(
        "Condition"
      )
    );
  }
  if (input.Redirect !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlRedirect(input.Redirect, context).withName("Redirect")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlRoutingRules = (
  input: Array<RoutingRule>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlRoutingRule(entry, context);
    collectedNodes.push(node.withName("RoutingRule"));
  }
  return collectedNodes;
};

const serializeAws_restXmlS3KeyFilter = (
  input: S3KeyFilter,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("S3KeyFilter");
  if (input.FilterRules !== undefined) {
    const nodes = serializeAws_restXmlFilterRuleList(
      input.FilterRules,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("FilterRule");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlS3Location = (
  input: S3Location,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("S3Location");
  if (input.AccessControlList !== undefined) {
    const nodes = serializeAws_restXmlGrants(input.AccessControlList, context);
    const containerNode = new __XmlNode("AccessControlList");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.BucketName !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("BucketName")
        .addChildNode(new __XmlText(input.BucketName))
        .withName("BucketName")
    );
  }
  if (input.CannedACL !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ObjectCannedACL")
        .addChildNode(new __XmlText(input.CannedACL))
        .withName("CannedACL")
    );
  }
  if (input.Encryption !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlEncryption(input.Encryption, context).withName(
        "Encryption"
      )
    );
  }
  if (input.Prefix !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("LocationPrefix")
        .addChildNode(new __XmlText(input.Prefix))
        .withName("Prefix")
    );
  }
  if (input.StorageClass !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("StorageClass")
        .addChildNode(new __XmlText(input.StorageClass))
        .withName("StorageClass")
    );
  }
  if (input.Tagging !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlTagging(input.Tagging, context).withName("Tagging")
    );
  }
  if (input.UserMetadata !== undefined) {
    const nodes = serializeAws_restXmlUserMetadata(input.UserMetadata, context);
    const containerNode = new __XmlNode("UserMetadata");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  return bodyNode;
};

const serializeAws_restXmlSSEKMS = (
  input: SSEKMS,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("SSE-KMS");
  if (input.KeyId !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("SSEKMSKeyId")
        .addChildNode(new __XmlText(input.KeyId))
        .withName("KeyId")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlSSES3 = (
  input: SSES3,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("SSE-S3");
  return bodyNode;
};

const serializeAws_restXmlScanRange = (
  input: ScanRange,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ScanRange");
  if (input.End !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("End")
        .addChildNode(new __XmlText(String(input.End)))
        .withName("End")
    );
  }
  if (input.Start !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Start")
        .addChildNode(new __XmlText(String(input.Start)))
        .withName("Start")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlSelectParameters = (
  input: SelectParameters,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("SelectParameters");
  if (input.Expression !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Expression")
        .addChildNode(new __XmlText(input.Expression))
        .withName("Expression")
    );
  }
  if (input.ExpressionType !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ExpressionType")
        .addChildNode(new __XmlText(input.ExpressionType))
        .withName("ExpressionType")
    );
  }
  if (input.InputSerialization !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlInputSerialization(
        input.InputSerialization,
        context
      ).withName("InputSerialization")
    );
  }
  if (input.OutputSerialization !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlOutputSerialization(
        input.OutputSerialization,
        context
      ).withName("OutputSerialization")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlServerSideEncryptionByDefault = (
  input: ServerSideEncryptionByDefault,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ServerSideEncryptionByDefault");
  if (input.KMSMasterKeyID !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("SSEKMSKeyId")
        .addChildNode(new __XmlText(input.KMSMasterKeyID))
        .withName("KMSMasterKeyID")
    );
  }
  if (input.SSEAlgorithm !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ServerSideEncryption")
        .addChildNode(new __XmlText(input.SSEAlgorithm))
        .withName("SSEAlgorithm")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlServerSideEncryptionConfiguration = (
  input: ServerSideEncryptionConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ServerSideEncryptionConfiguration");
  if (input.Rules !== undefined) {
    const nodes = serializeAws_restXmlServerSideEncryptionRules(
      input.Rules,
      context
    );
    nodes.map((node: any) => {
      node = node.withName("Rule");
      bodyNode.addChildNode(node);
    });
  }
  return bodyNode;
};

const serializeAws_restXmlServerSideEncryptionRule = (
  input: ServerSideEncryptionRule,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ServerSideEncryptionRule");
  if (input.ApplyServerSideEncryptionByDefault !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlServerSideEncryptionByDefault(
        input.ApplyServerSideEncryptionByDefault,
        context
      ).withName("ApplyServerSideEncryptionByDefault")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlServerSideEncryptionRules = (
  input: Array<ServerSideEncryptionRule>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlServerSideEncryptionRule(entry, context);
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlSourceSelectionCriteria = (
  input: SourceSelectionCriteria,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("SourceSelectionCriteria");
  if (input.SseKmsEncryptedObjects !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlSseKmsEncryptedObjects(
        input.SseKmsEncryptedObjects,
        context
      ).withName("SseKmsEncryptedObjects")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlSseKmsEncryptedObjects = (
  input: SseKmsEncryptedObjects,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("SseKmsEncryptedObjects");
  if (input.Status !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("SseKmsEncryptedObjectsStatus")
        .addChildNode(new __XmlText(input.Status))
        .withName("Status")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlStorageClassAnalysis = (
  input: StorageClassAnalysis,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("StorageClassAnalysis");
  if (input.DataExport !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlStorageClassAnalysisDataExport(
        input.DataExport,
        context
      ).withName("DataExport")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlStorageClassAnalysisDataExport = (
  input: StorageClassAnalysisDataExport,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("StorageClassAnalysisDataExport");
  if (input.Destination !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlAnalyticsExportDestination(
        input.Destination,
        context
      ).withName("Destination")
    );
  }
  if (input.OutputSchemaVersion !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("StorageClassAnalysisSchemaVersion")
        .addChildNode(new __XmlText(input.OutputSchemaVersion))
        .withName("OutputSchemaVersion")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlTag = (input: Tag, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Tag");
  if (input.Key !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("ObjectKey")
        .addChildNode(new __XmlText(input.Key))
        .withName("Key")
    );
  }
  if (input.Value !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Value")
        .addChildNode(new __XmlText(input.Value))
        .withName("Value")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlTagSet = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlTag(entry, context);
    collectedNodes.push(node.withName("Tag"));
  }
  return collectedNodes;
};

const serializeAws_restXmlTagging = (
  input: Tagging,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Tagging");
  if (input.TagSet !== undefined) {
    const nodes = serializeAws_restXmlTagSet(input.TagSet, context);
    const containerNode = new __XmlNode("TagSet");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  return bodyNode;
};

const serializeAws_restXmlTargetGrant = (
  input: TargetGrant,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("TargetGrant");
  if (input.Grantee !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlGrantee(input.Grantee, context).withName("Grantee")
    );
  }
  if (input.Permission !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("BucketLogsPermission")
        .addChildNode(new __XmlText(input.Permission))
        .withName("Permission")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlTargetGrants = (
  input: Array<TargetGrant>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlTargetGrant(entry, context);
    collectedNodes.push(node.withName("Grant"));
  }
  return collectedNodes;
};

const serializeAws_restXmlTopicConfiguration = (
  input: TopicConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("TopicConfiguration");
  if (input.Events !== undefined) {
    const nodes = serializeAws_restXmlEventList(input.Events, context);
    nodes.map((node: any) => {
      node = node.withName("Event");
      bodyNode.addChildNode(node);
    });
  }
  if (input.Filter !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlNotificationConfigurationFilter(
        input.Filter,
        context
      ).withName("Filter")
    );
  }
  if (input.Id !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("NotificationId")
        .addChildNode(new __XmlText(input.Id))
        .withName("Id")
    );
  }
  if (input.TopicArn !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("TopicArn")
        .addChildNode(new __XmlText(input.TopicArn))
        .withName("Topic")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlTopicConfigurationList = (
  input: Array<TopicConfiguration>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlTopicConfiguration(entry, context);
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlTransition = (
  input: Transition,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Transition");
  if (input.Date !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Date")
        .addChildNode(
          new __XmlText(input.Date.toISOString().split(".")[0] + "Z")
        )
        .withName("Date")
    );
  }
  if (input.Days !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("Days")
        .addChildNode(new __XmlText(String(input.Days)))
        .withName("Days")
    );
  }
  if (input.StorageClass !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("TransitionStorageClass")
        .addChildNode(new __XmlText(input.StorageClass))
        .withName("StorageClass")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlTransitionList = (
  input: Array<Transition>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlTransition(entry, context);
    collectedNodes.push(node.withName("member"));
  }
  return collectedNodes;
};

const serializeAws_restXmlUserMetadata = (
  input: Array<MetadataEntry>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  for (let entry of input) {
    const node = serializeAws_restXmlMetadataEntry(entry, context);
    collectedNodes.push(node.withName("MetadataEntry"));
  }
  return collectedNodes;
};

const serializeAws_restXmlVersioningConfiguration = (
  input: VersioningConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("VersioningConfiguration");
  if (input.MFADelete !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("MFADelete")
        .addChildNode(new __XmlText(input.MFADelete))
        .withName("MfaDelete")
    );
  }
  if (input.Status !== undefined) {
    bodyNode.addChildNode(
      new __XmlNode("BucketVersioningStatus")
        .addChildNode(new __XmlText(input.Status))
        .withName("Status")
    );
  }
  return bodyNode;
};

const serializeAws_restXmlWebsiteConfiguration = (
  input: WebsiteConfiguration,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("WebsiteConfiguration");
  if (input.ErrorDocument !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlErrorDocument(input.ErrorDocument, context).withName(
        "ErrorDocument"
      )
    );
  }
  if (input.IndexDocument !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlIndexDocument(input.IndexDocument, context).withName(
        "IndexDocument"
      )
    );
  }
  if (input.RedirectAllRequestsTo !== undefined) {
    bodyNode.addChildNode(
      serializeAws_restXmlRedirectAllRequestsTo(
        input.RedirectAllRequestsTo,
        context
      ).withName("RedirectAllRequestsTo")
    );
  }
  if (input.RoutingRules !== undefined) {
    const nodes = serializeAws_restXmlRoutingRules(input.RoutingRules, context);
    const containerNode = new __XmlNode("RoutingRules");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  return bodyNode;
};

const deserializeAws_restXmlAbortIncompleteMultipartUpload = (
  output: any,
  context: __SerdeContext
): AbortIncompleteMultipartUpload => {
  let contents: any = {
    __type: "AbortIncompleteMultipartUpload",
    DaysAfterInitiation: undefined
  };
  if (output["DaysAfterInitiation"] !== undefined) {
    contents.DaysAfterInitiation = parseInt(output["DaysAfterInitiation"]);
  }
  return contents;
};

const deserializeAws_restXmlAccessControlTranslation = (
  output: any,
  context: __SerdeContext
): AccessControlTranslation => {
  let contents: any = {
    __type: "AccessControlTranslation",
    Owner: undefined
  };
  if (output["Owner"] !== undefined) {
    contents.Owner = output["Owner"];
  }
  return contents;
};

const deserializeAws_restXmlAllowedHeaders = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry);
  });
  return contents;
};

const deserializeAws_restXmlAllowedMethods = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry);
  });
  return contents;
};

const deserializeAws_restXmlAllowedOrigins = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry);
  });
  return contents;
};

const deserializeAws_restXmlAnalyticsAndOperator = (
  output: any,
  context: __SerdeContext
): AnalyticsAndOperator => {
  let contents: any = {
    __type: "AnalyticsAndOperator",
    Prefix: undefined,
    Tags: undefined
  };
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  if (output.Tag === "") {
    contents.Tags = [];
  }
  if (output["Tag"] !== undefined) {
    const wrappedItem =
      output["Tag"] instanceof Array ? output["Tag"] : [output["Tag"]];
    contents.Tags = deserializeAws_restXmlTagSet(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_restXmlAnalyticsConfiguration = (
  output: any,
  context: __SerdeContext
): AnalyticsConfiguration => {
  let contents: any = {
    __type: "AnalyticsConfiguration",
    Filter: undefined,
    Id: undefined,
    StorageClassAnalysis: undefined
  };
  if (output["Filter"] !== undefined) {
    contents.Filter = deserializeAws_restXmlAnalyticsFilter(
      output["Filter"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["StorageClassAnalysis"] !== undefined) {
    contents.StorageClassAnalysis = deserializeAws_restXmlStorageClassAnalysis(
      output["StorageClassAnalysis"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlAnalyticsConfigurationList = (
  output: any,
  context: __SerdeContext
): Array<AnalyticsConfiguration> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlAnalyticsConfiguration(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlAnalyticsExportDestination = (
  output: any,
  context: __SerdeContext
): AnalyticsExportDestination => {
  let contents: any = {
    __type: "AnalyticsExportDestination",
    S3BucketDestination: undefined
  };
  if (output["S3BucketDestination"] !== undefined) {
    contents.S3BucketDestination = deserializeAws_restXmlAnalyticsS3BucketDestination(
      output["S3BucketDestination"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlAnalyticsFilter = (
  output: any,
  context: __SerdeContext
): AnalyticsFilter => {
  let contents: any = {
    __type: "AnalyticsFilter",
    And: undefined,
    Prefix: undefined,
    Tag: undefined
  };
  if (output["And"] !== undefined) {
    contents.And = deserializeAws_restXmlAnalyticsAndOperator(
      output["And"],
      context
    );
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  if (output["Tag"] !== undefined) {
    contents.Tag = deserializeAws_restXmlTag(output["Tag"], context);
  }
  return contents;
};

const deserializeAws_restXmlAnalyticsS3BucketDestination = (
  output: any,
  context: __SerdeContext
): AnalyticsS3BucketDestination => {
  let contents: any = {
    __type: "AnalyticsS3BucketDestination",
    Bucket: undefined,
    BucketAccountId: undefined,
    Format: undefined,
    Prefix: undefined
  };
  if (output["Bucket"] !== undefined) {
    contents.Bucket = output["Bucket"];
  }
  if (output["BucketAccountId"] !== undefined) {
    contents.BucketAccountId = output["BucketAccountId"];
  }
  if (output["Format"] !== undefined) {
    contents.Format = output["Format"];
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  return contents;
};

const deserializeAws_restXmlBucket = (
  output: any,
  context: __SerdeContext
): Bucket => {
  let contents: any = {
    __type: "Bucket",
    CreationDate: undefined,
    Name: undefined
  };
  if (output["CreationDate"] !== undefined) {
    contents.CreationDate = new Date(output["CreationDate"]);
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  return contents;
};

const deserializeAws_restXmlBuckets = (
  output: any,
  context: __SerdeContext
): Array<Bucket> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlBucket(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlCORSRule = (
  output: any,
  context: __SerdeContext
): CORSRule => {
  let contents: any = {
    __type: "CORSRule",
    AllowedHeaders: undefined,
    AllowedMethods: undefined,
    AllowedOrigins: undefined,
    ExposeHeaders: undefined,
    MaxAgeSeconds: undefined
  };
  if (output.AllowedHeader === "") {
    contents.AllowedHeaders = [];
  }
  if (output["AllowedHeader"] !== undefined) {
    const wrappedItem =
      output["AllowedHeader"] instanceof Array
        ? output["AllowedHeader"]
        : [output["AllowedHeader"]];
    contents.AllowedHeaders = deserializeAws_restXmlAllowedHeaders(
      wrappedItem,
      context
    );
  }
  if (output.AllowedMethod === "") {
    contents.AllowedMethods = [];
  }
  if (output["AllowedMethod"] !== undefined) {
    const wrappedItem =
      output["AllowedMethod"] instanceof Array
        ? output["AllowedMethod"]
        : [output["AllowedMethod"]];
    contents.AllowedMethods = deserializeAws_restXmlAllowedMethods(
      wrappedItem,
      context
    );
  }
  if (output.AllowedOrigin === "") {
    contents.AllowedOrigins = [];
  }
  if (output["AllowedOrigin"] !== undefined) {
    const wrappedItem =
      output["AllowedOrigin"] instanceof Array
        ? output["AllowedOrigin"]
        : [output["AllowedOrigin"]];
    contents.AllowedOrigins = deserializeAws_restXmlAllowedOrigins(
      wrappedItem,
      context
    );
  }
  if (output.ExposeHeader === "") {
    contents.ExposeHeaders = [];
  }
  if (output["ExposeHeader"] !== undefined) {
    const wrappedItem =
      output["ExposeHeader"] instanceof Array
        ? output["ExposeHeader"]
        : [output["ExposeHeader"]];
    contents.ExposeHeaders = deserializeAws_restXmlExposeHeaders(
      wrappedItem,
      context
    );
  }
  if (output["MaxAgeSeconds"] !== undefined) {
    contents.MaxAgeSeconds = parseInt(output["MaxAgeSeconds"]);
  }
  return contents;
};

const deserializeAws_restXmlCORSRules = (
  output: any,
  context: __SerdeContext
): Array<CORSRule> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlCORSRule(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlCommonPrefix = (
  output: any,
  context: __SerdeContext
): CommonPrefix => {
  let contents: any = {
    __type: "CommonPrefix",
    Prefix: undefined
  };
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  return contents;
};

const deserializeAws_restXmlCommonPrefixList = (
  output: any,
  context: __SerdeContext
): Array<CommonPrefix> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlCommonPrefix(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlCondition = (
  output: any,
  context: __SerdeContext
): Condition => {
  let contents: any = {
    __type: "Condition",
    HttpErrorCodeReturnedEquals: undefined,
    KeyPrefixEquals: undefined
  };
  if (output["HttpErrorCodeReturnedEquals"] !== undefined) {
    contents.HttpErrorCodeReturnedEquals =
      output["HttpErrorCodeReturnedEquals"];
  }
  if (output["KeyPrefixEquals"] !== undefined) {
    contents.KeyPrefixEquals = output["KeyPrefixEquals"];
  }
  return contents;
};

const deserializeAws_restXmlCopyObjectResult = (
  output: any,
  context: __SerdeContext
): CopyObjectResult => {
  let contents: any = {
    __type: "CopyObjectResult",
    ETag: undefined,
    LastModified: undefined
  };
  if (output["ETag"] !== undefined) {
    contents.ETag = output["ETag"];
  }
  if (output["LastModified"] !== undefined) {
    contents.LastModified = new Date(output["LastModified"]);
  }
  return contents;
};

const deserializeAws_restXmlCopyPartResult = (
  output: any,
  context: __SerdeContext
): CopyPartResult => {
  let contents: any = {
    __type: "CopyPartResult",
    ETag: undefined,
    LastModified: undefined
  };
  if (output["ETag"] !== undefined) {
    contents.ETag = output["ETag"];
  }
  if (output["LastModified"] !== undefined) {
    contents.LastModified = new Date(output["LastModified"]);
  }
  return contents;
};

const deserializeAws_restXmlDefaultRetention = (
  output: any,
  context: __SerdeContext
): DefaultRetention => {
  let contents: any = {
    __type: "DefaultRetention",
    Days: undefined,
    Mode: undefined,
    Years: undefined
  };
  if (output["Days"] !== undefined) {
    contents.Days = parseInt(output["Days"]);
  }
  if (output["Mode"] !== undefined) {
    contents.Mode = output["Mode"];
  }
  if (output["Years"] !== undefined) {
    contents.Years = parseInt(output["Years"]);
  }
  return contents;
};

const deserializeAws_restXmlDeleteMarkerEntry = (
  output: any,
  context: __SerdeContext
): DeleteMarkerEntry => {
  let contents: any = {
    __type: "DeleteMarkerEntry",
    IsLatest: undefined,
    Key: undefined,
    LastModified: undefined,
    Owner: undefined,
    VersionId: undefined
  };
  if (output["IsLatest"] !== undefined) {
    contents.IsLatest = output["IsLatest"] == "true";
  }
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["LastModified"] !== undefined) {
    contents.LastModified = new Date(output["LastModified"]);
  }
  if (output["Owner"] !== undefined) {
    contents.Owner = deserializeAws_restXmlOwner(output["Owner"], context);
  }
  if (output["VersionId"] !== undefined) {
    contents.VersionId = output["VersionId"];
  }
  return contents;
};

const deserializeAws_restXmlDeleteMarkerReplication = (
  output: any,
  context: __SerdeContext
): DeleteMarkerReplication => {
  let contents: any = {
    __type: "DeleteMarkerReplication",
    Status: undefined
  };
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlDeleteMarkers = (
  output: any,
  context: __SerdeContext
): Array<DeleteMarkerEntry> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlDeleteMarkerEntry(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlDeletedObject = (
  output: any,
  context: __SerdeContext
): DeletedObject => {
  let contents: any = {
    __type: "DeletedObject",
    DeleteMarker: undefined,
    DeleteMarkerVersionId: undefined,
    Key: undefined,
    VersionId: undefined
  };
  if (output["DeleteMarker"] !== undefined) {
    contents.DeleteMarker = output["DeleteMarker"] == "true";
  }
  if (output["DeleteMarkerVersionId"] !== undefined) {
    contents.DeleteMarkerVersionId = output["DeleteMarkerVersionId"];
  }
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["VersionId"] !== undefined) {
    contents.VersionId = output["VersionId"];
  }
  return contents;
};

const deserializeAws_restXmlDeletedObjects = (
  output: any,
  context: __SerdeContext
): Array<DeletedObject> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlDeletedObject(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlDestination = (
  output: any,
  context: __SerdeContext
): Destination => {
  let contents: any = {
    __type: "Destination",
    AccessControlTranslation: undefined,
    Account: undefined,
    Bucket: undefined,
    EncryptionConfiguration: undefined,
    Metrics: undefined,
    ReplicationTime: undefined,
    StorageClass: undefined
  };
  if (output["AccessControlTranslation"] !== undefined) {
    contents.AccessControlTranslation = deserializeAws_restXmlAccessControlTranslation(
      output["AccessControlTranslation"],
      context
    );
  }
  if (output["Account"] !== undefined) {
    contents.Account = output["Account"];
  }
  if (output["Bucket"] !== undefined) {
    contents.Bucket = output["Bucket"];
  }
  if (output["EncryptionConfiguration"] !== undefined) {
    contents.EncryptionConfiguration = deserializeAws_restXmlEncryptionConfiguration(
      output["EncryptionConfiguration"],
      context
    );
  }
  if (output["Metrics"] !== undefined) {
    contents.Metrics = deserializeAws_restXmlMetrics(
      output["Metrics"],
      context
    );
  }
  if (output["ReplicationTime"] !== undefined) {
    contents.ReplicationTime = deserializeAws_restXmlReplicationTime(
      output["ReplicationTime"],
      context
    );
  }
  if (output["StorageClass"] !== undefined) {
    contents.StorageClass = output["StorageClass"];
  }
  return contents;
};

const deserializeAws_restXmlEncryptionConfiguration = (
  output: any,
  context: __SerdeContext
): EncryptionConfiguration => {
  let contents: any = {
    __type: "EncryptionConfiguration",
    ReplicaKmsKeyID: undefined
  };
  if (output["ReplicaKmsKeyID"] !== undefined) {
    contents.ReplicaKmsKeyID = output["ReplicaKmsKeyID"];
  }
  return contents;
};

const deserializeAws_restXml_Error = (
  output: any,
  context: __SerdeContext
): _Error => {
  let contents: any = {
    __type: "Error",
    Code: undefined,
    Key: undefined,
    Message: undefined,
    VersionId: undefined
  };
  if (output["Code"] !== undefined) {
    contents.Code = output["Code"];
  }
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["Message"] !== undefined) {
    contents.Message = output["Message"];
  }
  if (output["VersionId"] !== undefined) {
    contents.VersionId = output["VersionId"];
  }
  return contents;
};

const deserializeAws_restXmlErrorDocument = (
  output: any,
  context: __SerdeContext
): ErrorDocument => {
  let contents: any = {
    __type: "ErrorDocument",
    Key: undefined
  };
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  return contents;
};

const deserializeAws_restXmlErrors = (
  output: any,
  context: __SerdeContext
): Array<_Error> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXml_Error(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlEventList = (
  output: any,
  context: __SerdeContext
): Array<Event | string> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry);
  });
  return contents;
};

const deserializeAws_restXmlExistingObjectReplication = (
  output: any,
  context: __SerdeContext
): ExistingObjectReplication => {
  let contents: any = {
    __type: "ExistingObjectReplication",
    Status: undefined
  };
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlExposeHeaders = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry);
  });
  return contents;
};

const deserializeAws_restXmlFilterRule = (
  output: any,
  context: __SerdeContext
): FilterRule => {
  let contents: any = {
    __type: "FilterRule",
    Name: undefined,
    Value: undefined
  };
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_restXmlFilterRuleList = (
  output: any,
  context: __SerdeContext
): Array<FilterRule> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlFilterRule(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlGrant = (
  output: any,
  context: __SerdeContext
): Grant => {
  let contents: any = {
    __type: "Grant",
    Grantee: undefined,
    Permission: undefined
  };
  if (output["Grantee"] !== undefined) {
    contents.Grantee = deserializeAws_restXmlGrantee(
      output["Grantee"],
      context
    );
  }
  if (output["Permission"] !== undefined) {
    contents.Permission = output["Permission"];
  }
  return contents;
};

const deserializeAws_restXmlGrantee = (
  output: any,
  context: __SerdeContext
): Grantee => {
  let contents: any = {
    __type: "Grantee",
    DisplayName: undefined,
    EmailAddress: undefined,
    ID: undefined,
    Type: undefined,
    URI: undefined
  };
  if (output["DisplayName"] !== undefined) {
    contents.DisplayName = output["DisplayName"];
  }
  if (output["EmailAddress"] !== undefined) {
    contents.EmailAddress = output["EmailAddress"];
  }
  if (output["ID"] !== undefined) {
    contents.ID = output["ID"];
  }
  if (output["xsi:type"] !== undefined) {
    contents.Type = output["xsi:type"];
  }
  if (output["URI"] !== undefined) {
    contents.URI = output["URI"];
  }
  return contents;
};

const deserializeAws_restXmlGrants = (
  output: any,
  context: __SerdeContext
): Array<Grant> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlGrant(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlIndexDocument = (
  output: any,
  context: __SerdeContext
): IndexDocument => {
  let contents: any = {
    __type: "IndexDocument",
    Suffix: undefined
  };
  if (output["Suffix"] !== undefined) {
    contents.Suffix = output["Suffix"];
  }
  return contents;
};

const deserializeAws_restXmlInitiator = (
  output: any,
  context: __SerdeContext
): Initiator => {
  let contents: any = {
    __type: "Initiator",
    DisplayName: undefined,
    ID: undefined
  };
  if (output["DisplayName"] !== undefined) {
    contents.DisplayName = output["DisplayName"];
  }
  if (output["ID"] !== undefined) {
    contents.ID = output["ID"];
  }
  return contents;
};

const deserializeAws_restXmlInventoryConfiguration = (
  output: any,
  context: __SerdeContext
): InventoryConfiguration => {
  let contents: any = {
    __type: "InventoryConfiguration",
    Destination: undefined,
    Filter: undefined,
    Id: undefined,
    IncludedObjectVersions: undefined,
    IsEnabled: undefined,
    OptionalFields: undefined,
    Schedule: undefined
  };
  if (output["Destination"] !== undefined) {
    contents.Destination = deserializeAws_restXmlInventoryDestination(
      output["Destination"],
      context
    );
  }
  if (output["Filter"] !== undefined) {
    contents.Filter = deserializeAws_restXmlInventoryFilter(
      output["Filter"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["IncludedObjectVersions"] !== undefined) {
    contents.IncludedObjectVersions = output["IncludedObjectVersions"];
  }
  if (output["IsEnabled"] !== undefined) {
    contents.IsEnabled = output["IsEnabled"] == "true";
  }
  if (output.OptionalFields === "") {
    contents.OptionalFields = [];
  }
  if (
    output["OptionalFields"] !== undefined &&
    output["OptionalFields"]["Field"] !== undefined
  ) {
    const wrappedItem =
      output["OptionalFields"]["Field"] instanceof Array
        ? output["OptionalFields"]["Field"]
        : [output["OptionalFields"]["Field"]];
    contents.OptionalFields = deserializeAws_restXmlInventoryOptionalFields(
      wrappedItem,
      context
    );
  }
  if (output["Schedule"] !== undefined) {
    contents.Schedule = deserializeAws_restXmlInventorySchedule(
      output["Schedule"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlInventoryConfigurationList = (
  output: any,
  context: __SerdeContext
): Array<InventoryConfiguration> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlInventoryConfiguration(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlInventoryDestination = (
  output: any,
  context: __SerdeContext
): InventoryDestination => {
  let contents: any = {
    __type: "InventoryDestination",
    S3BucketDestination: undefined
  };
  if (output["S3BucketDestination"] !== undefined) {
    contents.S3BucketDestination = deserializeAws_restXmlInventoryS3BucketDestination(
      output["S3BucketDestination"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlInventoryEncryption = (
  output: any,
  context: __SerdeContext
): InventoryEncryption => {
  let contents: any = {
    __type: "InventoryEncryption",
    SSEKMS: undefined,
    SSES3: undefined
  };
  if (output["SSE-KMS"] !== undefined) {
    contents.SSEKMS = deserializeAws_restXmlSSEKMS(output["SSE-KMS"], context);
  }
  if (output["SSE-S3"] !== undefined) {
    contents.SSES3 = deserializeAws_restXmlSSES3(output["SSE-S3"], context);
  }
  return contents;
};

const deserializeAws_restXmlInventoryFilter = (
  output: any,
  context: __SerdeContext
): InventoryFilter => {
  let contents: any = {
    __type: "InventoryFilter",
    Prefix: undefined
  };
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  return contents;
};

const deserializeAws_restXmlInventoryOptionalFields = (
  output: any,
  context: __SerdeContext
): Array<InventoryOptionalField | string> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry);
  });
  return contents;
};

const deserializeAws_restXmlInventoryS3BucketDestination = (
  output: any,
  context: __SerdeContext
): InventoryS3BucketDestination => {
  let contents: any = {
    __type: "InventoryS3BucketDestination",
    AccountId: undefined,
    Bucket: undefined,
    Encryption: undefined,
    Format: undefined,
    Prefix: undefined
  };
  if (output["AccountId"] !== undefined) {
    contents.AccountId = output["AccountId"];
  }
  if (output["Bucket"] !== undefined) {
    contents.Bucket = output["Bucket"];
  }
  if (output["Encryption"] !== undefined) {
    contents.Encryption = deserializeAws_restXmlInventoryEncryption(
      output["Encryption"],
      context
    );
  }
  if (output["Format"] !== undefined) {
    contents.Format = output["Format"];
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  return contents;
};

const deserializeAws_restXmlInventorySchedule = (
  output: any,
  context: __SerdeContext
): InventorySchedule => {
  let contents: any = {
    __type: "InventorySchedule",
    Frequency: undefined
  };
  if (output["Frequency"] !== undefined) {
    contents.Frequency = output["Frequency"];
  }
  return contents;
};

const deserializeAws_restXmlLambdaFunctionConfiguration = (
  output: any,
  context: __SerdeContext
): LambdaFunctionConfiguration => {
  let contents: any = {
    __type: "LambdaFunctionConfiguration",
    Events: undefined,
    Filter: undefined,
    Id: undefined,
    LambdaFunctionArn: undefined
  };
  if (output.Event === "") {
    contents.Events = [];
  }
  if (output["Event"] !== undefined) {
    const wrappedItem =
      output["Event"] instanceof Array ? output["Event"] : [output["Event"]];
    contents.Events = deserializeAws_restXmlEventList(wrappedItem, context);
  }
  if (output["Filter"] !== undefined) {
    contents.Filter = deserializeAws_restXmlNotificationConfigurationFilter(
      output["Filter"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["CloudFunction"] !== undefined) {
    contents.LambdaFunctionArn = output["CloudFunction"];
  }
  return contents;
};

const deserializeAws_restXmlLambdaFunctionConfigurationList = (
  output: any,
  context: __SerdeContext
): Array<LambdaFunctionConfiguration> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_restXmlLambdaFunctionConfiguration(entry, context)
    );
  });
  return contents;
};

const deserializeAws_restXmlLifecycleExpiration = (
  output: any,
  context: __SerdeContext
): LifecycleExpiration => {
  let contents: any = {
    __type: "LifecycleExpiration",
    Date: undefined,
    Days: undefined,
    ExpiredObjectDeleteMarker: undefined
  };
  if (output["Date"] !== undefined) {
    contents.Date = new Date(output["Date"]);
  }
  if (output["Days"] !== undefined) {
    contents.Days = parseInt(output["Days"]);
  }
  if (output["ExpiredObjectDeleteMarker"] !== undefined) {
    contents.ExpiredObjectDeleteMarker =
      output["ExpiredObjectDeleteMarker"] == "true";
  }
  return contents;
};

const deserializeAws_restXmlLifecycleRule = (
  output: any,
  context: __SerdeContext
): LifecycleRule => {
  let contents: any = {
    __type: "LifecycleRule",
    AbortIncompleteMultipartUpload: undefined,
    Expiration: undefined,
    Filter: undefined,
    ID: undefined,
    NoncurrentVersionExpiration: undefined,
    NoncurrentVersionTransitions: undefined,
    Prefix: undefined,
    Status: undefined,
    Transitions: undefined
  };
  if (output["AbortIncompleteMultipartUpload"] !== undefined) {
    contents.AbortIncompleteMultipartUpload = deserializeAws_restXmlAbortIncompleteMultipartUpload(
      output["AbortIncompleteMultipartUpload"],
      context
    );
  }
  if (output["Expiration"] !== undefined) {
    contents.Expiration = deserializeAws_restXmlLifecycleExpiration(
      output["Expiration"],
      context
    );
  }
  if (output["Filter"] !== undefined) {
    contents.Filter = deserializeAws_restXmlLifecycleRuleFilter(
      output["Filter"],
      context
    );
  }
  if (output["ID"] !== undefined) {
    contents.ID = output["ID"];
  }
  if (output["NoncurrentVersionExpiration"] !== undefined) {
    contents.NoncurrentVersionExpiration = deserializeAws_restXmlNoncurrentVersionExpiration(
      output["NoncurrentVersionExpiration"],
      context
    );
  }
  if (output.NoncurrentVersionTransition === "") {
    contents.NoncurrentVersionTransitions = [];
  }
  if (output["NoncurrentVersionTransition"] !== undefined) {
    const wrappedItem =
      output["NoncurrentVersionTransition"] instanceof Array
        ? output["NoncurrentVersionTransition"]
        : [output["NoncurrentVersionTransition"]];
    contents.NoncurrentVersionTransitions = deserializeAws_restXmlNoncurrentVersionTransitionList(
      wrappedItem,
      context
    );
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output.Transition === "") {
    contents.Transitions = [];
  }
  if (output["Transition"] !== undefined) {
    const wrappedItem =
      output["Transition"] instanceof Array
        ? output["Transition"]
        : [output["Transition"]];
    contents.Transitions = deserializeAws_restXmlTransitionList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlLifecycleRuleAndOperator = (
  output: any,
  context: __SerdeContext
): LifecycleRuleAndOperator => {
  let contents: any = {
    __type: "LifecycleRuleAndOperator",
    Prefix: undefined,
    Tags: undefined
  };
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  if (output.Tag === "") {
    contents.Tags = [];
  }
  if (output["Tag"] !== undefined) {
    const wrappedItem =
      output["Tag"] instanceof Array ? output["Tag"] : [output["Tag"]];
    contents.Tags = deserializeAws_restXmlTagSet(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_restXmlLifecycleRuleFilter = (
  output: any,
  context: __SerdeContext
): LifecycleRuleFilter => {
  let contents: any = {
    __type: "LifecycleRuleFilter",
    And: undefined,
    Prefix: undefined,
    Tag: undefined
  };
  if (output["And"] !== undefined) {
    contents.And = deserializeAws_restXmlLifecycleRuleAndOperator(
      output["And"],
      context
    );
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  if (output["Tag"] !== undefined) {
    contents.Tag = deserializeAws_restXmlTag(output["Tag"], context);
  }
  return contents;
};

const deserializeAws_restXmlLifecycleRules = (
  output: any,
  context: __SerdeContext
): Array<LifecycleRule> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlLifecycleRule(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlLoggingEnabled = (
  output: any,
  context: __SerdeContext
): LoggingEnabled => {
  let contents: any = {
    __type: "LoggingEnabled",
    TargetBucket: undefined,
    TargetGrants: undefined,
    TargetPrefix: undefined
  };
  if (output["TargetBucket"] !== undefined) {
    contents.TargetBucket = output["TargetBucket"];
  }
  if (output.TargetGrants === "") {
    contents.TargetGrants = [];
  }
  if (
    output["TargetGrants"] !== undefined &&
    output["TargetGrants"]["Grant"] !== undefined
  ) {
    const wrappedItem =
      output["TargetGrants"]["Grant"] instanceof Array
        ? output["TargetGrants"]["Grant"]
        : [output["TargetGrants"]["Grant"]];
    contents.TargetGrants = deserializeAws_restXmlTargetGrants(
      wrappedItem,
      context
    );
  }
  if (output["TargetPrefix"] !== undefined) {
    contents.TargetPrefix = output["TargetPrefix"];
  }
  return contents;
};

const deserializeAws_restXmlMetrics = (
  output: any,
  context: __SerdeContext
): Metrics => {
  let contents: any = {
    __type: "Metrics",
    EventThreshold: undefined,
    Status: undefined
  };
  if (output["EventThreshold"] !== undefined) {
    contents.EventThreshold = deserializeAws_restXmlReplicationTimeValue(
      output["EventThreshold"],
      context
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlMetricsAndOperator = (
  output: any,
  context: __SerdeContext
): MetricsAndOperator => {
  let contents: any = {
    __type: "MetricsAndOperator",
    Prefix: undefined,
    Tags: undefined
  };
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  if (output.Tag === "") {
    contents.Tags = [];
  }
  if (output["Tag"] !== undefined) {
    const wrappedItem =
      output["Tag"] instanceof Array ? output["Tag"] : [output["Tag"]];
    contents.Tags = deserializeAws_restXmlTagSet(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_restXmlMetricsConfiguration = (
  output: any,
  context: __SerdeContext
): MetricsConfiguration => {
  let contents: any = {
    __type: "MetricsConfiguration",
    Filter: undefined,
    Id: undefined
  };
  if (output["Filter"] !== undefined) {
    contents.Filter = deserializeAws_restXmlMetricsFilter(
      output["Filter"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  return contents;
};

const deserializeAws_restXmlMetricsConfigurationList = (
  output: any,
  context: __SerdeContext
): Array<MetricsConfiguration> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlMetricsConfiguration(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlMetricsFilter = (
  output: any,
  context: __SerdeContext
): MetricsFilter => {
  let contents: any = {
    __type: "MetricsFilter",
    And: undefined,
    Prefix: undefined,
    Tag: undefined
  };
  if (output["And"] !== undefined) {
    contents.And = deserializeAws_restXmlMetricsAndOperator(
      output["And"],
      context
    );
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  if (output["Tag"] !== undefined) {
    contents.Tag = deserializeAws_restXmlTag(output["Tag"], context);
  }
  return contents;
};

const deserializeAws_restXmlMultipartUpload = (
  output: any,
  context: __SerdeContext
): MultipartUpload => {
  let contents: any = {
    __type: "MultipartUpload",
    Initiated: undefined,
    Initiator: undefined,
    Key: undefined,
    Owner: undefined,
    StorageClass: undefined,
    UploadId: undefined
  };
  if (output["Initiated"] !== undefined) {
    contents.Initiated = new Date(output["Initiated"]);
  }
  if (output["Initiator"] !== undefined) {
    contents.Initiator = deserializeAws_restXmlInitiator(
      output["Initiator"],
      context
    );
  }
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["Owner"] !== undefined) {
    contents.Owner = deserializeAws_restXmlOwner(output["Owner"], context);
  }
  if (output["StorageClass"] !== undefined) {
    contents.StorageClass = output["StorageClass"];
  }
  if (output["UploadId"] !== undefined) {
    contents.UploadId = output["UploadId"];
  }
  return contents;
};

const deserializeAws_restXmlMultipartUploadList = (
  output: any,
  context: __SerdeContext
): Array<MultipartUpload> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlMultipartUpload(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlNoncurrentVersionExpiration = (
  output: any,
  context: __SerdeContext
): NoncurrentVersionExpiration => {
  let contents: any = {
    __type: "NoncurrentVersionExpiration",
    NoncurrentDays: undefined
  };
  if (output["NoncurrentDays"] !== undefined) {
    contents.NoncurrentDays = parseInt(output["NoncurrentDays"]);
  }
  return contents;
};

const deserializeAws_restXmlNoncurrentVersionTransition = (
  output: any,
  context: __SerdeContext
): NoncurrentVersionTransition => {
  let contents: any = {
    __type: "NoncurrentVersionTransition",
    NoncurrentDays: undefined,
    StorageClass: undefined
  };
  if (output["NoncurrentDays"] !== undefined) {
    contents.NoncurrentDays = parseInt(output["NoncurrentDays"]);
  }
  if (output["StorageClass"] !== undefined) {
    contents.StorageClass = output["StorageClass"];
  }
  return contents;
};

const deserializeAws_restXmlNoncurrentVersionTransitionList = (
  output: any,
  context: __SerdeContext
): Array<NoncurrentVersionTransition> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_restXmlNoncurrentVersionTransition(entry, context)
    );
  });
  return contents;
};

const deserializeAws_restXmlNotificationConfigurationFilter = (
  output: any,
  context: __SerdeContext
): NotificationConfigurationFilter => {
  let contents: any = {
    __type: "NotificationConfigurationFilter",
    Key: undefined
  };
  if (output["S3Key"] !== undefined) {
    contents.Key = deserializeAws_restXmlS3KeyFilter(output["S3Key"], context);
  }
  return contents;
};

const deserializeAws_restXml_Object = (
  output: any,
  context: __SerdeContext
): _Object => {
  let contents: any = {
    __type: "Object",
    ETag: undefined,
    Key: undefined,
    LastModified: undefined,
    Owner: undefined,
    Size: undefined,
    StorageClass: undefined
  };
  if (output["ETag"] !== undefined) {
    contents.ETag = output["ETag"];
  }
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["LastModified"] !== undefined) {
    contents.LastModified = new Date(output["LastModified"]);
  }
  if (output["Owner"] !== undefined) {
    contents.Owner = deserializeAws_restXmlOwner(output["Owner"], context);
  }
  if (output["Size"] !== undefined) {
    contents.Size = parseInt(output["Size"]);
  }
  if (output["StorageClass"] !== undefined) {
    contents.StorageClass = output["StorageClass"];
  }
  return contents;
};

const deserializeAws_restXmlObjectList = (
  output: any,
  context: __SerdeContext
): Array<_Object> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXml_Object(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlObjectLockConfiguration = (
  output: any,
  context: __SerdeContext
): ObjectLockConfiguration => {
  let contents: any = {
    __type: "ObjectLockConfiguration",
    ObjectLockEnabled: undefined,
    Rule: undefined
  };
  if (output["ObjectLockEnabled"] !== undefined) {
    contents.ObjectLockEnabled = output["ObjectLockEnabled"];
  }
  if (output["Rule"] !== undefined) {
    contents.Rule = deserializeAws_restXmlObjectLockRule(
      output["Rule"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlObjectLockLegalHold = (
  output: any,
  context: __SerdeContext
): ObjectLockLegalHold => {
  let contents: any = {
    __type: "ObjectLockLegalHold",
    Status: undefined
  };
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlObjectLockRetention = (
  output: any,
  context: __SerdeContext
): ObjectLockRetention => {
  let contents: any = {
    __type: "ObjectLockRetention",
    Mode: undefined,
    RetainUntilDate: undefined
  };
  if (output["Mode"] !== undefined) {
    contents.Mode = output["Mode"];
  }
  if (output["RetainUntilDate"] !== undefined) {
    contents.RetainUntilDate = new Date(output["RetainUntilDate"]);
  }
  return contents;
};

const deserializeAws_restXmlObjectLockRule = (
  output: any,
  context: __SerdeContext
): ObjectLockRule => {
  let contents: any = {
    __type: "ObjectLockRule",
    DefaultRetention: undefined
  };
  if (output["DefaultRetention"] !== undefined) {
    contents.DefaultRetention = deserializeAws_restXmlDefaultRetention(
      output["DefaultRetention"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlObjectVersion = (
  output: any,
  context: __SerdeContext
): ObjectVersion => {
  let contents: any = {
    __type: "ObjectVersion",
    ETag: undefined,
    IsLatest: undefined,
    Key: undefined,
    LastModified: undefined,
    Owner: undefined,
    Size: undefined,
    StorageClass: undefined,
    VersionId: undefined
  };
  if (output["ETag"] !== undefined) {
    contents.ETag = output["ETag"];
  }
  if (output["IsLatest"] !== undefined) {
    contents.IsLatest = output["IsLatest"] == "true";
  }
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["LastModified"] !== undefined) {
    contents.LastModified = new Date(output["LastModified"]);
  }
  if (output["Owner"] !== undefined) {
    contents.Owner = deserializeAws_restXmlOwner(output["Owner"], context);
  }
  if (output["Size"] !== undefined) {
    contents.Size = parseInt(output["Size"]);
  }
  if (output["StorageClass"] !== undefined) {
    contents.StorageClass = output["StorageClass"];
  }
  if (output["VersionId"] !== undefined) {
    contents.VersionId = output["VersionId"];
  }
  return contents;
};

const deserializeAws_restXmlObjectVersionList = (
  output: any,
  context: __SerdeContext
): Array<ObjectVersion> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlObjectVersion(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlOwner = (
  output: any,
  context: __SerdeContext
): Owner => {
  let contents: any = {
    __type: "Owner",
    DisplayName: undefined,
    ID: undefined
  };
  if (output["DisplayName"] !== undefined) {
    contents.DisplayName = output["DisplayName"];
  }
  if (output["ID"] !== undefined) {
    contents.ID = output["ID"];
  }
  return contents;
};

const deserializeAws_restXmlPart = (
  output: any,
  context: __SerdeContext
): Part => {
  let contents: any = {
    __type: "Part",
    ETag: undefined,
    LastModified: undefined,
    PartNumber: undefined,
    Size: undefined
  };
  if (output["ETag"] !== undefined) {
    contents.ETag = output["ETag"];
  }
  if (output["LastModified"] !== undefined) {
    contents.LastModified = new Date(output["LastModified"]);
  }
  if (output["PartNumber"] !== undefined) {
    contents.PartNumber = parseInt(output["PartNumber"]);
  }
  if (output["Size"] !== undefined) {
    contents.Size = parseInt(output["Size"]);
  }
  return contents;
};

const deserializeAws_restXmlParts = (
  output: any,
  context: __SerdeContext
): Array<Part> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlPart(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlPolicyStatus = (
  output: any,
  context: __SerdeContext
): PolicyStatus => {
  let contents: any = {
    __type: "PolicyStatus",
    IsPublic: undefined
  };
  if (output["IsPublic"] !== undefined) {
    contents.IsPublic = output["IsPublic"] == "true";
  }
  return contents;
};

const deserializeAws_restXmlPublicAccessBlockConfiguration = (
  output: any,
  context: __SerdeContext
): PublicAccessBlockConfiguration => {
  let contents: any = {
    __type: "PublicAccessBlockConfiguration",
    BlockPublicAcls: undefined,
    BlockPublicPolicy: undefined,
    IgnorePublicAcls: undefined,
    RestrictPublicBuckets: undefined
  };
  if (output["BlockPublicAcls"] !== undefined) {
    contents.BlockPublicAcls = output["BlockPublicAcls"] == "true";
  }
  if (output["BlockPublicPolicy"] !== undefined) {
    contents.BlockPublicPolicy = output["BlockPublicPolicy"] == "true";
  }
  if (output["IgnorePublicAcls"] !== undefined) {
    contents.IgnorePublicAcls = output["IgnorePublicAcls"] == "true";
  }
  if (output["RestrictPublicBuckets"] !== undefined) {
    contents.RestrictPublicBuckets = output["RestrictPublicBuckets"] == "true";
  }
  return contents;
};

const deserializeAws_restXmlQueueConfiguration = (
  output: any,
  context: __SerdeContext
): QueueConfiguration => {
  let contents: any = {
    __type: "QueueConfiguration",
    Events: undefined,
    Filter: undefined,
    Id: undefined,
    QueueArn: undefined
  };
  if (output.Event === "") {
    contents.Events = [];
  }
  if (output["Event"] !== undefined) {
    const wrappedItem =
      output["Event"] instanceof Array ? output["Event"] : [output["Event"]];
    contents.Events = deserializeAws_restXmlEventList(wrappedItem, context);
  }
  if (output["Filter"] !== undefined) {
    contents.Filter = deserializeAws_restXmlNotificationConfigurationFilter(
      output["Filter"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Queue"] !== undefined) {
    contents.QueueArn = output["Queue"];
  }
  return contents;
};

const deserializeAws_restXmlQueueConfigurationList = (
  output: any,
  context: __SerdeContext
): Array<QueueConfiguration> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlQueueConfiguration(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlRedirect = (
  output: any,
  context: __SerdeContext
): Redirect => {
  let contents: any = {
    __type: "Redirect",
    HostName: undefined,
    HttpRedirectCode: undefined,
    Protocol: undefined,
    ReplaceKeyPrefixWith: undefined,
    ReplaceKeyWith: undefined
  };
  if (output["HostName"] !== undefined) {
    contents.HostName = output["HostName"];
  }
  if (output["HttpRedirectCode"] !== undefined) {
    contents.HttpRedirectCode = output["HttpRedirectCode"];
  }
  if (output["Protocol"] !== undefined) {
    contents.Protocol = output["Protocol"];
  }
  if (output["ReplaceKeyPrefixWith"] !== undefined) {
    contents.ReplaceKeyPrefixWith = output["ReplaceKeyPrefixWith"];
  }
  if (output["ReplaceKeyWith"] !== undefined) {
    contents.ReplaceKeyWith = output["ReplaceKeyWith"];
  }
  return contents;
};

const deserializeAws_restXmlRedirectAllRequestsTo = (
  output: any,
  context: __SerdeContext
): RedirectAllRequestsTo => {
  let contents: any = {
    __type: "RedirectAllRequestsTo",
    HostName: undefined,
    Protocol: undefined
  };
  if (output["HostName"] !== undefined) {
    contents.HostName = output["HostName"];
  }
  if (output["Protocol"] !== undefined) {
    contents.Protocol = output["Protocol"];
  }
  return contents;
};

const deserializeAws_restXmlReplicationConfiguration = (
  output: any,
  context: __SerdeContext
): ReplicationConfiguration => {
  let contents: any = {
    __type: "ReplicationConfiguration",
    Role: undefined,
    Rules: undefined
  };
  if (output["Role"] !== undefined) {
    contents.Role = output["Role"];
  }
  if (output.Rule === "") {
    contents.Rules = [];
  }
  if (output["Rule"] !== undefined) {
    const wrappedItem =
      output["Rule"] instanceof Array ? output["Rule"] : [output["Rule"]];
    contents.Rules = deserializeAws_restXmlReplicationRules(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlReplicationRule = (
  output: any,
  context: __SerdeContext
): ReplicationRule => {
  let contents: any = {
    __type: "ReplicationRule",
    DeleteMarkerReplication: undefined,
    Destination: undefined,
    ExistingObjectReplication: undefined,
    Filter: undefined,
    ID: undefined,
    Prefix: undefined,
    Priority: undefined,
    SourceSelectionCriteria: undefined,
    Status: undefined
  };
  if (output["DeleteMarkerReplication"] !== undefined) {
    contents.DeleteMarkerReplication = deserializeAws_restXmlDeleteMarkerReplication(
      output["DeleteMarkerReplication"],
      context
    );
  }
  if (output["Destination"] !== undefined) {
    contents.Destination = deserializeAws_restXmlDestination(
      output["Destination"],
      context
    );
  }
  if (output["ExistingObjectReplication"] !== undefined) {
    contents.ExistingObjectReplication = deserializeAws_restXmlExistingObjectReplication(
      output["ExistingObjectReplication"],
      context
    );
  }
  if (output["Filter"] !== undefined) {
    contents.Filter = deserializeAws_restXmlReplicationRuleFilter(
      output["Filter"],
      context
    );
  }
  if (output["ID"] !== undefined) {
    contents.ID = output["ID"];
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  if (output["Priority"] !== undefined) {
    contents.Priority = parseInt(output["Priority"]);
  }
  if (output["SourceSelectionCriteria"] !== undefined) {
    contents.SourceSelectionCriteria = deserializeAws_restXmlSourceSelectionCriteria(
      output["SourceSelectionCriteria"],
      context
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlReplicationRuleAndOperator = (
  output: any,
  context: __SerdeContext
): ReplicationRuleAndOperator => {
  let contents: any = {
    __type: "ReplicationRuleAndOperator",
    Prefix: undefined,
    Tags: undefined
  };
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  if (output.Tag === "") {
    contents.Tags = [];
  }
  if (output["Tag"] !== undefined) {
    const wrappedItem =
      output["Tag"] instanceof Array ? output["Tag"] : [output["Tag"]];
    contents.Tags = deserializeAws_restXmlTagSet(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_restXmlReplicationRuleFilter = (
  output: any,
  context: __SerdeContext
): ReplicationRuleFilter => {
  let contents: any = {
    __type: "ReplicationRuleFilter",
    And: undefined,
    Prefix: undefined,
    Tag: undefined
  };
  if (output["And"] !== undefined) {
    contents.And = deserializeAws_restXmlReplicationRuleAndOperator(
      output["And"],
      context
    );
  }
  if (output["Prefix"] !== undefined) {
    contents.Prefix = output["Prefix"];
  }
  if (output["Tag"] !== undefined) {
    contents.Tag = deserializeAws_restXmlTag(output["Tag"], context);
  }
  return contents;
};

const deserializeAws_restXmlReplicationRules = (
  output: any,
  context: __SerdeContext
): Array<ReplicationRule> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlReplicationRule(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlReplicationTime = (
  output: any,
  context: __SerdeContext
): ReplicationTime => {
  let contents: any = {
    __type: "ReplicationTime",
    Status: undefined,
    Time: undefined
  };
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["Time"] !== undefined) {
    contents.Time = deserializeAws_restXmlReplicationTimeValue(
      output["Time"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlReplicationTimeValue = (
  output: any,
  context: __SerdeContext
): ReplicationTimeValue => {
  let contents: any = {
    __type: "ReplicationTimeValue",
    Minutes: undefined
  };
  if (output["Minutes"] !== undefined) {
    contents.Minutes = parseInt(output["Minutes"]);
  }
  return contents;
};

const deserializeAws_restXmlRoutingRule = (
  output: any,
  context: __SerdeContext
): RoutingRule => {
  let contents: any = {
    __type: "RoutingRule",
    Condition: undefined,
    Redirect: undefined
  };
  if (output["Condition"] !== undefined) {
    contents.Condition = deserializeAws_restXmlCondition(
      output["Condition"],
      context
    );
  }
  if (output["Redirect"] !== undefined) {
    contents.Redirect = deserializeAws_restXmlRedirect(
      output["Redirect"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlRoutingRules = (
  output: any,
  context: __SerdeContext
): Array<RoutingRule> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlRoutingRule(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlS3KeyFilter = (
  output: any,
  context: __SerdeContext
): S3KeyFilter => {
  let contents: any = {
    __type: "S3KeyFilter",
    FilterRules: undefined
  };
  if (output.FilterRule === "") {
    contents.FilterRules = [];
  }
  if (output["FilterRule"] !== undefined) {
    const wrappedItem =
      output["FilterRule"] instanceof Array
        ? output["FilterRule"]
        : [output["FilterRule"]];
    contents.FilterRules = deserializeAws_restXmlFilterRuleList(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlSSEKMS = (
  output: any,
  context: __SerdeContext
): SSEKMS => {
  let contents: any = {
    __type: "SSEKMS",
    KeyId: undefined
  };
  if (output["KeyId"] !== undefined) {
    contents.KeyId = output["KeyId"];
  }
  return contents;
};

const deserializeAws_restXmlSSES3 = (
  output: any,
  context: __SerdeContext
): SSES3 => {
  let contents: any = {
    __type: "SSES3"
  };
  return contents;
};

const deserializeAws_restXmlServerSideEncryptionByDefault = (
  output: any,
  context: __SerdeContext
): ServerSideEncryptionByDefault => {
  let contents: any = {
    __type: "ServerSideEncryptionByDefault",
    KMSMasterKeyID: undefined,
    SSEAlgorithm: undefined
  };
  if (output["KMSMasterKeyID"] !== undefined) {
    contents.KMSMasterKeyID = output["KMSMasterKeyID"];
  }
  if (output["SSEAlgorithm"] !== undefined) {
    contents.SSEAlgorithm = output["SSEAlgorithm"];
  }
  return contents;
};

const deserializeAws_restXmlServerSideEncryptionConfiguration = (
  output: any,
  context: __SerdeContext
): ServerSideEncryptionConfiguration => {
  let contents: any = {
    __type: "ServerSideEncryptionConfiguration",
    Rules: undefined
  };
  if (output.Rule === "") {
    contents.Rules = [];
  }
  if (output["Rule"] !== undefined) {
    const wrappedItem =
      output["Rule"] instanceof Array ? output["Rule"] : [output["Rule"]];
    contents.Rules = deserializeAws_restXmlServerSideEncryptionRules(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlServerSideEncryptionRule = (
  output: any,
  context: __SerdeContext
): ServerSideEncryptionRule => {
  let contents: any = {
    __type: "ServerSideEncryptionRule",
    ApplyServerSideEncryptionByDefault: undefined
  };
  if (output["ApplyServerSideEncryptionByDefault"] !== undefined) {
    contents.ApplyServerSideEncryptionByDefault = deserializeAws_restXmlServerSideEncryptionByDefault(
      output["ApplyServerSideEncryptionByDefault"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlServerSideEncryptionRules = (
  output: any,
  context: __SerdeContext
): Array<ServerSideEncryptionRule> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_restXmlServerSideEncryptionRule(entry, context)
    );
  });
  return contents;
};

const deserializeAws_restXmlSourceSelectionCriteria = (
  output: any,
  context: __SerdeContext
): SourceSelectionCriteria => {
  let contents: any = {
    __type: "SourceSelectionCriteria",
    SseKmsEncryptedObjects: undefined
  };
  if (output["SseKmsEncryptedObjects"] !== undefined) {
    contents.SseKmsEncryptedObjects = deserializeAws_restXmlSseKmsEncryptedObjects(
      output["SseKmsEncryptedObjects"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlSseKmsEncryptedObjects = (
  output: any,
  context: __SerdeContext
): SseKmsEncryptedObjects => {
  let contents: any = {
    __type: "SseKmsEncryptedObjects",
    Status: undefined
  };
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlStorageClassAnalysis = (
  output: any,
  context: __SerdeContext
): StorageClassAnalysis => {
  let contents: any = {
    __type: "StorageClassAnalysis",
    DataExport: undefined
  };
  if (output["DataExport"] !== undefined) {
    contents.DataExport = deserializeAws_restXmlStorageClassAnalysisDataExport(
      output["DataExport"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlStorageClassAnalysisDataExport = (
  output: any,
  context: __SerdeContext
): StorageClassAnalysisDataExport => {
  let contents: any = {
    __type: "StorageClassAnalysisDataExport",
    Destination: undefined,
    OutputSchemaVersion: undefined
  };
  if (output["Destination"] !== undefined) {
    contents.Destination = deserializeAws_restXmlAnalyticsExportDestination(
      output["Destination"],
      context
    );
  }
  if (output["OutputSchemaVersion"] !== undefined) {
    contents.OutputSchemaVersion = output["OutputSchemaVersion"];
  }
  return contents;
};

const deserializeAws_restXmlTag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_restXmlTagSet = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlTag(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlTargetGrant = (
  output: any,
  context: __SerdeContext
): TargetGrant => {
  let contents: any = {
    __type: "TargetGrant",
    Grantee: undefined,
    Permission: undefined
  };
  if (output["Grantee"] !== undefined) {
    contents.Grantee = deserializeAws_restXmlGrantee(
      output["Grantee"],
      context
    );
  }
  if (output["Permission"] !== undefined) {
    contents.Permission = output["Permission"];
  }
  return contents;
};

const deserializeAws_restXmlTargetGrants = (
  output: any,
  context: __SerdeContext
): Array<TargetGrant> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlTargetGrant(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlTopicConfiguration = (
  output: any,
  context: __SerdeContext
): TopicConfiguration => {
  let contents: any = {
    __type: "TopicConfiguration",
    Events: undefined,
    Filter: undefined,
    Id: undefined,
    TopicArn: undefined
  };
  if (output.Event === "") {
    contents.Events = [];
  }
  if (output["Event"] !== undefined) {
    const wrappedItem =
      output["Event"] instanceof Array ? output["Event"] : [output["Event"]];
    contents.Events = deserializeAws_restXmlEventList(wrappedItem, context);
  }
  if (output["Filter"] !== undefined) {
    contents.Filter = deserializeAws_restXmlNotificationConfigurationFilter(
      output["Filter"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Topic"] !== undefined) {
    contents.TopicArn = output["Topic"];
  }
  return contents;
};

const deserializeAws_restXmlTopicConfigurationList = (
  output: any,
  context: __SerdeContext
): Array<TopicConfiguration> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlTopicConfiguration(entry, context));
  });
  return contents;
};

const deserializeAws_restXmlTransition = (
  output: any,
  context: __SerdeContext
): Transition => {
  let contents: any = {
    __type: "Transition",
    Date: undefined,
    Days: undefined,
    StorageClass: undefined
  };
  if (output["Date"] !== undefined) {
    contents.Date = new Date(output["Date"]);
  }
  if (output["Days"] !== undefined) {
    contents.Days = parseInt(output["Days"]);
  }
  if (output["StorageClass"] !== undefined) {
    contents.StorageClass = output["StorageClass"];
  }
  return contents;
};

const deserializeAws_restXmlTransitionList = (
  output: any,
  context: __SerdeContext
): Array<Transition> => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_restXmlTransition(entry, context));
  });
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const decodeEscapedXML = (str: string) => {
  return str
    .replace(/&amp;/g, "&")
    .replace(/&apos;/g, "'")
    .replace(/&quot;/g, '"')
    .replace(/&gt;/g, ">")
    .replace(/&lt;/g, "<");
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      const parsedObj = xmlParse(encoded, {
        attributeNamePrefix: "",
        ignoreAttributes: false,
        parseNodeValue: false,
        tagValueProcessor: (val, tagName) => decodeEscapedXML(val)
      });
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return parsedObjToReturn;
    }
    return {};
  });
};

const loadRestXmlErrorCode = (output: __HttpResponse, data: any): string => {
  if (data.Code !== undefined) {
    return data.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
  return "";
};
