import {
  AddRoleToDBClusterCommandInput,
  AddRoleToDBClusterCommandOutput
} from "../commands/AddRoleToDBClusterCommand";
import {
  AddRoleToDBInstanceCommandInput,
  AddRoleToDBInstanceCommandOutput
} from "../commands/AddRoleToDBInstanceCommand";
import {
  AddSourceIdentifierToSubscriptionCommandInput,
  AddSourceIdentifierToSubscriptionCommandOutput
} from "../commands/AddSourceIdentifierToSubscriptionCommand";
import {
  AddTagsToResourceCommandInput,
  AddTagsToResourceCommandOutput
} from "../commands/AddTagsToResourceCommand";
import {
  ApplyPendingMaintenanceActionCommandInput,
  ApplyPendingMaintenanceActionCommandOutput
} from "../commands/ApplyPendingMaintenanceActionCommand";
import {
  AuthorizeDBSecurityGroupIngressCommandInput,
  AuthorizeDBSecurityGroupIngressCommandOutput
} from "../commands/AuthorizeDBSecurityGroupIngressCommand";
import {
  BacktrackDBClusterCommandInput,
  BacktrackDBClusterCommandOutput
} from "../commands/BacktrackDBClusterCommand";
import {
  CopyDBClusterParameterGroupCommandInput,
  CopyDBClusterParameterGroupCommandOutput
} from "../commands/CopyDBClusterParameterGroupCommand";
import {
  CopyDBClusterSnapshotCommandInput,
  CopyDBClusterSnapshotCommandOutput
} from "../commands/CopyDBClusterSnapshotCommand";
import {
  CopyDBParameterGroupCommandInput,
  CopyDBParameterGroupCommandOutput
} from "../commands/CopyDBParameterGroupCommand";
import {
  CopyDBSnapshotCommandInput,
  CopyDBSnapshotCommandOutput
} from "../commands/CopyDBSnapshotCommand";
import {
  CopyOptionGroupCommandInput,
  CopyOptionGroupCommandOutput
} from "../commands/CopyOptionGroupCommand";
import {
  CreateCustomAvailabilityZoneCommandInput,
  CreateCustomAvailabilityZoneCommandOutput
} from "../commands/CreateCustomAvailabilityZoneCommand";
import {
  CreateDBClusterCommandInput,
  CreateDBClusterCommandOutput
} from "../commands/CreateDBClusterCommand";
import {
  CreateDBClusterEndpointCommandInput,
  CreateDBClusterEndpointCommandOutput
} from "../commands/CreateDBClusterEndpointCommand";
import {
  CreateDBClusterParameterGroupCommandInput,
  CreateDBClusterParameterGroupCommandOutput
} from "../commands/CreateDBClusterParameterGroupCommand";
import {
  CreateDBClusterSnapshotCommandInput,
  CreateDBClusterSnapshotCommandOutput
} from "../commands/CreateDBClusterSnapshotCommand";
import {
  CreateDBInstanceCommandInput,
  CreateDBInstanceCommandOutput
} from "../commands/CreateDBInstanceCommand";
import {
  CreateDBInstanceReadReplicaCommandInput,
  CreateDBInstanceReadReplicaCommandOutput
} from "../commands/CreateDBInstanceReadReplicaCommand";
import {
  CreateDBParameterGroupCommandInput,
  CreateDBParameterGroupCommandOutput
} from "../commands/CreateDBParameterGroupCommand";
import {
  CreateDBProxyCommandInput,
  CreateDBProxyCommandOutput
} from "../commands/CreateDBProxyCommand";
import {
  CreateDBSecurityGroupCommandInput,
  CreateDBSecurityGroupCommandOutput
} from "../commands/CreateDBSecurityGroupCommand";
import {
  CreateDBSnapshotCommandInput,
  CreateDBSnapshotCommandOutput
} from "../commands/CreateDBSnapshotCommand";
import {
  CreateDBSubnetGroupCommandInput,
  CreateDBSubnetGroupCommandOutput
} from "../commands/CreateDBSubnetGroupCommand";
import {
  CreateEventSubscriptionCommandInput,
  CreateEventSubscriptionCommandOutput
} from "../commands/CreateEventSubscriptionCommand";
import {
  CreateGlobalClusterCommandInput,
  CreateGlobalClusterCommandOutput
} from "../commands/CreateGlobalClusterCommand";
import {
  CreateOptionGroupCommandInput,
  CreateOptionGroupCommandOutput
} from "../commands/CreateOptionGroupCommand";
import {
  DeleteCustomAvailabilityZoneCommandInput,
  DeleteCustomAvailabilityZoneCommandOutput
} from "../commands/DeleteCustomAvailabilityZoneCommand";
import {
  DeleteDBClusterCommandInput,
  DeleteDBClusterCommandOutput
} from "../commands/DeleteDBClusterCommand";
import {
  DeleteDBClusterEndpointCommandInput,
  DeleteDBClusterEndpointCommandOutput
} from "../commands/DeleteDBClusterEndpointCommand";
import {
  DeleteDBClusterParameterGroupCommandInput,
  DeleteDBClusterParameterGroupCommandOutput
} from "../commands/DeleteDBClusterParameterGroupCommand";
import {
  DeleteDBClusterSnapshotCommandInput,
  DeleteDBClusterSnapshotCommandOutput
} from "../commands/DeleteDBClusterSnapshotCommand";
import {
  DeleteDBInstanceAutomatedBackupCommandInput,
  DeleteDBInstanceAutomatedBackupCommandOutput
} from "../commands/DeleteDBInstanceAutomatedBackupCommand";
import {
  DeleteDBInstanceCommandInput,
  DeleteDBInstanceCommandOutput
} from "../commands/DeleteDBInstanceCommand";
import {
  DeleteDBParameterGroupCommandInput,
  DeleteDBParameterGroupCommandOutput
} from "../commands/DeleteDBParameterGroupCommand";
import {
  DeleteDBProxyCommandInput,
  DeleteDBProxyCommandOutput
} from "../commands/DeleteDBProxyCommand";
import {
  DeleteDBSecurityGroupCommandInput,
  DeleteDBSecurityGroupCommandOutput
} from "../commands/DeleteDBSecurityGroupCommand";
import {
  DeleteDBSnapshotCommandInput,
  DeleteDBSnapshotCommandOutput
} from "../commands/DeleteDBSnapshotCommand";
import {
  DeleteDBSubnetGroupCommandInput,
  DeleteDBSubnetGroupCommandOutput
} from "../commands/DeleteDBSubnetGroupCommand";
import {
  DeleteEventSubscriptionCommandInput,
  DeleteEventSubscriptionCommandOutput
} from "../commands/DeleteEventSubscriptionCommand";
import {
  DeleteGlobalClusterCommandInput,
  DeleteGlobalClusterCommandOutput
} from "../commands/DeleteGlobalClusterCommand";
import {
  DeleteInstallationMediaCommandInput,
  DeleteInstallationMediaCommandOutput
} from "../commands/DeleteInstallationMediaCommand";
import {
  DeleteOptionGroupCommandInput,
  DeleteOptionGroupCommandOutput
} from "../commands/DeleteOptionGroupCommand";
import {
  DeregisterDBProxyTargetsCommandInput,
  DeregisterDBProxyTargetsCommandOutput
} from "../commands/DeregisterDBProxyTargetsCommand";
import {
  DescribeAccountAttributesCommandInput,
  DescribeAccountAttributesCommandOutput
} from "../commands/DescribeAccountAttributesCommand";
import {
  DescribeCertificatesCommandInput,
  DescribeCertificatesCommandOutput
} from "../commands/DescribeCertificatesCommand";
import {
  DescribeCustomAvailabilityZonesCommandInput,
  DescribeCustomAvailabilityZonesCommandOutput
} from "../commands/DescribeCustomAvailabilityZonesCommand";
import {
  DescribeDBClusterBacktracksCommandInput,
  DescribeDBClusterBacktracksCommandOutput
} from "../commands/DescribeDBClusterBacktracksCommand";
import {
  DescribeDBClusterEndpointsCommandInput,
  DescribeDBClusterEndpointsCommandOutput
} from "../commands/DescribeDBClusterEndpointsCommand";
import {
  DescribeDBClusterParameterGroupsCommandInput,
  DescribeDBClusterParameterGroupsCommandOutput
} from "../commands/DescribeDBClusterParameterGroupsCommand";
import {
  DescribeDBClusterParametersCommandInput,
  DescribeDBClusterParametersCommandOutput
} from "../commands/DescribeDBClusterParametersCommand";
import {
  DescribeDBClusterSnapshotAttributesCommandInput,
  DescribeDBClusterSnapshotAttributesCommandOutput
} from "../commands/DescribeDBClusterSnapshotAttributesCommand";
import {
  DescribeDBClusterSnapshotsCommandInput,
  DescribeDBClusterSnapshotsCommandOutput
} from "../commands/DescribeDBClusterSnapshotsCommand";
import {
  DescribeDBClustersCommandInput,
  DescribeDBClustersCommandOutput
} from "../commands/DescribeDBClustersCommand";
import {
  DescribeDBEngineVersionsCommandInput,
  DescribeDBEngineVersionsCommandOutput
} from "../commands/DescribeDBEngineVersionsCommand";
import {
  DescribeDBInstanceAutomatedBackupsCommandInput,
  DescribeDBInstanceAutomatedBackupsCommandOutput
} from "../commands/DescribeDBInstanceAutomatedBackupsCommand";
import {
  DescribeDBInstancesCommandInput,
  DescribeDBInstancesCommandOutput
} from "../commands/DescribeDBInstancesCommand";
import {
  DescribeDBLogFilesCommandInput,
  DescribeDBLogFilesCommandOutput
} from "../commands/DescribeDBLogFilesCommand";
import {
  DescribeDBParameterGroupsCommandInput,
  DescribeDBParameterGroupsCommandOutput
} from "../commands/DescribeDBParameterGroupsCommand";
import {
  DescribeDBParametersCommandInput,
  DescribeDBParametersCommandOutput
} from "../commands/DescribeDBParametersCommand";
import {
  DescribeDBProxiesCommandInput,
  DescribeDBProxiesCommandOutput
} from "../commands/DescribeDBProxiesCommand";
import {
  DescribeDBProxyTargetGroupsCommandInput,
  DescribeDBProxyTargetGroupsCommandOutput
} from "../commands/DescribeDBProxyTargetGroupsCommand";
import {
  DescribeDBProxyTargetsCommandInput,
  DescribeDBProxyTargetsCommandOutput
} from "../commands/DescribeDBProxyTargetsCommand";
import {
  DescribeDBSecurityGroupsCommandInput,
  DescribeDBSecurityGroupsCommandOutput
} from "../commands/DescribeDBSecurityGroupsCommand";
import {
  DescribeDBSnapshotAttributesCommandInput,
  DescribeDBSnapshotAttributesCommandOutput
} from "../commands/DescribeDBSnapshotAttributesCommand";
import {
  DescribeDBSnapshotsCommandInput,
  DescribeDBSnapshotsCommandOutput
} from "../commands/DescribeDBSnapshotsCommand";
import {
  DescribeDBSubnetGroupsCommandInput,
  DescribeDBSubnetGroupsCommandOutput
} from "../commands/DescribeDBSubnetGroupsCommand";
import {
  DescribeEngineDefaultClusterParametersCommandInput,
  DescribeEngineDefaultClusterParametersCommandOutput
} from "../commands/DescribeEngineDefaultClusterParametersCommand";
import {
  DescribeEngineDefaultParametersCommandInput,
  DescribeEngineDefaultParametersCommandOutput
} from "../commands/DescribeEngineDefaultParametersCommand";
import {
  DescribeEventCategoriesCommandInput,
  DescribeEventCategoriesCommandOutput
} from "../commands/DescribeEventCategoriesCommand";
import {
  DescribeEventSubscriptionsCommandInput,
  DescribeEventSubscriptionsCommandOutput
} from "../commands/DescribeEventSubscriptionsCommand";
import {
  DescribeEventsCommandInput,
  DescribeEventsCommandOutput
} from "../commands/DescribeEventsCommand";
import {
  DescribeGlobalClustersCommandInput,
  DescribeGlobalClustersCommandOutput
} from "../commands/DescribeGlobalClustersCommand";
import {
  DescribeInstallationMediaCommandInput,
  DescribeInstallationMediaCommandOutput
} from "../commands/DescribeInstallationMediaCommand";
import {
  DescribeOptionGroupOptionsCommandInput,
  DescribeOptionGroupOptionsCommandOutput
} from "../commands/DescribeOptionGroupOptionsCommand";
import {
  DescribeOptionGroupsCommandInput,
  DescribeOptionGroupsCommandOutput
} from "../commands/DescribeOptionGroupsCommand";
import {
  DescribeOrderableDBInstanceOptionsCommandInput,
  DescribeOrderableDBInstanceOptionsCommandOutput
} from "../commands/DescribeOrderableDBInstanceOptionsCommand";
import {
  DescribePendingMaintenanceActionsCommandInput,
  DescribePendingMaintenanceActionsCommandOutput
} from "../commands/DescribePendingMaintenanceActionsCommand";
import {
  DescribeReservedDBInstancesCommandInput,
  DescribeReservedDBInstancesCommandOutput
} from "../commands/DescribeReservedDBInstancesCommand";
import {
  DescribeReservedDBInstancesOfferingsCommandInput,
  DescribeReservedDBInstancesOfferingsCommandOutput
} from "../commands/DescribeReservedDBInstancesOfferingsCommand";
import {
  DescribeSourceRegionsCommandInput,
  DescribeSourceRegionsCommandOutput
} from "../commands/DescribeSourceRegionsCommand";
import {
  DescribeValidDBInstanceModificationsCommandInput,
  DescribeValidDBInstanceModificationsCommandOutput
} from "../commands/DescribeValidDBInstanceModificationsCommand";
import {
  DownloadDBLogFilePortionCommandInput,
  DownloadDBLogFilePortionCommandOutput
} from "../commands/DownloadDBLogFilePortionCommand";
import {
  FailoverDBClusterCommandInput,
  FailoverDBClusterCommandOutput
} from "../commands/FailoverDBClusterCommand";
import {
  ImportInstallationMediaCommandInput,
  ImportInstallationMediaCommandOutput
} from "../commands/ImportInstallationMediaCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ModifyCertificatesCommandInput,
  ModifyCertificatesCommandOutput
} from "../commands/ModifyCertificatesCommand";
import {
  ModifyCurrentDBClusterCapacityCommandInput,
  ModifyCurrentDBClusterCapacityCommandOutput
} from "../commands/ModifyCurrentDBClusterCapacityCommand";
import {
  ModifyDBClusterCommandInput,
  ModifyDBClusterCommandOutput
} from "../commands/ModifyDBClusterCommand";
import {
  ModifyDBClusterEndpointCommandInput,
  ModifyDBClusterEndpointCommandOutput
} from "../commands/ModifyDBClusterEndpointCommand";
import {
  ModifyDBClusterParameterGroupCommandInput,
  ModifyDBClusterParameterGroupCommandOutput
} from "../commands/ModifyDBClusterParameterGroupCommand";
import {
  ModifyDBClusterSnapshotAttributeCommandInput,
  ModifyDBClusterSnapshotAttributeCommandOutput
} from "../commands/ModifyDBClusterSnapshotAttributeCommand";
import {
  ModifyDBInstanceCommandInput,
  ModifyDBInstanceCommandOutput
} from "../commands/ModifyDBInstanceCommand";
import {
  ModifyDBParameterGroupCommandInput,
  ModifyDBParameterGroupCommandOutput
} from "../commands/ModifyDBParameterGroupCommand";
import {
  ModifyDBProxyCommandInput,
  ModifyDBProxyCommandOutput
} from "../commands/ModifyDBProxyCommand";
import {
  ModifyDBProxyTargetGroupCommandInput,
  ModifyDBProxyTargetGroupCommandOutput
} from "../commands/ModifyDBProxyTargetGroupCommand";
import {
  ModifyDBSnapshotAttributeCommandInput,
  ModifyDBSnapshotAttributeCommandOutput
} from "../commands/ModifyDBSnapshotAttributeCommand";
import {
  ModifyDBSnapshotCommandInput,
  ModifyDBSnapshotCommandOutput
} from "../commands/ModifyDBSnapshotCommand";
import {
  ModifyDBSubnetGroupCommandInput,
  ModifyDBSubnetGroupCommandOutput
} from "../commands/ModifyDBSubnetGroupCommand";
import {
  ModifyEventSubscriptionCommandInput,
  ModifyEventSubscriptionCommandOutput
} from "../commands/ModifyEventSubscriptionCommand";
import {
  ModifyGlobalClusterCommandInput,
  ModifyGlobalClusterCommandOutput
} from "../commands/ModifyGlobalClusterCommand";
import {
  ModifyOptionGroupCommandInput,
  ModifyOptionGroupCommandOutput
} from "../commands/ModifyOptionGroupCommand";
import {
  PromoteReadReplicaCommandInput,
  PromoteReadReplicaCommandOutput
} from "../commands/PromoteReadReplicaCommand";
import {
  PromoteReadReplicaDBClusterCommandInput,
  PromoteReadReplicaDBClusterCommandOutput
} from "../commands/PromoteReadReplicaDBClusterCommand";
import {
  PurchaseReservedDBInstancesOfferingCommandInput,
  PurchaseReservedDBInstancesOfferingCommandOutput
} from "../commands/PurchaseReservedDBInstancesOfferingCommand";
import {
  RebootDBInstanceCommandInput,
  RebootDBInstanceCommandOutput
} from "../commands/RebootDBInstanceCommand";
import {
  RegisterDBProxyTargetsCommandInput,
  RegisterDBProxyTargetsCommandOutput
} from "../commands/RegisterDBProxyTargetsCommand";
import {
  RemoveFromGlobalClusterCommandInput,
  RemoveFromGlobalClusterCommandOutput
} from "../commands/RemoveFromGlobalClusterCommand";
import {
  RemoveRoleFromDBClusterCommandInput,
  RemoveRoleFromDBClusterCommandOutput
} from "../commands/RemoveRoleFromDBClusterCommand";
import {
  RemoveRoleFromDBInstanceCommandInput,
  RemoveRoleFromDBInstanceCommandOutput
} from "../commands/RemoveRoleFromDBInstanceCommand";
import {
  RemoveSourceIdentifierFromSubscriptionCommandInput,
  RemoveSourceIdentifierFromSubscriptionCommandOutput
} from "../commands/RemoveSourceIdentifierFromSubscriptionCommand";
import {
  RemoveTagsFromResourceCommandInput,
  RemoveTagsFromResourceCommandOutput
} from "../commands/RemoveTagsFromResourceCommand";
import {
  ResetDBClusterParameterGroupCommandInput,
  ResetDBClusterParameterGroupCommandOutput
} from "../commands/ResetDBClusterParameterGroupCommand";
import {
  ResetDBParameterGroupCommandInput,
  ResetDBParameterGroupCommandOutput
} from "../commands/ResetDBParameterGroupCommand";
import {
  RestoreDBClusterFromS3CommandInput,
  RestoreDBClusterFromS3CommandOutput
} from "../commands/RestoreDBClusterFromS3Command";
import {
  RestoreDBClusterFromSnapshotCommandInput,
  RestoreDBClusterFromSnapshotCommandOutput
} from "../commands/RestoreDBClusterFromSnapshotCommand";
import {
  RestoreDBClusterToPointInTimeCommandInput,
  RestoreDBClusterToPointInTimeCommandOutput
} from "../commands/RestoreDBClusterToPointInTimeCommand";
import {
  RestoreDBInstanceFromDBSnapshotCommandInput,
  RestoreDBInstanceFromDBSnapshotCommandOutput
} from "../commands/RestoreDBInstanceFromDBSnapshotCommand";
import {
  RestoreDBInstanceFromS3CommandInput,
  RestoreDBInstanceFromS3CommandOutput
} from "../commands/RestoreDBInstanceFromS3Command";
import {
  RestoreDBInstanceToPointInTimeCommandInput,
  RestoreDBInstanceToPointInTimeCommandOutput
} from "../commands/RestoreDBInstanceToPointInTimeCommand";
import {
  RevokeDBSecurityGroupIngressCommandInput,
  RevokeDBSecurityGroupIngressCommandOutput
} from "../commands/RevokeDBSecurityGroupIngressCommand";
import {
  StartActivityStreamCommandInput,
  StartActivityStreamCommandOutput
} from "../commands/StartActivityStreamCommand";
import {
  StartDBClusterCommandInput,
  StartDBClusterCommandOutput
} from "../commands/StartDBClusterCommand";
import {
  StartDBInstanceCommandInput,
  StartDBInstanceCommandOutput
} from "../commands/StartDBInstanceCommand";
import {
  StopActivityStreamCommandInput,
  StopActivityStreamCommandOutput
} from "../commands/StopActivityStreamCommand";
import {
  StopDBClusterCommandInput,
  StopDBClusterCommandOutput
} from "../commands/StopDBClusterCommand";
import {
  StopDBInstanceCommandInput,
  StopDBInstanceCommandOutput
} from "../commands/StopDBInstanceCommand";
import {
  AccountAttributesMessage,
  AccountQuota,
  AddRoleToDBClusterMessage,
  AddRoleToDBInstanceMessage,
  AddSourceIdentifierToSubscriptionMessage,
  AddSourceIdentifierToSubscriptionResult,
  AddTagsToResourceMessage,
  ApplyPendingMaintenanceActionMessage,
  ApplyPendingMaintenanceActionResult,
  AuthorizationAlreadyExistsFault,
  AuthorizationNotFoundFault,
  AuthorizationQuotaExceededFault,
  AuthorizeDBSecurityGroupIngressMessage,
  AuthorizeDBSecurityGroupIngressResult,
  AvailabilityZone,
  AvailableProcessorFeature,
  BacktrackDBClusterMessage,
  BackupPolicyNotFoundFault,
  Certificate,
  CertificateMessage,
  CertificateNotFoundFault,
  CharacterSet,
  CloudwatchLogsExportConfiguration,
  ConnectionPoolConfiguration,
  ConnectionPoolConfigurationInfo,
  CopyDBClusterParameterGroupMessage,
  CopyDBClusterParameterGroupResult,
  CopyDBClusterSnapshotMessage,
  CopyDBClusterSnapshotResult,
  CopyDBParameterGroupMessage,
  CopyDBParameterGroupResult,
  CopyDBSnapshotMessage,
  CopyDBSnapshotResult,
  CopyOptionGroupMessage,
  CopyOptionGroupResult,
  CreateCustomAvailabilityZoneMessage,
  CreateCustomAvailabilityZoneResult,
  CreateDBClusterEndpointMessage,
  CreateDBClusterMessage,
  CreateDBClusterParameterGroupMessage,
  CreateDBClusterParameterGroupResult,
  CreateDBClusterResult,
  CreateDBClusterSnapshotMessage,
  CreateDBClusterSnapshotResult,
  CreateDBInstanceMessage,
  CreateDBInstanceReadReplicaMessage,
  CreateDBInstanceReadReplicaResult,
  CreateDBInstanceResult,
  CreateDBParameterGroupMessage,
  CreateDBParameterGroupResult,
  CreateDBProxyRequest,
  CreateDBProxyResponse,
  CreateDBSecurityGroupMessage,
  CreateDBSecurityGroupResult,
  CreateDBSnapshotMessage,
  CreateDBSnapshotResult,
  CreateDBSubnetGroupMessage,
  CreateDBSubnetGroupResult,
  CreateEventSubscriptionMessage,
  CreateEventSubscriptionResult,
  CreateGlobalClusterMessage,
  CreateGlobalClusterResult,
  CreateOptionGroupMessage,
  CreateOptionGroupResult,
  CustomAvailabilityZone,
  CustomAvailabilityZoneAlreadyExistsFault,
  CustomAvailabilityZoneMessage,
  CustomAvailabilityZoneNotFoundFault,
  CustomAvailabilityZoneQuotaExceededFault,
  DBCluster,
  DBClusterAlreadyExistsFault,
  DBClusterBacktrack,
  DBClusterBacktrackMessage,
  DBClusterBacktrackNotFoundFault,
  DBClusterCapacityInfo,
  DBClusterEndpoint,
  DBClusterEndpointAlreadyExistsFault,
  DBClusterEndpointMessage,
  DBClusterEndpointNotFoundFault,
  DBClusterEndpointQuotaExceededFault,
  DBClusterMember,
  DBClusterMessage,
  DBClusterNotFoundFault,
  DBClusterOptionGroupStatus,
  DBClusterParameterGroup,
  DBClusterParameterGroupDetails,
  DBClusterParameterGroupNameMessage,
  DBClusterParameterGroupNotFoundFault,
  DBClusterParameterGroupsMessage,
  DBClusterQuotaExceededFault,
  DBClusterRole,
  DBClusterRoleAlreadyExistsFault,
  DBClusterRoleNotFoundFault,
  DBClusterRoleQuotaExceededFault,
  DBClusterSnapshot,
  DBClusterSnapshotAlreadyExistsFault,
  DBClusterSnapshotAttribute,
  DBClusterSnapshotAttributesResult,
  DBClusterSnapshotMessage,
  DBClusterSnapshotNotFoundFault,
  DBEngineVersion,
  DBEngineVersionMessage,
  DBInstance,
  DBInstanceAlreadyExistsFault,
  DBInstanceAutomatedBackup,
  DBInstanceAutomatedBackupMessage,
  DBInstanceAutomatedBackupNotFoundFault,
  DBInstanceAutomatedBackupQuotaExceededFault,
  DBInstanceMessage,
  DBInstanceNotFoundFault,
  DBInstanceRole,
  DBInstanceRoleAlreadyExistsFault,
  DBInstanceRoleNotFoundFault,
  DBInstanceRoleQuotaExceededFault,
  DBInstanceStatusInfo,
  DBLogFileNotFoundFault,
  DBParameterGroup,
  DBParameterGroupAlreadyExistsFault,
  DBParameterGroupDetails,
  DBParameterGroupNameMessage,
  DBParameterGroupNotFoundFault,
  DBParameterGroupQuotaExceededFault,
  DBParameterGroupStatus,
  DBParameterGroupsMessage,
  DBProxy,
  DBProxyAlreadyExistsFault,
  DBProxyNotFoundFault,
  DBProxyQuotaExceededFault,
  DBProxyTarget,
  DBProxyTargetAlreadyRegisteredFault,
  DBProxyTargetGroup,
  DBProxyTargetGroupNotFoundFault,
  DBProxyTargetNotFoundFault,
  DBSecurityGroup,
  DBSecurityGroupAlreadyExistsFault,
  DBSecurityGroupMembership,
  DBSecurityGroupMessage,
  DBSecurityGroupNotFoundFault,
  DBSecurityGroupNotSupportedFault,
  DBSecurityGroupQuotaExceededFault,
  DBSnapshot,
  DBSnapshotAlreadyExistsFault,
  DBSnapshotAttribute,
  DBSnapshotAttributesResult,
  DBSnapshotMessage,
  DBSnapshotNotFoundFault,
  DBSubnetGroup,
  DBSubnetGroupAlreadyExistsFault,
  DBSubnetGroupDoesNotCoverEnoughAZs,
  DBSubnetGroupMessage,
  DBSubnetGroupNotAllowedFault,
  DBSubnetGroupNotFoundFault,
  DBSubnetGroupQuotaExceededFault,
  DBSubnetQuotaExceededFault,
  DBUpgradeDependencyFailureFault,
  DeleteCustomAvailabilityZoneMessage,
  DeleteCustomAvailabilityZoneResult,
  DeleteDBClusterEndpointMessage,
  DeleteDBClusterMessage,
  DeleteDBClusterParameterGroupMessage,
  DeleteDBClusterResult,
  DeleteDBClusterSnapshotMessage,
  DeleteDBClusterSnapshotResult,
  DeleteDBInstanceAutomatedBackupMessage,
  DeleteDBInstanceAutomatedBackupResult,
  DeleteDBInstanceMessage,
  DeleteDBInstanceResult,
  DeleteDBParameterGroupMessage,
  DeleteDBProxyRequest,
  DeleteDBProxyResponse,
  DeleteDBSecurityGroupMessage,
  DeleteDBSnapshotMessage,
  DeleteDBSnapshotResult,
  DeleteDBSubnetGroupMessage,
  DeleteEventSubscriptionMessage,
  DeleteEventSubscriptionResult,
  DeleteGlobalClusterMessage,
  DeleteGlobalClusterResult,
  DeleteInstallationMediaMessage,
  DeleteOptionGroupMessage,
  DeregisterDBProxyTargetsRequest,
  DeregisterDBProxyTargetsResponse,
  DescribeAccountAttributesMessage,
  DescribeCertificatesMessage,
  DescribeCustomAvailabilityZonesMessage,
  DescribeDBClusterBacktracksMessage,
  DescribeDBClusterEndpointsMessage,
  DescribeDBClusterParameterGroupsMessage,
  DescribeDBClusterParametersMessage,
  DescribeDBClusterSnapshotAttributesMessage,
  DescribeDBClusterSnapshotAttributesResult,
  DescribeDBClusterSnapshotsMessage,
  DescribeDBClustersMessage,
  DescribeDBEngineVersionsMessage,
  DescribeDBInstanceAutomatedBackupsMessage,
  DescribeDBInstancesMessage,
  DescribeDBLogFilesDetails,
  DescribeDBLogFilesMessage,
  DescribeDBLogFilesResponse,
  DescribeDBParameterGroupsMessage,
  DescribeDBParametersMessage,
  DescribeDBProxiesRequest,
  DescribeDBProxiesResponse,
  DescribeDBProxyTargetGroupsRequest,
  DescribeDBProxyTargetGroupsResponse,
  DescribeDBProxyTargetsRequest,
  DescribeDBProxyTargetsResponse,
  DescribeDBSecurityGroupsMessage,
  DescribeDBSnapshotAttributesMessage,
  DescribeDBSnapshotAttributesResult,
  DescribeDBSnapshotsMessage,
  DescribeDBSubnetGroupsMessage,
  DescribeEngineDefaultClusterParametersMessage,
  DescribeEngineDefaultClusterParametersResult,
  DescribeEngineDefaultParametersMessage,
  DescribeEngineDefaultParametersResult,
  DescribeEventCategoriesMessage,
  DescribeEventSubscriptionsMessage,
  DescribeEventsMessage,
  DescribeGlobalClustersMessage,
  DescribeInstallationMediaMessage,
  DescribeOptionGroupOptionsMessage,
  DescribeOptionGroupsMessage,
  DescribeOrderableDBInstanceOptionsMessage,
  DescribePendingMaintenanceActionsMessage,
  DescribeReservedDBInstancesMessage,
  DescribeReservedDBInstancesOfferingsMessage,
  DescribeSourceRegionsMessage,
  DescribeValidDBInstanceModificationsMessage,
  DescribeValidDBInstanceModificationsResult,
  DomainMembership,
  DomainNotFoundFault,
  DoubleRange,
  DownloadDBLogFilePortionDetails,
  DownloadDBLogFilePortionMessage,
  EC2SecurityGroup,
  Endpoint,
  EngineDefaults,
  Event,
  EventCategoriesMap,
  EventCategoriesMessage,
  EventSubscription,
  EventSubscriptionQuotaExceededFault,
  EventSubscriptionsMessage,
  EventsMessage,
  FailoverDBClusterMessage,
  FailoverDBClusterResult,
  Filter,
  GlobalCluster,
  GlobalClusterAlreadyExistsFault,
  GlobalClusterMember,
  GlobalClusterNotFoundFault,
  GlobalClusterQuotaExceededFault,
  GlobalClustersMessage,
  IPRange,
  ImportInstallationMediaMessage,
  InstallationMedia,
  InstallationMediaAlreadyExistsFault,
  InstallationMediaFailureCause,
  InstallationMediaMessage,
  InstallationMediaNotFoundFault,
  InstanceQuotaExceededFault,
  InsufficientDBClusterCapacityFault,
  InsufficientDBInstanceCapacityFault,
  InsufficientStorageClusterCapacityFault,
  InvalidDBClusterCapacityFault,
  InvalidDBClusterEndpointStateFault,
  InvalidDBClusterSnapshotStateFault,
  InvalidDBClusterStateFault,
  InvalidDBInstanceAutomatedBackupStateFault,
  InvalidDBInstanceStateFault,
  InvalidDBParameterGroupStateFault,
  InvalidDBProxyStateFault,
  InvalidDBSecurityGroupStateFault,
  InvalidDBSnapshotStateFault,
  InvalidDBSubnetGroupFault,
  InvalidDBSubnetGroupStateFault,
  InvalidDBSubnetStateFault,
  InvalidEventSubscriptionStateFault,
  InvalidGlobalClusterStateFault,
  InvalidOptionGroupStateFault,
  InvalidRestoreFault,
  InvalidS3BucketFault,
  InvalidSubnet,
  InvalidVPCNetworkStateFault,
  KMSKeyNotAccessibleFault,
  ListTagsForResourceMessage,
  MinimumEngineVersionPerAllowedValue,
  ModifyCertificatesMessage,
  ModifyCertificatesResult,
  ModifyCurrentDBClusterCapacityMessage,
  ModifyDBClusterEndpointMessage,
  ModifyDBClusterMessage,
  ModifyDBClusterParameterGroupMessage,
  ModifyDBClusterResult,
  ModifyDBClusterSnapshotAttributeMessage,
  ModifyDBClusterSnapshotAttributeResult,
  ModifyDBInstanceMessage,
  ModifyDBInstanceResult,
  ModifyDBParameterGroupMessage,
  ModifyDBProxyRequest,
  ModifyDBProxyResponse,
  ModifyDBProxyTargetGroupRequest,
  ModifyDBProxyTargetGroupResponse,
  ModifyDBSnapshotAttributeMessage,
  ModifyDBSnapshotAttributeResult,
  ModifyDBSnapshotMessage,
  ModifyDBSnapshotResult,
  ModifyDBSubnetGroupMessage,
  ModifyDBSubnetGroupResult,
  ModifyEventSubscriptionMessage,
  ModifyEventSubscriptionResult,
  ModifyGlobalClusterMessage,
  ModifyGlobalClusterResult,
  ModifyOptionGroupMessage,
  ModifyOptionGroupResult,
  Option,
  OptionConfiguration,
  OptionGroup,
  OptionGroupAlreadyExistsFault,
  OptionGroupMembership,
  OptionGroupNotFoundFault,
  OptionGroupOption,
  OptionGroupOptionSetting,
  OptionGroupOptionsMessage,
  OptionGroupQuotaExceededFault,
  OptionGroups,
  OptionSetting,
  OptionVersion,
  OrderableDBInstanceOption,
  OrderableDBInstanceOptionsMessage,
  Parameter,
  PendingCloudwatchLogsExports,
  PendingMaintenanceAction,
  PendingMaintenanceActionsMessage,
  PendingModifiedValues,
  PointInTimeRestoreNotEnabledFault,
  ProcessorFeature,
  PromoteReadReplicaDBClusterMessage,
  PromoteReadReplicaDBClusterResult,
  PromoteReadReplicaMessage,
  PromoteReadReplicaResult,
  ProvisionedIopsNotAvailableInAZFault,
  PurchaseReservedDBInstancesOfferingMessage,
  PurchaseReservedDBInstancesOfferingResult,
  Range,
  RebootDBInstanceMessage,
  RebootDBInstanceResult,
  RecurringCharge,
  RegisterDBProxyTargetsRequest,
  RegisterDBProxyTargetsResponse,
  RemoveFromGlobalClusterMessage,
  RemoveFromGlobalClusterResult,
  RemoveRoleFromDBClusterMessage,
  RemoveRoleFromDBInstanceMessage,
  RemoveSourceIdentifierFromSubscriptionMessage,
  RemoveSourceIdentifierFromSubscriptionResult,
  RemoveTagsFromResourceMessage,
  ReservedDBInstance,
  ReservedDBInstanceAlreadyExistsFault,
  ReservedDBInstanceMessage,
  ReservedDBInstanceNotFoundFault,
  ReservedDBInstanceQuotaExceededFault,
  ReservedDBInstancesOffering,
  ReservedDBInstancesOfferingMessage,
  ReservedDBInstancesOfferingNotFoundFault,
  ResetDBClusterParameterGroupMessage,
  ResetDBParameterGroupMessage,
  ResourceNotFoundFault,
  ResourcePendingMaintenanceActions,
  RestoreDBClusterFromS3Message,
  RestoreDBClusterFromS3Result,
  RestoreDBClusterFromSnapshotMessage,
  RestoreDBClusterFromSnapshotResult,
  RestoreDBClusterToPointInTimeMessage,
  RestoreDBClusterToPointInTimeResult,
  RestoreDBInstanceFromDBSnapshotMessage,
  RestoreDBInstanceFromDBSnapshotResult,
  RestoreDBInstanceFromS3Message,
  RestoreDBInstanceFromS3Result,
  RestoreDBInstanceToPointInTimeMessage,
  RestoreDBInstanceToPointInTimeResult,
  RestoreWindow,
  RevokeDBSecurityGroupIngressMessage,
  RevokeDBSecurityGroupIngressResult,
  SNSInvalidTopicFault,
  SNSNoAuthorizationFault,
  SNSTopicArnNotFoundFault,
  ScalingConfiguration,
  ScalingConfigurationInfo,
  SharedSnapshotQuotaExceededFault,
  SnapshotQuotaExceededFault,
  SourceNotFoundFault,
  SourceRegion,
  SourceRegionMessage,
  StartActivityStreamRequest,
  StartActivityStreamResponse,
  StartDBClusterMessage,
  StartDBClusterResult,
  StartDBInstanceMessage,
  StartDBInstanceResult,
  StopActivityStreamRequest,
  StopActivityStreamResponse,
  StopDBClusterMessage,
  StopDBClusterResult,
  StopDBInstanceMessage,
  StopDBInstanceResult,
  StorageQuotaExceededFault,
  StorageTypeNotSupportedFault,
  Subnet,
  SubnetAlreadyInUse,
  SubscriptionAlreadyExistFault,
  SubscriptionCategoryNotFoundFault,
  SubscriptionNotFoundFault,
  Tag,
  TagListMessage,
  Timezone,
  UpgradeTarget,
  UserAuthConfig,
  UserAuthConfigInfo,
  ValidDBInstanceModificationsMessage,
  ValidStorageOptions,
  VpcSecurityGroupMembership,
  VpnDetails
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent,
  getArrayIfSingleItem as __getArrayIfSingleItem
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import { parse as xmlParse } from "fast-xml-parser";

export const serializeAws_queryAddRoleToDBClusterCommand = async (
  input: AddRoleToDBClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryAddRoleToDBClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "AddRoleToDBCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryAddRoleToDBInstanceCommand = async (
  input: AddRoleToDBInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryAddRoleToDBInstanceMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "AddRoleToDBInstance",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryAddSourceIdentifierToSubscriptionCommand = async (
  input: AddSourceIdentifierToSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryAddSourceIdentifierToSubscriptionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "AddSourceIdentifierToSubscription",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryAddTagsToResourceCommand = async (
  input: AddTagsToResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryAddTagsToResourceMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "AddTagsToResource",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryApplyPendingMaintenanceActionCommand = async (
  input: ApplyPendingMaintenanceActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryApplyPendingMaintenanceActionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ApplyPendingMaintenanceAction",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryAuthorizeDBSecurityGroupIngressCommand = async (
  input: AuthorizeDBSecurityGroupIngressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryAuthorizeDBSecurityGroupIngressMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "AuthorizeDBSecurityGroupIngress",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryBacktrackDBClusterCommand = async (
  input: BacktrackDBClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryBacktrackDBClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "BacktrackDBCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCopyDBClusterParameterGroupCommand = async (
  input: CopyDBClusterParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCopyDBClusterParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CopyDBClusterParameterGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCopyDBClusterSnapshotCommand = async (
  input: CopyDBClusterSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCopyDBClusterSnapshotMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CopyDBClusterSnapshot",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCopyDBParameterGroupCommand = async (
  input: CopyDBParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCopyDBParameterGroupMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CopyDBParameterGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCopyDBSnapshotCommand = async (
  input: CopyDBSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCopyDBSnapshotMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CopyDBSnapshot",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCopyOptionGroupCommand = async (
  input: CopyOptionGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCopyOptionGroupMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CopyOptionGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateCustomAvailabilityZoneCommand = async (
  input: CreateCustomAvailabilityZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateCustomAvailabilityZoneMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateCustomAvailabilityZone",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBClusterCommand = async (
  input: CreateDBClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBClusterEndpointCommand = async (
  input: CreateDBClusterEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBClusterEndpointMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBClusterEndpoint",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBClusterParameterGroupCommand = async (
  input: CreateDBClusterParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBClusterParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBClusterParameterGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBClusterSnapshotCommand = async (
  input: CreateDBClusterSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBClusterSnapshotMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBClusterSnapshot",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBInstanceCommand = async (
  input: CreateDBInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBInstanceMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBInstance",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBInstanceReadReplicaCommand = async (
  input: CreateDBInstanceReadReplicaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBInstanceReadReplicaMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBInstanceReadReplica",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBParameterGroupCommand = async (
  input: CreateDBParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBParameterGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBProxyCommand = async (
  input: CreateDBProxyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBProxyRequest(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBProxy",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBSecurityGroupCommand = async (
  input: CreateDBSecurityGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBSecurityGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBSecurityGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBSnapshotCommand = async (
  input: CreateDBSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBSnapshotMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBSnapshot",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateDBSubnetGroupCommand = async (
  input: CreateDBSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateDBSubnetGroupMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateDBSubnetGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateEventSubscriptionCommand = async (
  input: CreateEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateEventSubscriptionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateEventSubscription",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateGlobalClusterCommand = async (
  input: CreateGlobalClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateGlobalClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateGlobalCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryCreateOptionGroupCommand = async (
  input: CreateOptionGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryCreateOptionGroupMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "CreateOptionGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteCustomAvailabilityZoneCommand = async (
  input: DeleteCustomAvailabilityZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteCustomAvailabilityZoneMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteCustomAvailabilityZone",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBClusterCommand = async (
  input: DeleteDBClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBClusterEndpointCommand = async (
  input: DeleteDBClusterEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBClusterEndpointMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBClusterEndpoint",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBClusterParameterGroupCommand = async (
  input: DeleteDBClusterParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBClusterParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBClusterParameterGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBClusterSnapshotCommand = async (
  input: DeleteDBClusterSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBClusterSnapshotMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBClusterSnapshot",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBInstanceCommand = async (
  input: DeleteDBInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBInstanceMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBInstance",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBInstanceAutomatedBackupCommand = async (
  input: DeleteDBInstanceAutomatedBackupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBInstanceAutomatedBackupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBInstanceAutomatedBackup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBParameterGroupCommand = async (
  input: DeleteDBParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBParameterGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBProxyCommand = async (
  input: DeleteDBProxyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBProxyRequest(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBProxy",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBSecurityGroupCommand = async (
  input: DeleteDBSecurityGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBSecurityGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBSecurityGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBSnapshotCommand = async (
  input: DeleteDBSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBSnapshotMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBSnapshot",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteDBSubnetGroupCommand = async (
  input: DeleteDBSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteDBSubnetGroupMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteDBSubnetGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteEventSubscriptionCommand = async (
  input: DeleteEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteEventSubscriptionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteEventSubscription",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteGlobalClusterCommand = async (
  input: DeleteGlobalClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteGlobalClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteGlobalCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteInstallationMediaCommand = async (
  input: DeleteInstallationMediaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteInstallationMediaMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteInstallationMedia",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeleteOptionGroupCommand = async (
  input: DeleteOptionGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeleteOptionGroupMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeleteOptionGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDeregisterDBProxyTargetsCommand = async (
  input: DeregisterDBProxyTargetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDeregisterDBProxyTargetsRequest(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DeregisterDBProxyTargets",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeAccountAttributesCommand = async (
  input: DescribeAccountAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeAccountAttributesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeAccountAttributes",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeCertificatesCommand = async (
  input: DescribeCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeCertificatesMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeCertificates",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeCustomAvailabilityZonesCommand = async (
  input: DescribeCustomAvailabilityZonesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeCustomAvailabilityZonesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeCustomAvailabilityZones",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBClusterBacktracksCommand = async (
  input: DescribeDBClusterBacktracksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBClusterBacktracksMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBClusterBacktracks",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBClusterEndpointsCommand = async (
  input: DescribeDBClusterEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBClusterEndpointsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBClusterEndpoints",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBClusterParameterGroupsCommand = async (
  input: DescribeDBClusterParameterGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBClusterParameterGroupsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBClusterParameterGroups",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBClusterParametersCommand = async (
  input: DescribeDBClusterParametersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBClusterParametersMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBClusterParameters",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBClusterSnapshotAttributesCommand = async (
  input: DescribeDBClusterSnapshotAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBClusterSnapshotAttributesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBClusterSnapshotAttributes",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBClusterSnapshotsCommand = async (
  input: DescribeDBClusterSnapshotsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBClusterSnapshotsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBClusterSnapshots",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBClustersCommand = async (
  input: DescribeDBClustersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBClustersMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBClusters",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBEngineVersionsCommand = async (
  input: DescribeDBEngineVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBEngineVersionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBEngineVersions",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBInstanceAutomatedBackupsCommand = async (
  input: DescribeDBInstanceAutomatedBackupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBInstanceAutomatedBackupsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBInstanceAutomatedBackups",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBInstancesCommand = async (
  input: DescribeDBInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBInstancesMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBInstances",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBLogFilesCommand = async (
  input: DescribeDBLogFilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBLogFilesMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBLogFiles",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBParameterGroupsCommand = async (
  input: DescribeDBParameterGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBParameterGroupsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBParameterGroups",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBParametersCommand = async (
  input: DescribeDBParametersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBParametersMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBParameters",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBProxiesCommand = async (
  input: DescribeDBProxiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBProxiesRequest(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBProxies",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBProxyTargetGroupsCommand = async (
  input: DescribeDBProxyTargetGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBProxyTargetGroupsRequest(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBProxyTargetGroups",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBProxyTargetsCommand = async (
  input: DescribeDBProxyTargetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBProxyTargetsRequest(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBProxyTargets",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBSecurityGroupsCommand = async (
  input: DescribeDBSecurityGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBSecurityGroupsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBSecurityGroups",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBSnapshotAttributesCommand = async (
  input: DescribeDBSnapshotAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBSnapshotAttributesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBSnapshotAttributes",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBSnapshotsCommand = async (
  input: DescribeDBSnapshotsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBSnapshotsMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBSnapshots",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeDBSubnetGroupsCommand = async (
  input: DescribeDBSubnetGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeDBSubnetGroupsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeDBSubnetGroups",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeEngineDefaultClusterParametersCommand = async (
  input: DescribeEngineDefaultClusterParametersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeEngineDefaultClusterParametersMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeEngineDefaultClusterParameters",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeEngineDefaultParametersCommand = async (
  input: DescribeEngineDefaultParametersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeEngineDefaultParametersMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeEngineDefaultParameters",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeEventCategoriesCommand = async (
  input: DescribeEventCategoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeEventCategoriesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeEventCategories",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeEventSubscriptionsCommand = async (
  input: DescribeEventSubscriptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeEventSubscriptionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeEventSubscriptions",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeEventsCommand = async (
  input: DescribeEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeEventsMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeEvents",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeGlobalClustersCommand = async (
  input: DescribeGlobalClustersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeGlobalClustersMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeGlobalClusters",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeInstallationMediaCommand = async (
  input: DescribeInstallationMediaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeInstallationMediaMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeInstallationMedia",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeOptionGroupOptionsCommand = async (
  input: DescribeOptionGroupOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeOptionGroupOptionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeOptionGroupOptions",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeOptionGroupsCommand = async (
  input: DescribeOptionGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeOptionGroupsMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeOptionGroups",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeOrderableDBInstanceOptionsCommand = async (
  input: DescribeOrderableDBInstanceOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeOrderableDBInstanceOptionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeOrderableDBInstanceOptions",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribePendingMaintenanceActionsCommand = async (
  input: DescribePendingMaintenanceActionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribePendingMaintenanceActionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribePendingMaintenanceActions",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeReservedDBInstancesCommand = async (
  input: DescribeReservedDBInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeReservedDBInstancesMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeReservedDBInstances",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeReservedDBInstancesOfferingsCommand = async (
  input: DescribeReservedDBInstancesOfferingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeReservedDBInstancesOfferingsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeReservedDBInstancesOfferings",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeSourceRegionsCommand = async (
  input: DescribeSourceRegionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeSourceRegionsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeSourceRegions",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDescribeValidDBInstanceModificationsCommand = async (
  input: DescribeValidDBInstanceModificationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDescribeValidDBInstanceModificationsMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DescribeValidDBInstanceModifications",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryDownloadDBLogFilePortionCommand = async (
  input: DownloadDBLogFilePortionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryDownloadDBLogFilePortionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "DownloadDBLogFilePortion",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryFailoverDBClusterCommand = async (
  input: FailoverDBClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryFailoverDBClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "FailoverDBCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryImportInstallationMediaCommand = async (
  input: ImportInstallationMediaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryImportInstallationMediaMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ImportInstallationMedia",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryListTagsForResourceCommand = async (
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryListTagsForResourceMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ListTagsForResource",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyCertificatesCommand = async (
  input: ModifyCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyCertificatesMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyCertificates",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyCurrentDBClusterCapacityCommand = async (
  input: ModifyCurrentDBClusterCapacityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyCurrentDBClusterCapacityMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyCurrentDBClusterCapacity",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBClusterCommand = async (
  input: ModifyDBClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBClusterEndpointCommand = async (
  input: ModifyDBClusterEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBClusterEndpointMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBClusterEndpoint",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBClusterParameterGroupCommand = async (
  input: ModifyDBClusterParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBClusterParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBClusterParameterGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBClusterSnapshotAttributeCommand = async (
  input: ModifyDBClusterSnapshotAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBClusterSnapshotAttributeMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBClusterSnapshotAttribute",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBInstanceCommand = async (
  input: ModifyDBInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBInstanceMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBInstance",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBParameterGroupCommand = async (
  input: ModifyDBParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBParameterGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBProxyCommand = async (
  input: ModifyDBProxyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBProxyRequest(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBProxy",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBProxyTargetGroupCommand = async (
  input: ModifyDBProxyTargetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBProxyTargetGroupRequest(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBProxyTargetGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBSnapshotCommand = async (
  input: ModifyDBSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBSnapshotMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBSnapshot",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBSnapshotAttributeCommand = async (
  input: ModifyDBSnapshotAttributeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBSnapshotAttributeMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBSnapshotAttribute",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyDBSubnetGroupCommand = async (
  input: ModifyDBSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyDBSubnetGroupMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyDBSubnetGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyEventSubscriptionCommand = async (
  input: ModifyEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyEventSubscriptionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyEventSubscription",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyGlobalClusterCommand = async (
  input: ModifyGlobalClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyGlobalClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyGlobalCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryModifyOptionGroupCommand = async (
  input: ModifyOptionGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryModifyOptionGroupMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ModifyOptionGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryPromoteReadReplicaCommand = async (
  input: PromoteReadReplicaCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryPromoteReadReplicaMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "PromoteReadReplica",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryPromoteReadReplicaDBClusterCommand = async (
  input: PromoteReadReplicaDBClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryPromoteReadReplicaDBClusterMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "PromoteReadReplicaDBCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryPurchaseReservedDBInstancesOfferingCommand = async (
  input: PurchaseReservedDBInstancesOfferingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryPurchaseReservedDBInstancesOfferingMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "PurchaseReservedDBInstancesOffering",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRebootDBInstanceCommand = async (
  input: RebootDBInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRebootDBInstanceMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RebootDBInstance",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRegisterDBProxyTargetsCommand = async (
  input: RegisterDBProxyTargetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRegisterDBProxyTargetsRequest(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RegisterDBProxyTargets",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRemoveFromGlobalClusterCommand = async (
  input: RemoveFromGlobalClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRemoveFromGlobalClusterMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RemoveFromGlobalCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRemoveRoleFromDBClusterCommand = async (
  input: RemoveRoleFromDBClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRemoveRoleFromDBClusterMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RemoveRoleFromDBCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRemoveRoleFromDBInstanceCommand = async (
  input: RemoveRoleFromDBInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRemoveRoleFromDBInstanceMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RemoveRoleFromDBInstance",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRemoveSourceIdentifierFromSubscriptionCommand = async (
  input: RemoveSourceIdentifierFromSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRemoveSourceIdentifierFromSubscriptionMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RemoveSourceIdentifierFromSubscription",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRemoveTagsFromResourceCommand = async (
  input: RemoveTagsFromResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRemoveTagsFromResourceMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RemoveTagsFromResource",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryResetDBClusterParameterGroupCommand = async (
  input: ResetDBClusterParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryResetDBClusterParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ResetDBClusterParameterGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryResetDBParameterGroupCommand = async (
  input: ResetDBParameterGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryResetDBParameterGroupMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "ResetDBParameterGroup",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRestoreDBClusterFromS3Command = async (
  input: RestoreDBClusterFromS3CommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRestoreDBClusterFromS3Message(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RestoreDBClusterFromS3",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRestoreDBClusterFromSnapshotCommand = async (
  input: RestoreDBClusterFromSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRestoreDBClusterFromSnapshotMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RestoreDBClusterFromSnapshot",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRestoreDBClusterToPointInTimeCommand = async (
  input: RestoreDBClusterToPointInTimeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRestoreDBClusterToPointInTimeMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RestoreDBClusterToPointInTime",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRestoreDBInstanceFromDBSnapshotCommand = async (
  input: RestoreDBInstanceFromDBSnapshotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRestoreDBInstanceFromDBSnapshotMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RestoreDBInstanceFromDBSnapshot",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRestoreDBInstanceFromS3Command = async (
  input: RestoreDBInstanceFromS3CommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRestoreDBInstanceFromS3Message(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RestoreDBInstanceFromS3",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRestoreDBInstanceToPointInTimeCommand = async (
  input: RestoreDBInstanceToPointInTimeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRestoreDBInstanceToPointInTimeMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RestoreDBInstanceToPointInTime",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryRevokeDBSecurityGroupIngressCommand = async (
  input: RevokeDBSecurityGroupIngressCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryRevokeDBSecurityGroupIngressMessage(
    input,
    context
  );
  body = buildFormUrlencodedString({
    ...entries,
    Action: "RevokeDBSecurityGroupIngress",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryStartActivityStreamCommand = async (
  input: StartActivityStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryStartActivityStreamRequest(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "StartActivityStream",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryStartDBClusterCommand = async (
  input: StartDBClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryStartDBClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "StartDBCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryStartDBInstanceCommand = async (
  input: StartDBInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryStartDBInstanceMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "StartDBInstance",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryStopActivityStreamCommand = async (
  input: StopActivityStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryStopActivityStreamRequest(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "StopActivityStream",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryStopDBClusterCommand = async (
  input: StopDBClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryStopDBClusterMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "StopDBCluster",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_queryStopDBInstanceCommand = async (
  input: StopDBInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-www-form-urlencoded";
  let body: any;
  const entries = serializeAws_queryStopDBInstanceMessage(input, context);
  body = buildFormUrlencodedString({
    ...entries,
    Action: "StopDBInstance",
    Version: "2014-10-31"
  });
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const deserializeAws_queryAddRoleToDBClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddRoleToDBClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryAddRoleToDBClusterCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: AddRoleToDBClusterCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryAddRoleToDBClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddRoleToDBClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterRoleAlreadyExistsFault":
    case "rds.admin#DBClusterRoleAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBClusterRoleAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterRoleQuotaExceededFault":
    case "rds.admin#DBClusterRoleQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBClusterRoleQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryAddRoleToDBInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddRoleToDBInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryAddRoleToDBInstanceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: AddRoleToDBInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryAddRoleToDBInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddRoleToDBInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceRoleAlreadyExistsFault":
    case "rds.admin#DBInstanceRoleAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBInstanceRoleAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceRoleQuotaExceededFault":
    case "rds.admin#DBInstanceRoleQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBInstanceRoleQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryAddSourceIdentifierToSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddSourceIdentifierToSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryAddSourceIdentifierToSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryAddSourceIdentifierToSubscriptionResult(
    data.AddSourceIdentifierToSubscriptionResult,
    context
  );
  const response: AddSourceIdentifierToSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AddSourceIdentifierToSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryAddSourceIdentifierToSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddSourceIdentifierToSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "SourceNotFoundFault":
    case "rds.admin#SourceNotFoundFault":
      response = {
        ...(await deserializeAws_querySourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubscriptionNotFoundFault":
    case "rds.admin#SubscriptionNotFoundFault":
      response = {
        ...(await deserializeAws_querySubscriptionNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryAddTagsToResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryAddTagsToResourceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: AddTagsToResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryAddTagsToResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryApplyPendingMaintenanceActionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApplyPendingMaintenanceActionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryApplyPendingMaintenanceActionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryApplyPendingMaintenanceActionResult(
    data.ApplyPendingMaintenanceActionResult,
    context
  );
  const response: ApplyPendingMaintenanceActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApplyPendingMaintenanceActionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryApplyPendingMaintenanceActionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApplyPendingMaintenanceActionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "rds.admin#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_queryResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryAuthorizeDBSecurityGroupIngressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeDBSecurityGroupIngressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryAuthorizeDBSecurityGroupIngressCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryAuthorizeDBSecurityGroupIngressResult(
    data.AuthorizeDBSecurityGroupIngressResult,
    context
  );
  const response: AuthorizeDBSecurityGroupIngressCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AuthorizeDBSecurityGroupIngressResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryAuthorizeDBSecurityGroupIngressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AuthorizeDBSecurityGroupIngressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationAlreadyExistsFault":
    case "rds.admin#AuthorizationAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryAuthorizationAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AuthorizationQuotaExceededFault":
    case "rds.admin#AuthorizationQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryAuthorizationQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSecurityGroupNotFoundFault":
    case "rds.admin#DBSecurityGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSecurityGroupStateFault":
    case "rds.admin#InvalidDBSecurityGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSecurityGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryBacktrackDBClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BacktrackDBClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryBacktrackDBClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterBacktrack(
    data.BacktrackDBClusterResult,
    context
  );
  const response: BacktrackDBClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterBacktrack",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryBacktrackDBClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BacktrackDBClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCopyDBClusterParameterGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyDBClusterParameterGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCopyDBClusterParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCopyDBClusterParameterGroupResult(
    data.CopyDBClusterParameterGroupResult,
    context
  );
  const response: CopyDBClusterParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CopyDBClusterParameterGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCopyDBClusterParameterGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyDBClusterParameterGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupAlreadyExistsFault":
    case "rds.admin#DBParameterGroupAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupQuotaExceededFault":
    case "rds.admin#DBParameterGroupQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCopyDBClusterSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyDBClusterSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCopyDBClusterSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCopyDBClusterSnapshotResult(
    data.CopyDBClusterSnapshotResult,
    context
  );
  const response: CopyDBClusterSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CopyDBClusterSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCopyDBClusterSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyDBClusterSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterSnapshotAlreadyExistsFault":
    case "rds.admin#DBClusterSnapshotAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBClusterSnapshotAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterSnapshotNotFoundFault":
    case "rds.admin#DBClusterSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterSnapshotStateFault":
    case "rds.admin#InvalidDBClusterSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SnapshotQuotaExceededFault":
    case "rds.admin#SnapshotQuotaExceededFault":
      response = {
        ...(await deserializeAws_querySnapshotQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCopyDBParameterGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyDBParameterGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCopyDBParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCopyDBParameterGroupResult(
    data.CopyDBParameterGroupResult,
    context
  );
  const response: CopyDBParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CopyDBParameterGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCopyDBParameterGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyDBParameterGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupAlreadyExistsFault":
    case "rds.admin#DBParameterGroupAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupQuotaExceededFault":
    case "rds.admin#DBParameterGroupQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCopyDBSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyDBSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCopyDBSnapshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCopyDBSnapshotResult(
    data.CopyDBSnapshotResult,
    context
  );
  const response: CopyDBSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CopyDBSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCopyDBSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyDBSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSnapshotAlreadyExistsFault":
    case "rds.admin#DBSnapshotAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSnapshotStateFault":
    case "rds.admin#InvalidDBSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SnapshotQuotaExceededFault":
    case "rds.admin#SnapshotQuotaExceededFault":
      response = {
        ...(await deserializeAws_querySnapshotQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCopyOptionGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyOptionGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCopyOptionGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCopyOptionGroupResult(
    data.CopyOptionGroupResult,
    context
  );
  const response: CopyOptionGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CopyOptionGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCopyOptionGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CopyOptionGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "OptionGroupAlreadyExistsFault":
    case "rds.admin#OptionGroupAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryOptionGroupAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupQuotaExceededFault":
    case "rds.admin#OptionGroupQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryOptionGroupQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateCustomAvailabilityZoneCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCustomAvailabilityZoneCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateCustomAvailabilityZoneCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateCustomAvailabilityZoneResult(
    data.CreateCustomAvailabilityZoneResult,
    context
  );
  const response: CreateCustomAvailabilityZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCustomAvailabilityZoneResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateCustomAvailabilityZoneCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCustomAvailabilityZoneCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CustomAvailabilityZoneAlreadyExistsFault":
    case "rds.admin#CustomAvailabilityZoneAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryCustomAvailabilityZoneAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CustomAvailabilityZoneQuotaExceededFault":
    case "rds.admin#CustomAvailabilityZoneQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryCustomAvailabilityZoneQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateDBClusterResult(
    data.CreateDBClusterResult,
    context
  );
  const response: CreateDBClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDBClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterAlreadyExistsFault":
    case "rds.admin#DBClusterAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBClusterAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterParameterGroupNotFoundFault":
    case "rds.admin#DBClusterParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterQuotaExceededFault":
    case "rds.admin#DBClusterQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBClusterQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupDoesNotCoverEnoughAZs":
    case "rds.admin#DBSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DomainNotFoundFault":
    case "rds.admin#DomainNotFoundFault":
      response = {
        ...(await deserializeAws_queryDomainNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlobalClusterNotFoundFault":
    case "rds.admin#GlobalClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryGlobalClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientStorageClusterCapacityFault":
    case "rds.admin#InsufficientStorageClusterCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientStorageClusterCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSubnetGroupStateFault":
    case "rds.admin#InvalidDBSubnetGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSubnetGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidGlobalClusterStateFault":
    case "rds.admin#InvalidGlobalClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidGlobalClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBClusterEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBClusterEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBClusterEndpointCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterEndpoint(
    data.CreateDBClusterEndpointResult,
    context
  );
  const response: CreateDBClusterEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterEndpoint",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBClusterEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBClusterEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterEndpointAlreadyExistsFault":
    case "rds.admin#DBClusterEndpointAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBClusterEndpointAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterEndpointQuotaExceededFault":
    case "rds.admin#DBClusterEndpointQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBClusterEndpointQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBClusterParameterGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBClusterParameterGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBClusterParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateDBClusterParameterGroupResult(
    data.CreateDBClusterParameterGroupResult,
    context
  );
  const response: CreateDBClusterParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDBClusterParameterGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBClusterParameterGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBClusterParameterGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupAlreadyExistsFault":
    case "rds.admin#DBParameterGroupAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupQuotaExceededFault":
    case "rds.admin#DBParameterGroupQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBClusterSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBClusterSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBClusterSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateDBClusterSnapshotResult(
    data.CreateDBClusterSnapshotResult,
    context
  );
  const response: CreateDBClusterSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDBClusterSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBClusterSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBClusterSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterSnapshotAlreadyExistsFault":
    case "rds.admin#DBClusterSnapshotAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBClusterSnapshotAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterSnapshotStateFault":
    case "rds.admin#InvalidDBClusterSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SnapshotQuotaExceededFault":
    case "rds.admin#SnapshotQuotaExceededFault":
      response = {
        ...(await deserializeAws_querySnapshotQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBInstanceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateDBInstanceResult(
    data.CreateDBInstanceResult,
    context
  );
  const response: CreateDBInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDBInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationNotFoundFault":
    case "rds.admin#AuthorizationNotFoundFault":
      response = {
        ...(await deserializeAws_queryAuthorizationNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BackupPolicyNotFoundFault":
    case "rds.admin#BackupPolicyNotFoundFault":
      response = {
        ...(await deserializeAws_queryBackupPolicyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceAlreadyExistsFault":
    case "rds.admin#DBInstanceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBInstanceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSecurityGroupNotFoundFault":
    case "rds.admin#DBSecurityGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupDoesNotCoverEnoughAZs":
    case "rds.admin#DBSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DomainNotFoundFault":
    case "rds.admin#DomainNotFoundFault":
      response = {
        ...(await deserializeAws_queryDomainNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InstanceQuotaExceededFault":
    case "rds.admin#InstanceQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryInstanceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientDBInstanceCapacityFault":
    case "rds.admin#InsufficientDBInstanceCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientDBInstanceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ProvisionedIopsNotAvailableInAZFault":
    case "rds.admin#ProvisionedIopsNotAvailableInAZFault":
      response = {
        ...(await deserializeAws_queryProvisionedIopsNotAvailableInAZFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageTypeNotSupportedFault":
    case "rds.admin#StorageTypeNotSupportedFault":
      response = {
        ...(await deserializeAws_queryStorageTypeNotSupportedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBInstanceReadReplicaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBInstanceReadReplicaCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBInstanceReadReplicaCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateDBInstanceReadReplicaResult(
    data.CreateDBInstanceReadReplicaResult,
    context
  );
  const response: CreateDBInstanceReadReplicaCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDBInstanceReadReplicaResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBInstanceReadReplicaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBInstanceReadReplicaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceAlreadyExistsFault":
    case "rds.admin#DBInstanceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBInstanceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSecurityGroupNotFoundFault":
    case "rds.admin#DBSecurityGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupDoesNotCoverEnoughAZs":
    case "rds.admin#DBSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotAllowedFault":
    case "rds.admin#DBSubnetGroupNotAllowedFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotAllowedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DomainNotFoundFault":
    case "rds.admin#DomainNotFoundFault":
      response = {
        ...(await deserializeAws_queryDomainNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InstanceQuotaExceededFault":
    case "rds.admin#InstanceQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryInstanceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientDBInstanceCapacityFault":
    case "rds.admin#InsufficientDBInstanceCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientDBInstanceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSubnetGroupFault":
    case "rds.admin#InvalidDBSubnetGroupFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSubnetGroupFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ProvisionedIopsNotAvailableInAZFault":
    case "rds.admin#ProvisionedIopsNotAvailableInAZFault":
      response = {
        ...(await deserializeAws_queryProvisionedIopsNotAvailableInAZFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageTypeNotSupportedFault":
    case "rds.admin#StorageTypeNotSupportedFault":
      response = {
        ...(await deserializeAws_queryStorageTypeNotSupportedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBParameterGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBParameterGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateDBParameterGroupResult(
    data.CreateDBParameterGroupResult,
    context
  );
  const response: CreateDBParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDBParameterGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBParameterGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBParameterGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupAlreadyExistsFault":
    case "rds.admin#DBParameterGroupAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupQuotaExceededFault":
    case "rds.admin#DBParameterGroupQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBProxyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBProxyCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBProxyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateDBProxyResponse(
    data.CreateDBProxyResult,
    context
  );
  const response: CreateDBProxyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDBProxyResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBProxyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBProxyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBProxyAlreadyExistsFault":
    case "rds.admin#DBProxyAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBProxyAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBProxyQuotaExceededFault":
    case "rds.admin#DBProxyQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBProxyQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBSecurityGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBSecurityGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBSecurityGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateDBSecurityGroupResult(
    data.CreateDBSecurityGroupResult,
    context
  );
  const response: CreateDBSecurityGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDBSecurityGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBSecurityGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBSecurityGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSecurityGroupAlreadyExistsFault":
    case "rds.admin#DBSecurityGroupAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSecurityGroupNotSupportedFault":
    case "rds.admin#DBSecurityGroupNotSupportedFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotSupportedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSecurityGroupQuotaExceededFault":
    case "rds.admin#DBSecurityGroupQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBSnapshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateDBSnapshotResult(
    data.CreateDBSnapshotResult,
    context
  );
  const response: CreateDBSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDBSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSnapshotAlreadyExistsFault":
    case "rds.admin#DBSnapshotAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SnapshotQuotaExceededFault":
    case "rds.admin#SnapshotQuotaExceededFault":
      response = {
        ...(await deserializeAws_querySnapshotQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateDBSubnetGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBSubnetGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateDBSubnetGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateDBSubnetGroupResult(
    data.CreateDBSubnetGroupResult,
    context
  );
  const response: CreateDBSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDBSubnetGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateDBSubnetGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDBSubnetGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSubnetGroupAlreadyExistsFault":
    case "rds.admin#DBSubnetGroupAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupDoesNotCoverEnoughAZs":
    case "rds.admin#DBSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupQuotaExceededFault":
    case "rds.admin#DBSubnetGroupQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetQuotaExceededFault":
    case "rds.admin#DBSubnetQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBSubnetQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateEventSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEventSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateEventSubscriptionResult(
    data.CreateEventSubscriptionResult,
    context
  );
  const response: CreateEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEventSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateEventSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEventSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EventSubscriptionQuotaExceededFault":
    case "rds.admin#EventSubscriptionQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryEventSubscriptionQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSInvalidTopicFault":
    case "rds.admin#SNSInvalidTopicFault":
      response = {
        ...(await deserializeAws_querySNSInvalidTopicFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSNoAuthorizationFault":
    case "rds.admin#SNSNoAuthorizationFault":
      response = {
        ...(await deserializeAws_querySNSNoAuthorizationFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSTopicArnNotFoundFault":
    case "rds.admin#SNSTopicArnNotFoundFault":
      response = {
        ...(await deserializeAws_querySNSTopicArnNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SourceNotFoundFault":
    case "rds.admin#SourceNotFoundFault":
      response = {
        ...(await deserializeAws_querySourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubscriptionAlreadyExistFault":
    case "rds.admin#SubscriptionAlreadyExistFault":
      response = {
        ...(await deserializeAws_querySubscriptionAlreadyExistFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubscriptionCategoryNotFoundFault":
    case "rds.admin#SubscriptionCategoryNotFoundFault":
      response = {
        ...(await deserializeAws_querySubscriptionCategoryNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateGlobalClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGlobalClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateGlobalClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateGlobalClusterResult(
    data.CreateGlobalClusterResult,
    context
  );
  const response: CreateGlobalClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGlobalClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateGlobalClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGlobalClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlobalClusterAlreadyExistsFault":
    case "rds.admin#GlobalClusterAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryGlobalClusterAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlobalClusterQuotaExceededFault":
    case "rds.admin#GlobalClusterQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryGlobalClusterQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryCreateOptionGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateOptionGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryCreateOptionGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCreateOptionGroupResult(
    data.CreateOptionGroupResult,
    context
  );
  const response: CreateOptionGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateOptionGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryCreateOptionGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateOptionGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "OptionGroupAlreadyExistsFault":
    case "rds.admin#OptionGroupAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryOptionGroupAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupQuotaExceededFault":
    case "rds.admin#OptionGroupQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryOptionGroupQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteCustomAvailabilityZoneCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCustomAvailabilityZoneCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteCustomAvailabilityZoneCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteCustomAvailabilityZoneResult(
    data.DeleteCustomAvailabilityZoneResult,
    context
  );
  const response: DeleteCustomAvailabilityZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteCustomAvailabilityZoneResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteCustomAvailabilityZoneCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCustomAvailabilityZoneCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CustomAvailabilityZoneNotFoundFault":
    case "rds.admin#CustomAvailabilityZoneNotFoundFault":
      response = {
        ...(await deserializeAws_queryCustomAvailabilityZoneNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteDBClusterResult(
    data.DeleteDBClusterResult,
    context
  );
  const response: DeleteDBClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDBClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterSnapshotAlreadyExistsFault":
    case "rds.admin#DBClusterSnapshotAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBClusterSnapshotAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterSnapshotStateFault":
    case "rds.admin#InvalidDBClusterSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SnapshotQuotaExceededFault":
    case "rds.admin#SnapshotQuotaExceededFault":
      response = {
        ...(await deserializeAws_querySnapshotQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBClusterEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBClusterEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBClusterEndpointCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterEndpoint(
    data.DeleteDBClusterEndpointResult,
    context
  );
  const response: DeleteDBClusterEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterEndpoint",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBClusterEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBClusterEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterEndpointNotFoundFault":
    case "rds.admin#DBClusterEndpointNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterEndpointNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterEndpointStateFault":
    case "rds.admin#InvalidDBClusterEndpointStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterEndpointStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBClusterParameterGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBClusterParameterGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBClusterParameterGroupCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteDBClusterParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBClusterParameterGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBClusterParameterGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBParameterGroupStateFault":
    case "rds.admin#InvalidDBParameterGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBParameterGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBClusterSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBClusterSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBClusterSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteDBClusterSnapshotResult(
    data.DeleteDBClusterSnapshotResult,
    context
  );
  const response: DeleteDBClusterSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDBClusterSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBClusterSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBClusterSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterSnapshotNotFoundFault":
    case "rds.admin#DBClusterSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterSnapshotStateFault":
    case "rds.admin#InvalidDBClusterSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBInstanceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteDBInstanceResult(
    data.DeleteDBInstanceResult,
    context
  );
  const response: DeleteDBInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDBInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceAutomatedBackupQuotaExceededFault":
    case "rds.admin#DBInstanceAutomatedBackupQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBInstanceAutomatedBackupQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSnapshotAlreadyExistsFault":
    case "rds.admin#DBSnapshotAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SnapshotQuotaExceededFault":
    case "rds.admin#SnapshotQuotaExceededFault":
      response = {
        ...(await deserializeAws_querySnapshotQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBInstanceAutomatedBackupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBInstanceAutomatedBackupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBInstanceAutomatedBackupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteDBInstanceAutomatedBackupResult(
    data.DeleteDBInstanceAutomatedBackupResult,
    context
  );
  const response: DeleteDBInstanceAutomatedBackupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDBInstanceAutomatedBackupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBInstanceAutomatedBackupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBInstanceAutomatedBackupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceAutomatedBackupNotFoundFault":
    case "rds.admin#DBInstanceAutomatedBackupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceAutomatedBackupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceAutomatedBackupStateFault":
    case "rds.admin#InvalidDBInstanceAutomatedBackupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceAutomatedBackupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBParameterGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBParameterGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBParameterGroupCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteDBParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBParameterGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBParameterGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBParameterGroupStateFault":
    case "rds.admin#InvalidDBParameterGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBParameterGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBProxyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBProxyCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBProxyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteDBProxyResponse(
    data.DeleteDBProxyResult,
    context
  );
  const response: DeleteDBProxyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDBProxyResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBProxyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBProxyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBProxyNotFoundFault":
    case "rds.admin#DBProxyNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBProxyStateFault":
    case "rds.admin#InvalidDBProxyStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBProxyStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBSecurityGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBSecurityGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBSecurityGroupCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteDBSecurityGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBSecurityGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBSecurityGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSecurityGroupNotFoundFault":
    case "rds.admin#DBSecurityGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSecurityGroupStateFault":
    case "rds.admin#InvalidDBSecurityGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSecurityGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBSnapshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteDBSnapshotResult(
    data.DeleteDBSnapshotResult,
    context
  );
  const response: DeleteDBSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDBSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSnapshotStateFault":
    case "rds.admin#InvalidDBSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteDBSubnetGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBSubnetGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteDBSubnetGroupCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteDBSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteDBSubnetGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDBSubnetGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSubnetGroupStateFault":
    case "rds.admin#InvalidDBSubnetGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSubnetGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSubnetStateFault":
    case "rds.admin#InvalidDBSubnetStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSubnetStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteEventSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteEventSubscriptionResult(
    data.DeleteEventSubscriptionResult,
    context
  );
  const response: DeleteEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEventSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteEventSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidEventSubscriptionStateFault":
    case "rds.admin#InvalidEventSubscriptionStateFault":
      response = {
        ...(await deserializeAws_queryInvalidEventSubscriptionStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubscriptionNotFoundFault":
    case "rds.admin#SubscriptionNotFoundFault":
      response = {
        ...(await deserializeAws_querySubscriptionNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteGlobalClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGlobalClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteGlobalClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeleteGlobalClusterResult(
    data.DeleteGlobalClusterResult,
    context
  );
  const response: DeleteGlobalClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteGlobalClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteGlobalClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGlobalClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "GlobalClusterNotFoundFault":
    case "rds.admin#GlobalClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryGlobalClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidGlobalClusterStateFault":
    case "rds.admin#InvalidGlobalClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidGlobalClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteInstallationMediaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInstallationMediaCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteInstallationMediaCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryInstallationMedia(
    data.DeleteInstallationMediaResult,
    context
  );
  const response: DeleteInstallationMediaCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "InstallationMedia",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteInstallationMediaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInstallationMediaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InstallationMediaNotFoundFault":
    case "rds.admin#InstallationMediaNotFoundFault":
      response = {
        ...(await deserializeAws_queryInstallationMediaNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeleteOptionGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteOptionGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeleteOptionGroupCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteOptionGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeleteOptionGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteOptionGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidOptionGroupStateFault":
    case "rds.admin#InvalidOptionGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidOptionGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDeregisterDBProxyTargetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterDBProxyTargetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDeregisterDBProxyTargetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDeregisterDBProxyTargetsResponse(
    data.DeregisterDBProxyTargetsResult,
    context
  );
  const response: DeregisterDBProxyTargetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeregisterDBProxyTargetsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDeregisterDBProxyTargetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterDBProxyTargetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBProxyNotFoundFault":
    case "rds.admin#DBProxyNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBProxyTargetGroupNotFoundFault":
    case "rds.admin#DBProxyTargetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyTargetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBProxyTargetNotFoundFault":
    case "rds.admin#DBProxyTargetNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyTargetNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeAccountAttributesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeAccountAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryAccountAttributesMessage(
    data.DescribeAccountAttributesResult,
    context
  );
  const response: DescribeAccountAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AccountAttributesMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeAccountAttributesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeCertificatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificatesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeCertificatesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCertificateMessage(
    data.DescribeCertificatesResult,
    context
  );
  const response: DescribeCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CertificateMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeCertificatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateNotFoundFault":
    case "rds.admin#CertificateNotFoundFault":
      response = {
        ...(await deserializeAws_queryCertificateNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeCustomAvailabilityZonesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCustomAvailabilityZonesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeCustomAvailabilityZonesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryCustomAvailabilityZoneMessage(
    data.DescribeCustomAvailabilityZonesResult,
    context
  );
  const response: DescribeCustomAvailabilityZonesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CustomAvailabilityZoneMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeCustomAvailabilityZonesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCustomAvailabilityZonesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CustomAvailabilityZoneNotFoundFault":
    case "rds.admin#CustomAvailabilityZoneNotFoundFault":
      response = {
        ...(await deserializeAws_queryCustomAvailabilityZoneNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBClusterBacktracksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterBacktracksCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBClusterBacktracksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterBacktrackMessage(
    data.DescribeDBClusterBacktracksResult,
    context
  );
  const response: DescribeDBClusterBacktracksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterBacktrackMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBClusterBacktracksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterBacktracksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterBacktrackNotFoundFault":
    case "rds.admin#DBClusterBacktrackNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterBacktrackNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBClusterEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterEndpointsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBClusterEndpointsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterEndpointMessage(
    data.DescribeDBClusterEndpointsResult,
    context
  );
  const response: DescribeDBClusterEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterEndpointMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBClusterEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBClusterParameterGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterParameterGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBClusterParameterGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterParameterGroupsMessage(
    data.DescribeDBClusterParameterGroupsResult,
    context
  );
  const response: DescribeDBClusterParameterGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterParameterGroupsMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBClusterParameterGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterParameterGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBClusterParametersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterParametersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBClusterParametersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterParameterGroupDetails(
    data.DescribeDBClusterParametersResult,
    context
  );
  const response: DescribeDBClusterParametersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterParameterGroupDetails",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBClusterParametersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterParametersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBClusterSnapshotAttributesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterSnapshotAttributesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBClusterSnapshotAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeDBClusterSnapshotAttributesResult(
    data.DescribeDBClusterSnapshotAttributesResult,
    context
  );
  const response: DescribeDBClusterSnapshotAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDBClusterSnapshotAttributesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBClusterSnapshotAttributesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterSnapshotAttributesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterSnapshotNotFoundFault":
    case "rds.admin#DBClusterSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBClusterSnapshotsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterSnapshotsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBClusterSnapshotsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterSnapshotMessage(
    data.DescribeDBClusterSnapshotsResult,
    context
  );
  const response: DescribeDBClusterSnapshotsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterSnapshotMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBClusterSnapshotsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClusterSnapshotsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterSnapshotNotFoundFault":
    case "rds.admin#DBClusterSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBClustersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClustersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBClustersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterMessage(
    data.DescribeDBClustersResult,
    context
  );
  const response: DescribeDBClustersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBClustersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBClustersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBEngineVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBEngineVersionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBEngineVersionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBEngineVersionMessage(
    data.DescribeDBEngineVersionsResult,
    context
  );
  const response: DescribeDBEngineVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBEngineVersionMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBEngineVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBEngineVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBInstanceAutomatedBackupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBInstanceAutomatedBackupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBInstanceAutomatedBackupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBInstanceAutomatedBackupMessage(
    data.DescribeDBInstanceAutomatedBackupsResult,
    context
  );
  const response: DescribeDBInstanceAutomatedBackupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBInstanceAutomatedBackupMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBInstanceAutomatedBackupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBInstanceAutomatedBackupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceAutomatedBackupNotFoundFault":
    case "rds.admin#DBInstanceAutomatedBackupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceAutomatedBackupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBInstanceMessage(
    data.DescribeDBInstancesResult,
    context
  );
  const response: DescribeDBInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBInstanceMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBLogFilesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBLogFilesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBLogFilesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeDBLogFilesResponse(
    data.DescribeDBLogFilesResult,
    context
  );
  const response: DescribeDBLogFilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDBLogFilesResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBLogFilesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBLogFilesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBParameterGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBParameterGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBParameterGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBParameterGroupsMessage(
    data.DescribeDBParameterGroupsResult,
    context
  );
  const response: DescribeDBParameterGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBParameterGroupsMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBParameterGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBParameterGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBParametersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBParametersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBParametersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBParameterGroupDetails(
    data.DescribeDBParametersResult,
    context
  );
  const response: DescribeDBParametersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBParameterGroupDetails",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBParametersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBParametersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBProxiesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBProxiesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBProxiesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeDBProxiesResponse(
    data.DescribeDBProxiesResult,
    context
  );
  const response: DescribeDBProxiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDBProxiesResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBProxiesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBProxiesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBProxyNotFoundFault":
    case "rds.admin#DBProxyNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBProxyTargetGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBProxyTargetGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBProxyTargetGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeDBProxyTargetGroupsResponse(
    data.DescribeDBProxyTargetGroupsResult,
    context
  );
  const response: DescribeDBProxyTargetGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDBProxyTargetGroupsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBProxyTargetGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBProxyTargetGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBProxyTargetGroupNotFoundFault":
    case "rds.admin#DBProxyTargetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyTargetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBProxyTargetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBProxyTargetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBProxyTargetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeDBProxyTargetsResponse(
    data.DescribeDBProxyTargetsResult,
    context
  );
  const response: DescribeDBProxyTargetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDBProxyTargetsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBProxyTargetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBProxyTargetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBProxyNotFoundFault":
    case "rds.admin#DBProxyNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBProxyTargetGroupNotFoundFault":
    case "rds.admin#DBProxyTargetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyTargetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBProxyTargetNotFoundFault":
    case "rds.admin#DBProxyTargetNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyTargetNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBSecurityGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBSecurityGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBSecurityGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBSecurityGroupMessage(
    data.DescribeDBSecurityGroupsResult,
    context
  );
  const response: DescribeDBSecurityGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBSecurityGroupMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBSecurityGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBSecurityGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSecurityGroupNotFoundFault":
    case "rds.admin#DBSecurityGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBSnapshotAttributesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBSnapshotAttributesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBSnapshotAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeDBSnapshotAttributesResult(
    data.DescribeDBSnapshotAttributesResult,
    context
  );
  const response: DescribeDBSnapshotAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDBSnapshotAttributesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBSnapshotAttributesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBSnapshotAttributesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBSnapshotsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBSnapshotsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBSnapshotsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBSnapshotMessage(
    data.DescribeDBSnapshotsResult,
    context
  );
  const response: DescribeDBSnapshotsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBSnapshotMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBSnapshotsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBSnapshotsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeDBSubnetGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBSubnetGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeDBSubnetGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBSubnetGroupMessage(
    data.DescribeDBSubnetGroupsResult,
    context
  );
  const response: DescribeDBSubnetGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBSubnetGroupMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeDBSubnetGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDBSubnetGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeEngineDefaultClusterParametersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEngineDefaultClusterParametersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeEngineDefaultClusterParametersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeEngineDefaultClusterParametersResult(
    data.DescribeEngineDefaultClusterParametersResult,
    context
  );
  const response: DescribeEngineDefaultClusterParametersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEngineDefaultClusterParametersResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeEngineDefaultClusterParametersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEngineDefaultClusterParametersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeEngineDefaultParametersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEngineDefaultParametersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeEngineDefaultParametersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeEngineDefaultParametersResult(
    data.DescribeEngineDefaultParametersResult,
    context
  );
  const response: DescribeEngineDefaultParametersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEngineDefaultParametersResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeEngineDefaultParametersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEngineDefaultParametersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeEventCategoriesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventCategoriesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeEventCategoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryEventCategoriesMessage(
    data.DescribeEventCategoriesResult,
    context
  );
  const response: DescribeEventCategoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EventCategoriesMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeEventCategoriesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventCategoriesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeEventSubscriptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventSubscriptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeEventSubscriptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryEventSubscriptionsMessage(
    data.DescribeEventSubscriptionsResult,
    context
  );
  const response: DescribeEventSubscriptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EventSubscriptionsMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeEventSubscriptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventSubscriptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "SubscriptionNotFoundFault":
    case "rds.admin#SubscriptionNotFoundFault":
      response = {
        ...(await deserializeAws_querySubscriptionNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeEventsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeEventsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryEventsMessage(
    data.DescribeEventsResult,
    context
  );
  const response: DescribeEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "EventsMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeEventsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeGlobalClustersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGlobalClustersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeGlobalClustersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryGlobalClustersMessage(
    data.DescribeGlobalClustersResult,
    context
  );
  const response: DescribeGlobalClustersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GlobalClustersMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeGlobalClustersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGlobalClustersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "GlobalClusterNotFoundFault":
    case "rds.admin#GlobalClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryGlobalClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeInstallationMediaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstallationMediaCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeInstallationMediaCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryInstallationMediaMessage(
    data.DescribeInstallationMediaResult,
    context
  );
  const response: DescribeInstallationMediaCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "InstallationMediaMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeInstallationMediaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstallationMediaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InstallationMediaNotFoundFault":
    case "rds.admin#InstallationMediaNotFoundFault":
      response = {
        ...(await deserializeAws_queryInstallationMediaNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeOptionGroupOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOptionGroupOptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeOptionGroupOptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryOptionGroupOptionsMessage(
    data.DescribeOptionGroupOptionsResult,
    context
  );
  const response: DescribeOptionGroupOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "OptionGroupOptionsMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeOptionGroupOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOptionGroupOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeOptionGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOptionGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeOptionGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryOptionGroups(
    data.DescribeOptionGroupsResult,
    context
  );
  const response: DescribeOptionGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "OptionGroups",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeOptionGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOptionGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeOrderableDBInstanceOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOrderableDBInstanceOptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeOrderableDBInstanceOptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryOrderableDBInstanceOptionsMessage(
    data.DescribeOrderableDBInstanceOptionsResult,
    context
  );
  const response: DescribeOrderableDBInstanceOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "OrderableDBInstanceOptionsMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeOrderableDBInstanceOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOrderableDBInstanceOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribePendingMaintenanceActionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePendingMaintenanceActionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribePendingMaintenanceActionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryPendingMaintenanceActionsMessage(
    data.DescribePendingMaintenanceActionsResult,
    context
  );
  const response: DescribePendingMaintenanceActionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PendingMaintenanceActionsMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribePendingMaintenanceActionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePendingMaintenanceActionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "rds.admin#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_queryResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeReservedDBInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedDBInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeReservedDBInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryReservedDBInstanceMessage(
    data.DescribeReservedDBInstancesResult,
    context
  );
  const response: DescribeReservedDBInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReservedDBInstanceMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeReservedDBInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedDBInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ReservedDBInstanceNotFoundFault":
    case "rds.admin#ReservedDBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryReservedDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeReservedDBInstancesOfferingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedDBInstancesOfferingsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeReservedDBInstancesOfferingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryReservedDBInstancesOfferingMessage(
    data.DescribeReservedDBInstancesOfferingsResult,
    context
  );
  const response: DescribeReservedDBInstancesOfferingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReservedDBInstancesOfferingMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeReservedDBInstancesOfferingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReservedDBInstancesOfferingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ReservedDBInstancesOfferingNotFoundFault":
    case "rds.admin#ReservedDBInstancesOfferingNotFoundFault":
      response = {
        ...(await deserializeAws_queryReservedDBInstancesOfferingNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeSourceRegionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSourceRegionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeSourceRegionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_querySourceRegionMessage(
    data.DescribeSourceRegionsResult,
    context
  );
  const response: DescribeSourceRegionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SourceRegionMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeSourceRegionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSourceRegionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDescribeValidDBInstanceModificationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeValidDBInstanceModificationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDescribeValidDBInstanceModificationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDescribeValidDBInstanceModificationsResult(
    data.DescribeValidDBInstanceModificationsResult,
    context
  );
  const response: DescribeValidDBInstanceModificationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeValidDBInstanceModificationsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDescribeValidDBInstanceModificationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeValidDBInstanceModificationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryDownloadDBLogFilePortionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DownloadDBLogFilePortionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryDownloadDBLogFilePortionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDownloadDBLogFilePortionDetails(
    data.DownloadDBLogFilePortionResult,
    context
  );
  const response: DownloadDBLogFilePortionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DownloadDBLogFilePortionDetails",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryDownloadDBLogFilePortionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DownloadDBLogFilePortionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBLogFileNotFoundFault":
    case "rds.admin#DBLogFileNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBLogFileNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryFailoverDBClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<FailoverDBClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryFailoverDBClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryFailoverDBClusterResult(
    data.FailoverDBClusterResult,
    context
  );
  const response: FailoverDBClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "FailoverDBClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryFailoverDBClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<FailoverDBClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryImportInstallationMediaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportInstallationMediaCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryImportInstallationMediaCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryInstallationMedia(
    data.ImportInstallationMediaResult,
    context
  );
  const response: ImportInstallationMediaCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "InstallationMedia",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryImportInstallationMediaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportInstallationMediaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CustomAvailabilityZoneNotFoundFault":
    case "rds.admin#CustomAvailabilityZoneNotFoundFault":
      response = {
        ...(await deserializeAws_queryCustomAvailabilityZoneNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InstallationMediaAlreadyExistsFault":
    case "rds.admin#InstallationMediaAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryInstallationMediaAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryListTagsForResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryListTagsForResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryTagListMessage(
    data.ListTagsForResourceResult,
    context
  );
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagListMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryListTagsForResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyCertificatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyCertificatesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyCertificatesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyCertificatesResult(
    data.ModifyCertificatesResult,
    context
  );
  const response: ModifyCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyCertificatesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyCertificatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyCertificatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateNotFoundFault":
    case "rds.admin#CertificateNotFoundFault":
      response = {
        ...(await deserializeAws_queryCertificateNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyCurrentDBClusterCapacityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyCurrentDBClusterCapacityCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyCurrentDBClusterCapacityCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterCapacityInfo(
    data.ModifyCurrentDBClusterCapacityResult,
    context
  );
  const response: ModifyCurrentDBClusterCapacityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterCapacityInfo",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyCurrentDBClusterCapacityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyCurrentDBClusterCapacityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterCapacityFault":
    case "rds.admin#InvalidDBClusterCapacityFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyDBClusterResult(
    data.ModifyDBClusterResult,
    context
  );
  const response: ModifyDBClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyDBClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterAlreadyExistsFault":
    case "rds.admin#DBClusterAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBClusterAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterParameterGroupNotFoundFault":
    case "rds.admin#DBClusterParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DomainNotFoundFault":
    case "rds.admin#DomainNotFoundFault":
      response = {
        ...(await deserializeAws_queryDomainNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSecurityGroupStateFault":
    case "rds.admin#InvalidDBSecurityGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSecurityGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSubnetGroupStateFault":
    case "rds.admin#InvalidDBSubnetGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSubnetGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBClusterEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBClusterEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBClusterEndpointCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterEndpoint(
    data.ModifyDBClusterEndpointResult,
    context
  );
  const response: ModifyDBClusterEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterEndpoint",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBClusterEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBClusterEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterEndpointNotFoundFault":
    case "rds.admin#DBClusterEndpointNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterEndpointNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterEndpointStateFault":
    case "rds.admin#InvalidDBClusterEndpointStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterEndpointStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBClusterParameterGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBClusterParameterGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBClusterParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterParameterGroupNameMessage(
    data.ModifyDBClusterParameterGroupResult,
    context
  );
  const response: ModifyDBClusterParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterParameterGroupNameMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBClusterParameterGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBClusterParameterGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBParameterGroupStateFault":
    case "rds.admin#InvalidDBParameterGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBParameterGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBClusterSnapshotAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBClusterSnapshotAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBClusterSnapshotAttributeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyDBClusterSnapshotAttributeResult(
    data.ModifyDBClusterSnapshotAttributeResult,
    context
  );
  const response: ModifyDBClusterSnapshotAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyDBClusterSnapshotAttributeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBClusterSnapshotAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBClusterSnapshotAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterSnapshotNotFoundFault":
    case "rds.admin#DBClusterSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterSnapshotStateFault":
    case "rds.admin#InvalidDBClusterSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SharedSnapshotQuotaExceededFault":
    case "rds.admin#SharedSnapshotQuotaExceededFault":
      response = {
        ...(await deserializeAws_querySharedSnapshotQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBInstanceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyDBInstanceResult(
    data.ModifyDBInstanceResult,
    context
  );
  const response: ModifyDBInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyDBInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationNotFoundFault":
    case "rds.admin#AuthorizationNotFoundFault":
      response = {
        ...(await deserializeAws_queryAuthorizationNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BackupPolicyNotFoundFault":
    case "rds.admin#BackupPolicyNotFoundFault":
      response = {
        ...(await deserializeAws_queryBackupPolicyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CertificateNotFoundFault":
    case "rds.admin#CertificateNotFoundFault":
      response = {
        ...(await deserializeAws_queryCertificateNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceAlreadyExistsFault":
    case "rds.admin#DBInstanceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBInstanceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSecurityGroupNotFoundFault":
    case "rds.admin#DBSecurityGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBUpgradeDependencyFailureFault":
    case "rds.admin#DBUpgradeDependencyFailureFault":
      response = {
        ...(await deserializeAws_queryDBUpgradeDependencyFailureFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DomainNotFoundFault":
    case "rds.admin#DomainNotFoundFault":
      response = {
        ...(await deserializeAws_queryDomainNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientDBInstanceCapacityFault":
    case "rds.admin#InsufficientDBInstanceCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientDBInstanceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSecurityGroupStateFault":
    case "rds.admin#InvalidDBSecurityGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSecurityGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ProvisionedIopsNotAvailableInAZFault":
    case "rds.admin#ProvisionedIopsNotAvailableInAZFault":
      response = {
        ...(await deserializeAws_queryProvisionedIopsNotAvailableInAZFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageTypeNotSupportedFault":
    case "rds.admin#StorageTypeNotSupportedFault":
      response = {
        ...(await deserializeAws_queryStorageTypeNotSupportedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBParameterGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBParameterGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBParameterGroupNameMessage(
    data.ModifyDBParameterGroupResult,
    context
  );
  const response: ModifyDBParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBParameterGroupNameMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBParameterGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBParameterGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBParameterGroupStateFault":
    case "rds.admin#InvalidDBParameterGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBParameterGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBProxyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBProxyCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBProxyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyDBProxyResponse(
    data.ModifyDBProxyResult,
    context
  );
  const response: ModifyDBProxyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyDBProxyResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBProxyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBProxyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBProxyAlreadyExistsFault":
    case "rds.admin#DBProxyAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBProxyAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBProxyNotFoundFault":
    case "rds.admin#DBProxyNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBProxyStateFault":
    case "rds.admin#InvalidDBProxyStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBProxyStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBProxyTargetGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBProxyTargetGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBProxyTargetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyDBProxyTargetGroupResponse(
    data.ModifyDBProxyTargetGroupResult,
    context
  );
  const response: ModifyDBProxyTargetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyDBProxyTargetGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBProxyTargetGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBProxyTargetGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBProxyNotFoundFault":
    case "rds.admin#DBProxyNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBProxyTargetGroupNotFoundFault":
    case "rds.admin#DBProxyTargetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyTargetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBSnapshotCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyDBSnapshotResult(
    data.ModifyDBSnapshotResult,
    context
  );
  const response: ModifyDBSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyDBSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBSnapshotAttributeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBSnapshotAttributeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBSnapshotAttributeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyDBSnapshotAttributeResult(
    data.ModifyDBSnapshotAttributeResult,
    context
  );
  const response: ModifyDBSnapshotAttributeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyDBSnapshotAttributeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBSnapshotAttributeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBSnapshotAttributeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSnapshotStateFault":
    case "rds.admin#InvalidDBSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SharedSnapshotQuotaExceededFault":
    case "rds.admin#SharedSnapshotQuotaExceededFault":
      response = {
        ...(await deserializeAws_querySharedSnapshotQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyDBSubnetGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBSubnetGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyDBSubnetGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyDBSubnetGroupResult(
    data.ModifyDBSubnetGroupResult,
    context
  );
  const response: ModifyDBSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyDBSubnetGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyDBSubnetGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyDBSubnetGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBSubnetGroupDoesNotCoverEnoughAZs":
    case "rds.admin#DBSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetQuotaExceededFault":
    case "rds.admin#DBSubnetQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBSubnetQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubnetAlreadyInUse":
    case "rds.admin#SubnetAlreadyInUse":
      response = {
        ...(await deserializeAws_querySubnetAlreadyInUseResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyEventSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEventSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyEventSubscriptionResult(
    data.ModifyEventSubscriptionResult,
    context
  );
  const response: ModifyEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyEventSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyEventSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEventSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "EventSubscriptionQuotaExceededFault":
    case "rds.admin#EventSubscriptionQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryEventSubscriptionQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSInvalidTopicFault":
    case "rds.admin#SNSInvalidTopicFault":
      response = {
        ...(await deserializeAws_querySNSInvalidTopicFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSNoAuthorizationFault":
    case "rds.admin#SNSNoAuthorizationFault":
      response = {
        ...(await deserializeAws_querySNSNoAuthorizationFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSTopicArnNotFoundFault":
    case "rds.admin#SNSTopicArnNotFoundFault":
      response = {
        ...(await deserializeAws_querySNSTopicArnNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubscriptionCategoryNotFoundFault":
    case "rds.admin#SubscriptionCategoryNotFoundFault":
      response = {
        ...(await deserializeAws_querySubscriptionCategoryNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubscriptionNotFoundFault":
    case "rds.admin#SubscriptionNotFoundFault":
      response = {
        ...(await deserializeAws_querySubscriptionNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyGlobalClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyGlobalClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyGlobalClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyGlobalClusterResult(
    data.ModifyGlobalClusterResult,
    context
  );
  const response: ModifyGlobalClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyGlobalClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyGlobalClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyGlobalClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "GlobalClusterNotFoundFault":
    case "rds.admin#GlobalClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryGlobalClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidGlobalClusterStateFault":
    case "rds.admin#InvalidGlobalClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidGlobalClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryModifyOptionGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyOptionGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryModifyOptionGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryModifyOptionGroupResult(
    data.ModifyOptionGroupResult,
    context
  );
  const response: ModifyOptionGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyOptionGroupResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryModifyOptionGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyOptionGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidOptionGroupStateFault":
    case "rds.admin#InvalidOptionGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidOptionGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryPromoteReadReplicaCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PromoteReadReplicaCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryPromoteReadReplicaCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryPromoteReadReplicaResult(
    data.PromoteReadReplicaResult,
    context
  );
  const response: PromoteReadReplicaCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PromoteReadReplicaResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryPromoteReadReplicaCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PromoteReadReplicaCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryPromoteReadReplicaDBClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PromoteReadReplicaDBClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryPromoteReadReplicaDBClusterCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryPromoteReadReplicaDBClusterResult(
    data.PromoteReadReplicaDBClusterResult,
    context
  );
  const response: PromoteReadReplicaDBClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PromoteReadReplicaDBClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryPromoteReadReplicaDBClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PromoteReadReplicaDBClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryPurchaseReservedDBInstancesOfferingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PurchaseReservedDBInstancesOfferingCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryPurchaseReservedDBInstancesOfferingCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryPurchaseReservedDBInstancesOfferingResult(
    data.PurchaseReservedDBInstancesOfferingResult,
    context
  );
  const response: PurchaseReservedDBInstancesOfferingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PurchaseReservedDBInstancesOfferingResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryPurchaseReservedDBInstancesOfferingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PurchaseReservedDBInstancesOfferingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ReservedDBInstanceAlreadyExistsFault":
    case "rds.admin#ReservedDBInstanceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryReservedDBInstanceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReservedDBInstanceQuotaExceededFault":
    case "rds.admin#ReservedDBInstanceQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryReservedDBInstanceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReservedDBInstancesOfferingNotFoundFault":
    case "rds.admin#ReservedDBInstancesOfferingNotFoundFault":
      response = {
        ...(await deserializeAws_queryReservedDBInstancesOfferingNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRebootDBInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootDBInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRebootDBInstanceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRebootDBInstanceResult(
    data.RebootDBInstanceResult,
    context
  );
  const response: RebootDBInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RebootDBInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRebootDBInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootDBInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRegisterDBProxyTargetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterDBProxyTargetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRegisterDBProxyTargetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRegisterDBProxyTargetsResponse(
    data.RegisterDBProxyTargetsResult,
    context
  );
  const response: RegisterDBProxyTargetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterDBProxyTargetsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRegisterDBProxyTargetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterDBProxyTargetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBProxyNotFoundFault":
    case "rds.admin#DBProxyNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBProxyTargetAlreadyRegisteredFault":
    case "rds.admin#DBProxyTargetAlreadyRegisteredFault":
      response = {
        ...(await deserializeAws_queryDBProxyTargetAlreadyRegisteredFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBProxyTargetGroupNotFoundFault":
    case "rds.admin#DBProxyTargetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBProxyTargetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRemoveFromGlobalClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveFromGlobalClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRemoveFromGlobalClusterCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRemoveFromGlobalClusterResult(
    data.RemoveFromGlobalClusterResult,
    context
  );
  const response: RemoveFromGlobalClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveFromGlobalClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRemoveFromGlobalClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveFromGlobalClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "GlobalClusterNotFoundFault":
    case "rds.admin#GlobalClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryGlobalClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidGlobalClusterStateFault":
    case "rds.admin#InvalidGlobalClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidGlobalClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRemoveRoleFromDBClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveRoleFromDBClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRemoveRoleFromDBClusterCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: RemoveRoleFromDBClusterCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRemoveRoleFromDBClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveRoleFromDBClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterRoleNotFoundFault":
    case "rds.admin#DBClusterRoleNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterRoleNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRemoveRoleFromDBInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveRoleFromDBInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRemoveRoleFromDBInstanceCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: RemoveRoleFromDBInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRemoveRoleFromDBInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveRoleFromDBInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceRoleNotFoundFault":
    case "rds.admin#DBInstanceRoleNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceRoleNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRemoveSourceIdentifierFromSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveSourceIdentifierFromSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRemoveSourceIdentifierFromSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRemoveSourceIdentifierFromSubscriptionResult(
    data.RemoveSourceIdentifierFromSubscriptionResult,
    context
  );
  const response: RemoveSourceIdentifierFromSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveSourceIdentifierFromSubscriptionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRemoveSourceIdentifierFromSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveSourceIdentifierFromSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "SourceNotFoundFault":
    case "rds.admin#SourceNotFoundFault":
      response = {
        ...(await deserializeAws_querySourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubscriptionNotFoundFault":
    case "rds.admin#SubscriptionNotFoundFault":
      response = {
        ...(await deserializeAws_querySubscriptionNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRemoveTagsFromResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRemoveTagsFromResourceCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: RemoveTagsFromResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRemoveTagsFromResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryResetDBClusterParameterGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetDBClusterParameterGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryResetDBClusterParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBClusterParameterGroupNameMessage(
    data.ResetDBClusterParameterGroupResult,
    context
  );
  const response: ResetDBClusterParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBClusterParameterGroupNameMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryResetDBClusterParameterGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetDBClusterParameterGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBParameterGroupStateFault":
    case "rds.admin#InvalidDBParameterGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBParameterGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryResetDBParameterGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetDBParameterGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryResetDBParameterGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryDBParameterGroupNameMessage(
    data.ResetDBParameterGroupResult,
    context
  );
  const response: ResetDBParameterGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DBParameterGroupNameMessage",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryResetDBParameterGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetDBParameterGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBParameterGroupStateFault":
    case "rds.admin#InvalidDBParameterGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBParameterGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRestoreDBClusterFromS3Command = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBClusterFromS3CommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRestoreDBClusterFromS3CommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRestoreDBClusterFromS3Result(
    data.RestoreDBClusterFromS3Result,
    context
  );
  const response: RestoreDBClusterFromS3CommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreDBClusterFromS3Result",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRestoreDBClusterFromS3CommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBClusterFromS3CommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterAlreadyExistsFault":
    case "rds.admin#DBClusterAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBClusterAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterParameterGroupNotFoundFault":
    case "rds.admin#DBClusterParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterQuotaExceededFault":
    case "rds.admin#DBClusterQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBClusterQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DomainNotFoundFault":
    case "rds.admin#DomainNotFoundFault":
      response = {
        ...(await deserializeAws_queryDomainNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientStorageClusterCapacityFault":
    case "rds.admin#InsufficientStorageClusterCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientStorageClusterCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSubnetGroupStateFault":
    case "rds.admin#InvalidDBSubnetGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSubnetGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidS3BucketFault":
    case "rds.admin#InvalidS3BucketFault":
      response = {
        ...(await deserializeAws_queryInvalidS3BucketFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRestoreDBClusterFromSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBClusterFromSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRestoreDBClusterFromSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRestoreDBClusterFromSnapshotResult(
    data.RestoreDBClusterFromSnapshotResult,
    context
  );
  const response: RestoreDBClusterFromSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreDBClusterFromSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRestoreDBClusterFromSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBClusterFromSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterAlreadyExistsFault":
    case "rds.admin#DBClusterAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBClusterAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterParameterGroupNotFoundFault":
    case "rds.admin#DBClusterParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterQuotaExceededFault":
    case "rds.admin#DBClusterQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBClusterQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterSnapshotNotFoundFault":
    case "rds.admin#DBClusterSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DomainNotFoundFault":
    case "rds.admin#DomainNotFoundFault":
      response = {
        ...(await deserializeAws_queryDomainNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientDBClusterCapacityFault":
    case "rds.admin#InsufficientDBClusterCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientDBClusterCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientStorageClusterCapacityFault":
    case "rds.admin#InsufficientStorageClusterCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientStorageClusterCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterSnapshotStateFault":
    case "rds.admin#InvalidDBClusterSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSnapshotStateFault":
    case "rds.admin#InvalidDBSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRestoreFault":
    case "rds.admin#InvalidRestoreFault":
      response = {
        ...(await deserializeAws_queryInvalidRestoreFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRestoreDBClusterToPointInTimeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBClusterToPointInTimeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRestoreDBClusterToPointInTimeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRestoreDBClusterToPointInTimeResult(
    data.RestoreDBClusterToPointInTimeResult,
    context
  );
  const response: RestoreDBClusterToPointInTimeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreDBClusterToPointInTimeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRestoreDBClusterToPointInTimeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBClusterToPointInTimeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterAlreadyExistsFault":
    case "rds.admin#DBClusterAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBClusterAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterParameterGroupNotFoundFault":
    case "rds.admin#DBClusterParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterQuotaExceededFault":
    case "rds.admin#DBClusterQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryDBClusterQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterSnapshotNotFoundFault":
    case "rds.admin#DBClusterSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DomainNotFoundFault":
    case "rds.admin#DomainNotFoundFault":
      response = {
        ...(await deserializeAws_queryDomainNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientDBClusterCapacityFault":
    case "rds.admin#InsufficientDBClusterCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientDBClusterCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientStorageClusterCapacityFault":
    case "rds.admin#InsufficientStorageClusterCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientStorageClusterCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterSnapshotStateFault":
    case "rds.admin#InvalidDBClusterSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSnapshotStateFault":
    case "rds.admin#InvalidDBSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRestoreFault":
    case "rds.admin#InvalidRestoreFault":
      response = {
        ...(await deserializeAws_queryInvalidRestoreFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRestoreDBInstanceFromDBSnapshotCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBInstanceFromDBSnapshotCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRestoreDBInstanceFromDBSnapshotCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRestoreDBInstanceFromDBSnapshotResult(
    data.RestoreDBInstanceFromDBSnapshotResult,
    context
  );
  const response: RestoreDBInstanceFromDBSnapshotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreDBInstanceFromDBSnapshotResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRestoreDBInstanceFromDBSnapshotCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBInstanceFromDBSnapshotCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationNotFoundFault":
    case "rds.admin#AuthorizationNotFoundFault":
      response = {
        ...(await deserializeAws_queryAuthorizationNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BackupPolicyNotFoundFault":
    case "rds.admin#BackupPolicyNotFoundFault":
      response = {
        ...(await deserializeAws_queryBackupPolicyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceAlreadyExistsFault":
    case "rds.admin#DBInstanceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBInstanceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSecurityGroupNotFoundFault":
    case "rds.admin#DBSecurityGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSnapshotNotFoundFault":
    case "rds.admin#DBSnapshotNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupDoesNotCoverEnoughAZs":
    case "rds.admin#DBSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DomainNotFoundFault":
    case "rds.admin#DomainNotFoundFault":
      response = {
        ...(await deserializeAws_queryDomainNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InstanceQuotaExceededFault":
    case "rds.admin#InstanceQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryInstanceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientDBInstanceCapacityFault":
    case "rds.admin#InsufficientDBInstanceCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientDBInstanceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSnapshotStateFault":
    case "rds.admin#InvalidDBSnapshotStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSnapshotStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRestoreFault":
    case "rds.admin#InvalidRestoreFault":
      response = {
        ...(await deserializeAws_queryInvalidRestoreFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ProvisionedIopsNotAvailableInAZFault":
    case "rds.admin#ProvisionedIopsNotAvailableInAZFault":
      response = {
        ...(await deserializeAws_queryProvisionedIopsNotAvailableInAZFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageTypeNotSupportedFault":
    case "rds.admin#StorageTypeNotSupportedFault":
      response = {
        ...(await deserializeAws_queryStorageTypeNotSupportedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRestoreDBInstanceFromS3Command = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBInstanceFromS3CommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRestoreDBInstanceFromS3CommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRestoreDBInstanceFromS3Result(
    data.RestoreDBInstanceFromS3Result,
    context
  );
  const response: RestoreDBInstanceFromS3CommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreDBInstanceFromS3Result",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRestoreDBInstanceFromS3CommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBInstanceFromS3CommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationNotFoundFault":
    case "rds.admin#AuthorizationNotFoundFault":
      response = {
        ...(await deserializeAws_queryAuthorizationNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BackupPolicyNotFoundFault":
    case "rds.admin#BackupPolicyNotFoundFault":
      response = {
        ...(await deserializeAws_queryBackupPolicyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceAlreadyExistsFault":
    case "rds.admin#DBInstanceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBInstanceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSecurityGroupNotFoundFault":
    case "rds.admin#DBSecurityGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupDoesNotCoverEnoughAZs":
    case "rds.admin#DBSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InstanceQuotaExceededFault":
    case "rds.admin#InstanceQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryInstanceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientDBInstanceCapacityFault":
    case "rds.admin#InsufficientDBInstanceCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientDBInstanceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidS3BucketFault":
    case "rds.admin#InvalidS3BucketFault":
      response = {
        ...(await deserializeAws_queryInvalidS3BucketFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ProvisionedIopsNotAvailableInAZFault":
    case "rds.admin#ProvisionedIopsNotAvailableInAZFault":
      response = {
        ...(await deserializeAws_queryProvisionedIopsNotAvailableInAZFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageTypeNotSupportedFault":
    case "rds.admin#StorageTypeNotSupportedFault":
      response = {
        ...(await deserializeAws_queryStorageTypeNotSupportedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRestoreDBInstanceToPointInTimeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBInstanceToPointInTimeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRestoreDBInstanceToPointInTimeCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRestoreDBInstanceToPointInTimeResult(
    data.RestoreDBInstanceToPointInTimeResult,
    context
  );
  const response: RestoreDBInstanceToPointInTimeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestoreDBInstanceToPointInTimeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRestoreDBInstanceToPointInTimeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestoreDBInstanceToPointInTimeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationNotFoundFault":
    case "rds.admin#AuthorizationNotFoundFault":
      response = {
        ...(await deserializeAws_queryAuthorizationNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BackupPolicyNotFoundFault":
    case "rds.admin#BackupPolicyNotFoundFault":
      response = {
        ...(await deserializeAws_queryBackupPolicyNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceAlreadyExistsFault":
    case "rds.admin#DBInstanceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBInstanceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceAutomatedBackupNotFoundFault":
    case "rds.admin#DBInstanceAutomatedBackupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceAutomatedBackupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBParameterGroupNotFoundFault":
    case "rds.admin#DBParameterGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBParameterGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSecurityGroupNotFoundFault":
    case "rds.admin#DBSecurityGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupDoesNotCoverEnoughAZs":
    case "rds.admin#DBSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DomainNotFoundFault":
    case "rds.admin#DomainNotFoundFault":
      response = {
        ...(await deserializeAws_queryDomainNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InstanceQuotaExceededFault":
    case "rds.admin#InstanceQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryInstanceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientDBInstanceCapacityFault":
    case "rds.admin#InsufficientDBInstanceCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientDBInstanceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRestoreFault":
    case "rds.admin#InvalidRestoreFault":
      response = {
        ...(await deserializeAws_queryInvalidRestoreFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "OptionGroupNotFoundFault":
    case "rds.admin#OptionGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryOptionGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PointInTimeRestoreNotEnabledFault":
    case "rds.admin#PointInTimeRestoreNotEnabledFault":
      response = {
        ...(await deserializeAws_queryPointInTimeRestoreNotEnabledFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ProvisionedIopsNotAvailableInAZFault":
    case "rds.admin#ProvisionedIopsNotAvailableInAZFault":
      response = {
        ...(await deserializeAws_queryProvisionedIopsNotAvailableInAZFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "rds.admin#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_queryStorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageTypeNotSupportedFault":
    case "rds.admin#StorageTypeNotSupportedFault":
      response = {
        ...(await deserializeAws_queryStorageTypeNotSupportedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryRevokeDBSecurityGroupIngressCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeDBSecurityGroupIngressCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryRevokeDBSecurityGroupIngressCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryRevokeDBSecurityGroupIngressResult(
    data.RevokeDBSecurityGroupIngressResult,
    context
  );
  const response: RevokeDBSecurityGroupIngressCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RevokeDBSecurityGroupIngressResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryRevokeDBSecurityGroupIngressCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RevokeDBSecurityGroupIngressCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationNotFoundFault":
    case "rds.admin#AuthorizationNotFoundFault":
      response = {
        ...(await deserializeAws_queryAuthorizationNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSecurityGroupNotFoundFault":
    case "rds.admin#DBSecurityGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSecurityGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBSecurityGroupStateFault":
    case "rds.admin#InvalidDBSecurityGroupStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBSecurityGroupStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryStartActivityStreamCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartActivityStreamCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryStartActivityStreamCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryStartActivityStreamResponse(
    data.StartActivityStreamResult,
    context
  );
  const response: StartActivityStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartActivityStreamResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryStartActivityStreamCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartActivityStreamCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "rds.admin#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_queryResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryStartDBClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDBClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryStartDBClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryStartDBClusterResult(
    data.StartDBClusterResult,
    context
  );
  const response: StartDBClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartDBClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryStartDBClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDBClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryStartDBInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDBInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryStartDBInstanceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryStartDBInstanceResult(
    data.StartDBInstanceResult,
    context
  );
  const response: StartDBInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartDBInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryStartDBInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDBInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AuthorizationNotFoundFault":
    case "rds.admin#AuthorizationNotFoundFault":
      response = {
        ...(await deserializeAws_queryAuthorizationNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupDoesNotCoverEnoughAZs":
    case "rds.admin#DBSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSubnetGroupNotFoundFault":
    case "rds.admin#DBSubnetGroupNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBSubnetGroupNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientDBInstanceCapacityFault":
    case "rds.admin#InsufficientDBInstanceCapacityFault":
      response = {
        ...(await deserializeAws_queryInsufficientDBInstanceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "rds.admin#InvalidSubnet":
      response = {
        ...(await deserializeAws_queryInvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCNetworkStateFault":
    case "rds.admin#InvalidVPCNetworkStateFault":
      response = {
        ...(await deserializeAws_queryInvalidVPCNetworkStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "rds.admin#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_queryKMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryStopActivityStreamCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopActivityStreamCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryStopActivityStreamCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryStopActivityStreamResponse(
    data.StopActivityStreamResult,
    context
  );
  const response: StopActivityStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopActivityStreamResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryStopActivityStreamCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopActivityStreamCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "rds.admin#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_queryResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryStopDBClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopDBClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryStopDBClusterCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryStopDBClusterResult(
    data.StopDBClusterResult,
    context
  );
  const response: StopDBClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopDBClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryStopDBClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopDBClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBClusterNotFoundFault":
    case "rds.admin#DBClusterNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBClusterNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_queryStopDBInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopDBInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_queryStopDBInstanceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_queryStopDBInstanceResult(
    data.StopDBInstanceResult,
    context
  );
  const response: StopDBInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopDBInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_queryStopDBInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopDBInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadQueryErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DBInstanceNotFoundFault":
    case "rds.admin#DBInstanceNotFoundFault":
      response = {
        ...(await deserializeAws_queryDBInstanceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DBSnapshotAlreadyExistsFault":
    case "rds.admin#DBSnapshotAlreadyExistsFault":
      response = {
        ...(await deserializeAws_queryDBSnapshotAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBClusterStateFault":
    case "rds.admin#InvalidDBClusterStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBClusterStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDBInstanceStateFault":
    case "rds.admin#InvalidDBInstanceStateFault":
      response = {
        ...(await deserializeAws_queryInvalidDBInstanceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SnapshotQuotaExceededFault":
    case "rds.admin#SnapshotQuotaExceededFault":
      response = {
        ...(await deserializeAws_querySnapshotQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_queryAuthorizationAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AuthorizationAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryAuthorizationAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: AuthorizationAlreadyExistsFault = {
    name: "AuthorizationAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryAuthorizationNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AuthorizationNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryAuthorizationNotFoundFault(
    body.Error,
    context
  );
  const contents: AuthorizationNotFoundFault = {
    name: "AuthorizationNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryAuthorizationQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AuthorizationQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryAuthorizationQuotaExceededFault(
    body.Error,
    context
  );
  const contents: AuthorizationQuotaExceededFault = {
    name: "AuthorizationQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryBackupPolicyNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<BackupPolicyNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryBackupPolicyNotFoundFault(
    body.Error,
    context
  );
  const contents: BackupPolicyNotFoundFault = {
    name: "BackupPolicyNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryCertificateNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CertificateNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryCertificateNotFoundFault(
    body.Error,
    context
  );
  const contents: CertificateNotFoundFault = {
    name: "CertificateNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryCustomAvailabilityZoneAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CustomAvailabilityZoneAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryCustomAvailabilityZoneAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: CustomAvailabilityZoneAlreadyExistsFault = {
    name: "CustomAvailabilityZoneAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryCustomAvailabilityZoneNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CustomAvailabilityZoneNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryCustomAvailabilityZoneNotFoundFault(
    body.Error,
    context
  );
  const contents: CustomAvailabilityZoneNotFoundFault = {
    name: "CustomAvailabilityZoneNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryCustomAvailabilityZoneQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CustomAvailabilityZoneQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryCustomAvailabilityZoneQuotaExceededFault(
    body.Error,
    context
  );
  const contents: CustomAvailabilityZoneQuotaExceededFault = {
    name: "CustomAvailabilityZoneQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBClusterAlreadyExistsFault = {
    name: "DBClusterAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterBacktrackNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterBacktrackNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterBacktrackNotFoundFault(
    body.Error,
    context
  );
  const contents: DBClusterBacktrackNotFoundFault = {
    name: "DBClusterBacktrackNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterEndpointAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterEndpointAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterEndpointAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBClusterEndpointAlreadyExistsFault = {
    name: "DBClusterEndpointAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterEndpointNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterEndpointNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterEndpointNotFoundFault(
    body.Error,
    context
  );
  const contents: DBClusterEndpointNotFoundFault = {
    name: "DBClusterEndpointNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterEndpointQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterEndpointQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterEndpointQuotaExceededFault(
    body.Error,
    context
  );
  const contents: DBClusterEndpointQuotaExceededFault = {
    name: "DBClusterEndpointQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterNotFoundFault(
    body.Error,
    context
  );
  const contents: DBClusterNotFoundFault = {
    name: "DBClusterNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterParameterGroupNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterParameterGroupNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterParameterGroupNotFoundFault(
    body.Error,
    context
  );
  const contents: DBClusterParameterGroupNotFoundFault = {
    name: "DBClusterParameterGroupNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterQuotaExceededFault(
    body.Error,
    context
  );
  const contents: DBClusterQuotaExceededFault = {
    name: "DBClusterQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterRoleAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterRoleAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterRoleAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBClusterRoleAlreadyExistsFault = {
    name: "DBClusterRoleAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterRoleNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterRoleNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterRoleNotFoundFault(
    body.Error,
    context
  );
  const contents: DBClusterRoleNotFoundFault = {
    name: "DBClusterRoleNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterRoleQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterRoleQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterRoleQuotaExceededFault(
    body.Error,
    context
  );
  const contents: DBClusterRoleQuotaExceededFault = {
    name: "DBClusterRoleQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterSnapshotAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterSnapshotAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterSnapshotAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBClusterSnapshotAlreadyExistsFault = {
    name: "DBClusterSnapshotAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBClusterSnapshotNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBClusterSnapshotNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBClusterSnapshotNotFoundFault(
    body.Error,
    context
  );
  const contents: DBClusterSnapshotNotFoundFault = {
    name: "DBClusterSnapshotNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBInstanceAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBInstanceAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBInstanceAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBInstanceAlreadyExistsFault = {
    name: "DBInstanceAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBInstanceAutomatedBackupNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBInstanceAutomatedBackupNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBInstanceAutomatedBackupNotFoundFault(
    body.Error,
    context
  );
  const contents: DBInstanceAutomatedBackupNotFoundFault = {
    name: "DBInstanceAutomatedBackupNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBInstanceAutomatedBackupQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBInstanceAutomatedBackupQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBInstanceAutomatedBackupQuotaExceededFault(
    body.Error,
    context
  );
  const contents: DBInstanceAutomatedBackupQuotaExceededFault = {
    name: "DBInstanceAutomatedBackupQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBInstanceNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBInstanceNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBInstanceNotFoundFault(
    body.Error,
    context
  );
  const contents: DBInstanceNotFoundFault = {
    name: "DBInstanceNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBInstanceRoleAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBInstanceRoleAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBInstanceRoleAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBInstanceRoleAlreadyExistsFault = {
    name: "DBInstanceRoleAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBInstanceRoleNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBInstanceRoleNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBInstanceRoleNotFoundFault(
    body.Error,
    context
  );
  const contents: DBInstanceRoleNotFoundFault = {
    name: "DBInstanceRoleNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBInstanceRoleQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBInstanceRoleQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBInstanceRoleQuotaExceededFault(
    body.Error,
    context
  );
  const contents: DBInstanceRoleQuotaExceededFault = {
    name: "DBInstanceRoleQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBLogFileNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBLogFileNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBLogFileNotFoundFault(
    body.Error,
    context
  );
  const contents: DBLogFileNotFoundFault = {
    name: "DBLogFileNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBParameterGroupAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBParameterGroupAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBParameterGroupAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBParameterGroupAlreadyExistsFault = {
    name: "DBParameterGroupAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBParameterGroupNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBParameterGroupNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBParameterGroupNotFoundFault(
    body.Error,
    context
  );
  const contents: DBParameterGroupNotFoundFault = {
    name: "DBParameterGroupNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBParameterGroupQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBParameterGroupQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBParameterGroupQuotaExceededFault(
    body.Error,
    context
  );
  const contents: DBParameterGroupQuotaExceededFault = {
    name: "DBParameterGroupQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBProxyAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBProxyAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBProxyAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBProxyAlreadyExistsFault = {
    name: "DBProxyAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBProxyNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBProxyNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBProxyNotFoundFault(
    body.Error,
    context
  );
  const contents: DBProxyNotFoundFault = {
    name: "DBProxyNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBProxyQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBProxyQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBProxyQuotaExceededFault(
    body.Error,
    context
  );
  const contents: DBProxyQuotaExceededFault = {
    name: "DBProxyQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBProxyTargetAlreadyRegisteredFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBProxyTargetAlreadyRegisteredFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBProxyTargetAlreadyRegisteredFault(
    body.Error,
    context
  );
  const contents: DBProxyTargetAlreadyRegisteredFault = {
    name: "DBProxyTargetAlreadyRegisteredFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBProxyTargetGroupNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBProxyTargetGroupNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBProxyTargetGroupNotFoundFault(
    body.Error,
    context
  );
  const contents: DBProxyTargetGroupNotFoundFault = {
    name: "DBProxyTargetGroupNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBProxyTargetNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBProxyTargetNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBProxyTargetNotFoundFault(
    body.Error,
    context
  );
  const contents: DBProxyTargetNotFoundFault = {
    name: "DBProxyTargetNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSecurityGroupAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSecurityGroupAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSecurityGroupAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBSecurityGroupAlreadyExistsFault = {
    name: "DBSecurityGroupAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSecurityGroupNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSecurityGroupNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSecurityGroupNotFoundFault(
    body.Error,
    context
  );
  const contents: DBSecurityGroupNotFoundFault = {
    name: "DBSecurityGroupNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSecurityGroupNotSupportedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSecurityGroupNotSupportedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSecurityGroupNotSupportedFault(
    body.Error,
    context
  );
  const contents: DBSecurityGroupNotSupportedFault = {
    name: "DBSecurityGroupNotSupportedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSecurityGroupQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSecurityGroupQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSecurityGroupQuotaExceededFault(
    body.Error,
    context
  );
  const contents: DBSecurityGroupQuotaExceededFault = {
    name: "DBSecurityGroupQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSnapshotAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSnapshotAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSnapshotAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBSnapshotAlreadyExistsFault = {
    name: "DBSnapshotAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSnapshotNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSnapshotNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSnapshotNotFoundFault(
    body.Error,
    context
  );
  const contents: DBSnapshotNotFoundFault = {
    name: "DBSnapshotNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSubnetGroupAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSubnetGroupAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSubnetGroupAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: DBSubnetGroupAlreadyExistsFault = {
    name: "DBSubnetGroupAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSubnetGroupDoesNotCoverEnoughAZs> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZs(
    body.Error,
    context
  );
  const contents: DBSubnetGroupDoesNotCoverEnoughAZs = {
    name: "DBSubnetGroupDoesNotCoverEnoughAZs",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSubnetGroupNotAllowedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSubnetGroupNotAllowedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSubnetGroupNotAllowedFault(
    body.Error,
    context
  );
  const contents: DBSubnetGroupNotAllowedFault = {
    name: "DBSubnetGroupNotAllowedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSubnetGroupNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSubnetGroupNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSubnetGroupNotFoundFault(
    body.Error,
    context
  );
  const contents: DBSubnetGroupNotFoundFault = {
    name: "DBSubnetGroupNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSubnetGroupQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSubnetGroupQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSubnetGroupQuotaExceededFault(
    body.Error,
    context
  );
  const contents: DBSubnetGroupQuotaExceededFault = {
    name: "DBSubnetGroupQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBSubnetQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBSubnetQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBSubnetQuotaExceededFault(
    body.Error,
    context
  );
  const contents: DBSubnetQuotaExceededFault = {
    name: "DBSubnetQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDBUpgradeDependencyFailureFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DBUpgradeDependencyFailureFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDBUpgradeDependencyFailureFault(
    body.Error,
    context
  );
  const contents: DBUpgradeDependencyFailureFault = {
    name: "DBUpgradeDependencyFailureFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryDomainNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DomainNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryDomainNotFoundFault(
    body.Error,
    context
  );
  const contents: DomainNotFoundFault = {
    name: "DomainNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryEventSubscriptionQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<EventSubscriptionQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryEventSubscriptionQuotaExceededFault(
    body.Error,
    context
  );
  const contents: EventSubscriptionQuotaExceededFault = {
    name: "EventSubscriptionQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryGlobalClusterAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<GlobalClusterAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryGlobalClusterAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: GlobalClusterAlreadyExistsFault = {
    name: "GlobalClusterAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryGlobalClusterNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<GlobalClusterNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryGlobalClusterNotFoundFault(
    body.Error,
    context
  );
  const contents: GlobalClusterNotFoundFault = {
    name: "GlobalClusterNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryGlobalClusterQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<GlobalClusterQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryGlobalClusterQuotaExceededFault(
    body.Error,
    context
  );
  const contents: GlobalClusterQuotaExceededFault = {
    name: "GlobalClusterQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInstallationMediaAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InstallationMediaAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInstallationMediaAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: InstallationMediaAlreadyExistsFault = {
    name: "InstallationMediaAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInstallationMediaNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InstallationMediaNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInstallationMediaNotFoundFault(
    body.Error,
    context
  );
  const contents: InstallationMediaNotFoundFault = {
    name: "InstallationMediaNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInstanceQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InstanceQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInstanceQuotaExceededFault(
    body.Error,
    context
  );
  const contents: InstanceQuotaExceededFault = {
    name: "InstanceQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInsufficientDBClusterCapacityFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InsufficientDBClusterCapacityFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInsufficientDBClusterCapacityFault(
    body.Error,
    context
  );
  const contents: InsufficientDBClusterCapacityFault = {
    name: "InsufficientDBClusterCapacityFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInsufficientDBInstanceCapacityFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InsufficientDBInstanceCapacityFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInsufficientDBInstanceCapacityFault(
    body.Error,
    context
  );
  const contents: InsufficientDBInstanceCapacityFault = {
    name: "InsufficientDBInstanceCapacityFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInsufficientStorageClusterCapacityFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InsufficientStorageClusterCapacityFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInsufficientStorageClusterCapacityFault(
    body.Error,
    context
  );
  const contents: InsufficientStorageClusterCapacityFault = {
    name: "InsufficientStorageClusterCapacityFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBClusterCapacityFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBClusterCapacityFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBClusterCapacityFault(
    body.Error,
    context
  );
  const contents: InvalidDBClusterCapacityFault = {
    name: "InvalidDBClusterCapacityFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBClusterEndpointStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBClusterEndpointStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBClusterEndpointStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBClusterEndpointStateFault = {
    name: "InvalidDBClusterEndpointStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBClusterSnapshotStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBClusterSnapshotStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBClusterSnapshotStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBClusterSnapshotStateFault = {
    name: "InvalidDBClusterSnapshotStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBClusterStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBClusterStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBClusterStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBClusterStateFault = {
    name: "InvalidDBClusterStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBInstanceAutomatedBackupStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBInstanceAutomatedBackupStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBInstanceAutomatedBackupStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBInstanceAutomatedBackupStateFault = {
    name: "InvalidDBInstanceAutomatedBackupStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBInstanceStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBInstanceStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBInstanceStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBInstanceStateFault = {
    name: "InvalidDBInstanceStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBParameterGroupStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBParameterGroupStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBParameterGroupStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBParameterGroupStateFault = {
    name: "InvalidDBParameterGroupStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBProxyStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBProxyStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBProxyStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBProxyStateFault = {
    name: "InvalidDBProxyStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBSecurityGroupStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBSecurityGroupStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBSecurityGroupStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBSecurityGroupStateFault = {
    name: "InvalidDBSecurityGroupStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBSnapshotStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBSnapshotStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBSnapshotStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBSnapshotStateFault = {
    name: "InvalidDBSnapshotStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBSubnetGroupFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBSubnetGroupFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBSubnetGroupFault(
    body.Error,
    context
  );
  const contents: InvalidDBSubnetGroupFault = {
    name: "InvalidDBSubnetGroupFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBSubnetGroupStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBSubnetGroupStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBSubnetGroupStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBSubnetGroupStateFault = {
    name: "InvalidDBSubnetGroupStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidDBSubnetStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDBSubnetStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidDBSubnetStateFault(
    body.Error,
    context
  );
  const contents: InvalidDBSubnetStateFault = {
    name: "InvalidDBSubnetStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidEventSubscriptionStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidEventSubscriptionStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidEventSubscriptionStateFault(
    body.Error,
    context
  );
  const contents: InvalidEventSubscriptionStateFault = {
    name: "InvalidEventSubscriptionStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidGlobalClusterStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidGlobalClusterStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidGlobalClusterStateFault(
    body.Error,
    context
  );
  const contents: InvalidGlobalClusterStateFault = {
    name: "InvalidGlobalClusterStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidOptionGroupStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidOptionGroupStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidOptionGroupStateFault(
    body.Error,
    context
  );
  const contents: InvalidOptionGroupStateFault = {
    name: "InvalidOptionGroupStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidRestoreFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRestoreFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidRestoreFault(
    body.Error,
    context
  );
  const contents: InvalidRestoreFault = {
    name: "InvalidRestoreFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidS3BucketFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidS3BucketFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidS3BucketFault(
    body.Error,
    context
  );
  const contents: InvalidS3BucketFault = {
    name: "InvalidS3BucketFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidSubnetResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSubnet> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidSubnet(
    body.Error,
    context
  );
  const contents: InvalidSubnet = {
    name: "InvalidSubnet",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryInvalidVPCNetworkStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidVPCNetworkStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryInvalidVPCNetworkStateFault(
    body.Error,
    context
  );
  const contents: InvalidVPCNetworkStateFault = {
    name: "InvalidVPCNetworkStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryKMSKeyNotAccessibleFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSKeyNotAccessibleFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryKMSKeyNotAccessibleFault(
    body.Error,
    context
  );
  const contents: KMSKeyNotAccessibleFault = {
    name: "KMSKeyNotAccessibleFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryOptionGroupAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OptionGroupAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryOptionGroupAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: OptionGroupAlreadyExistsFault = {
    name: "OptionGroupAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryOptionGroupNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OptionGroupNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryOptionGroupNotFoundFault(
    body.Error,
    context
  );
  const contents: OptionGroupNotFoundFault = {
    name: "OptionGroupNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryOptionGroupQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<OptionGroupQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryOptionGroupQuotaExceededFault(
    body.Error,
    context
  );
  const contents: OptionGroupQuotaExceededFault = {
    name: "OptionGroupQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryPointInTimeRestoreNotEnabledFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PointInTimeRestoreNotEnabledFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryPointInTimeRestoreNotEnabledFault(
    body.Error,
    context
  );
  const contents: PointInTimeRestoreNotEnabledFault = {
    name: "PointInTimeRestoreNotEnabledFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryProvisionedIopsNotAvailableInAZFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ProvisionedIopsNotAvailableInAZFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryProvisionedIopsNotAvailableInAZFault(
    body.Error,
    context
  );
  const contents: ProvisionedIopsNotAvailableInAZFault = {
    name: "ProvisionedIopsNotAvailableInAZFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryReservedDBInstanceAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReservedDBInstanceAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryReservedDBInstanceAlreadyExistsFault(
    body.Error,
    context
  );
  const contents: ReservedDBInstanceAlreadyExistsFault = {
    name: "ReservedDBInstanceAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryReservedDBInstanceNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReservedDBInstanceNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryReservedDBInstanceNotFoundFault(
    body.Error,
    context
  );
  const contents: ReservedDBInstanceNotFoundFault = {
    name: "ReservedDBInstanceNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryReservedDBInstanceQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReservedDBInstanceQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryReservedDBInstanceQuotaExceededFault(
    body.Error,
    context
  );
  const contents: ReservedDBInstanceQuotaExceededFault = {
    name: "ReservedDBInstanceQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryReservedDBInstancesOfferingNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReservedDBInstancesOfferingNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryReservedDBInstancesOfferingNotFoundFault(
    body.Error,
    context
  );
  const contents: ReservedDBInstancesOfferingNotFoundFault = {
    name: "ReservedDBInstancesOfferingNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryResourceNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryResourceNotFoundFault(
    body.Error,
    context
  );
  const contents: ResourceNotFoundFault = {
    name: "ResourceNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySNSInvalidTopicFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SNSInvalidTopicFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySNSInvalidTopicFault(
    body.Error,
    context
  );
  const contents: SNSInvalidTopicFault = {
    name: "SNSInvalidTopicFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySNSNoAuthorizationFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SNSNoAuthorizationFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySNSNoAuthorizationFault(
    body.Error,
    context
  );
  const contents: SNSNoAuthorizationFault = {
    name: "SNSNoAuthorizationFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySNSTopicArnNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SNSTopicArnNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySNSTopicArnNotFoundFault(
    body.Error,
    context
  );
  const contents: SNSTopicArnNotFoundFault = {
    name: "SNSTopicArnNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySharedSnapshotQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SharedSnapshotQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySharedSnapshotQuotaExceededFault(
    body.Error,
    context
  );
  const contents: SharedSnapshotQuotaExceededFault = {
    name: "SharedSnapshotQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySnapshotQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SnapshotQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySnapshotQuotaExceededFault(
    body.Error,
    context
  );
  const contents: SnapshotQuotaExceededFault = {
    name: "SnapshotQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySourceNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SourceNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySourceNotFoundFault(
    body.Error,
    context
  );
  const contents: SourceNotFoundFault = {
    name: "SourceNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryStorageQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<StorageQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryStorageQuotaExceededFault(
    body.Error,
    context
  );
  const contents: StorageQuotaExceededFault = {
    name: "StorageQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_queryStorageTypeNotSupportedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<StorageTypeNotSupportedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_queryStorageTypeNotSupportedFault(
    body.Error,
    context
  );
  const contents: StorageTypeNotSupportedFault = {
    name: "StorageTypeNotSupportedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySubnetAlreadyInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubnetAlreadyInUse> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySubnetAlreadyInUse(
    body.Error,
    context
  );
  const contents: SubnetAlreadyInUse = {
    name: "SubnetAlreadyInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySubscriptionAlreadyExistFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubscriptionAlreadyExistFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySubscriptionAlreadyExistFault(
    body.Error,
    context
  );
  const contents: SubscriptionAlreadyExistFault = {
    name: "SubscriptionAlreadyExistFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySubscriptionCategoryNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubscriptionCategoryNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySubscriptionCategoryNotFoundFault(
    body.Error,
    context
  );
  const contents: SubscriptionCategoryNotFoundFault = {
    name: "SubscriptionCategoryNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_querySubscriptionNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubscriptionNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_querySubscriptionNotFoundFault(
    body.Error,
    context
  );
  const contents: SubscriptionNotFoundFault = {
    name: "SubscriptionNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_queryAddRoleToDBClusterMessage = (
  input: AddRoleToDBClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.FeatureName !== undefined) {
    entries["FeatureName"] = input.FeatureName;
  }
  if (input.RoleArn !== undefined) {
    entries["RoleArn"] = input.RoleArn;
  }
  return entries;
};

const serializeAws_queryAddRoleToDBInstanceMessage = (
  input: AddRoleToDBInstanceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.FeatureName !== undefined) {
    entries["FeatureName"] = input.FeatureName;
  }
  if (input.RoleArn !== undefined) {
    entries["RoleArn"] = input.RoleArn;
  }
  return entries;
};

const serializeAws_queryAddSourceIdentifierToSubscriptionMessage = (
  input: AddSourceIdentifierToSubscriptionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.SourceIdentifier !== undefined) {
    entries["SourceIdentifier"] = input.SourceIdentifier;
  }
  if (input.SubscriptionName !== undefined) {
    entries["SubscriptionName"] = input.SubscriptionName;
  }
  return entries;
};

const serializeAws_queryAddTagsToResourceMessage = (
  input: AddTagsToResourceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ResourceName !== undefined) {
    entries["ResourceName"] = input.ResourceName;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryApplyPendingMaintenanceActionMessage = (
  input: ApplyPendingMaintenanceActionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ApplyAction !== undefined) {
    entries["ApplyAction"] = input.ApplyAction;
  }
  if (input.OptInType !== undefined) {
    entries["OptInType"] = input.OptInType;
  }
  if (input.ResourceIdentifier !== undefined) {
    entries["ResourceIdentifier"] = input.ResourceIdentifier;
  }
  return entries;
};

const serializeAws_queryAttributeValueList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`AttributeValue.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryAuthorizeDBSecurityGroupIngressMessage = (
  input: AuthorizeDBSecurityGroupIngressMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CIDRIP !== undefined) {
    entries["CIDRIP"] = input.CIDRIP;
  }
  if (input.DBSecurityGroupName !== undefined) {
    entries["DBSecurityGroupName"] = input.DBSecurityGroupName;
  }
  if (input.EC2SecurityGroupId !== undefined) {
    entries["EC2SecurityGroupId"] = input.EC2SecurityGroupId;
  }
  if (input.EC2SecurityGroupName !== undefined) {
    entries["EC2SecurityGroupName"] = input.EC2SecurityGroupName;
  }
  if (input.EC2SecurityGroupOwnerId !== undefined) {
    entries["EC2SecurityGroupOwnerId"] = input.EC2SecurityGroupOwnerId;
  }
  return entries;
};

const serializeAws_queryAvailabilityZones = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`AvailabilityZone.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryBacktrackDBClusterMessage = (
  input: BacktrackDBClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BacktrackTo !== undefined) {
    entries["BacktrackTo"] =
      input.BacktrackTo.toISOString().split(".")[0] + "Z";
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.Force !== undefined) {
    entries["Force"] = input.Force;
  }
  if (input.UseEarliestTimeOnPointInTimeUnavailable !== undefined) {
    entries["UseEarliestTimeOnPointInTimeUnavailable"] =
      input.UseEarliestTimeOnPointInTimeUnavailable;
  }
  return entries;
};

const serializeAws_queryCloudwatchLogsExportConfiguration = (
  input: CloudwatchLogsExportConfiguration,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DisableLogTypes !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.DisableLogTypes,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `DisableLogTypes.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.EnableLogTypes !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.EnableLogTypes,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EnableLogTypes.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryConnectionPoolConfiguration = (
  input: ConnectionPoolConfiguration,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ConnectionBorrowTimeout !== undefined) {
    entries["ConnectionBorrowTimeout"] = input.ConnectionBorrowTimeout;
  }
  if (input.InitQuery !== undefined) {
    entries["InitQuery"] = input.InitQuery;
  }
  if (input.MaxConnectionsPercent !== undefined) {
    entries["MaxConnectionsPercent"] = input.MaxConnectionsPercent;
  }
  if (input.MaxIdleConnectionsPercent !== undefined) {
    entries["MaxIdleConnectionsPercent"] = input.MaxIdleConnectionsPercent;
  }
  if (input.SessionPinningFilters !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.SessionPinningFilters,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SessionPinningFilters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCopyDBClusterParameterGroupMessage = (
  input: CopyDBClusterParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.SourceDBClusterParameterGroupIdentifier !== undefined) {
    entries["SourceDBClusterParameterGroupIdentifier"] =
      input.SourceDBClusterParameterGroupIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TargetDBClusterParameterGroupDescription !== undefined) {
    entries["TargetDBClusterParameterGroupDescription"] =
      input.TargetDBClusterParameterGroupDescription;
  }
  if (input.TargetDBClusterParameterGroupIdentifier !== undefined) {
    entries["TargetDBClusterParameterGroupIdentifier"] =
      input.TargetDBClusterParameterGroupIdentifier;
  }
  return entries;
};

const serializeAws_queryCopyDBClusterSnapshotMessage = (
  input: CopyDBClusterSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CopyTags !== undefined) {
    entries["CopyTags"] = input.CopyTags;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.PreSignedUrl !== undefined) {
    entries["PreSignedUrl"] = input.PreSignedUrl;
  }
  if (input.SourceDBClusterSnapshotIdentifier !== undefined) {
    entries["SourceDBClusterSnapshotIdentifier"] =
      input.SourceDBClusterSnapshotIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TargetDBClusterSnapshotIdentifier !== undefined) {
    entries["TargetDBClusterSnapshotIdentifier"] =
      input.TargetDBClusterSnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryCopyDBParameterGroupMessage = (
  input: CopyDBParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.SourceDBParameterGroupIdentifier !== undefined) {
    entries["SourceDBParameterGroupIdentifier"] =
      input.SourceDBParameterGroupIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TargetDBParameterGroupDescription !== undefined) {
    entries["TargetDBParameterGroupDescription"] =
      input.TargetDBParameterGroupDescription;
  }
  if (input.TargetDBParameterGroupIdentifier !== undefined) {
    entries["TargetDBParameterGroupIdentifier"] =
      input.TargetDBParameterGroupIdentifier;
  }
  return entries;
};

const serializeAws_queryCopyDBSnapshotMessage = (
  input: CopyDBSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CopyTags !== undefined) {
    entries["CopyTags"] = input.CopyTags;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.PreSignedUrl !== undefined) {
    entries["PreSignedUrl"] = input.PreSignedUrl;
  }
  if (input.SourceDBSnapshotIdentifier !== undefined) {
    entries["SourceDBSnapshotIdentifier"] = input.SourceDBSnapshotIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TargetDBSnapshotIdentifier !== undefined) {
    entries["TargetDBSnapshotIdentifier"] = input.TargetDBSnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryCopyOptionGroupMessage = (
  input: CopyOptionGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.SourceOptionGroupIdentifier !== undefined) {
    entries["SourceOptionGroupIdentifier"] = input.SourceOptionGroupIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TargetOptionGroupDescription !== undefined) {
    entries["TargetOptionGroupDescription"] =
      input.TargetOptionGroupDescription;
  }
  if (input.TargetOptionGroupIdentifier !== undefined) {
    entries["TargetOptionGroupIdentifier"] = input.TargetOptionGroupIdentifier;
  }
  return entries;
};

const serializeAws_queryCreateCustomAvailabilityZoneMessage = (
  input: CreateCustomAvailabilityZoneMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CustomAvailabilityZoneName !== undefined) {
    entries["CustomAvailabilityZoneName"] = input.CustomAvailabilityZoneName;
  }
  if (input.ExistingVpnId !== undefined) {
    entries["ExistingVpnId"] = input.ExistingVpnId;
  }
  if (input.NewVpnTunnelName !== undefined) {
    entries["NewVpnTunnelName"] = input.NewVpnTunnelName;
  }
  if (input.VpnTunnelOriginatorIP !== undefined) {
    entries["VpnTunnelOriginatorIP"] = input.VpnTunnelOriginatorIP;
  }
  return entries;
};

const serializeAws_queryCreateDBClusterEndpointMessage = (
  input: CreateDBClusterEndpointMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterEndpointIdentifier !== undefined) {
    entries["DBClusterEndpointIdentifier"] = input.DBClusterEndpointIdentifier;
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.EndpointType !== undefined) {
    entries["EndpointType"] = input.EndpointType;
  }
  if (input.ExcludedMembers !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.ExcludedMembers,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ExcludedMembers.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.StaticMembers !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.StaticMembers,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `StaticMembers.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateDBClusterMessage = (
  input: CreateDBClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZones !== undefined) {
    const memberEntries = serializeAws_queryAvailabilityZones(
      input.AvailabilityZones,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `AvailabilityZones.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.BacktrackWindow !== undefined) {
    entries["BacktrackWindow"] = input.BacktrackWindow;
  }
  if (input.BackupRetentionPeriod !== undefined) {
    entries["BackupRetentionPeriod"] = input.BackupRetentionPeriod;
  }
  if (input.CharacterSetName !== undefined) {
    entries["CharacterSetName"] = input.CharacterSetName;
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.DatabaseName !== undefined) {
    entries["DatabaseName"] = input.DatabaseName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.EnableCloudwatchLogsExports !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.EnableCloudwatchLogsExports,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EnableCloudwatchLogsExports.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.EnableHttpEndpoint !== undefined) {
    entries["EnableHttpEndpoint"] = input.EnableHttpEndpoint;
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.EngineMode !== undefined) {
    entries["EngineMode"] = input.EngineMode;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.GlobalClusterIdentifier !== undefined) {
    entries["GlobalClusterIdentifier"] = input.GlobalClusterIdentifier;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MasterUserPassword !== undefined) {
    entries["MasterUserPassword"] = input.MasterUserPassword;
  }
  if (input.MasterUsername !== undefined) {
    entries["MasterUsername"] = input.MasterUsername;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.PreSignedUrl !== undefined) {
    entries["PreSignedUrl"] = input.PreSignedUrl;
  }
  if (input.PreferredBackupWindow !== undefined) {
    entries["PreferredBackupWindow"] = input.PreferredBackupWindow;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    entries["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.ReplicationSourceIdentifier !== undefined) {
    entries["ReplicationSourceIdentifier"] = input.ReplicationSourceIdentifier;
  }
  if (input.ScalingConfiguration !== undefined) {
    const memberEntries = serializeAws_queryScalingConfiguration(
      input.ScalingConfiguration,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ScalingConfiguration.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.StorageEncrypted !== undefined) {
    entries["StorageEncrypted"] = input.StorageEncrypted;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateDBClusterParameterGroupMessage = (
  input: CreateDBClusterParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  if (input.DBParameterGroupFamily !== undefined) {
    entries["DBParameterGroupFamily"] = input.DBParameterGroupFamily;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateDBClusterSnapshotMessage = (
  input: CreateDBClusterSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.DBClusterSnapshotIdentifier !== undefined) {
    entries["DBClusterSnapshotIdentifier"] = input.DBClusterSnapshotIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateDBInstanceMessage = (
  input: CreateDBInstanceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllocatedStorage !== undefined) {
    entries["AllocatedStorage"] = input.AllocatedStorage;
  }
  if (input.AutoMinorVersionUpgrade !== undefined) {
    entries["AutoMinorVersionUpgrade"] = input.AutoMinorVersionUpgrade;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.BackupRetentionPeriod !== undefined) {
    entries["BackupRetentionPeriod"] = input.BackupRetentionPeriod;
  }
  if (input.CharacterSetName !== undefined) {
    entries["CharacterSetName"] = input.CharacterSetName;
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.DBInstanceClass !== undefined) {
    entries["DBInstanceClass"] = input.DBInstanceClass;
  }
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.DBName !== undefined) {
    entries["DBName"] = input.DBName;
  }
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.DBSecurityGroups !== undefined) {
    const memberEntries = serializeAws_queryDBSecurityGroupNameList(
      input.DBSecurityGroups,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `DBSecurityGroups.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.Domain !== undefined) {
    entries["Domain"] = input.Domain;
  }
  if (input.DomainIAMRoleName !== undefined) {
    entries["DomainIAMRoleName"] = input.DomainIAMRoleName;
  }
  if (input.EnableCloudwatchLogsExports !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.EnableCloudwatchLogsExports,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EnableCloudwatchLogsExports.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.EnablePerformanceInsights !== undefined) {
    entries["EnablePerformanceInsights"] = input.EnablePerformanceInsights;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.LicenseModel !== undefined) {
    entries["LicenseModel"] = input.LicenseModel;
  }
  if (input.MasterUserPassword !== undefined) {
    entries["MasterUserPassword"] = input.MasterUserPassword;
  }
  if (input.MasterUsername !== undefined) {
    entries["MasterUsername"] = input.MasterUsername;
  }
  if (input.MaxAllocatedStorage !== undefined) {
    entries["MaxAllocatedStorage"] = input.MaxAllocatedStorage;
  }
  if (input.MonitoringInterval !== undefined) {
    entries["MonitoringInterval"] = input.MonitoringInterval;
  }
  if (input.MonitoringRoleArn !== undefined) {
    entries["MonitoringRoleArn"] = input.MonitoringRoleArn;
  }
  if (input.MultiAZ !== undefined) {
    entries["MultiAZ"] = input.MultiAZ;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.PerformanceInsightsKMSKeyId !== undefined) {
    entries["PerformanceInsightsKMSKeyId"] = input.PerformanceInsightsKMSKeyId;
  }
  if (input.PerformanceInsightsRetentionPeriod !== undefined) {
    entries["PerformanceInsightsRetentionPeriod"] =
      input.PerformanceInsightsRetentionPeriod;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.PreferredBackupWindow !== undefined) {
    entries["PreferredBackupWindow"] = input.PreferredBackupWindow;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    entries["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.ProcessorFeatures !== undefined) {
    const memberEntries = serializeAws_queryProcessorFeatureList(
      input.ProcessorFeatures,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ProcessorFeatures.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.PromotionTier !== undefined) {
    entries["PromotionTier"] = input.PromotionTier;
  }
  if (input.PubliclyAccessible !== undefined) {
    entries["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.StorageEncrypted !== undefined) {
    entries["StorageEncrypted"] = input.StorageEncrypted;
  }
  if (input.StorageType !== undefined) {
    entries["StorageType"] = input.StorageType;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TdeCredentialArn !== undefined) {
    entries["TdeCredentialArn"] = input.TdeCredentialArn;
  }
  if (input.TdeCredentialPassword !== undefined) {
    entries["TdeCredentialPassword"] = input.TdeCredentialPassword;
  }
  if (input.Timezone !== undefined) {
    entries["Timezone"] = input.Timezone;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateDBInstanceReadReplicaMessage = (
  input: CreateDBInstanceReadReplicaMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AutoMinorVersionUpgrade !== undefined) {
    entries["AutoMinorVersionUpgrade"] = input.AutoMinorVersionUpgrade;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBInstanceClass !== undefined) {
    entries["DBInstanceClass"] = input.DBInstanceClass;
  }
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.Domain !== undefined) {
    entries["Domain"] = input.Domain;
  }
  if (input.DomainIAMRoleName !== undefined) {
    entries["DomainIAMRoleName"] = input.DomainIAMRoleName;
  }
  if (input.EnableCloudwatchLogsExports !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.EnableCloudwatchLogsExports,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EnableCloudwatchLogsExports.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.EnablePerformanceInsights !== undefined) {
    entries["EnablePerformanceInsights"] = input.EnablePerformanceInsights;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MonitoringInterval !== undefined) {
    entries["MonitoringInterval"] = input.MonitoringInterval;
  }
  if (input.MonitoringRoleArn !== undefined) {
    entries["MonitoringRoleArn"] = input.MonitoringRoleArn;
  }
  if (input.MultiAZ !== undefined) {
    entries["MultiAZ"] = input.MultiAZ;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.PerformanceInsightsKMSKeyId !== undefined) {
    entries["PerformanceInsightsKMSKeyId"] = input.PerformanceInsightsKMSKeyId;
  }
  if (input.PerformanceInsightsRetentionPeriod !== undefined) {
    entries["PerformanceInsightsRetentionPeriod"] =
      input.PerformanceInsightsRetentionPeriod;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.PreSignedUrl !== undefined) {
    entries["PreSignedUrl"] = input.PreSignedUrl;
  }
  if (input.ProcessorFeatures !== undefined) {
    const memberEntries = serializeAws_queryProcessorFeatureList(
      input.ProcessorFeatures,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ProcessorFeatures.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.PubliclyAccessible !== undefined) {
    entries["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.SourceDBInstanceIdentifier !== undefined) {
    entries["SourceDBInstanceIdentifier"] = input.SourceDBInstanceIdentifier;
  }
  if (input.StorageType !== undefined) {
    entries["StorageType"] = input.StorageType;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.UseDefaultProcessorFeatures !== undefined) {
    entries["UseDefaultProcessorFeatures"] = input.UseDefaultProcessorFeatures;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateDBParameterGroupMessage = (
  input: CreateDBParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBParameterGroupFamily !== undefined) {
    entries["DBParameterGroupFamily"] = input.DBParameterGroupFamily;
  }
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateDBProxyRequest = (
  input: CreateDBProxyRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Auth !== undefined) {
    const memberEntries = serializeAws_queryUserAuthConfigList(
      input.Auth,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Auth.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DBProxyName !== undefined) {
    entries["DBProxyName"] = input.DBProxyName;
  }
  if (input.DebugLogging !== undefined) {
    entries["DebugLogging"] = input.DebugLogging;
  }
  if (input.EngineFamily !== undefined) {
    entries["EngineFamily"] = input.EngineFamily;
  }
  if (input.IdleClientTimeout !== undefined) {
    entries["IdleClientTimeout"] = input.IdleClientTimeout;
  }
  if (input.RequireTLS !== undefined) {
    entries["RequireTLS"] = input.RequireTLS;
  }
  if (input.RoleArn !== undefined) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.VpcSubnetIds !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.VpcSubnetIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSubnetIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateDBSecurityGroupMessage = (
  input: CreateDBSecurityGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSecurityGroupDescription !== undefined) {
    entries["DBSecurityGroupDescription"] = input.DBSecurityGroupDescription;
  }
  if (input.DBSecurityGroupName !== undefined) {
    entries["DBSecurityGroupName"] = input.DBSecurityGroupName;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateDBSnapshotMessage = (
  input: CreateDBSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.DBSnapshotIdentifier !== undefined) {
    entries["DBSnapshotIdentifier"] = input.DBSnapshotIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateDBSubnetGroupMessage = (
  input: CreateDBSubnetGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSubnetGroupDescription !== undefined) {
    entries["DBSubnetGroupDescription"] = input.DBSubnetGroupDescription;
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.SubnetIds !== undefined) {
    const memberEntries = serializeAws_querySubnetIdentifierList(
      input.SubnetIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SubnetIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateEventSubscriptionMessage = (
  input: CreateEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Enabled !== undefined) {
    entries["Enabled"] = input.Enabled;
  }
  if (input.EventCategories !== undefined) {
    const memberEntries = serializeAws_queryEventCategoriesList(
      input.EventCategories,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EventCategories.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.SnsTopicArn !== undefined) {
    entries["SnsTopicArn"] = input.SnsTopicArn;
  }
  if (input.SourceIds !== undefined) {
    const memberEntries = serializeAws_querySourceIdsList(
      input.SourceIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SourceIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.SourceType !== undefined) {
    entries["SourceType"] = input.SourceType;
  }
  if (input.SubscriptionName !== undefined) {
    entries["SubscriptionName"] = input.SubscriptionName;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryCreateGlobalClusterMessage = (
  input: CreateGlobalClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DatabaseName !== undefined) {
    entries["DatabaseName"] = input.DatabaseName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.GlobalClusterIdentifier !== undefined) {
    entries["GlobalClusterIdentifier"] = input.GlobalClusterIdentifier;
  }
  if (input.SourceDBClusterIdentifier !== undefined) {
    entries["SourceDBClusterIdentifier"] = input.SourceDBClusterIdentifier;
  }
  if (input.StorageEncrypted !== undefined) {
    entries["StorageEncrypted"] = input.StorageEncrypted;
  }
  return entries;
};

const serializeAws_queryCreateOptionGroupMessage = (
  input: CreateOptionGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.EngineName !== undefined) {
    entries["EngineName"] = input.EngineName;
  }
  if (input.MajorEngineVersion !== undefined) {
    entries["MajorEngineVersion"] = input.MajorEngineVersion;
  }
  if (input.OptionGroupDescription !== undefined) {
    entries["OptionGroupDescription"] = input.OptionGroupDescription;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryDBSecurityGroupNameList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`DBSecurityGroupName.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryDeleteCustomAvailabilityZoneMessage = (
  input: DeleteCustomAvailabilityZoneMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CustomAvailabilityZoneId !== undefined) {
    entries["CustomAvailabilityZoneId"] = input.CustomAvailabilityZoneId;
  }
  return entries;
};

const serializeAws_queryDeleteDBClusterEndpointMessage = (
  input: DeleteDBClusterEndpointMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterEndpointIdentifier !== undefined) {
    entries["DBClusterEndpointIdentifier"] = input.DBClusterEndpointIdentifier;
  }
  return entries;
};

const serializeAws_queryDeleteDBClusterMessage = (
  input: DeleteDBClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.FinalDBSnapshotIdentifier !== undefined) {
    entries["FinalDBSnapshotIdentifier"] = input.FinalDBSnapshotIdentifier;
  }
  if (input.SkipFinalSnapshot !== undefined) {
    entries["SkipFinalSnapshot"] = input.SkipFinalSnapshot;
  }
  return entries;
};

const serializeAws_queryDeleteDBClusterParameterGroupMessage = (
  input: DeleteDBClusterParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  return entries;
};

const serializeAws_queryDeleteDBClusterSnapshotMessage = (
  input: DeleteDBClusterSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterSnapshotIdentifier !== undefined) {
    entries["DBClusterSnapshotIdentifier"] = input.DBClusterSnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryDeleteDBInstanceAutomatedBackupMessage = (
  input: DeleteDBInstanceAutomatedBackupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DbiResourceId !== undefined) {
    entries["DbiResourceId"] = input.DbiResourceId;
  }
  return entries;
};

const serializeAws_queryDeleteDBInstanceMessage = (
  input: DeleteDBInstanceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.DeleteAutomatedBackups !== undefined) {
    entries["DeleteAutomatedBackups"] = input.DeleteAutomatedBackups;
  }
  if (input.FinalDBSnapshotIdentifier !== undefined) {
    entries["FinalDBSnapshotIdentifier"] = input.FinalDBSnapshotIdentifier;
  }
  if (input.SkipFinalSnapshot !== undefined) {
    entries["SkipFinalSnapshot"] = input.SkipFinalSnapshot;
  }
  return entries;
};

const serializeAws_queryDeleteDBParameterGroupMessage = (
  input: DeleteDBParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  return entries;
};

const serializeAws_queryDeleteDBProxyRequest = (
  input: DeleteDBProxyRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBProxyName !== undefined) {
    entries["DBProxyName"] = input.DBProxyName;
  }
  return entries;
};

const serializeAws_queryDeleteDBSecurityGroupMessage = (
  input: DeleteDBSecurityGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSecurityGroupName !== undefined) {
    entries["DBSecurityGroupName"] = input.DBSecurityGroupName;
  }
  return entries;
};

const serializeAws_queryDeleteDBSnapshotMessage = (
  input: DeleteDBSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSnapshotIdentifier !== undefined) {
    entries["DBSnapshotIdentifier"] = input.DBSnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryDeleteDBSubnetGroupMessage = (
  input: DeleteDBSubnetGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  return entries;
};

const serializeAws_queryDeleteEventSubscriptionMessage = (
  input: DeleteEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.SubscriptionName !== undefined) {
    entries["SubscriptionName"] = input.SubscriptionName;
  }
  return entries;
};

const serializeAws_queryDeleteGlobalClusterMessage = (
  input: DeleteGlobalClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.GlobalClusterIdentifier !== undefined) {
    entries["GlobalClusterIdentifier"] = input.GlobalClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryDeleteInstallationMediaMessage = (
  input: DeleteInstallationMediaMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.InstallationMediaId !== undefined) {
    entries["InstallationMediaId"] = input.InstallationMediaId;
  }
  return entries;
};

const serializeAws_queryDeleteOptionGroupMessage = (
  input: DeleteOptionGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  return entries;
};

const serializeAws_queryDeregisterDBProxyTargetsRequest = (
  input: DeregisterDBProxyTargetsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifiers !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.DBClusterIdentifiers,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `DBClusterIdentifiers.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DBInstanceIdentifiers !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.DBInstanceIdentifiers,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `DBInstanceIdentifiers.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DBProxyName !== undefined) {
    entries["DBProxyName"] = input.DBProxyName;
  }
  if (input.TargetGroupName !== undefined) {
    entries["TargetGroupName"] = input.TargetGroupName;
  }
  return entries;
};

const serializeAws_queryDescribeAccountAttributesMessage = (
  input: DescribeAccountAttributesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  return entries;
};

const serializeAws_queryDescribeCertificatesMessage = (
  input: DescribeCertificatesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CertificateIdentifier !== undefined) {
    entries["CertificateIdentifier"] = input.CertificateIdentifier;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeCustomAvailabilityZonesMessage = (
  input: DescribeCustomAvailabilityZonesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CustomAvailabilityZoneId !== undefined) {
    entries["CustomAvailabilityZoneId"] = input.CustomAvailabilityZoneId;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBClusterBacktracksMessage = (
  input: DescribeDBClusterBacktracksMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BacktrackIdentifier !== undefined) {
    entries["BacktrackIdentifier"] = input.BacktrackIdentifier;
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBClusterEndpointsMessage = (
  input: DescribeDBClusterEndpointsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterEndpointIdentifier !== undefined) {
    entries["DBClusterEndpointIdentifier"] = input.DBClusterEndpointIdentifier;
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBClusterParameterGroupsMessage = (
  input: DescribeDBClusterParameterGroupsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBClusterParametersMessage = (
  input: DescribeDBClusterParametersMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.Source !== undefined) {
    entries["Source"] = input.Source;
  }
  return entries;
};

const serializeAws_queryDescribeDBClusterSnapshotAttributesMessage = (
  input: DescribeDBClusterSnapshotAttributesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterSnapshotIdentifier !== undefined) {
    entries["DBClusterSnapshotIdentifier"] = input.DBClusterSnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryDescribeDBClusterSnapshotsMessage = (
  input: DescribeDBClusterSnapshotsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.DBClusterSnapshotIdentifier !== undefined) {
    entries["DBClusterSnapshotIdentifier"] = input.DBClusterSnapshotIdentifier;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.IncludePublic !== undefined) {
    entries["IncludePublic"] = input.IncludePublic;
  }
  if (input.IncludeShared !== undefined) {
    entries["IncludeShared"] = input.IncludeShared;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.SnapshotType !== undefined) {
    entries["SnapshotType"] = input.SnapshotType;
  }
  return entries;
};

const serializeAws_queryDescribeDBClustersMessage = (
  input: DescribeDBClustersMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.IncludeShared !== undefined) {
    entries["IncludeShared"] = input.IncludeShared;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBEngineVersionsMessage = (
  input: DescribeDBEngineVersionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBParameterGroupFamily !== undefined) {
    entries["DBParameterGroupFamily"] = input.DBParameterGroupFamily;
  }
  if (input.DefaultOnly !== undefined) {
    entries["DefaultOnly"] = input.DefaultOnly;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.IncludeAll !== undefined) {
    entries["IncludeAll"] = input.IncludeAll;
  }
  if (input.ListSupportedCharacterSets !== undefined) {
    entries["ListSupportedCharacterSets"] = input.ListSupportedCharacterSets;
  }
  if (input.ListSupportedTimezones !== undefined) {
    entries["ListSupportedTimezones"] = input.ListSupportedTimezones;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBInstanceAutomatedBackupsMessage = (
  input: DescribeDBInstanceAutomatedBackupsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.DbiResourceId !== undefined) {
    entries["DbiResourceId"] = input.DbiResourceId;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBInstancesMessage = (
  input: DescribeDBInstancesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBLogFilesMessage = (
  input: DescribeDBLogFilesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.FileLastWritten !== undefined) {
    entries["FileLastWritten"] = input.FileLastWritten;
  }
  if (input.FileSize !== undefined) {
    entries["FileSize"] = input.FileSize;
  }
  if (input.FilenameContains !== undefined) {
    entries["FilenameContains"] = input.FilenameContains;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBParameterGroupsMessage = (
  input: DescribeDBParameterGroupsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBParametersMessage = (
  input: DescribeDBParametersMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.Source !== undefined) {
    entries["Source"] = input.Source;
  }
  return entries;
};

const serializeAws_queryDescribeDBProxiesRequest = (
  input: DescribeDBProxiesRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBProxyName !== undefined) {
    entries["DBProxyName"] = input.DBProxyName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBProxyTargetGroupsRequest = (
  input: DescribeDBProxyTargetGroupsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBProxyName !== undefined) {
    entries["DBProxyName"] = input.DBProxyName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.TargetGroupName !== undefined) {
    entries["TargetGroupName"] = input.TargetGroupName;
  }
  return entries;
};

const serializeAws_queryDescribeDBProxyTargetsRequest = (
  input: DescribeDBProxyTargetsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBProxyName !== undefined) {
    entries["DBProxyName"] = input.DBProxyName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.TargetGroupName !== undefined) {
    entries["TargetGroupName"] = input.TargetGroupName;
  }
  return entries;
};

const serializeAws_queryDescribeDBSecurityGroupsMessage = (
  input: DescribeDBSecurityGroupsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSecurityGroupName !== undefined) {
    entries["DBSecurityGroupName"] = input.DBSecurityGroupName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeDBSnapshotAttributesMessage = (
  input: DescribeDBSnapshotAttributesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSnapshotIdentifier !== undefined) {
    entries["DBSnapshotIdentifier"] = input.DBSnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryDescribeDBSnapshotsMessage = (
  input: DescribeDBSnapshotsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.DBSnapshotIdentifier !== undefined) {
    entries["DBSnapshotIdentifier"] = input.DBSnapshotIdentifier;
  }
  if (input.DbiResourceId !== undefined) {
    entries["DbiResourceId"] = input.DbiResourceId;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.IncludePublic !== undefined) {
    entries["IncludePublic"] = input.IncludePublic;
  }
  if (input.IncludeShared !== undefined) {
    entries["IncludeShared"] = input.IncludeShared;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.SnapshotType !== undefined) {
    entries["SnapshotType"] = input.SnapshotType;
  }
  return entries;
};

const serializeAws_queryDescribeDBSubnetGroupsMessage = (
  input: DescribeDBSubnetGroupsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeEngineDefaultClusterParametersMessage = (
  input: DescribeEngineDefaultClusterParametersMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBParameterGroupFamily !== undefined) {
    entries["DBParameterGroupFamily"] = input.DBParameterGroupFamily;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeEngineDefaultParametersMessage = (
  input: DescribeEngineDefaultParametersMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBParameterGroupFamily !== undefined) {
    entries["DBParameterGroupFamily"] = input.DBParameterGroupFamily;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeEventCategoriesMessage = (
  input: DescribeEventCategoriesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.SourceType !== undefined) {
    entries["SourceType"] = input.SourceType;
  }
  return entries;
};

const serializeAws_queryDescribeEventSubscriptionsMessage = (
  input: DescribeEventSubscriptionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.SubscriptionName !== undefined) {
    entries["SubscriptionName"] = input.SubscriptionName;
  }
  return entries;
};

const serializeAws_queryDescribeEventsMessage = (
  input: DescribeEventsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Duration !== undefined) {
    entries["Duration"] = input.Duration;
  }
  if (input.EndTime !== undefined) {
    entries["EndTime"] = input.EndTime.toISOString().split(".")[0] + "Z";
  }
  if (input.EventCategories !== undefined) {
    const memberEntries = serializeAws_queryEventCategoriesList(
      input.EventCategories,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EventCategories.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.SourceIdentifier !== undefined) {
    entries["SourceIdentifier"] = input.SourceIdentifier;
  }
  if (input.SourceType !== undefined) {
    entries["SourceType"] = input.SourceType;
  }
  if (input.StartTime !== undefined) {
    entries["StartTime"] = input.StartTime.toISOString().split(".")[0] + "Z";
  }
  return entries;
};

const serializeAws_queryDescribeGlobalClustersMessage = (
  input: DescribeGlobalClustersMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.GlobalClusterIdentifier !== undefined) {
    entries["GlobalClusterIdentifier"] = input.GlobalClusterIdentifier;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeInstallationMediaMessage = (
  input: DescribeInstallationMediaMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.InstallationMediaId !== undefined) {
    entries["InstallationMediaId"] = input.InstallationMediaId;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeOptionGroupOptionsMessage = (
  input: DescribeOptionGroupOptionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.EngineName !== undefined) {
    entries["EngineName"] = input.EngineName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.MajorEngineVersion !== undefined) {
    entries["MajorEngineVersion"] = input.MajorEngineVersion;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  return entries;
};

const serializeAws_queryDescribeOptionGroupsMessage = (
  input: DescribeOptionGroupsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.EngineName !== undefined) {
    entries["EngineName"] = input.EngineName;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.MajorEngineVersion !== undefined) {
    entries["MajorEngineVersion"] = input.MajorEngineVersion;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  return entries;
};

const serializeAws_queryDescribeOrderableDBInstanceOptionsMessage = (
  input: DescribeOrderableDBInstanceOptionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceClass !== undefined) {
    entries["DBInstanceClass"] = input.DBInstanceClass;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.LicenseModel !== undefined) {
    entries["LicenseModel"] = input.LicenseModel;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.Vpc !== undefined) {
    entries["Vpc"] = input.Vpc;
  }
  return entries;
};

const serializeAws_queryDescribePendingMaintenanceActionsMessage = (
  input: DescribePendingMaintenanceActionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.ResourceIdentifier !== undefined) {
    entries["ResourceIdentifier"] = input.ResourceIdentifier;
  }
  return entries;
};

const serializeAws_queryDescribeReservedDBInstancesMessage = (
  input: DescribeReservedDBInstancesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceClass !== undefined) {
    entries["DBInstanceClass"] = input.DBInstanceClass;
  }
  if (input.Duration !== undefined) {
    entries["Duration"] = input.Duration;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.LeaseId !== undefined) {
    entries["LeaseId"] = input.LeaseId;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.MultiAZ !== undefined) {
    entries["MultiAZ"] = input.MultiAZ;
  }
  if (input.OfferingType !== undefined) {
    entries["OfferingType"] = input.OfferingType;
  }
  if (input.ProductDescription !== undefined) {
    entries["ProductDescription"] = input.ProductDescription;
  }
  if (input.ReservedDBInstanceId !== undefined) {
    entries["ReservedDBInstanceId"] = input.ReservedDBInstanceId;
  }
  if (input.ReservedDBInstancesOfferingId !== undefined) {
    entries["ReservedDBInstancesOfferingId"] =
      input.ReservedDBInstancesOfferingId;
  }
  return entries;
};

const serializeAws_queryDescribeReservedDBInstancesOfferingsMessage = (
  input: DescribeReservedDBInstancesOfferingsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceClass !== undefined) {
    entries["DBInstanceClass"] = input.DBInstanceClass;
  }
  if (input.Duration !== undefined) {
    entries["Duration"] = input.Duration;
  }
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.MultiAZ !== undefined) {
    entries["MultiAZ"] = input.MultiAZ;
  }
  if (input.OfferingType !== undefined) {
    entries["OfferingType"] = input.OfferingType;
  }
  if (input.ProductDescription !== undefined) {
    entries["ProductDescription"] = input.ProductDescription;
  }
  if (input.ReservedDBInstancesOfferingId !== undefined) {
    entries["ReservedDBInstancesOfferingId"] =
      input.ReservedDBInstancesOfferingId;
  }
  return entries;
};

const serializeAws_queryDescribeSourceRegionsMessage = (
  input: DescribeSourceRegionsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    entries["MaxRecords"] = input.MaxRecords;
  }
  if (input.RegionName !== undefined) {
    entries["RegionName"] = input.RegionName;
  }
  return entries;
};

const serializeAws_queryDescribeValidDBInstanceModificationsMessage = (
  input: DescribeValidDBInstanceModificationsMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  return entries;
};

const serializeAws_queryDownloadDBLogFilePortionMessage = (
  input: DownloadDBLogFilePortionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.LogFileName !== undefined) {
    entries["LogFileName"] = input.LogFileName;
  }
  if (input.Marker !== undefined) {
    entries["Marker"] = input.Marker;
  }
  if (input.NumberOfLines !== undefined) {
    entries["NumberOfLines"] = input.NumberOfLines;
  }
  return entries;
};

const serializeAws_queryEngineModeList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryEventCategoriesList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`EventCategory.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryFailoverDBClusterMessage = (
  input: FailoverDBClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.TargetDBInstanceIdentifier !== undefined) {
    entries["TargetDBInstanceIdentifier"] = input.TargetDBInstanceIdentifier;
  }
  return entries;
};

const serializeAws_queryFilter = (
  input: Filter,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    const memberEntries = serializeAws_queryFilterValueList(
      input.Values,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Values.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryFilterList = (
  input: Filter[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_queryFilter(entry, context);
    Object.keys(memberEntries).forEach(key => {
      entries[`Filter.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  }
  return entries;
};

const serializeAws_queryFilterValueList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`Value.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryImportInstallationMediaMessage = (
  input: ImportInstallationMediaMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CustomAvailabilityZoneId !== undefined) {
    entries["CustomAvailabilityZoneId"] = input.CustomAvailabilityZoneId;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.EngineInstallationMediaPath !== undefined) {
    entries["EngineInstallationMediaPath"] = input.EngineInstallationMediaPath;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.OSInstallationMediaPath !== undefined) {
    entries["OSInstallationMediaPath"] = input.OSInstallationMediaPath;
  }
  return entries;
};

const serializeAws_queryKeyList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryListTagsForResourceMessage = (
  input: ListTagsForResourceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Filters !== undefined) {
    const memberEntries = serializeAws_queryFilterList(input.Filters, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Filters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ResourceName !== undefined) {
    entries["ResourceName"] = input.ResourceName;
  }
  return entries;
};

const serializeAws_queryLogTypeList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryModifyCertificatesMessage = (
  input: ModifyCertificatesMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CertificateIdentifier !== undefined) {
    entries["CertificateIdentifier"] = input.CertificateIdentifier;
  }
  if (input.RemoveCustomerOverride !== undefined) {
    entries["RemoveCustomerOverride"] = input.RemoveCustomerOverride;
  }
  return entries;
};

const serializeAws_queryModifyCurrentDBClusterCapacityMessage = (
  input: ModifyCurrentDBClusterCapacityMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Capacity !== undefined) {
    entries["Capacity"] = input.Capacity;
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.SecondsBeforeTimeout !== undefined) {
    entries["SecondsBeforeTimeout"] = input.SecondsBeforeTimeout;
  }
  if (input.TimeoutAction !== undefined) {
    entries["TimeoutAction"] = input.TimeoutAction;
  }
  return entries;
};

const serializeAws_queryModifyDBClusterEndpointMessage = (
  input: ModifyDBClusterEndpointMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterEndpointIdentifier !== undefined) {
    entries["DBClusterEndpointIdentifier"] = input.DBClusterEndpointIdentifier;
  }
  if (input.EndpointType !== undefined) {
    entries["EndpointType"] = input.EndpointType;
  }
  if (input.ExcludedMembers !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.ExcludedMembers,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ExcludedMembers.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.StaticMembers !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.StaticMembers,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `StaticMembers.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyDBClusterMessage = (
  input: ModifyDBClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllowMajorVersionUpgrade !== undefined) {
    entries["AllowMajorVersionUpgrade"] = input.AllowMajorVersionUpgrade;
  }
  if (input.ApplyImmediately !== undefined) {
    entries["ApplyImmediately"] = input.ApplyImmediately;
  }
  if (input.BacktrackWindow !== undefined) {
    entries["BacktrackWindow"] = input.BacktrackWindow;
  }
  if (input.BackupRetentionPeriod !== undefined) {
    entries["BackupRetentionPeriod"] = input.BackupRetentionPeriod;
  }
  if (input.CloudwatchLogsExportConfiguration !== undefined) {
    const memberEntries = serializeAws_queryCloudwatchLogsExportConfiguration(
      input.CloudwatchLogsExportConfiguration,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `CloudwatchLogsExportConfiguration.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  if (input.DBInstanceParameterGroupName !== undefined) {
    entries["DBInstanceParameterGroupName"] =
      input.DBInstanceParameterGroupName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.EnableHttpEndpoint !== undefined) {
    entries["EnableHttpEndpoint"] = input.EnableHttpEndpoint;
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.MasterUserPassword !== undefined) {
    entries["MasterUserPassword"] = input.MasterUserPassword;
  }
  if (input.NewDBClusterIdentifier !== undefined) {
    entries["NewDBClusterIdentifier"] = input.NewDBClusterIdentifier;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.PreferredBackupWindow !== undefined) {
    entries["PreferredBackupWindow"] = input.PreferredBackupWindow;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    entries["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.ScalingConfiguration !== undefined) {
    const memberEntries = serializeAws_queryScalingConfiguration(
      input.ScalingConfiguration,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ScalingConfiguration.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyDBClusterParameterGroupMessage = (
  input: ModifyDBClusterParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  if (input.Parameters !== undefined) {
    const memberEntries = serializeAws_queryParametersList(
      input.Parameters,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Parameters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyDBClusterSnapshotAttributeMessage = (
  input: ModifyDBClusterSnapshotAttributeMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AttributeName !== undefined) {
    entries["AttributeName"] = input.AttributeName;
  }
  if (input.DBClusterSnapshotIdentifier !== undefined) {
    entries["DBClusterSnapshotIdentifier"] = input.DBClusterSnapshotIdentifier;
  }
  if (input.ValuesToAdd !== undefined) {
    const memberEntries = serializeAws_queryAttributeValueList(
      input.ValuesToAdd,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ValuesToAdd.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ValuesToRemove !== undefined) {
    const memberEntries = serializeAws_queryAttributeValueList(
      input.ValuesToRemove,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ValuesToRemove.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyDBInstanceMessage = (
  input: ModifyDBInstanceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllocatedStorage !== undefined) {
    entries["AllocatedStorage"] = input.AllocatedStorage;
  }
  if (input.AllowMajorVersionUpgrade !== undefined) {
    entries["AllowMajorVersionUpgrade"] = input.AllowMajorVersionUpgrade;
  }
  if (input.ApplyImmediately !== undefined) {
    entries["ApplyImmediately"] = input.ApplyImmediately;
  }
  if (input.AutoMinorVersionUpgrade !== undefined) {
    entries["AutoMinorVersionUpgrade"] = input.AutoMinorVersionUpgrade;
  }
  if (input.BackupRetentionPeriod !== undefined) {
    entries["BackupRetentionPeriod"] = input.BackupRetentionPeriod;
  }
  if (input.CACertificateIdentifier !== undefined) {
    entries["CACertificateIdentifier"] = input.CACertificateIdentifier;
  }
  if (input.CertificateRotationRestart !== undefined) {
    entries["CertificateRotationRestart"] = input.CertificateRotationRestart;
  }
  if (input.CloudwatchLogsExportConfiguration !== undefined) {
    const memberEntries = serializeAws_queryCloudwatchLogsExportConfiguration(
      input.CloudwatchLogsExportConfiguration,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `CloudwatchLogsExportConfiguration.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBInstanceClass !== undefined) {
    entries["DBInstanceClass"] = input.DBInstanceClass;
  }
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.DBPortNumber !== undefined) {
    entries["DBPortNumber"] = input.DBPortNumber;
  }
  if (input.DBSecurityGroups !== undefined) {
    const memberEntries = serializeAws_queryDBSecurityGroupNameList(
      input.DBSecurityGroups,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `DBSecurityGroups.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.Domain !== undefined) {
    entries["Domain"] = input.Domain;
  }
  if (input.DomainIAMRoleName !== undefined) {
    entries["DomainIAMRoleName"] = input.DomainIAMRoleName;
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.EnablePerformanceInsights !== undefined) {
    entries["EnablePerformanceInsights"] = input.EnablePerformanceInsights;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.LicenseModel !== undefined) {
    entries["LicenseModel"] = input.LicenseModel;
  }
  if (input.MasterUserPassword !== undefined) {
    entries["MasterUserPassword"] = input.MasterUserPassword;
  }
  if (input.MaxAllocatedStorage !== undefined) {
    entries["MaxAllocatedStorage"] = input.MaxAllocatedStorage;
  }
  if (input.MonitoringInterval !== undefined) {
    entries["MonitoringInterval"] = input.MonitoringInterval;
  }
  if (input.MonitoringRoleArn !== undefined) {
    entries["MonitoringRoleArn"] = input.MonitoringRoleArn;
  }
  if (input.MultiAZ !== undefined) {
    entries["MultiAZ"] = input.MultiAZ;
  }
  if (input.NewDBInstanceIdentifier !== undefined) {
    entries["NewDBInstanceIdentifier"] = input.NewDBInstanceIdentifier;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.PerformanceInsightsKMSKeyId !== undefined) {
    entries["PerformanceInsightsKMSKeyId"] = input.PerformanceInsightsKMSKeyId;
  }
  if (input.PerformanceInsightsRetentionPeriod !== undefined) {
    entries["PerformanceInsightsRetentionPeriod"] =
      input.PerformanceInsightsRetentionPeriod;
  }
  if (input.PreferredBackupWindow !== undefined) {
    entries["PreferredBackupWindow"] = input.PreferredBackupWindow;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    entries["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.ProcessorFeatures !== undefined) {
    const memberEntries = serializeAws_queryProcessorFeatureList(
      input.ProcessorFeatures,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ProcessorFeatures.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.PromotionTier !== undefined) {
    entries["PromotionTier"] = input.PromotionTier;
  }
  if (input.PubliclyAccessible !== undefined) {
    entries["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.StorageType !== undefined) {
    entries["StorageType"] = input.StorageType;
  }
  if (input.TdeCredentialArn !== undefined) {
    entries["TdeCredentialArn"] = input.TdeCredentialArn;
  }
  if (input.TdeCredentialPassword !== undefined) {
    entries["TdeCredentialPassword"] = input.TdeCredentialPassword;
  }
  if (input.UseDefaultProcessorFeatures !== undefined) {
    entries["UseDefaultProcessorFeatures"] = input.UseDefaultProcessorFeatures;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyDBParameterGroupMessage = (
  input: ModifyDBParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.Parameters !== undefined) {
    const memberEntries = serializeAws_queryParametersList(
      input.Parameters,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Parameters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyDBProxyRequest = (
  input: ModifyDBProxyRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Auth !== undefined) {
    const memberEntries = serializeAws_queryUserAuthConfigList(
      input.Auth,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Auth.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DBProxyName !== undefined) {
    entries["DBProxyName"] = input.DBProxyName;
  }
  if (input.DebugLogging !== undefined) {
    entries["DebugLogging"] = input.DebugLogging;
  }
  if (input.IdleClientTimeout !== undefined) {
    entries["IdleClientTimeout"] = input.IdleClientTimeout;
  }
  if (input.NewDBProxyName !== undefined) {
    entries["NewDBProxyName"] = input.NewDBProxyName;
  }
  if (input.RequireTLS !== undefined) {
    entries["RequireTLS"] = input.RequireTLS;
  }
  if (input.RoleArn !== undefined) {
    entries["RoleArn"] = input.RoleArn;
  }
  if (input.SecurityGroups !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.SecurityGroups,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SecurityGroups.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyDBProxyTargetGroupRequest = (
  input: ModifyDBProxyTargetGroupRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ConnectionPoolConfig !== undefined) {
    const memberEntries = serializeAws_queryConnectionPoolConfiguration(
      input.ConnectionPoolConfig,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ConnectionPoolConfig.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DBProxyName !== undefined) {
    entries["DBProxyName"] = input.DBProxyName;
  }
  if (input.NewName !== undefined) {
    entries["NewName"] = input.NewName;
  }
  if (input.TargetGroupName !== undefined) {
    entries["TargetGroupName"] = input.TargetGroupName;
  }
  return entries;
};

const serializeAws_queryModifyDBSnapshotAttributeMessage = (
  input: ModifyDBSnapshotAttributeMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AttributeName !== undefined) {
    entries["AttributeName"] = input.AttributeName;
  }
  if (input.DBSnapshotIdentifier !== undefined) {
    entries["DBSnapshotIdentifier"] = input.DBSnapshotIdentifier;
  }
  if (input.ValuesToAdd !== undefined) {
    const memberEntries = serializeAws_queryAttributeValueList(
      input.ValuesToAdd,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ValuesToAdd.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ValuesToRemove !== undefined) {
    const memberEntries = serializeAws_queryAttributeValueList(
      input.ValuesToRemove,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ValuesToRemove.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyDBSnapshotMessage = (
  input: ModifyDBSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSnapshotIdentifier !== undefined) {
    entries["DBSnapshotIdentifier"] = input.DBSnapshotIdentifier;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  return entries;
};

const serializeAws_queryModifyDBSubnetGroupMessage = (
  input: ModifyDBSubnetGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSubnetGroupDescription !== undefined) {
    entries["DBSubnetGroupDescription"] = input.DBSubnetGroupDescription;
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.SubnetIds !== undefined) {
    const memberEntries = serializeAws_querySubnetIdentifierList(
      input.SubnetIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SubnetIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryModifyEventSubscriptionMessage = (
  input: ModifyEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Enabled !== undefined) {
    entries["Enabled"] = input.Enabled;
  }
  if (input.EventCategories !== undefined) {
    const memberEntries = serializeAws_queryEventCategoriesList(
      input.EventCategories,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EventCategories.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.SnsTopicArn !== undefined) {
    entries["SnsTopicArn"] = input.SnsTopicArn;
  }
  if (input.SourceType !== undefined) {
    entries["SourceType"] = input.SourceType;
  }
  if (input.SubscriptionName !== undefined) {
    entries["SubscriptionName"] = input.SubscriptionName;
  }
  return entries;
};

const serializeAws_queryModifyGlobalClusterMessage = (
  input: ModifyGlobalClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.GlobalClusterIdentifier !== undefined) {
    entries["GlobalClusterIdentifier"] = input.GlobalClusterIdentifier;
  }
  if (input.NewGlobalClusterIdentifier !== undefined) {
    entries["NewGlobalClusterIdentifier"] = input.NewGlobalClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryModifyOptionGroupMessage = (
  input: ModifyOptionGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ApplyImmediately !== undefined) {
    entries["ApplyImmediately"] = input.ApplyImmediately;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.OptionsToInclude !== undefined) {
    const memberEntries = serializeAws_queryOptionConfigurationList(
      input.OptionsToInclude,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `OptionsToInclude.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.OptionsToRemove !== undefined) {
    const memberEntries = serializeAws_queryOptionNamesList(
      input.OptionsToRemove,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `OptionsToRemove.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryOptionConfiguration = (
  input: OptionConfiguration,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBSecurityGroupMemberships !== undefined) {
    const memberEntries = serializeAws_queryDBSecurityGroupNameList(
      input.DBSecurityGroupMemberships,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `DBSecurityGroupMemberships.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.OptionName !== undefined) {
    entries["OptionName"] = input.OptionName;
  }
  if (input.OptionSettings !== undefined) {
    const memberEntries = serializeAws_queryOptionSettingsList(
      input.OptionSettings,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `OptionSettings.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.OptionVersion !== undefined) {
    entries["OptionVersion"] = input.OptionVersion;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.VpcSecurityGroupMemberships !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupMemberships,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupMemberships.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryOptionConfigurationList = (
  input: OptionConfiguration[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_queryOptionConfiguration(entry, context);
    Object.keys(memberEntries).forEach(key => {
      entries[`OptionConfiguration.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  }
  return entries;
};

const serializeAws_queryOptionNamesList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryOptionSetting = (
  input: OptionSetting,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllowedValues !== undefined) {
    entries["AllowedValues"] = input.AllowedValues;
  }
  if (input.ApplyType !== undefined) {
    entries["ApplyType"] = input.ApplyType;
  }
  if (input.DataType !== undefined) {
    entries["DataType"] = input.DataType;
  }
  if (input.DefaultValue !== undefined) {
    entries["DefaultValue"] = input.DefaultValue;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.IsCollection !== undefined) {
    entries["IsCollection"] = input.IsCollection;
  }
  if (input.IsModifiable !== undefined) {
    entries["IsModifiable"] = input.IsModifiable;
  }
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_queryOptionSettingsList = (
  input: OptionSetting[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_queryOptionSetting(entry, context);
    Object.keys(memberEntries).forEach(key => {
      entries[`OptionSetting.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  }
  return entries;
};

const serializeAws_queryParameter = (
  input: Parameter,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllowedValues !== undefined) {
    entries["AllowedValues"] = input.AllowedValues;
  }
  if (input.ApplyMethod !== undefined) {
    entries["ApplyMethod"] = input.ApplyMethod;
  }
  if (input.ApplyType !== undefined) {
    entries["ApplyType"] = input.ApplyType;
  }
  if (input.DataType !== undefined) {
    entries["DataType"] = input.DataType;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.IsModifiable !== undefined) {
    entries["IsModifiable"] = input.IsModifiable;
  }
  if (input.MinimumEngineVersion !== undefined) {
    entries["MinimumEngineVersion"] = input.MinimumEngineVersion;
  }
  if (input.ParameterName !== undefined) {
    entries["ParameterName"] = input.ParameterName;
  }
  if (input.ParameterValue !== undefined) {
    entries["ParameterValue"] = input.ParameterValue;
  }
  if (input.Source !== undefined) {
    entries["Source"] = input.Source;
  }
  if (input.SupportedEngineModes !== undefined) {
    const memberEntries = serializeAws_queryEngineModeList(
      input.SupportedEngineModes,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `SupportedEngineModes.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryParametersList = (
  input: Parameter[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_queryParameter(entry, context);
    Object.keys(memberEntries).forEach(key => {
      entries[`Parameter.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  }
  return entries;
};

const serializeAws_queryProcessorFeature = (
  input: ProcessorFeature,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.Name !== undefined) {
    entries["Name"] = input.Name;
  }
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_queryProcessorFeatureList = (
  input: ProcessorFeature[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_queryProcessorFeature(entry, context);
    Object.keys(memberEntries).forEach(key => {
      entries[`ProcessorFeature.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  }
  return entries;
};

const serializeAws_queryPromoteReadReplicaDBClusterMessage = (
  input: PromoteReadReplicaDBClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryPromoteReadReplicaMessage = (
  input: PromoteReadReplicaMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BackupRetentionPeriod !== undefined) {
    entries["BackupRetentionPeriod"] = input.BackupRetentionPeriod;
  }
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.PreferredBackupWindow !== undefined) {
    entries["PreferredBackupWindow"] = input.PreferredBackupWindow;
  }
  return entries;
};

const serializeAws_queryPurchaseReservedDBInstancesOfferingMessage = (
  input: PurchaseReservedDBInstancesOfferingMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceCount !== undefined) {
    entries["DBInstanceCount"] = input.DBInstanceCount;
  }
  if (input.ReservedDBInstanceId !== undefined) {
    entries["ReservedDBInstanceId"] = input.ReservedDBInstanceId;
  }
  if (input.ReservedDBInstancesOfferingId !== undefined) {
    entries["ReservedDBInstancesOfferingId"] =
      input.ReservedDBInstancesOfferingId;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryRebootDBInstanceMessage = (
  input: RebootDBInstanceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.ForceFailover !== undefined) {
    entries["ForceFailover"] = input.ForceFailover;
  }
  return entries;
};

const serializeAws_queryRegisterDBProxyTargetsRequest = (
  input: RegisterDBProxyTargetsRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifiers !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.DBClusterIdentifiers,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `DBClusterIdentifiers.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DBInstanceIdentifiers !== undefined) {
    const memberEntries = serializeAws_queryStringList(
      input.DBInstanceIdentifiers,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `DBInstanceIdentifiers.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DBProxyName !== undefined) {
    entries["DBProxyName"] = input.DBProxyName;
  }
  if (input.TargetGroupName !== undefined) {
    entries["TargetGroupName"] = input.TargetGroupName;
  }
  return entries;
};

const serializeAws_queryRemoveFromGlobalClusterMessage = (
  input: RemoveFromGlobalClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DbClusterIdentifier !== undefined) {
    entries["DbClusterIdentifier"] = input.DbClusterIdentifier;
  }
  if (input.GlobalClusterIdentifier !== undefined) {
    entries["GlobalClusterIdentifier"] = input.GlobalClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryRemoveRoleFromDBClusterMessage = (
  input: RemoveRoleFromDBClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.FeatureName !== undefined) {
    entries["FeatureName"] = input.FeatureName;
  }
  if (input.RoleArn !== undefined) {
    entries["RoleArn"] = input.RoleArn;
  }
  return entries;
};

const serializeAws_queryRemoveRoleFromDBInstanceMessage = (
  input: RemoveRoleFromDBInstanceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.FeatureName !== undefined) {
    entries["FeatureName"] = input.FeatureName;
  }
  if (input.RoleArn !== undefined) {
    entries["RoleArn"] = input.RoleArn;
  }
  return entries;
};

const serializeAws_queryRemoveSourceIdentifierFromSubscriptionMessage = (
  input: RemoveSourceIdentifierFromSubscriptionMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.SourceIdentifier !== undefined) {
    entries["SourceIdentifier"] = input.SourceIdentifier;
  }
  if (input.SubscriptionName !== undefined) {
    entries["SubscriptionName"] = input.SubscriptionName;
  }
  return entries;
};

const serializeAws_queryRemoveTagsFromResourceMessage = (
  input: RemoveTagsFromResourceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ResourceName !== undefined) {
    entries["ResourceName"] = input.ResourceName;
  }
  if (input.TagKeys !== undefined) {
    const memberEntries = serializeAws_queryKeyList(input.TagKeys, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `TagKeys.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryResetDBClusterParameterGroupMessage = (
  input: ResetDBClusterParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  if (input.Parameters !== undefined) {
    const memberEntries = serializeAws_queryParametersList(
      input.Parameters,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Parameters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ResetAllParameters !== undefined) {
    entries["ResetAllParameters"] = input.ResetAllParameters;
  }
  return entries;
};

const serializeAws_queryResetDBParameterGroupMessage = (
  input: ResetDBParameterGroupMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.Parameters !== undefined) {
    const memberEntries = serializeAws_queryParametersList(
      input.Parameters,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `Parameters.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.ResetAllParameters !== undefined) {
    entries["ResetAllParameters"] = input.ResetAllParameters;
  }
  return entries;
};

const serializeAws_queryRestoreDBClusterFromS3Message = (
  input: RestoreDBClusterFromS3Message,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZones !== undefined) {
    const memberEntries = serializeAws_queryAvailabilityZones(
      input.AvailabilityZones,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `AvailabilityZones.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.BacktrackWindow !== undefined) {
    entries["BacktrackWindow"] = input.BacktrackWindow;
  }
  if (input.BackupRetentionPeriod !== undefined) {
    entries["BackupRetentionPeriod"] = input.BackupRetentionPeriod;
  }
  if (input.CharacterSetName !== undefined) {
    entries["CharacterSetName"] = input.CharacterSetName;
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.DatabaseName !== undefined) {
    entries["DatabaseName"] = input.DatabaseName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.EnableCloudwatchLogsExports !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.EnableCloudwatchLogsExports,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EnableCloudwatchLogsExports.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MasterUserPassword !== undefined) {
    entries["MasterUserPassword"] = input.MasterUserPassword;
  }
  if (input.MasterUsername !== undefined) {
    entries["MasterUsername"] = input.MasterUsername;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.PreferredBackupWindow !== undefined) {
    entries["PreferredBackupWindow"] = input.PreferredBackupWindow;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    entries["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.S3BucketName !== undefined) {
    entries["S3BucketName"] = input.S3BucketName;
  }
  if (input.S3IngestionRoleArn !== undefined) {
    entries["S3IngestionRoleArn"] = input.S3IngestionRoleArn;
  }
  if (input.S3Prefix !== undefined) {
    entries["S3Prefix"] = input.S3Prefix;
  }
  if (input.SourceEngine !== undefined) {
    entries["SourceEngine"] = input.SourceEngine;
  }
  if (input.SourceEngineVersion !== undefined) {
    entries["SourceEngineVersion"] = input.SourceEngineVersion;
  }
  if (input.StorageEncrypted !== undefined) {
    entries["StorageEncrypted"] = input.StorageEncrypted;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryRestoreDBClusterFromSnapshotMessage = (
  input: RestoreDBClusterFromSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AvailabilityZones !== undefined) {
    const memberEntries = serializeAws_queryAvailabilityZones(
      input.AvailabilityZones,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `AvailabilityZones.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.BacktrackWindow !== undefined) {
    entries["BacktrackWindow"] = input.BacktrackWindow;
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.DatabaseName !== undefined) {
    entries["DatabaseName"] = input.DatabaseName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.EnableCloudwatchLogsExports !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.EnableCloudwatchLogsExports,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EnableCloudwatchLogsExports.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.EngineMode !== undefined) {
    entries["EngineMode"] = input.EngineMode;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.ScalingConfiguration !== undefined) {
    const memberEntries = serializeAws_queryScalingConfiguration(
      input.ScalingConfiguration,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ScalingConfiguration.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.SnapshotIdentifier !== undefined) {
    entries["SnapshotIdentifier"] = input.SnapshotIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryRestoreDBClusterToPointInTimeMessage = (
  input: RestoreDBClusterToPointInTimeMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.BacktrackWindow !== undefined) {
    entries["BacktrackWindow"] = input.BacktrackWindow;
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  if (input.DBClusterParameterGroupName !== undefined) {
    entries["DBClusterParameterGroupName"] = input.DBClusterParameterGroupName;
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.EnableCloudwatchLogsExports !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.EnableCloudwatchLogsExports,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EnableCloudwatchLogsExports.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.RestoreToTime !== undefined) {
    entries["RestoreToTime"] =
      input.RestoreToTime.toISOString().split(".")[0] + "Z";
  }
  if (input.RestoreType !== undefined) {
    entries["RestoreType"] = input.RestoreType;
  }
  if (input.SourceDBClusterIdentifier !== undefined) {
    entries["SourceDBClusterIdentifier"] = input.SourceDBClusterIdentifier;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.UseLatestRestorableTime !== undefined) {
    entries["UseLatestRestorableTime"] = input.UseLatestRestorableTime;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryRestoreDBInstanceFromDBSnapshotMessage = (
  input: RestoreDBInstanceFromDBSnapshotMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AutoMinorVersionUpgrade !== undefined) {
    entries["AutoMinorVersionUpgrade"] = input.AutoMinorVersionUpgrade;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBInstanceClass !== undefined) {
    entries["DBInstanceClass"] = input.DBInstanceClass;
  }
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.DBName !== undefined) {
    entries["DBName"] = input.DBName;
  }
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.DBSnapshotIdentifier !== undefined) {
    entries["DBSnapshotIdentifier"] = input.DBSnapshotIdentifier;
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.Domain !== undefined) {
    entries["Domain"] = input.Domain;
  }
  if (input.DomainIAMRoleName !== undefined) {
    entries["DomainIAMRoleName"] = input.DomainIAMRoleName;
  }
  if (input.EnableCloudwatchLogsExports !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.EnableCloudwatchLogsExports,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EnableCloudwatchLogsExports.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.LicenseModel !== undefined) {
    entries["LicenseModel"] = input.LicenseModel;
  }
  if (input.MultiAZ !== undefined) {
    entries["MultiAZ"] = input.MultiAZ;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.ProcessorFeatures !== undefined) {
    const memberEntries = serializeAws_queryProcessorFeatureList(
      input.ProcessorFeatures,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ProcessorFeatures.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.PubliclyAccessible !== undefined) {
    entries["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.StorageType !== undefined) {
    entries["StorageType"] = input.StorageType;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TdeCredentialArn !== undefined) {
    entries["TdeCredentialArn"] = input.TdeCredentialArn;
  }
  if (input.TdeCredentialPassword !== undefined) {
    entries["TdeCredentialPassword"] = input.TdeCredentialPassword;
  }
  if (input.UseDefaultProcessorFeatures !== undefined) {
    entries["UseDefaultProcessorFeatures"] = input.UseDefaultProcessorFeatures;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryRestoreDBInstanceFromS3Message = (
  input: RestoreDBInstanceFromS3Message,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AllocatedStorage !== undefined) {
    entries["AllocatedStorage"] = input.AllocatedStorage;
  }
  if (input.AutoMinorVersionUpgrade !== undefined) {
    entries["AutoMinorVersionUpgrade"] = input.AutoMinorVersionUpgrade;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.BackupRetentionPeriod !== undefined) {
    entries["BackupRetentionPeriod"] = input.BackupRetentionPeriod;
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBInstanceClass !== undefined) {
    entries["DBInstanceClass"] = input.DBInstanceClass;
  }
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.DBName !== undefined) {
    entries["DBName"] = input.DBName;
  }
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.DBSecurityGroups !== undefined) {
    const memberEntries = serializeAws_queryDBSecurityGroupNameList(
      input.DBSecurityGroups,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `DBSecurityGroups.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.EnableCloudwatchLogsExports !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.EnableCloudwatchLogsExports,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EnableCloudwatchLogsExports.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.EnablePerformanceInsights !== undefined) {
    entries["EnablePerformanceInsights"] = input.EnablePerformanceInsights;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.EngineVersion !== undefined) {
    entries["EngineVersion"] = input.EngineVersion;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.LicenseModel !== undefined) {
    entries["LicenseModel"] = input.LicenseModel;
  }
  if (input.MasterUserPassword !== undefined) {
    entries["MasterUserPassword"] = input.MasterUserPassword;
  }
  if (input.MasterUsername !== undefined) {
    entries["MasterUsername"] = input.MasterUsername;
  }
  if (input.MonitoringInterval !== undefined) {
    entries["MonitoringInterval"] = input.MonitoringInterval;
  }
  if (input.MonitoringRoleArn !== undefined) {
    entries["MonitoringRoleArn"] = input.MonitoringRoleArn;
  }
  if (input.MultiAZ !== undefined) {
    entries["MultiAZ"] = input.MultiAZ;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.PerformanceInsightsKMSKeyId !== undefined) {
    entries["PerformanceInsightsKMSKeyId"] = input.PerformanceInsightsKMSKeyId;
  }
  if (input.PerformanceInsightsRetentionPeriod !== undefined) {
    entries["PerformanceInsightsRetentionPeriod"] =
      input.PerformanceInsightsRetentionPeriod;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.PreferredBackupWindow !== undefined) {
    entries["PreferredBackupWindow"] = input.PreferredBackupWindow;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    entries["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.ProcessorFeatures !== undefined) {
    const memberEntries = serializeAws_queryProcessorFeatureList(
      input.ProcessorFeatures,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ProcessorFeatures.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.PubliclyAccessible !== undefined) {
    entries["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.S3BucketName !== undefined) {
    entries["S3BucketName"] = input.S3BucketName;
  }
  if (input.S3IngestionRoleArn !== undefined) {
    entries["S3IngestionRoleArn"] = input.S3IngestionRoleArn;
  }
  if (input.S3Prefix !== undefined) {
    entries["S3Prefix"] = input.S3Prefix;
  }
  if (input.SourceEngine !== undefined) {
    entries["SourceEngine"] = input.SourceEngine;
  }
  if (input.SourceEngineVersion !== undefined) {
    entries["SourceEngineVersion"] = input.SourceEngineVersion;
  }
  if (input.StorageEncrypted !== undefined) {
    entries["StorageEncrypted"] = input.StorageEncrypted;
  }
  if (input.StorageType !== undefined) {
    entries["StorageType"] = input.StorageType;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.UseDefaultProcessorFeatures !== undefined) {
    entries["UseDefaultProcessorFeatures"] = input.UseDefaultProcessorFeatures;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryRestoreDBInstanceToPointInTimeMessage = (
  input: RestoreDBInstanceToPointInTimeMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AutoMinorVersionUpgrade !== undefined) {
    entries["AutoMinorVersionUpgrade"] = input.AutoMinorVersionUpgrade;
  }
  if (input.AvailabilityZone !== undefined) {
    entries["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.CopyTagsToSnapshot !== undefined) {
    entries["CopyTagsToSnapshot"] = input.CopyTagsToSnapshot;
  }
  if (input.DBInstanceClass !== undefined) {
    entries["DBInstanceClass"] = input.DBInstanceClass;
  }
  if (input.DBName !== undefined) {
    entries["DBName"] = input.DBName;
  }
  if (input.DBParameterGroupName !== undefined) {
    entries["DBParameterGroupName"] = input.DBParameterGroupName;
  }
  if (input.DBSubnetGroupName !== undefined) {
    entries["DBSubnetGroupName"] = input.DBSubnetGroupName;
  }
  if (input.DeletionProtection !== undefined) {
    entries["DeletionProtection"] = input.DeletionProtection;
  }
  if (input.Domain !== undefined) {
    entries["Domain"] = input.Domain;
  }
  if (input.DomainIAMRoleName !== undefined) {
    entries["DomainIAMRoleName"] = input.DomainIAMRoleName;
  }
  if (input.EnableCloudwatchLogsExports !== undefined) {
    const memberEntries = serializeAws_queryLogTypeList(
      input.EnableCloudwatchLogsExports,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `EnableCloudwatchLogsExports.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.EnableIAMDatabaseAuthentication !== undefined) {
    entries["EnableIAMDatabaseAuthentication"] =
      input.EnableIAMDatabaseAuthentication;
  }
  if (input.Engine !== undefined) {
    entries["Engine"] = input.Engine;
  }
  if (input.Iops !== undefined) {
    entries["Iops"] = input.Iops;
  }
  if (input.LicenseModel !== undefined) {
    entries["LicenseModel"] = input.LicenseModel;
  }
  if (input.MultiAZ !== undefined) {
    entries["MultiAZ"] = input.MultiAZ;
  }
  if (input.OptionGroupName !== undefined) {
    entries["OptionGroupName"] = input.OptionGroupName;
  }
  if (input.Port !== undefined) {
    entries["Port"] = input.Port;
  }
  if (input.ProcessorFeatures !== undefined) {
    const memberEntries = serializeAws_queryProcessorFeatureList(
      input.ProcessorFeatures,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `ProcessorFeatures.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.PubliclyAccessible !== undefined) {
    entries["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.RestoreTime !== undefined) {
    entries["RestoreTime"] =
      input.RestoreTime.toISOString().split(".")[0] + "Z";
  }
  if (input.SourceDBInstanceIdentifier !== undefined) {
    entries["SourceDBInstanceIdentifier"] = input.SourceDBInstanceIdentifier;
  }
  if (input.SourceDbiResourceId !== undefined) {
    entries["SourceDbiResourceId"] = input.SourceDbiResourceId;
  }
  if (input.StorageType !== undefined) {
    entries["StorageType"] = input.StorageType;
  }
  if (input.Tags !== undefined) {
    const memberEntries = serializeAws_queryTagList(input.Tags, context);
    Object.keys(memberEntries).forEach(key => {
      const loc = `Tags.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  if (input.TargetDBInstanceIdentifier !== undefined) {
    entries["TargetDBInstanceIdentifier"] = input.TargetDBInstanceIdentifier;
  }
  if (input.TdeCredentialArn !== undefined) {
    entries["TdeCredentialArn"] = input.TdeCredentialArn;
  }
  if (input.TdeCredentialPassword !== undefined) {
    entries["TdeCredentialPassword"] = input.TdeCredentialPassword;
  }
  if (input.UseDefaultProcessorFeatures !== undefined) {
    entries["UseDefaultProcessorFeatures"] = input.UseDefaultProcessorFeatures;
  }
  if (input.UseLatestRestorableTime !== undefined) {
    entries["UseLatestRestorableTime"] = input.UseLatestRestorableTime;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    const memberEntries = serializeAws_queryVpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
    Object.keys(memberEntries).forEach(key => {
      const loc = `VpcSecurityGroupIds.${key}`;
      entries[loc] = memberEntries[key];
    });
  }
  return entries;
};

const serializeAws_queryRevokeDBSecurityGroupIngressMessage = (
  input: RevokeDBSecurityGroupIngressMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.CIDRIP !== undefined) {
    entries["CIDRIP"] = input.CIDRIP;
  }
  if (input.DBSecurityGroupName !== undefined) {
    entries["DBSecurityGroupName"] = input.DBSecurityGroupName;
  }
  if (input.EC2SecurityGroupId !== undefined) {
    entries["EC2SecurityGroupId"] = input.EC2SecurityGroupId;
  }
  if (input.EC2SecurityGroupName !== undefined) {
    entries["EC2SecurityGroupName"] = input.EC2SecurityGroupName;
  }
  if (input.EC2SecurityGroupOwnerId !== undefined) {
    entries["EC2SecurityGroupOwnerId"] = input.EC2SecurityGroupOwnerId;
  }
  return entries;
};

const serializeAws_queryScalingConfiguration = (
  input: ScalingConfiguration,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AutoPause !== undefined) {
    entries["AutoPause"] = input.AutoPause;
  }
  if (input.MaxCapacity !== undefined) {
    entries["MaxCapacity"] = input.MaxCapacity;
  }
  if (input.MinCapacity !== undefined) {
    entries["MinCapacity"] = input.MinCapacity;
  }
  if (input.SecondsUntilAutoPause !== undefined) {
    entries["SecondsUntilAutoPause"] = input.SecondsUntilAutoPause;
  }
  if (input.TimeoutAction !== undefined) {
    entries["TimeoutAction"] = input.TimeoutAction;
  }
  return entries;
};

const serializeAws_querySourceIdsList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`SourceId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryStartActivityStreamRequest = (
  input: StartActivityStreamRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ApplyImmediately !== undefined) {
    entries["ApplyImmediately"] = input.ApplyImmediately;
  }
  if (input.KmsKeyId !== undefined) {
    entries["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.Mode !== undefined) {
    entries["Mode"] = input.Mode;
  }
  if (input.ResourceArn !== undefined) {
    entries["ResourceArn"] = input.ResourceArn;
  }
  return entries;
};

const serializeAws_queryStartDBClusterMessage = (
  input: StartDBClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryStartDBInstanceMessage = (
  input: StartDBInstanceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  return entries;
};

const serializeAws_queryStopActivityStreamRequest = (
  input: StopActivityStreamRequest,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.ApplyImmediately !== undefined) {
    entries["ApplyImmediately"] = input.ApplyImmediately;
  }
  if (input.ResourceArn !== undefined) {
    entries["ResourceArn"] = input.ResourceArn;
  }
  return entries;
};

const serializeAws_queryStopDBClusterMessage = (
  input: StopDBClusterMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBClusterIdentifier !== undefined) {
    entries["DBClusterIdentifier"] = input.DBClusterIdentifier;
  }
  return entries;
};

const serializeAws_queryStopDBInstanceMessage = (
  input: StopDBInstanceMessage,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.DBInstanceIdentifier !== undefined) {
    entries["DBInstanceIdentifier"] = input.DBInstanceIdentifier;
  }
  if (input.DBSnapshotIdentifier !== undefined) {
    entries["DBSnapshotIdentifier"] = input.DBSnapshotIdentifier;
  }
  return entries;
};

const serializeAws_queryStringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`member.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_querySubnetIdentifierList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`SubnetIdentifier.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const serializeAws_queryTag = (input: Tag, context: __SerdeContext): any => {
  const entries: any = {};
  if (input.Key !== undefined) {
    entries["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    entries["Value"] = input.Value;
  }
  return entries;
};

const serializeAws_queryTagList = (
  input: Tag[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_queryTag(entry, context);
    Object.keys(memberEntries).forEach(key => {
      entries[`Tag.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  }
  return entries;
};

const serializeAws_queryUserAuthConfig = (
  input: UserAuthConfig,
  context: __SerdeContext
): any => {
  const entries: any = {};
  if (input.AuthScheme !== undefined) {
    entries["AuthScheme"] = input.AuthScheme;
  }
  if (input.Description !== undefined) {
    entries["Description"] = input.Description;
  }
  if (input.IAMAuth !== undefined) {
    entries["IAMAuth"] = input.IAMAuth;
  }
  if (input.SecretArn !== undefined) {
    entries["SecretArn"] = input.SecretArn;
  }
  if (input.UserName !== undefined) {
    entries["UserName"] = input.UserName;
  }
  return entries;
};

const serializeAws_queryUserAuthConfigList = (
  input: UserAuthConfig[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    const memberEntries = serializeAws_queryUserAuthConfig(entry, context);
    Object.keys(memberEntries).forEach(key => {
      entries[`member.${counter}.${key}`] = memberEntries[key];
    });
    counter++;
  }
  return entries;
};

const serializeAws_queryVpcSecurityGroupIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  const entries: any = {};
  let counter = 1;
  for (let entry of input) {
    entries[`VpcSecurityGroupId.${counter}`] = entry;
    counter++;
  }
  return entries;
};

const deserializeAws_queryAuthorizationAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): AuthorizationAlreadyExistsFault => {
  let contents: any = {
    __type: "AuthorizationAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryAuthorizationNotFoundFault = (
  output: any,
  context: __SerdeContext
): AuthorizationNotFoundFault => {
  let contents: any = {
    __type: "AuthorizationNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryAuthorizationQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): AuthorizationQuotaExceededFault => {
  let contents: any = {
    __type: "AuthorizationQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryBackupPolicyNotFoundFault = (
  output: any,
  context: __SerdeContext
): BackupPolicyNotFoundFault => {
  let contents: any = {
    __type: "BackupPolicyNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryCertificateNotFoundFault = (
  output: any,
  context: __SerdeContext
): CertificateNotFoundFault => {
  let contents: any = {
    __type: "CertificateNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryCustomAvailabilityZoneAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): CustomAvailabilityZoneAlreadyExistsFault => {
  let contents: any = {
    __type: "CustomAvailabilityZoneAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryCustomAvailabilityZoneNotFoundFault = (
  output: any,
  context: __SerdeContext
): CustomAvailabilityZoneNotFoundFault => {
  let contents: any = {
    __type: "CustomAvailabilityZoneNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryCustomAvailabilityZoneQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): CustomAvailabilityZoneQuotaExceededFault => {
  let contents: any = {
    __type: "CustomAvailabilityZoneQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBClusterAlreadyExistsFault => {
  let contents: any = {
    __type: "DBClusterAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterBacktrackNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBClusterBacktrackNotFoundFault => {
  let contents: any = {
    __type: "DBClusterBacktrackNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterEndpointAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBClusterEndpointAlreadyExistsFault => {
  let contents: any = {
    __type: "DBClusterEndpointAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterEndpointNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBClusterEndpointNotFoundFault => {
  let contents: any = {
    __type: "DBClusterEndpointNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterEndpointQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): DBClusterEndpointQuotaExceededFault => {
  let contents: any = {
    __type: "DBClusterEndpointQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBClusterNotFoundFault => {
  let contents: any = {
    __type: "DBClusterNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterParameterGroupNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBClusterParameterGroupNotFoundFault => {
  let contents: any = {
    __type: "DBClusterParameterGroupNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): DBClusterQuotaExceededFault => {
  let contents: any = {
    __type: "DBClusterQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterRoleAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBClusterRoleAlreadyExistsFault => {
  let contents: any = {
    __type: "DBClusterRoleAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterRoleNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBClusterRoleNotFoundFault => {
  let contents: any = {
    __type: "DBClusterRoleNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterRoleQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): DBClusterRoleQuotaExceededFault => {
  let contents: any = {
    __type: "DBClusterRoleQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterSnapshotAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBClusterSnapshotAlreadyExistsFault => {
  let contents: any = {
    __type: "DBClusterSnapshotAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBClusterSnapshotNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBClusterSnapshotNotFoundFault => {
  let contents: any = {
    __type: "DBClusterSnapshotNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBInstanceAlreadyExistsFault => {
  let contents: any = {
    __type: "DBInstanceAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceAutomatedBackupNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBInstanceAutomatedBackupNotFoundFault => {
  let contents: any = {
    __type: "DBInstanceAutomatedBackupNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceAutomatedBackupQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): DBInstanceAutomatedBackupQuotaExceededFault => {
  let contents: any = {
    __type: "DBInstanceAutomatedBackupQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBInstanceNotFoundFault => {
  let contents: any = {
    __type: "DBInstanceNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceRoleAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBInstanceRoleAlreadyExistsFault => {
  let contents: any = {
    __type: "DBInstanceRoleAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceRoleNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBInstanceRoleNotFoundFault => {
  let contents: any = {
    __type: "DBInstanceRoleNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceRoleQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): DBInstanceRoleQuotaExceededFault => {
  let contents: any = {
    __type: "DBInstanceRoleQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBLogFileNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBLogFileNotFoundFault => {
  let contents: any = {
    __type: "DBLogFileNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBParameterGroupAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBParameterGroupAlreadyExistsFault => {
  let contents: any = {
    __type: "DBParameterGroupAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBParameterGroupNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBParameterGroupNotFoundFault => {
  let contents: any = {
    __type: "DBParameterGroupNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBParameterGroupQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): DBParameterGroupQuotaExceededFault => {
  let contents: any = {
    __type: "DBParameterGroupQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBProxyAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBProxyAlreadyExistsFault => {
  let contents: any = {
    __type: "DBProxyAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBProxyNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBProxyNotFoundFault => {
  let contents: any = {
    __type: "DBProxyNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBProxyQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): DBProxyQuotaExceededFault => {
  let contents: any = {
    __type: "DBProxyQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBProxyTargetAlreadyRegisteredFault = (
  output: any,
  context: __SerdeContext
): DBProxyTargetAlreadyRegisteredFault => {
  let contents: any = {
    __type: "DBProxyTargetAlreadyRegisteredFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBProxyTargetGroupNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBProxyTargetGroupNotFoundFault => {
  let contents: any = {
    __type: "DBProxyTargetGroupNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBProxyTargetNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBProxyTargetNotFoundFault => {
  let contents: any = {
    __type: "DBProxyTargetNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSecurityGroupAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBSecurityGroupAlreadyExistsFault => {
  let contents: any = {
    __type: "DBSecurityGroupAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSecurityGroupNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBSecurityGroupNotFoundFault => {
  let contents: any = {
    __type: "DBSecurityGroupNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSecurityGroupNotSupportedFault = (
  output: any,
  context: __SerdeContext
): DBSecurityGroupNotSupportedFault => {
  let contents: any = {
    __type: "DBSecurityGroupNotSupportedFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSecurityGroupQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): DBSecurityGroupQuotaExceededFault => {
  let contents: any = {
    __type: "DBSecurityGroupQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSnapshotAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBSnapshotAlreadyExistsFault => {
  let contents: any = {
    __type: "DBSnapshotAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSnapshotNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBSnapshotNotFoundFault => {
  let contents: any = {
    __type: "DBSnapshotNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSubnetGroupAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): DBSubnetGroupAlreadyExistsFault => {
  let contents: any = {
    __type: "DBSubnetGroupAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSubnetGroupDoesNotCoverEnoughAZs = (
  output: any,
  context: __SerdeContext
): DBSubnetGroupDoesNotCoverEnoughAZs => {
  let contents: any = {
    __type: "DBSubnetGroupDoesNotCoverEnoughAZs",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSubnetGroupNotAllowedFault = (
  output: any,
  context: __SerdeContext
): DBSubnetGroupNotAllowedFault => {
  let contents: any = {
    __type: "DBSubnetGroupNotAllowedFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSubnetGroupNotFoundFault = (
  output: any,
  context: __SerdeContext
): DBSubnetGroupNotFoundFault => {
  let contents: any = {
    __type: "DBSubnetGroupNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSubnetGroupQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): DBSubnetGroupQuotaExceededFault => {
  let contents: any = {
    __type: "DBSubnetGroupQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBSubnetQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): DBSubnetQuotaExceededFault => {
  let contents: any = {
    __type: "DBSubnetQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDBUpgradeDependencyFailureFault = (
  output: any,
  context: __SerdeContext
): DBUpgradeDependencyFailureFault => {
  let contents: any = {
    __type: "DBUpgradeDependencyFailureFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryDomainNotFoundFault = (
  output: any,
  context: __SerdeContext
): DomainNotFoundFault => {
  let contents: any = {
    __type: "DomainNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryEventSubscriptionQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): EventSubscriptionQuotaExceededFault => {
  let contents: any = {
    __type: "EventSubscriptionQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryGlobalClusterAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): GlobalClusterAlreadyExistsFault => {
  let contents: any = {
    __type: "GlobalClusterAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryGlobalClusterNotFoundFault = (
  output: any,
  context: __SerdeContext
): GlobalClusterNotFoundFault => {
  let contents: any = {
    __type: "GlobalClusterNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryGlobalClusterQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): GlobalClusterQuotaExceededFault => {
  let contents: any = {
    __type: "GlobalClusterQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInstallationMediaAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): InstallationMediaAlreadyExistsFault => {
  let contents: any = {
    __type: "InstallationMediaAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInstallationMediaNotFoundFault = (
  output: any,
  context: __SerdeContext
): InstallationMediaNotFoundFault => {
  let contents: any = {
    __type: "InstallationMediaNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInstanceQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): InstanceQuotaExceededFault => {
  let contents: any = {
    __type: "InstanceQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInsufficientDBClusterCapacityFault = (
  output: any,
  context: __SerdeContext
): InsufficientDBClusterCapacityFault => {
  let contents: any = {
    __type: "InsufficientDBClusterCapacityFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInsufficientDBInstanceCapacityFault = (
  output: any,
  context: __SerdeContext
): InsufficientDBInstanceCapacityFault => {
  let contents: any = {
    __type: "InsufficientDBInstanceCapacityFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInsufficientStorageClusterCapacityFault = (
  output: any,
  context: __SerdeContext
): InsufficientStorageClusterCapacityFault => {
  let contents: any = {
    __type: "InsufficientStorageClusterCapacityFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBClusterCapacityFault = (
  output: any,
  context: __SerdeContext
): InvalidDBClusterCapacityFault => {
  let contents: any = {
    __type: "InvalidDBClusterCapacityFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBClusterEndpointStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBClusterEndpointStateFault => {
  let contents: any = {
    __type: "InvalidDBClusterEndpointStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBClusterSnapshotStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBClusterSnapshotStateFault => {
  let contents: any = {
    __type: "InvalidDBClusterSnapshotStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBClusterStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBClusterStateFault => {
  let contents: any = {
    __type: "InvalidDBClusterStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBInstanceAutomatedBackupStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBInstanceAutomatedBackupStateFault => {
  let contents: any = {
    __type: "InvalidDBInstanceAutomatedBackupStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBInstanceStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBInstanceStateFault => {
  let contents: any = {
    __type: "InvalidDBInstanceStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBParameterGroupStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBParameterGroupStateFault => {
  let contents: any = {
    __type: "InvalidDBParameterGroupStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBProxyStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBProxyStateFault => {
  let contents: any = {
    __type: "InvalidDBProxyStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBSecurityGroupStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBSecurityGroupStateFault => {
  let contents: any = {
    __type: "InvalidDBSecurityGroupStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBSnapshotStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBSnapshotStateFault => {
  let contents: any = {
    __type: "InvalidDBSnapshotStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBSubnetGroupFault = (
  output: any,
  context: __SerdeContext
): InvalidDBSubnetGroupFault => {
  let contents: any = {
    __type: "InvalidDBSubnetGroupFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBSubnetGroupStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBSubnetGroupStateFault => {
  let contents: any = {
    __type: "InvalidDBSubnetGroupStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidDBSubnetStateFault = (
  output: any,
  context: __SerdeContext
): InvalidDBSubnetStateFault => {
  let contents: any = {
    __type: "InvalidDBSubnetStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidEventSubscriptionStateFault = (
  output: any,
  context: __SerdeContext
): InvalidEventSubscriptionStateFault => {
  let contents: any = {
    __type: "InvalidEventSubscriptionStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidGlobalClusterStateFault = (
  output: any,
  context: __SerdeContext
): InvalidGlobalClusterStateFault => {
  let contents: any = {
    __type: "InvalidGlobalClusterStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidOptionGroupStateFault = (
  output: any,
  context: __SerdeContext
): InvalidOptionGroupStateFault => {
  let contents: any = {
    __type: "InvalidOptionGroupStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidRestoreFault = (
  output: any,
  context: __SerdeContext
): InvalidRestoreFault => {
  let contents: any = {
    __type: "InvalidRestoreFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidS3BucketFault = (
  output: any,
  context: __SerdeContext
): InvalidS3BucketFault => {
  let contents: any = {
    __type: "InvalidS3BucketFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidSubnet = (
  output: any,
  context: __SerdeContext
): InvalidSubnet => {
  let contents: any = {
    __type: "InvalidSubnet",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryInvalidVPCNetworkStateFault = (
  output: any,
  context: __SerdeContext
): InvalidVPCNetworkStateFault => {
  let contents: any = {
    __type: "InvalidVPCNetworkStateFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryKMSKeyNotAccessibleFault = (
  output: any,
  context: __SerdeContext
): KMSKeyNotAccessibleFault => {
  let contents: any = {
    __type: "KMSKeyNotAccessibleFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryOptionGroupAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): OptionGroupAlreadyExistsFault => {
  let contents: any = {
    __type: "OptionGroupAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryOptionGroupNotFoundFault = (
  output: any,
  context: __SerdeContext
): OptionGroupNotFoundFault => {
  let contents: any = {
    __type: "OptionGroupNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryOptionGroupQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): OptionGroupQuotaExceededFault => {
  let contents: any = {
    __type: "OptionGroupQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryPointInTimeRestoreNotEnabledFault = (
  output: any,
  context: __SerdeContext
): PointInTimeRestoreNotEnabledFault => {
  let contents: any = {
    __type: "PointInTimeRestoreNotEnabledFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryProvisionedIopsNotAvailableInAZFault = (
  output: any,
  context: __SerdeContext
): ProvisionedIopsNotAvailableInAZFault => {
  let contents: any = {
    __type: "ProvisionedIopsNotAvailableInAZFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryReservedDBInstanceAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ReservedDBInstanceAlreadyExistsFault => {
  let contents: any = {
    __type: "ReservedDBInstanceAlreadyExistsFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryReservedDBInstanceNotFoundFault = (
  output: any,
  context: __SerdeContext
): ReservedDBInstanceNotFoundFault => {
  let contents: any = {
    __type: "ReservedDBInstanceNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryReservedDBInstanceQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ReservedDBInstanceQuotaExceededFault => {
  let contents: any = {
    __type: "ReservedDBInstanceQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryReservedDBInstancesOfferingNotFoundFault = (
  output: any,
  context: __SerdeContext
): ReservedDBInstancesOfferingNotFoundFault => {
  let contents: any = {
    __type: "ReservedDBInstancesOfferingNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryResourceNotFoundFault = (
  output: any,
  context: __SerdeContext
): ResourceNotFoundFault => {
  let contents: any = {
    __type: "ResourceNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_querySNSInvalidTopicFault = (
  output: any,
  context: __SerdeContext
): SNSInvalidTopicFault => {
  let contents: any = {
    __type: "SNSInvalidTopicFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_querySNSNoAuthorizationFault = (
  output: any,
  context: __SerdeContext
): SNSNoAuthorizationFault => {
  let contents: any = {
    __type: "SNSNoAuthorizationFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_querySNSTopicArnNotFoundFault = (
  output: any,
  context: __SerdeContext
): SNSTopicArnNotFoundFault => {
  let contents: any = {
    __type: "SNSTopicArnNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_querySharedSnapshotQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): SharedSnapshotQuotaExceededFault => {
  let contents: any = {
    __type: "SharedSnapshotQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_querySnapshotQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): SnapshotQuotaExceededFault => {
  let contents: any = {
    __type: "SnapshotQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_querySourceNotFoundFault = (
  output: any,
  context: __SerdeContext
): SourceNotFoundFault => {
  let contents: any = {
    __type: "SourceNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryStorageQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): StorageQuotaExceededFault => {
  let contents: any = {
    __type: "StorageQuotaExceededFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryStorageTypeNotSupportedFault = (
  output: any,
  context: __SerdeContext
): StorageTypeNotSupportedFault => {
  let contents: any = {
    __type: "StorageTypeNotSupportedFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_querySubnetAlreadyInUse = (
  output: any,
  context: __SerdeContext
): SubnetAlreadyInUse => {
  let contents: any = {
    __type: "SubnetAlreadyInUse",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_querySubscriptionAlreadyExistFault = (
  output: any,
  context: __SerdeContext
): SubscriptionAlreadyExistFault => {
  let contents: any = {
    __type: "SubscriptionAlreadyExistFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_querySubscriptionCategoryNotFoundFault = (
  output: any,
  context: __SerdeContext
): SubscriptionCategoryNotFoundFault => {
  let contents: any = {
    __type: "SubscriptionCategoryNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_querySubscriptionNotFoundFault = (
  output: any,
  context: __SerdeContext
): SubscriptionNotFoundFault => {
  let contents: any = {
    __type: "SubscriptionNotFoundFault",
    message: undefined
  };
  if (output["message"] !== undefined) {
    contents.message =
      output["message"]["#text"] !== undefined
        ? output["message"]["#text"]
        : output["message"];
  }
  return contents;
};

const deserializeAws_queryAccountAttributesMessage = (
  output: any,
  context: __SerdeContext
): AccountAttributesMessage => {
  let contents: any = {
    __type: "AccountAttributesMessage",
    AccountQuotas: undefined
  };
  if (output.AccountQuotas === "") {
    contents.AccountQuotas = [];
  }
  if (
    output["AccountQuotas"] !== undefined &&
    output["AccountQuotas"]["AccountQuota"] !== undefined
  ) {
    contents.AccountQuotas = deserializeAws_queryAccountQuotaList(
      __getArrayIfSingleItem(output["AccountQuotas"]["AccountQuota"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryAccountQuota = (
  output: any,
  context: __SerdeContext
): AccountQuota => {
  let contents: any = {
    __type: "AccountQuota",
    AccountQuotaName: undefined,
    Max: undefined,
    Used: undefined
  };
  if (output["AccountQuotaName"] !== undefined) {
    contents.AccountQuotaName =
      output["AccountQuotaName"]["#text"] !== undefined
        ? output["AccountQuotaName"]["#text"]
        : output["AccountQuotaName"];
  }
  if (output["Max"] !== undefined) {
    contents.Max = parseInt(
      output["Max"]["#text"] !== undefined
        ? output["Max"]["#text"]
        : output["Max"]
    );
  }
  if (output["Used"] !== undefined) {
    contents.Used = parseInt(
      output["Used"]["#text"] !== undefined
        ? output["Used"]["#text"]
        : output["Used"]
    );
  }
  return contents;
};

const deserializeAws_queryAccountQuotaList = (
  output: any,
  context: __SerdeContext
): AccountQuota[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryAccountQuota(entry, context));
  });
  return contents;
};

const deserializeAws_queryAddSourceIdentifierToSubscriptionResult = (
  output: any,
  context: __SerdeContext
): AddSourceIdentifierToSubscriptionResult => {
  let contents: any = {
    __type: "AddSourceIdentifierToSubscriptionResult",
    EventSubscription: undefined
  };
  if (output["EventSubscription"] !== undefined) {
    contents.EventSubscription = deserializeAws_queryEventSubscription(
      output["EventSubscription"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryApplyPendingMaintenanceActionResult = (
  output: any,
  context: __SerdeContext
): ApplyPendingMaintenanceActionResult => {
  let contents: any = {
    __type: "ApplyPendingMaintenanceActionResult",
    ResourcePendingMaintenanceActions: undefined
  };
  if (output["ResourcePendingMaintenanceActions"] !== undefined) {
    contents.ResourcePendingMaintenanceActions = deserializeAws_queryResourcePendingMaintenanceActions(
      output["ResourcePendingMaintenanceActions"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryAttributeValueList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryAuthorizeDBSecurityGroupIngressResult = (
  output: any,
  context: __SerdeContext
): AuthorizeDBSecurityGroupIngressResult => {
  let contents: any = {
    __type: "AuthorizeDBSecurityGroupIngressResult",
    DBSecurityGroup: undefined
  };
  if (output["DBSecurityGroup"] !== undefined) {
    contents.DBSecurityGroup = deserializeAws_queryDBSecurityGroup(
      output["DBSecurityGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryAvailabilityZone = (
  output: any,
  context: __SerdeContext
): AvailabilityZone => {
  let contents: any = {
    __type: "AvailabilityZone",
    Name: undefined
  };
  if (output["Name"] !== undefined) {
    contents.Name =
      output["Name"]["#text"] !== undefined
        ? output["Name"]["#text"]
        : output["Name"];
  }
  return contents;
};

const deserializeAws_queryAvailabilityZoneList = (
  output: any,
  context: __SerdeContext
): AvailabilityZone[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryAvailabilityZone(entry, context));
  });
  return contents;
};

const deserializeAws_queryAvailabilityZones = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryAvailableProcessorFeature = (
  output: any,
  context: __SerdeContext
): AvailableProcessorFeature => {
  let contents: any = {
    __type: "AvailableProcessorFeature",
    AllowedValues: undefined,
    DefaultValue: undefined,
    Name: undefined
  };
  if (output["AllowedValues"] !== undefined) {
    contents.AllowedValues =
      output["AllowedValues"]["#text"] !== undefined
        ? output["AllowedValues"]["#text"]
        : output["AllowedValues"];
  }
  if (output["DefaultValue"] !== undefined) {
    contents.DefaultValue =
      output["DefaultValue"]["#text"] !== undefined
        ? output["DefaultValue"]["#text"]
        : output["DefaultValue"];
  }
  if (output["Name"] !== undefined) {
    contents.Name =
      output["Name"]["#text"] !== undefined
        ? output["Name"]["#text"]
        : output["Name"];
  }
  return contents;
};

const deserializeAws_queryAvailableProcessorFeatureList = (
  output: any,
  context: __SerdeContext
): AvailableProcessorFeature[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryAvailableProcessorFeature(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryCertificate = (
  output: any,
  context: __SerdeContext
): Certificate => {
  let contents: any = {
    __type: "Certificate",
    CertificateArn: undefined,
    CertificateIdentifier: undefined,
    CertificateType: undefined,
    CustomerOverride: undefined,
    CustomerOverrideValidTill: undefined,
    Thumbprint: undefined,
    ValidFrom: undefined,
    ValidTill: undefined
  };
  if (output["CertificateArn"] !== undefined) {
    contents.CertificateArn =
      output["CertificateArn"]["#text"] !== undefined
        ? output["CertificateArn"]["#text"]
        : output["CertificateArn"];
  }
  if (output["CertificateIdentifier"] !== undefined) {
    contents.CertificateIdentifier =
      output["CertificateIdentifier"]["#text"] !== undefined
        ? output["CertificateIdentifier"]["#text"]
        : output["CertificateIdentifier"];
  }
  if (output["CertificateType"] !== undefined) {
    contents.CertificateType =
      output["CertificateType"]["#text"] !== undefined
        ? output["CertificateType"]["#text"]
        : output["CertificateType"];
  }
  if (output["CustomerOverride"] !== undefined) {
    contents.CustomerOverride =
      (output["CustomerOverride"]["#text"] !== undefined
        ? output["CustomerOverride"]["#text"]
        : output["CustomerOverride"]) == "true";
  }
  if (output["CustomerOverrideValidTill"] !== undefined) {
    contents.CustomerOverrideValidTill = new Date(
      output["CustomerOverrideValidTill"]
    );
  }
  if (output["Thumbprint"] !== undefined) {
    contents.Thumbprint =
      output["Thumbprint"]["#text"] !== undefined
        ? output["Thumbprint"]["#text"]
        : output["Thumbprint"];
  }
  if (output["ValidFrom"] !== undefined) {
    contents.ValidFrom = new Date(output["ValidFrom"]);
  }
  if (output["ValidTill"] !== undefined) {
    contents.ValidTill = new Date(output["ValidTill"]);
  }
  return contents;
};

const deserializeAws_queryCertificateList = (
  output: any,
  context: __SerdeContext
): Certificate[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryCertificate(entry, context));
  });
  return contents;
};

const deserializeAws_queryCertificateMessage = (
  output: any,
  context: __SerdeContext
): CertificateMessage => {
  let contents: any = {
    __type: "CertificateMessage",
    Certificates: undefined,
    Marker: undefined
  };
  if (output.Certificates === "") {
    contents.Certificates = [];
  }
  if (
    output["Certificates"] !== undefined &&
    output["Certificates"]["Certificate"] !== undefined
  ) {
    contents.Certificates = deserializeAws_queryCertificateList(
      __getArrayIfSingleItem(output["Certificates"]["Certificate"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryCharacterSet = (
  output: any,
  context: __SerdeContext
): CharacterSet => {
  let contents: any = {
    __type: "CharacterSet",
    CharacterSetDescription: undefined,
    CharacterSetName: undefined
  };
  if (output["CharacterSetDescription"] !== undefined) {
    contents.CharacterSetDescription =
      output["CharacterSetDescription"]["#text"] !== undefined
        ? output["CharacterSetDescription"]["#text"]
        : output["CharacterSetDescription"];
  }
  if (output["CharacterSetName"] !== undefined) {
    contents.CharacterSetName =
      output["CharacterSetName"]["#text"] !== undefined
        ? output["CharacterSetName"]["#text"]
        : output["CharacterSetName"];
  }
  return contents;
};

const deserializeAws_queryConnectionPoolConfigurationInfo = (
  output: any,
  context: __SerdeContext
): ConnectionPoolConfigurationInfo => {
  let contents: any = {
    __type: "ConnectionPoolConfigurationInfo",
    ConnectionBorrowTimeout: undefined,
    InitQuery: undefined,
    MaxConnectionsPercent: undefined,
    MaxIdleConnectionsPercent: undefined,
    SessionPinningFilters: undefined
  };
  if (output["ConnectionBorrowTimeout"] !== undefined) {
    contents.ConnectionBorrowTimeout = parseInt(
      output["ConnectionBorrowTimeout"]["#text"] !== undefined
        ? output["ConnectionBorrowTimeout"]["#text"]
        : output["ConnectionBorrowTimeout"]
    );
  }
  if (output["InitQuery"] !== undefined) {
    contents.InitQuery =
      output["InitQuery"]["#text"] !== undefined
        ? output["InitQuery"]["#text"]
        : output["InitQuery"];
  }
  if (output["MaxConnectionsPercent"] !== undefined) {
    contents.MaxConnectionsPercent = parseInt(
      output["MaxConnectionsPercent"]["#text"] !== undefined
        ? output["MaxConnectionsPercent"]["#text"]
        : output["MaxConnectionsPercent"]
    );
  }
  if (output["MaxIdleConnectionsPercent"] !== undefined) {
    contents.MaxIdleConnectionsPercent = parseInt(
      output["MaxIdleConnectionsPercent"]["#text"] !== undefined
        ? output["MaxIdleConnectionsPercent"]["#text"]
        : output["MaxIdleConnectionsPercent"]
    );
  }
  if (output.SessionPinningFilters === "") {
    contents.SessionPinningFilters = [];
  }
  if (
    output["SessionPinningFilters"] !== undefined &&
    output["SessionPinningFilters"]["member"] !== undefined
  ) {
    contents.SessionPinningFilters = deserializeAws_queryStringList(
      __getArrayIfSingleItem(output["SessionPinningFilters"]["member"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryCopyDBClusterParameterGroupResult = (
  output: any,
  context: __SerdeContext
): CopyDBClusterParameterGroupResult => {
  let contents: any = {
    __type: "CopyDBClusterParameterGroupResult",
    DBClusterParameterGroup: undefined
  };
  if (output["DBClusterParameterGroup"] !== undefined) {
    contents.DBClusterParameterGroup = deserializeAws_queryDBClusterParameterGroup(
      output["DBClusterParameterGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCopyDBClusterSnapshotResult = (
  output: any,
  context: __SerdeContext
): CopyDBClusterSnapshotResult => {
  let contents: any = {
    __type: "CopyDBClusterSnapshotResult",
    DBClusterSnapshot: undefined
  };
  if (output["DBClusterSnapshot"] !== undefined) {
    contents.DBClusterSnapshot = deserializeAws_queryDBClusterSnapshot(
      output["DBClusterSnapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCopyDBParameterGroupResult = (
  output: any,
  context: __SerdeContext
): CopyDBParameterGroupResult => {
  let contents: any = {
    __type: "CopyDBParameterGroupResult",
    DBParameterGroup: undefined
  };
  if (output["DBParameterGroup"] !== undefined) {
    contents.DBParameterGroup = deserializeAws_queryDBParameterGroup(
      output["DBParameterGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCopyDBSnapshotResult = (
  output: any,
  context: __SerdeContext
): CopyDBSnapshotResult => {
  let contents: any = {
    __type: "CopyDBSnapshotResult",
    DBSnapshot: undefined
  };
  if (output["DBSnapshot"] !== undefined) {
    contents.DBSnapshot = deserializeAws_queryDBSnapshot(
      output["DBSnapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCopyOptionGroupResult = (
  output: any,
  context: __SerdeContext
): CopyOptionGroupResult => {
  let contents: any = {
    __type: "CopyOptionGroupResult",
    OptionGroup: undefined
  };
  if (output["OptionGroup"] !== undefined) {
    contents.OptionGroup = deserializeAws_queryOptionGroup(
      output["OptionGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateCustomAvailabilityZoneResult = (
  output: any,
  context: __SerdeContext
): CreateCustomAvailabilityZoneResult => {
  let contents: any = {
    __type: "CreateCustomAvailabilityZoneResult",
    CustomAvailabilityZone: undefined
  };
  if (output["CustomAvailabilityZone"] !== undefined) {
    contents.CustomAvailabilityZone = deserializeAws_queryCustomAvailabilityZone(
      output["CustomAvailabilityZone"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateDBClusterParameterGroupResult = (
  output: any,
  context: __SerdeContext
): CreateDBClusterParameterGroupResult => {
  let contents: any = {
    __type: "CreateDBClusterParameterGroupResult",
    DBClusterParameterGroup: undefined
  };
  if (output["DBClusterParameterGroup"] !== undefined) {
    contents.DBClusterParameterGroup = deserializeAws_queryDBClusterParameterGroup(
      output["DBClusterParameterGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateDBClusterResult = (
  output: any,
  context: __SerdeContext
): CreateDBClusterResult => {
  let contents: any = {
    __type: "CreateDBClusterResult",
    DBCluster: undefined
  };
  if (output["DBCluster"] !== undefined) {
    contents.DBCluster = deserializeAws_queryDBCluster(
      output["DBCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateDBClusterSnapshotResult = (
  output: any,
  context: __SerdeContext
): CreateDBClusterSnapshotResult => {
  let contents: any = {
    __type: "CreateDBClusterSnapshotResult",
    DBClusterSnapshot: undefined
  };
  if (output["DBClusterSnapshot"] !== undefined) {
    contents.DBClusterSnapshot = deserializeAws_queryDBClusterSnapshot(
      output["DBClusterSnapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateDBInstanceReadReplicaResult = (
  output: any,
  context: __SerdeContext
): CreateDBInstanceReadReplicaResult => {
  let contents: any = {
    __type: "CreateDBInstanceReadReplicaResult",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateDBInstanceResult = (
  output: any,
  context: __SerdeContext
): CreateDBInstanceResult => {
  let contents: any = {
    __type: "CreateDBInstanceResult",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateDBParameterGroupResult = (
  output: any,
  context: __SerdeContext
): CreateDBParameterGroupResult => {
  let contents: any = {
    __type: "CreateDBParameterGroupResult",
    DBParameterGroup: undefined
  };
  if (output["DBParameterGroup"] !== undefined) {
    contents.DBParameterGroup = deserializeAws_queryDBParameterGroup(
      output["DBParameterGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateDBProxyResponse = (
  output: any,
  context: __SerdeContext
): CreateDBProxyResponse => {
  let contents: any = {
    __type: "CreateDBProxyResponse",
    DBProxy: undefined
  };
  if (output["DBProxy"] !== undefined) {
    contents.DBProxy = deserializeAws_queryDBProxy(output["DBProxy"], context);
  }
  return contents;
};

const deserializeAws_queryCreateDBSecurityGroupResult = (
  output: any,
  context: __SerdeContext
): CreateDBSecurityGroupResult => {
  let contents: any = {
    __type: "CreateDBSecurityGroupResult",
    DBSecurityGroup: undefined
  };
  if (output["DBSecurityGroup"] !== undefined) {
    contents.DBSecurityGroup = deserializeAws_queryDBSecurityGroup(
      output["DBSecurityGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateDBSnapshotResult = (
  output: any,
  context: __SerdeContext
): CreateDBSnapshotResult => {
  let contents: any = {
    __type: "CreateDBSnapshotResult",
    DBSnapshot: undefined
  };
  if (output["DBSnapshot"] !== undefined) {
    contents.DBSnapshot = deserializeAws_queryDBSnapshot(
      output["DBSnapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateDBSubnetGroupResult = (
  output: any,
  context: __SerdeContext
): CreateDBSubnetGroupResult => {
  let contents: any = {
    __type: "CreateDBSubnetGroupResult",
    DBSubnetGroup: undefined
  };
  if (output["DBSubnetGroup"] !== undefined) {
    contents.DBSubnetGroup = deserializeAws_queryDBSubnetGroup(
      output["DBSubnetGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateEventSubscriptionResult = (
  output: any,
  context: __SerdeContext
): CreateEventSubscriptionResult => {
  let contents: any = {
    __type: "CreateEventSubscriptionResult",
    EventSubscription: undefined
  };
  if (output["EventSubscription"] !== undefined) {
    contents.EventSubscription = deserializeAws_queryEventSubscription(
      output["EventSubscription"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateGlobalClusterResult = (
  output: any,
  context: __SerdeContext
): CreateGlobalClusterResult => {
  let contents: any = {
    __type: "CreateGlobalClusterResult",
    GlobalCluster: undefined
  };
  if (output["GlobalCluster"] !== undefined) {
    contents.GlobalCluster = deserializeAws_queryGlobalCluster(
      output["GlobalCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCreateOptionGroupResult = (
  output: any,
  context: __SerdeContext
): CreateOptionGroupResult => {
  let contents: any = {
    __type: "CreateOptionGroupResult",
    OptionGroup: undefined
  };
  if (output["OptionGroup"] !== undefined) {
    contents.OptionGroup = deserializeAws_queryOptionGroup(
      output["OptionGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCustomAvailabilityZone = (
  output: any,
  context: __SerdeContext
): CustomAvailabilityZone => {
  let contents: any = {
    __type: "CustomAvailabilityZone",
    CustomAvailabilityZoneId: undefined,
    CustomAvailabilityZoneName: undefined,
    CustomAvailabilityZoneStatus: undefined,
    VpnDetails: undefined
  };
  if (output["CustomAvailabilityZoneId"] !== undefined) {
    contents.CustomAvailabilityZoneId =
      output["CustomAvailabilityZoneId"]["#text"] !== undefined
        ? output["CustomAvailabilityZoneId"]["#text"]
        : output["CustomAvailabilityZoneId"];
  }
  if (output["CustomAvailabilityZoneName"] !== undefined) {
    contents.CustomAvailabilityZoneName =
      output["CustomAvailabilityZoneName"]["#text"] !== undefined
        ? output["CustomAvailabilityZoneName"]["#text"]
        : output["CustomAvailabilityZoneName"];
  }
  if (output["CustomAvailabilityZoneStatus"] !== undefined) {
    contents.CustomAvailabilityZoneStatus =
      output["CustomAvailabilityZoneStatus"]["#text"] !== undefined
        ? output["CustomAvailabilityZoneStatus"]["#text"]
        : output["CustomAvailabilityZoneStatus"];
  }
  if (output["VpnDetails"] !== undefined) {
    contents.VpnDetails = deserializeAws_queryVpnDetails(
      output["VpnDetails"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryCustomAvailabilityZoneList = (
  output: any,
  context: __SerdeContext
): CustomAvailabilityZone[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryCustomAvailabilityZone(entry, context));
  });
  return contents;
};

const deserializeAws_queryCustomAvailabilityZoneMessage = (
  output: any,
  context: __SerdeContext
): CustomAvailabilityZoneMessage => {
  let contents: any = {
    __type: "CustomAvailabilityZoneMessage",
    CustomAvailabilityZones: undefined,
    Marker: undefined
  };
  if (output.CustomAvailabilityZones === "") {
    contents.CustomAvailabilityZones = [];
  }
  if (
    output["CustomAvailabilityZones"] !== undefined &&
    output["CustomAvailabilityZones"]["CustomAvailabilityZone"] !== undefined
  ) {
    contents.CustomAvailabilityZones = deserializeAws_queryCustomAvailabilityZoneList(
      __getArrayIfSingleItem(
        output["CustomAvailabilityZones"]["CustomAvailabilityZone"]
      ),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBCluster = (
  output: any,
  context: __SerdeContext
): DBCluster => {
  let contents: any = {
    __type: "DBCluster",
    ActivityStreamKinesisStreamName: undefined,
    ActivityStreamKmsKeyId: undefined,
    ActivityStreamMode: undefined,
    ActivityStreamStatus: undefined,
    AllocatedStorage: undefined,
    AssociatedRoles: undefined,
    AvailabilityZones: undefined,
    BacktrackConsumedChangeRecords: undefined,
    BacktrackWindow: undefined,
    BackupRetentionPeriod: undefined,
    Capacity: undefined,
    CharacterSetName: undefined,
    CloneGroupId: undefined,
    ClusterCreateTime: undefined,
    CopyTagsToSnapshot: undefined,
    CrossAccountClone: undefined,
    CustomEndpoints: undefined,
    DBClusterArn: undefined,
    DBClusterIdentifier: undefined,
    DBClusterMembers: undefined,
    DBClusterOptionGroupMemberships: undefined,
    DBClusterParameterGroup: undefined,
    DBSubnetGroup: undefined,
    DatabaseName: undefined,
    DbClusterResourceId: undefined,
    DeletionProtection: undefined,
    EarliestBacktrackTime: undefined,
    EarliestRestorableTime: undefined,
    EnabledCloudwatchLogsExports: undefined,
    Endpoint: undefined,
    Engine: undefined,
    EngineMode: undefined,
    EngineVersion: undefined,
    HostedZoneId: undefined,
    HttpEndpointEnabled: undefined,
    IAMDatabaseAuthenticationEnabled: undefined,
    KmsKeyId: undefined,
    LatestRestorableTime: undefined,
    MasterUsername: undefined,
    MultiAZ: undefined,
    PercentProgress: undefined,
    Port: undefined,
    PreferredBackupWindow: undefined,
    PreferredMaintenanceWindow: undefined,
    ReadReplicaIdentifiers: undefined,
    ReaderEndpoint: undefined,
    ReplicationSourceIdentifier: undefined,
    ScalingConfigurationInfo: undefined,
    Status: undefined,
    StorageEncrypted: undefined,
    VpcSecurityGroups: undefined
  };
  if (output["ActivityStreamKinesisStreamName"] !== undefined) {
    contents.ActivityStreamKinesisStreamName =
      output["ActivityStreamKinesisStreamName"]["#text"] !== undefined
        ? output["ActivityStreamKinesisStreamName"]["#text"]
        : output["ActivityStreamKinesisStreamName"];
  }
  if (output["ActivityStreamKmsKeyId"] !== undefined) {
    contents.ActivityStreamKmsKeyId =
      output["ActivityStreamKmsKeyId"]["#text"] !== undefined
        ? output["ActivityStreamKmsKeyId"]["#text"]
        : output["ActivityStreamKmsKeyId"];
  }
  if (output["ActivityStreamMode"] !== undefined) {
    contents.ActivityStreamMode =
      output["ActivityStreamMode"]["#text"] !== undefined
        ? output["ActivityStreamMode"]["#text"]
        : output["ActivityStreamMode"];
  }
  if (output["ActivityStreamStatus"] !== undefined) {
    contents.ActivityStreamStatus =
      output["ActivityStreamStatus"]["#text"] !== undefined
        ? output["ActivityStreamStatus"]["#text"]
        : output["ActivityStreamStatus"];
  }
  if (output["AllocatedStorage"] !== undefined) {
    contents.AllocatedStorage = parseInt(
      output["AllocatedStorage"]["#text"] !== undefined
        ? output["AllocatedStorage"]["#text"]
        : output["AllocatedStorage"]
    );
  }
  if (output.AssociatedRoles === "") {
    contents.AssociatedRoles = [];
  }
  if (
    output["AssociatedRoles"] !== undefined &&
    output["AssociatedRoles"]["DBClusterRole"] !== undefined
  ) {
    contents.AssociatedRoles = deserializeAws_queryDBClusterRoles(
      __getArrayIfSingleItem(output["AssociatedRoles"]["DBClusterRole"]),
      context
    );
  }
  if (output.AvailabilityZones === "") {
    contents.AvailabilityZones = [];
  }
  if (
    output["AvailabilityZones"] !== undefined &&
    output["AvailabilityZones"]["AvailabilityZone"] !== undefined
  ) {
    contents.AvailabilityZones = deserializeAws_queryAvailabilityZones(
      __getArrayIfSingleItem(output["AvailabilityZones"]["AvailabilityZone"]),
      context
    );
  }
  if (output["BacktrackConsumedChangeRecords"] !== undefined) {
    contents.BacktrackConsumedChangeRecords = parseInt(
      output["BacktrackConsumedChangeRecords"]["#text"] !== undefined
        ? output["BacktrackConsumedChangeRecords"]["#text"]
        : output["BacktrackConsumedChangeRecords"]
    );
  }
  if (output["BacktrackWindow"] !== undefined) {
    contents.BacktrackWindow = parseInt(
      output["BacktrackWindow"]["#text"] !== undefined
        ? output["BacktrackWindow"]["#text"]
        : output["BacktrackWindow"]
    );
  }
  if (output["BackupRetentionPeriod"] !== undefined) {
    contents.BackupRetentionPeriod = parseInt(
      output["BackupRetentionPeriod"]["#text"] !== undefined
        ? output["BackupRetentionPeriod"]["#text"]
        : output["BackupRetentionPeriod"]
    );
  }
  if (output["Capacity"] !== undefined) {
    contents.Capacity = parseInt(
      output["Capacity"]["#text"] !== undefined
        ? output["Capacity"]["#text"]
        : output["Capacity"]
    );
  }
  if (output["CharacterSetName"] !== undefined) {
    contents.CharacterSetName =
      output["CharacterSetName"]["#text"] !== undefined
        ? output["CharacterSetName"]["#text"]
        : output["CharacterSetName"];
  }
  if (output["CloneGroupId"] !== undefined) {
    contents.CloneGroupId =
      output["CloneGroupId"]["#text"] !== undefined
        ? output["CloneGroupId"]["#text"]
        : output["CloneGroupId"];
  }
  if (output["ClusterCreateTime"] !== undefined) {
    contents.ClusterCreateTime = new Date(output["ClusterCreateTime"]);
  }
  if (output["CopyTagsToSnapshot"] !== undefined) {
    contents.CopyTagsToSnapshot =
      (output["CopyTagsToSnapshot"]["#text"] !== undefined
        ? output["CopyTagsToSnapshot"]["#text"]
        : output["CopyTagsToSnapshot"]) == "true";
  }
  if (output["CrossAccountClone"] !== undefined) {
    contents.CrossAccountClone =
      (output["CrossAccountClone"]["#text"] !== undefined
        ? output["CrossAccountClone"]["#text"]
        : output["CrossAccountClone"]) == "true";
  }
  if (output.CustomEndpoints === "") {
    contents.CustomEndpoints = [];
  }
  if (
    output["CustomEndpoints"] !== undefined &&
    output["CustomEndpoints"]["member"] !== undefined
  ) {
    contents.CustomEndpoints = deserializeAws_queryStringList(
      __getArrayIfSingleItem(output["CustomEndpoints"]["member"]),
      context
    );
  }
  if (output["DBClusterArn"] !== undefined) {
    contents.DBClusterArn =
      output["DBClusterArn"]["#text"] !== undefined
        ? output["DBClusterArn"]["#text"]
        : output["DBClusterArn"];
  }
  if (output["DBClusterIdentifier"] !== undefined) {
    contents.DBClusterIdentifier =
      output["DBClusterIdentifier"]["#text"] !== undefined
        ? output["DBClusterIdentifier"]["#text"]
        : output["DBClusterIdentifier"];
  }
  if (output.DBClusterMembers === "") {
    contents.DBClusterMembers = [];
  }
  if (
    output["DBClusterMembers"] !== undefined &&
    output["DBClusterMembers"]["DBClusterMember"] !== undefined
  ) {
    contents.DBClusterMembers = deserializeAws_queryDBClusterMemberList(
      __getArrayIfSingleItem(output["DBClusterMembers"]["DBClusterMember"]),
      context
    );
  }
  if (output.DBClusterOptionGroupMemberships === "") {
    contents.DBClusterOptionGroupMemberships = [];
  }
  if (
    output["DBClusterOptionGroupMemberships"] !== undefined &&
    output["DBClusterOptionGroupMemberships"]["DBClusterOptionGroup"] !==
      undefined
  ) {
    contents.DBClusterOptionGroupMemberships = deserializeAws_queryDBClusterOptionGroupMemberships(
      __getArrayIfSingleItem(
        output["DBClusterOptionGroupMemberships"]["DBClusterOptionGroup"]
      ),
      context
    );
  }
  if (output["DBClusterParameterGroup"] !== undefined) {
    contents.DBClusterParameterGroup =
      output["DBClusterParameterGroup"]["#text"] !== undefined
        ? output["DBClusterParameterGroup"]["#text"]
        : output["DBClusterParameterGroup"];
  }
  if (output["DBSubnetGroup"] !== undefined) {
    contents.DBSubnetGroup =
      output["DBSubnetGroup"]["#text"] !== undefined
        ? output["DBSubnetGroup"]["#text"]
        : output["DBSubnetGroup"];
  }
  if (output["DatabaseName"] !== undefined) {
    contents.DatabaseName =
      output["DatabaseName"]["#text"] !== undefined
        ? output["DatabaseName"]["#text"]
        : output["DatabaseName"];
  }
  if (output["DbClusterResourceId"] !== undefined) {
    contents.DbClusterResourceId =
      output["DbClusterResourceId"]["#text"] !== undefined
        ? output["DbClusterResourceId"]["#text"]
        : output["DbClusterResourceId"];
  }
  if (output["DeletionProtection"] !== undefined) {
    contents.DeletionProtection =
      (output["DeletionProtection"]["#text"] !== undefined
        ? output["DeletionProtection"]["#text"]
        : output["DeletionProtection"]) == "true";
  }
  if (output["EarliestBacktrackTime"] !== undefined) {
    contents.EarliestBacktrackTime = new Date(output["EarliestBacktrackTime"]);
  }
  if (output["EarliestRestorableTime"] !== undefined) {
    contents.EarliestRestorableTime = new Date(
      output["EarliestRestorableTime"]
    );
  }
  if (output.EnabledCloudwatchLogsExports === "") {
    contents.EnabledCloudwatchLogsExports = [];
  }
  if (
    output["EnabledCloudwatchLogsExports"] !== undefined &&
    output["EnabledCloudwatchLogsExports"]["member"] !== undefined
  ) {
    contents.EnabledCloudwatchLogsExports = deserializeAws_queryLogTypeList(
      __getArrayIfSingleItem(output["EnabledCloudwatchLogsExports"]["member"]),
      context
    );
  }
  if (output["Endpoint"] !== undefined) {
    contents.Endpoint =
      output["Endpoint"]["#text"] !== undefined
        ? output["Endpoint"]["#text"]
        : output["Endpoint"];
  }
  if (output["Engine"] !== undefined) {
    contents.Engine =
      output["Engine"]["#text"] !== undefined
        ? output["Engine"]["#text"]
        : output["Engine"];
  }
  if (output["EngineMode"] !== undefined) {
    contents.EngineMode =
      output["EngineMode"]["#text"] !== undefined
        ? output["EngineMode"]["#text"]
        : output["EngineMode"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output["HostedZoneId"] !== undefined) {
    contents.HostedZoneId =
      output["HostedZoneId"]["#text"] !== undefined
        ? output["HostedZoneId"]["#text"]
        : output["HostedZoneId"];
  }
  if (output["HttpEndpointEnabled"] !== undefined) {
    contents.HttpEndpointEnabled =
      (output["HttpEndpointEnabled"]["#text"] !== undefined
        ? output["HttpEndpointEnabled"]["#text"]
        : output["HttpEndpointEnabled"]) == "true";
  }
  if (output["IAMDatabaseAuthenticationEnabled"] !== undefined) {
    contents.IAMDatabaseAuthenticationEnabled =
      (output["IAMDatabaseAuthenticationEnabled"]["#text"] !== undefined
        ? output["IAMDatabaseAuthenticationEnabled"]["#text"]
        : output["IAMDatabaseAuthenticationEnabled"]) == "true";
  }
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId =
      output["KmsKeyId"]["#text"] !== undefined
        ? output["KmsKeyId"]["#text"]
        : output["KmsKeyId"];
  }
  if (output["LatestRestorableTime"] !== undefined) {
    contents.LatestRestorableTime = new Date(output["LatestRestorableTime"]);
  }
  if (output["MasterUsername"] !== undefined) {
    contents.MasterUsername =
      output["MasterUsername"]["#text"] !== undefined
        ? output["MasterUsername"]["#text"]
        : output["MasterUsername"];
  }
  if (output["MultiAZ"] !== undefined) {
    contents.MultiAZ =
      (output["MultiAZ"]["#text"] !== undefined
        ? output["MultiAZ"]["#text"]
        : output["MultiAZ"]) == "true";
  }
  if (output["PercentProgress"] !== undefined) {
    contents.PercentProgress =
      output["PercentProgress"]["#text"] !== undefined
        ? output["PercentProgress"]["#text"]
        : output["PercentProgress"];
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(
      output["Port"]["#text"] !== undefined
        ? output["Port"]["#text"]
        : output["Port"]
    );
  }
  if (output["PreferredBackupWindow"] !== undefined) {
    contents.PreferredBackupWindow =
      output["PreferredBackupWindow"]["#text"] !== undefined
        ? output["PreferredBackupWindow"]["#text"]
        : output["PreferredBackupWindow"];
  }
  if (output["PreferredMaintenanceWindow"] !== undefined) {
    contents.PreferredMaintenanceWindow =
      output["PreferredMaintenanceWindow"]["#text"] !== undefined
        ? output["PreferredMaintenanceWindow"]["#text"]
        : output["PreferredMaintenanceWindow"];
  }
  if (output.ReadReplicaIdentifiers === "") {
    contents.ReadReplicaIdentifiers = [];
  }
  if (
    output["ReadReplicaIdentifiers"] !== undefined &&
    output["ReadReplicaIdentifiers"]["ReadReplicaIdentifier"] !== undefined
  ) {
    contents.ReadReplicaIdentifiers = deserializeAws_queryReadReplicaIdentifierList(
      __getArrayIfSingleItem(
        output["ReadReplicaIdentifiers"]["ReadReplicaIdentifier"]
      ),
      context
    );
  }
  if (output["ReaderEndpoint"] !== undefined) {
    contents.ReaderEndpoint =
      output["ReaderEndpoint"]["#text"] !== undefined
        ? output["ReaderEndpoint"]["#text"]
        : output["ReaderEndpoint"];
  }
  if (output["ReplicationSourceIdentifier"] !== undefined) {
    contents.ReplicationSourceIdentifier =
      output["ReplicationSourceIdentifier"]["#text"] !== undefined
        ? output["ReplicationSourceIdentifier"]["#text"]
        : output["ReplicationSourceIdentifier"];
  }
  if (output["ScalingConfigurationInfo"] !== undefined) {
    contents.ScalingConfigurationInfo = deserializeAws_queryScalingConfigurationInfo(
      output["ScalingConfigurationInfo"],
      context
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output["StorageEncrypted"] !== undefined) {
    contents.StorageEncrypted =
      (output["StorageEncrypted"]["#text"] !== undefined
        ? output["StorageEncrypted"]["#text"]
        : output["StorageEncrypted"]) == "true";
  }
  if (output.VpcSecurityGroups === "") {
    contents.VpcSecurityGroups = [];
  }
  if (
    output["VpcSecurityGroups"] !== undefined &&
    output["VpcSecurityGroups"]["VpcSecurityGroupMembership"] !== undefined
  ) {
    contents.VpcSecurityGroups = deserializeAws_queryVpcSecurityGroupMembershipList(
      __getArrayIfSingleItem(
        output["VpcSecurityGroups"]["VpcSecurityGroupMembership"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_queryDBClusterBacktrack = (
  output: any,
  context: __SerdeContext
): DBClusterBacktrack => {
  let contents: any = {
    __type: "DBClusterBacktrack",
    BacktrackIdentifier: undefined,
    BacktrackRequestCreationTime: undefined,
    BacktrackTo: undefined,
    BacktrackedFrom: undefined,
    DBClusterIdentifier: undefined,
    Status: undefined
  };
  if (output["BacktrackIdentifier"] !== undefined) {
    contents.BacktrackIdentifier =
      output["BacktrackIdentifier"]["#text"] !== undefined
        ? output["BacktrackIdentifier"]["#text"]
        : output["BacktrackIdentifier"];
  }
  if (output["BacktrackRequestCreationTime"] !== undefined) {
    contents.BacktrackRequestCreationTime = new Date(
      output["BacktrackRequestCreationTime"]
    );
  }
  if (output["BacktrackTo"] !== undefined) {
    contents.BacktrackTo = new Date(output["BacktrackTo"]);
  }
  if (output["BacktrackedFrom"] !== undefined) {
    contents.BacktrackedFrom = new Date(output["BacktrackedFrom"]);
  }
  if (output["DBClusterIdentifier"] !== undefined) {
    contents.DBClusterIdentifier =
      output["DBClusterIdentifier"]["#text"] !== undefined
        ? output["DBClusterIdentifier"]["#text"]
        : output["DBClusterIdentifier"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryDBClusterBacktrackList = (
  output: any,
  context: __SerdeContext
): DBClusterBacktrack[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBClusterBacktrack(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBClusterBacktrackMessage = (
  output: any,
  context: __SerdeContext
): DBClusterBacktrackMessage => {
  let contents: any = {
    __type: "DBClusterBacktrackMessage",
    DBClusterBacktracks: undefined,
    Marker: undefined
  };
  if (output.DBClusterBacktracks === "") {
    contents.DBClusterBacktracks = [];
  }
  if (
    output["DBClusterBacktracks"] !== undefined &&
    output["DBClusterBacktracks"]["DBClusterBacktrack"] !== undefined
  ) {
    contents.DBClusterBacktracks = deserializeAws_queryDBClusterBacktrackList(
      __getArrayIfSingleItem(
        output["DBClusterBacktracks"]["DBClusterBacktrack"]
      ),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBClusterCapacityInfo = (
  output: any,
  context: __SerdeContext
): DBClusterCapacityInfo => {
  let contents: any = {
    __type: "DBClusterCapacityInfo",
    CurrentCapacity: undefined,
    DBClusterIdentifier: undefined,
    PendingCapacity: undefined,
    SecondsBeforeTimeout: undefined,
    TimeoutAction: undefined
  };
  if (output["CurrentCapacity"] !== undefined) {
    contents.CurrentCapacity = parseInt(
      output["CurrentCapacity"]["#text"] !== undefined
        ? output["CurrentCapacity"]["#text"]
        : output["CurrentCapacity"]
    );
  }
  if (output["DBClusterIdentifier"] !== undefined) {
    contents.DBClusterIdentifier =
      output["DBClusterIdentifier"]["#text"] !== undefined
        ? output["DBClusterIdentifier"]["#text"]
        : output["DBClusterIdentifier"];
  }
  if (output["PendingCapacity"] !== undefined) {
    contents.PendingCapacity = parseInt(
      output["PendingCapacity"]["#text"] !== undefined
        ? output["PendingCapacity"]["#text"]
        : output["PendingCapacity"]
    );
  }
  if (output["SecondsBeforeTimeout"] !== undefined) {
    contents.SecondsBeforeTimeout = parseInt(
      output["SecondsBeforeTimeout"]["#text"] !== undefined
        ? output["SecondsBeforeTimeout"]["#text"]
        : output["SecondsBeforeTimeout"]
    );
  }
  if (output["TimeoutAction"] !== undefined) {
    contents.TimeoutAction =
      output["TimeoutAction"]["#text"] !== undefined
        ? output["TimeoutAction"]["#text"]
        : output["TimeoutAction"];
  }
  return contents;
};

const deserializeAws_queryDBClusterEndpoint = (
  output: any,
  context: __SerdeContext
): DBClusterEndpoint => {
  let contents: any = {
    __type: "DBClusterEndpoint",
    CustomEndpointType: undefined,
    DBClusterEndpointArn: undefined,
    DBClusterEndpointIdentifier: undefined,
    DBClusterEndpointResourceIdentifier: undefined,
    DBClusterIdentifier: undefined,
    Endpoint: undefined,
    EndpointType: undefined,
    ExcludedMembers: undefined,
    StaticMembers: undefined,
    Status: undefined
  };
  if (output["CustomEndpointType"] !== undefined) {
    contents.CustomEndpointType =
      output["CustomEndpointType"]["#text"] !== undefined
        ? output["CustomEndpointType"]["#text"]
        : output["CustomEndpointType"];
  }
  if (output["DBClusterEndpointArn"] !== undefined) {
    contents.DBClusterEndpointArn =
      output["DBClusterEndpointArn"]["#text"] !== undefined
        ? output["DBClusterEndpointArn"]["#text"]
        : output["DBClusterEndpointArn"];
  }
  if (output["DBClusterEndpointIdentifier"] !== undefined) {
    contents.DBClusterEndpointIdentifier =
      output["DBClusterEndpointIdentifier"]["#text"] !== undefined
        ? output["DBClusterEndpointIdentifier"]["#text"]
        : output["DBClusterEndpointIdentifier"];
  }
  if (output["DBClusterEndpointResourceIdentifier"] !== undefined) {
    contents.DBClusterEndpointResourceIdentifier =
      output["DBClusterEndpointResourceIdentifier"]["#text"] !== undefined
        ? output["DBClusterEndpointResourceIdentifier"]["#text"]
        : output["DBClusterEndpointResourceIdentifier"];
  }
  if (output["DBClusterIdentifier"] !== undefined) {
    contents.DBClusterIdentifier =
      output["DBClusterIdentifier"]["#text"] !== undefined
        ? output["DBClusterIdentifier"]["#text"]
        : output["DBClusterIdentifier"];
  }
  if (output["Endpoint"] !== undefined) {
    contents.Endpoint =
      output["Endpoint"]["#text"] !== undefined
        ? output["Endpoint"]["#text"]
        : output["Endpoint"];
  }
  if (output["EndpointType"] !== undefined) {
    contents.EndpointType =
      output["EndpointType"]["#text"] !== undefined
        ? output["EndpointType"]["#text"]
        : output["EndpointType"];
  }
  if (output.ExcludedMembers === "") {
    contents.ExcludedMembers = [];
  }
  if (
    output["ExcludedMembers"] !== undefined &&
    output["ExcludedMembers"]["member"] !== undefined
  ) {
    contents.ExcludedMembers = deserializeAws_queryStringList(
      __getArrayIfSingleItem(output["ExcludedMembers"]["member"]),
      context
    );
  }
  if (output.StaticMembers === "") {
    contents.StaticMembers = [];
  }
  if (
    output["StaticMembers"] !== undefined &&
    output["StaticMembers"]["member"] !== undefined
  ) {
    contents.StaticMembers = deserializeAws_queryStringList(
      __getArrayIfSingleItem(output["StaticMembers"]["member"]),
      context
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryDBClusterEndpointList = (
  output: any,
  context: __SerdeContext
): DBClusterEndpoint[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBClusterEndpoint(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBClusterEndpointMessage = (
  output: any,
  context: __SerdeContext
): DBClusterEndpointMessage => {
  let contents: any = {
    __type: "DBClusterEndpointMessage",
    DBClusterEndpoints: undefined,
    Marker: undefined
  };
  if (output.DBClusterEndpoints === "") {
    contents.DBClusterEndpoints = [];
  }
  if (
    output["DBClusterEndpoints"] !== undefined &&
    output["DBClusterEndpoints"]["DBClusterEndpointList"] !== undefined
  ) {
    contents.DBClusterEndpoints = deserializeAws_queryDBClusterEndpointList(
      __getArrayIfSingleItem(
        output["DBClusterEndpoints"]["DBClusterEndpointList"]
      ),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBClusterList = (
  output: any,
  context: __SerdeContext
): DBCluster[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBCluster(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBClusterMember = (
  output: any,
  context: __SerdeContext
): DBClusterMember => {
  let contents: any = {
    __type: "DBClusterMember",
    DBClusterParameterGroupStatus: undefined,
    DBInstanceIdentifier: undefined,
    IsClusterWriter: undefined,
    PromotionTier: undefined
  };
  if (output["DBClusterParameterGroupStatus"] !== undefined) {
    contents.DBClusterParameterGroupStatus =
      output["DBClusterParameterGroupStatus"]["#text"] !== undefined
        ? output["DBClusterParameterGroupStatus"]["#text"]
        : output["DBClusterParameterGroupStatus"];
  }
  if (output["DBInstanceIdentifier"] !== undefined) {
    contents.DBInstanceIdentifier =
      output["DBInstanceIdentifier"]["#text"] !== undefined
        ? output["DBInstanceIdentifier"]["#text"]
        : output["DBInstanceIdentifier"];
  }
  if (output["IsClusterWriter"] !== undefined) {
    contents.IsClusterWriter =
      (output["IsClusterWriter"]["#text"] !== undefined
        ? output["IsClusterWriter"]["#text"]
        : output["IsClusterWriter"]) == "true";
  }
  if (output["PromotionTier"] !== undefined) {
    contents.PromotionTier = parseInt(
      output["PromotionTier"]["#text"] !== undefined
        ? output["PromotionTier"]["#text"]
        : output["PromotionTier"]
    );
  }
  return contents;
};

const deserializeAws_queryDBClusterMemberList = (
  output: any,
  context: __SerdeContext
): DBClusterMember[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBClusterMember(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBClusterMessage = (
  output: any,
  context: __SerdeContext
): DBClusterMessage => {
  let contents: any = {
    __type: "DBClusterMessage",
    DBClusters: undefined,
    Marker: undefined
  };
  if (output.DBClusters === "") {
    contents.DBClusters = [];
  }
  if (
    output["DBClusters"] !== undefined &&
    output["DBClusters"]["DBCluster"] !== undefined
  ) {
    contents.DBClusters = deserializeAws_queryDBClusterList(
      __getArrayIfSingleItem(output["DBClusters"]["DBCluster"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBClusterOptionGroupMemberships = (
  output: any,
  context: __SerdeContext
): DBClusterOptionGroupStatus[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryDBClusterOptionGroupStatus(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryDBClusterOptionGroupStatus = (
  output: any,
  context: __SerdeContext
): DBClusterOptionGroupStatus => {
  let contents: any = {
    __type: "DBClusterOptionGroupStatus",
    DBClusterOptionGroupName: undefined,
    Status: undefined
  };
  if (output["DBClusterOptionGroupName"] !== undefined) {
    contents.DBClusterOptionGroupName =
      output["DBClusterOptionGroupName"]["#text"] !== undefined
        ? output["DBClusterOptionGroupName"]["#text"]
        : output["DBClusterOptionGroupName"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryDBClusterParameterGroup = (
  output: any,
  context: __SerdeContext
): DBClusterParameterGroup => {
  let contents: any = {
    __type: "DBClusterParameterGroup",
    DBClusterParameterGroupArn: undefined,
    DBClusterParameterGroupName: undefined,
    DBParameterGroupFamily: undefined,
    Description: undefined
  };
  if (output["DBClusterParameterGroupArn"] !== undefined) {
    contents.DBClusterParameterGroupArn =
      output["DBClusterParameterGroupArn"]["#text"] !== undefined
        ? output["DBClusterParameterGroupArn"]["#text"]
        : output["DBClusterParameterGroupArn"];
  }
  if (output["DBClusterParameterGroupName"] !== undefined) {
    contents.DBClusterParameterGroupName =
      output["DBClusterParameterGroupName"]["#text"] !== undefined
        ? output["DBClusterParameterGroupName"]["#text"]
        : output["DBClusterParameterGroupName"];
  }
  if (output["DBParameterGroupFamily"] !== undefined) {
    contents.DBParameterGroupFamily =
      output["DBParameterGroupFamily"]["#text"] !== undefined
        ? output["DBParameterGroupFamily"]["#text"]
        : output["DBParameterGroupFamily"];
  }
  if (output["Description"] !== undefined) {
    contents.Description =
      output["Description"]["#text"] !== undefined
        ? output["Description"]["#text"]
        : output["Description"];
  }
  return contents;
};

const deserializeAws_queryDBClusterParameterGroupDetails = (
  output: any,
  context: __SerdeContext
): DBClusterParameterGroupDetails => {
  let contents: any = {
    __type: "DBClusterParameterGroupDetails",
    Marker: undefined,
    Parameters: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.Parameters === "") {
    contents.Parameters = [];
  }
  if (
    output["Parameters"] !== undefined &&
    output["Parameters"]["Parameter"] !== undefined
  ) {
    contents.Parameters = deserializeAws_queryParametersList(
      __getArrayIfSingleItem(output["Parameters"]["Parameter"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryDBClusterParameterGroupList = (
  output: any,
  context: __SerdeContext
): DBClusterParameterGroup[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBClusterParameterGroup(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBClusterParameterGroupNameMessage = (
  output: any,
  context: __SerdeContext
): DBClusterParameterGroupNameMessage => {
  let contents: any = {
    __type: "DBClusterParameterGroupNameMessage",
    DBClusterParameterGroupName: undefined
  };
  if (output["DBClusterParameterGroupName"] !== undefined) {
    contents.DBClusterParameterGroupName =
      output["DBClusterParameterGroupName"]["#text"] !== undefined
        ? output["DBClusterParameterGroupName"]["#text"]
        : output["DBClusterParameterGroupName"];
  }
  return contents;
};

const deserializeAws_queryDBClusterParameterGroupsMessage = (
  output: any,
  context: __SerdeContext
): DBClusterParameterGroupsMessage => {
  let contents: any = {
    __type: "DBClusterParameterGroupsMessage",
    DBClusterParameterGroups: undefined,
    Marker: undefined
  };
  if (output.DBClusterParameterGroups === "") {
    contents.DBClusterParameterGroups = [];
  }
  if (
    output["DBClusterParameterGroups"] !== undefined &&
    output["DBClusterParameterGroups"]["DBClusterParameterGroup"] !== undefined
  ) {
    contents.DBClusterParameterGroups = deserializeAws_queryDBClusterParameterGroupList(
      __getArrayIfSingleItem(
        output["DBClusterParameterGroups"]["DBClusterParameterGroup"]
      ),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBClusterRole = (
  output: any,
  context: __SerdeContext
): DBClusterRole => {
  let contents: any = {
    __type: "DBClusterRole",
    FeatureName: undefined,
    RoleArn: undefined,
    Status: undefined
  };
  if (output["FeatureName"] !== undefined) {
    contents.FeatureName =
      output["FeatureName"]["#text"] !== undefined
        ? output["FeatureName"]["#text"]
        : output["FeatureName"];
  }
  if (output["RoleArn"] !== undefined) {
    contents.RoleArn =
      output["RoleArn"]["#text"] !== undefined
        ? output["RoleArn"]["#text"]
        : output["RoleArn"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryDBClusterRoles = (
  output: any,
  context: __SerdeContext
): DBClusterRole[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBClusterRole(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBClusterSnapshot = (
  output: any,
  context: __SerdeContext
): DBClusterSnapshot => {
  let contents: any = {
    __type: "DBClusterSnapshot",
    AllocatedStorage: undefined,
    AvailabilityZones: undefined,
    ClusterCreateTime: undefined,
    DBClusterIdentifier: undefined,
    DBClusterSnapshotArn: undefined,
    DBClusterSnapshotIdentifier: undefined,
    Engine: undefined,
    EngineVersion: undefined,
    IAMDatabaseAuthenticationEnabled: undefined,
    KmsKeyId: undefined,
    LicenseModel: undefined,
    MasterUsername: undefined,
    PercentProgress: undefined,
    Port: undefined,
    SnapshotCreateTime: undefined,
    SnapshotType: undefined,
    SourceDBClusterSnapshotArn: undefined,
    Status: undefined,
    StorageEncrypted: undefined,
    VpcId: undefined
  };
  if (output["AllocatedStorage"] !== undefined) {
    contents.AllocatedStorage = parseInt(
      output["AllocatedStorage"]["#text"] !== undefined
        ? output["AllocatedStorage"]["#text"]
        : output["AllocatedStorage"]
    );
  }
  if (output.AvailabilityZones === "") {
    contents.AvailabilityZones = [];
  }
  if (
    output["AvailabilityZones"] !== undefined &&
    output["AvailabilityZones"]["AvailabilityZone"] !== undefined
  ) {
    contents.AvailabilityZones = deserializeAws_queryAvailabilityZones(
      __getArrayIfSingleItem(output["AvailabilityZones"]["AvailabilityZone"]),
      context
    );
  }
  if (output["ClusterCreateTime"] !== undefined) {
    contents.ClusterCreateTime = new Date(output["ClusterCreateTime"]);
  }
  if (output["DBClusterIdentifier"] !== undefined) {
    contents.DBClusterIdentifier =
      output["DBClusterIdentifier"]["#text"] !== undefined
        ? output["DBClusterIdentifier"]["#text"]
        : output["DBClusterIdentifier"];
  }
  if (output["DBClusterSnapshotArn"] !== undefined) {
    contents.DBClusterSnapshotArn =
      output["DBClusterSnapshotArn"]["#text"] !== undefined
        ? output["DBClusterSnapshotArn"]["#text"]
        : output["DBClusterSnapshotArn"];
  }
  if (output["DBClusterSnapshotIdentifier"] !== undefined) {
    contents.DBClusterSnapshotIdentifier =
      output["DBClusterSnapshotIdentifier"]["#text"] !== undefined
        ? output["DBClusterSnapshotIdentifier"]["#text"]
        : output["DBClusterSnapshotIdentifier"];
  }
  if (output["Engine"] !== undefined) {
    contents.Engine =
      output["Engine"]["#text"] !== undefined
        ? output["Engine"]["#text"]
        : output["Engine"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output["IAMDatabaseAuthenticationEnabled"] !== undefined) {
    contents.IAMDatabaseAuthenticationEnabled =
      (output["IAMDatabaseAuthenticationEnabled"]["#text"] !== undefined
        ? output["IAMDatabaseAuthenticationEnabled"]["#text"]
        : output["IAMDatabaseAuthenticationEnabled"]) == "true";
  }
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId =
      output["KmsKeyId"]["#text"] !== undefined
        ? output["KmsKeyId"]["#text"]
        : output["KmsKeyId"];
  }
  if (output["LicenseModel"] !== undefined) {
    contents.LicenseModel =
      output["LicenseModel"]["#text"] !== undefined
        ? output["LicenseModel"]["#text"]
        : output["LicenseModel"];
  }
  if (output["MasterUsername"] !== undefined) {
    contents.MasterUsername =
      output["MasterUsername"]["#text"] !== undefined
        ? output["MasterUsername"]["#text"]
        : output["MasterUsername"];
  }
  if (output["PercentProgress"] !== undefined) {
    contents.PercentProgress = parseInt(
      output["PercentProgress"]["#text"] !== undefined
        ? output["PercentProgress"]["#text"]
        : output["PercentProgress"]
    );
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(
      output["Port"]["#text"] !== undefined
        ? output["Port"]["#text"]
        : output["Port"]
    );
  }
  if (output["SnapshotCreateTime"] !== undefined) {
    contents.SnapshotCreateTime = new Date(output["SnapshotCreateTime"]);
  }
  if (output["SnapshotType"] !== undefined) {
    contents.SnapshotType =
      output["SnapshotType"]["#text"] !== undefined
        ? output["SnapshotType"]["#text"]
        : output["SnapshotType"];
  }
  if (output["SourceDBClusterSnapshotArn"] !== undefined) {
    contents.SourceDBClusterSnapshotArn =
      output["SourceDBClusterSnapshotArn"]["#text"] !== undefined
        ? output["SourceDBClusterSnapshotArn"]["#text"]
        : output["SourceDBClusterSnapshotArn"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output["StorageEncrypted"] !== undefined) {
    contents.StorageEncrypted =
      (output["StorageEncrypted"]["#text"] !== undefined
        ? output["StorageEncrypted"]["#text"]
        : output["StorageEncrypted"]) == "true";
  }
  if (output["VpcId"] !== undefined) {
    contents.VpcId =
      output["VpcId"]["#text"] !== undefined
        ? output["VpcId"]["#text"]
        : output["VpcId"];
  }
  return contents;
};

const deserializeAws_queryDBClusterSnapshotAttribute = (
  output: any,
  context: __SerdeContext
): DBClusterSnapshotAttribute => {
  let contents: any = {
    __type: "DBClusterSnapshotAttribute",
    AttributeName: undefined,
    AttributeValues: undefined
  };
  if (output["AttributeName"] !== undefined) {
    contents.AttributeName =
      output["AttributeName"]["#text"] !== undefined
        ? output["AttributeName"]["#text"]
        : output["AttributeName"];
  }
  if (output.AttributeValues === "") {
    contents.AttributeValues = [];
  }
  if (
    output["AttributeValues"] !== undefined &&
    output["AttributeValues"]["AttributeValue"] !== undefined
  ) {
    contents.AttributeValues = deserializeAws_queryAttributeValueList(
      __getArrayIfSingleItem(output["AttributeValues"]["AttributeValue"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryDBClusterSnapshotAttributeList = (
  output: any,
  context: __SerdeContext
): DBClusterSnapshotAttribute[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryDBClusterSnapshotAttribute(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryDBClusterSnapshotAttributesResult = (
  output: any,
  context: __SerdeContext
): DBClusterSnapshotAttributesResult => {
  let contents: any = {
    __type: "DBClusterSnapshotAttributesResult",
    DBClusterSnapshotAttributes: undefined,
    DBClusterSnapshotIdentifier: undefined
  };
  if (output.DBClusterSnapshotAttributes === "") {
    contents.DBClusterSnapshotAttributes = [];
  }
  if (
    output["DBClusterSnapshotAttributes"] !== undefined &&
    output["DBClusterSnapshotAttributes"]["DBClusterSnapshotAttribute"] !==
      undefined
  ) {
    contents.DBClusterSnapshotAttributes = deserializeAws_queryDBClusterSnapshotAttributeList(
      __getArrayIfSingleItem(
        output["DBClusterSnapshotAttributes"]["DBClusterSnapshotAttribute"]
      ),
      context
    );
  }
  if (output["DBClusterSnapshotIdentifier"] !== undefined) {
    contents.DBClusterSnapshotIdentifier =
      output["DBClusterSnapshotIdentifier"]["#text"] !== undefined
        ? output["DBClusterSnapshotIdentifier"]["#text"]
        : output["DBClusterSnapshotIdentifier"];
  }
  return contents;
};

const deserializeAws_queryDBClusterSnapshotList = (
  output: any,
  context: __SerdeContext
): DBClusterSnapshot[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBClusterSnapshot(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBClusterSnapshotMessage = (
  output: any,
  context: __SerdeContext
): DBClusterSnapshotMessage => {
  let contents: any = {
    __type: "DBClusterSnapshotMessage",
    DBClusterSnapshots: undefined,
    Marker: undefined
  };
  if (output.DBClusterSnapshots === "") {
    contents.DBClusterSnapshots = [];
  }
  if (
    output["DBClusterSnapshots"] !== undefined &&
    output["DBClusterSnapshots"]["DBClusterSnapshot"] !== undefined
  ) {
    contents.DBClusterSnapshots = deserializeAws_queryDBClusterSnapshotList(
      __getArrayIfSingleItem(output["DBClusterSnapshots"]["DBClusterSnapshot"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBEngineVersion = (
  output: any,
  context: __SerdeContext
): DBEngineVersion => {
  let contents: any = {
    __type: "DBEngineVersion",
    DBEngineDescription: undefined,
    DBEngineVersionDescription: undefined,
    DBParameterGroupFamily: undefined,
    DefaultCharacterSet: undefined,
    Engine: undefined,
    EngineVersion: undefined,
    ExportableLogTypes: undefined,
    Status: undefined,
    SupportedCharacterSets: undefined,
    SupportedEngineModes: undefined,
    SupportedFeatureNames: undefined,
    SupportedTimezones: undefined,
    SupportsLogExportsToCloudwatchLogs: undefined,
    SupportsReadReplica: undefined,
    ValidUpgradeTarget: undefined
  };
  if (output["DBEngineDescription"] !== undefined) {
    contents.DBEngineDescription =
      output["DBEngineDescription"]["#text"] !== undefined
        ? output["DBEngineDescription"]["#text"]
        : output["DBEngineDescription"];
  }
  if (output["DBEngineVersionDescription"] !== undefined) {
    contents.DBEngineVersionDescription =
      output["DBEngineVersionDescription"]["#text"] !== undefined
        ? output["DBEngineVersionDescription"]["#text"]
        : output["DBEngineVersionDescription"];
  }
  if (output["DBParameterGroupFamily"] !== undefined) {
    contents.DBParameterGroupFamily =
      output["DBParameterGroupFamily"]["#text"] !== undefined
        ? output["DBParameterGroupFamily"]["#text"]
        : output["DBParameterGroupFamily"];
  }
  if (output["DefaultCharacterSet"] !== undefined) {
    contents.DefaultCharacterSet = deserializeAws_queryCharacterSet(
      output["DefaultCharacterSet"],
      context
    );
  }
  if (output["Engine"] !== undefined) {
    contents.Engine =
      output["Engine"]["#text"] !== undefined
        ? output["Engine"]["#text"]
        : output["Engine"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output.ExportableLogTypes === "") {
    contents.ExportableLogTypes = [];
  }
  if (
    output["ExportableLogTypes"] !== undefined &&
    output["ExportableLogTypes"]["member"] !== undefined
  ) {
    contents.ExportableLogTypes = deserializeAws_queryLogTypeList(
      __getArrayIfSingleItem(output["ExportableLogTypes"]["member"]),
      context
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output.SupportedCharacterSets === "") {
    contents.SupportedCharacterSets = [];
  }
  if (
    output["SupportedCharacterSets"] !== undefined &&
    output["SupportedCharacterSets"]["CharacterSet"] !== undefined
  ) {
    contents.SupportedCharacterSets = deserializeAws_querySupportedCharacterSetsList(
      __getArrayIfSingleItem(output["SupportedCharacterSets"]["CharacterSet"]),
      context
    );
  }
  if (output.SupportedEngineModes === "") {
    contents.SupportedEngineModes = [];
  }
  if (
    output["SupportedEngineModes"] !== undefined &&
    output["SupportedEngineModes"]["member"] !== undefined
  ) {
    contents.SupportedEngineModes = deserializeAws_queryEngineModeList(
      __getArrayIfSingleItem(output["SupportedEngineModes"]["member"]),
      context
    );
  }
  if (output.SupportedFeatureNames === "") {
    contents.SupportedFeatureNames = [];
  }
  if (
    output["SupportedFeatureNames"] !== undefined &&
    output["SupportedFeatureNames"]["member"] !== undefined
  ) {
    contents.SupportedFeatureNames = deserializeAws_queryFeatureNameList(
      __getArrayIfSingleItem(output["SupportedFeatureNames"]["member"]),
      context
    );
  }
  if (output.SupportedTimezones === "") {
    contents.SupportedTimezones = [];
  }
  if (
    output["SupportedTimezones"] !== undefined &&
    output["SupportedTimezones"]["Timezone"] !== undefined
  ) {
    contents.SupportedTimezones = deserializeAws_querySupportedTimezonesList(
      __getArrayIfSingleItem(output["SupportedTimezones"]["Timezone"]),
      context
    );
  }
  if (output["SupportsLogExportsToCloudwatchLogs"] !== undefined) {
    contents.SupportsLogExportsToCloudwatchLogs =
      (output["SupportsLogExportsToCloudwatchLogs"]["#text"] !== undefined
        ? output["SupportsLogExportsToCloudwatchLogs"]["#text"]
        : output["SupportsLogExportsToCloudwatchLogs"]) == "true";
  }
  if (output["SupportsReadReplica"] !== undefined) {
    contents.SupportsReadReplica =
      (output["SupportsReadReplica"]["#text"] !== undefined
        ? output["SupportsReadReplica"]["#text"]
        : output["SupportsReadReplica"]) == "true";
  }
  if (output.ValidUpgradeTarget === "") {
    contents.ValidUpgradeTarget = [];
  }
  if (
    output["ValidUpgradeTarget"] !== undefined &&
    output["ValidUpgradeTarget"]["UpgradeTarget"] !== undefined
  ) {
    contents.ValidUpgradeTarget = deserializeAws_queryValidUpgradeTargetList(
      __getArrayIfSingleItem(output["ValidUpgradeTarget"]["UpgradeTarget"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryDBEngineVersionList = (
  output: any,
  context: __SerdeContext
): DBEngineVersion[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBEngineVersion(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBEngineVersionMessage = (
  output: any,
  context: __SerdeContext
): DBEngineVersionMessage => {
  let contents: any = {
    __type: "DBEngineVersionMessage",
    DBEngineVersions: undefined,
    Marker: undefined
  };
  if (output.DBEngineVersions === "") {
    contents.DBEngineVersions = [];
  }
  if (
    output["DBEngineVersions"] !== undefined &&
    output["DBEngineVersions"]["DBEngineVersion"] !== undefined
  ) {
    contents.DBEngineVersions = deserializeAws_queryDBEngineVersionList(
      __getArrayIfSingleItem(output["DBEngineVersions"]["DBEngineVersion"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBInstance = (
  output: any,
  context: __SerdeContext
): DBInstance => {
  let contents: any = {
    __type: "DBInstance",
    AllocatedStorage: undefined,
    AssociatedRoles: undefined,
    AutoMinorVersionUpgrade: undefined,
    AvailabilityZone: undefined,
    BackupRetentionPeriod: undefined,
    CACertificateIdentifier: undefined,
    CharacterSetName: undefined,
    CopyTagsToSnapshot: undefined,
    DBClusterIdentifier: undefined,
    DBInstanceArn: undefined,
    DBInstanceClass: undefined,
    DBInstanceIdentifier: undefined,
    DBInstanceStatus: undefined,
    DBName: undefined,
    DBParameterGroups: undefined,
    DBSecurityGroups: undefined,
    DBSubnetGroup: undefined,
    DbInstancePort: undefined,
    DbiResourceId: undefined,
    DeletionProtection: undefined,
    DomainMemberships: undefined,
    EnabledCloudwatchLogsExports: undefined,
    Endpoint: undefined,
    Engine: undefined,
    EngineVersion: undefined,
    EnhancedMonitoringResourceArn: undefined,
    IAMDatabaseAuthenticationEnabled: undefined,
    InstanceCreateTime: undefined,
    Iops: undefined,
    KmsKeyId: undefined,
    LatestRestorableTime: undefined,
    LicenseModel: undefined,
    ListenerEndpoint: undefined,
    MasterUsername: undefined,
    MaxAllocatedStorage: undefined,
    MonitoringInterval: undefined,
    MonitoringRoleArn: undefined,
    MultiAZ: undefined,
    OptionGroupMemberships: undefined,
    PendingModifiedValues: undefined,
    PerformanceInsightsEnabled: undefined,
    PerformanceInsightsKMSKeyId: undefined,
    PerformanceInsightsRetentionPeriod: undefined,
    PreferredBackupWindow: undefined,
    PreferredMaintenanceWindow: undefined,
    ProcessorFeatures: undefined,
    PromotionTier: undefined,
    PubliclyAccessible: undefined,
    ReadReplicaDBClusterIdentifiers: undefined,
    ReadReplicaDBInstanceIdentifiers: undefined,
    ReadReplicaSourceDBInstanceIdentifier: undefined,
    SecondaryAvailabilityZone: undefined,
    StatusInfos: undefined,
    StorageEncrypted: undefined,
    StorageType: undefined,
    TdeCredentialArn: undefined,
    Timezone: undefined,
    VpcSecurityGroups: undefined
  };
  if (output["AllocatedStorage"] !== undefined) {
    contents.AllocatedStorage = parseInt(
      output["AllocatedStorage"]["#text"] !== undefined
        ? output["AllocatedStorage"]["#text"]
        : output["AllocatedStorage"]
    );
  }
  if (output.AssociatedRoles === "") {
    contents.AssociatedRoles = [];
  }
  if (
    output["AssociatedRoles"] !== undefined &&
    output["AssociatedRoles"]["DBInstanceRole"] !== undefined
  ) {
    contents.AssociatedRoles = deserializeAws_queryDBInstanceRoles(
      __getArrayIfSingleItem(output["AssociatedRoles"]["DBInstanceRole"]),
      context
    );
  }
  if (output["AutoMinorVersionUpgrade"] !== undefined) {
    contents.AutoMinorVersionUpgrade =
      (output["AutoMinorVersionUpgrade"]["#text"] !== undefined
        ? output["AutoMinorVersionUpgrade"]["#text"]
        : output["AutoMinorVersionUpgrade"]) == "true";
  }
  if (output["AvailabilityZone"] !== undefined) {
    contents.AvailabilityZone =
      output["AvailabilityZone"]["#text"] !== undefined
        ? output["AvailabilityZone"]["#text"]
        : output["AvailabilityZone"];
  }
  if (output["BackupRetentionPeriod"] !== undefined) {
    contents.BackupRetentionPeriod = parseInt(
      output["BackupRetentionPeriod"]["#text"] !== undefined
        ? output["BackupRetentionPeriod"]["#text"]
        : output["BackupRetentionPeriod"]
    );
  }
  if (output["CACertificateIdentifier"] !== undefined) {
    contents.CACertificateIdentifier =
      output["CACertificateIdentifier"]["#text"] !== undefined
        ? output["CACertificateIdentifier"]["#text"]
        : output["CACertificateIdentifier"];
  }
  if (output["CharacterSetName"] !== undefined) {
    contents.CharacterSetName =
      output["CharacterSetName"]["#text"] !== undefined
        ? output["CharacterSetName"]["#text"]
        : output["CharacterSetName"];
  }
  if (output["CopyTagsToSnapshot"] !== undefined) {
    contents.CopyTagsToSnapshot =
      (output["CopyTagsToSnapshot"]["#text"] !== undefined
        ? output["CopyTagsToSnapshot"]["#text"]
        : output["CopyTagsToSnapshot"]) == "true";
  }
  if (output["DBClusterIdentifier"] !== undefined) {
    contents.DBClusterIdentifier =
      output["DBClusterIdentifier"]["#text"] !== undefined
        ? output["DBClusterIdentifier"]["#text"]
        : output["DBClusterIdentifier"];
  }
  if (output["DBInstanceArn"] !== undefined) {
    contents.DBInstanceArn =
      output["DBInstanceArn"]["#text"] !== undefined
        ? output["DBInstanceArn"]["#text"]
        : output["DBInstanceArn"];
  }
  if (output["DBInstanceClass"] !== undefined) {
    contents.DBInstanceClass =
      output["DBInstanceClass"]["#text"] !== undefined
        ? output["DBInstanceClass"]["#text"]
        : output["DBInstanceClass"];
  }
  if (output["DBInstanceIdentifier"] !== undefined) {
    contents.DBInstanceIdentifier =
      output["DBInstanceIdentifier"]["#text"] !== undefined
        ? output["DBInstanceIdentifier"]["#text"]
        : output["DBInstanceIdentifier"];
  }
  if (output["DBInstanceStatus"] !== undefined) {
    contents.DBInstanceStatus =
      output["DBInstanceStatus"]["#text"] !== undefined
        ? output["DBInstanceStatus"]["#text"]
        : output["DBInstanceStatus"];
  }
  if (output["DBName"] !== undefined) {
    contents.DBName =
      output["DBName"]["#text"] !== undefined
        ? output["DBName"]["#text"]
        : output["DBName"];
  }
  if (output.DBParameterGroups === "") {
    contents.DBParameterGroups = [];
  }
  if (
    output["DBParameterGroups"] !== undefined &&
    output["DBParameterGroups"]["DBParameterGroup"] !== undefined
  ) {
    contents.DBParameterGroups = deserializeAws_queryDBParameterGroupStatusList(
      __getArrayIfSingleItem(output["DBParameterGroups"]["DBParameterGroup"]),
      context
    );
  }
  if (output.DBSecurityGroups === "") {
    contents.DBSecurityGroups = [];
  }
  if (
    output["DBSecurityGroups"] !== undefined &&
    output["DBSecurityGroups"]["DBSecurityGroup"] !== undefined
  ) {
    contents.DBSecurityGroups = deserializeAws_queryDBSecurityGroupMembershipList(
      __getArrayIfSingleItem(output["DBSecurityGroups"]["DBSecurityGroup"]),
      context
    );
  }
  if (output["DBSubnetGroup"] !== undefined) {
    contents.DBSubnetGroup = deserializeAws_queryDBSubnetGroup(
      output["DBSubnetGroup"],
      context
    );
  }
  if (output["DbInstancePort"] !== undefined) {
    contents.DbInstancePort = parseInt(
      output["DbInstancePort"]["#text"] !== undefined
        ? output["DbInstancePort"]["#text"]
        : output["DbInstancePort"]
    );
  }
  if (output["DbiResourceId"] !== undefined) {
    contents.DbiResourceId =
      output["DbiResourceId"]["#text"] !== undefined
        ? output["DbiResourceId"]["#text"]
        : output["DbiResourceId"];
  }
  if (output["DeletionProtection"] !== undefined) {
    contents.DeletionProtection =
      (output["DeletionProtection"]["#text"] !== undefined
        ? output["DeletionProtection"]["#text"]
        : output["DeletionProtection"]) == "true";
  }
  if (output.DomainMemberships === "") {
    contents.DomainMemberships = [];
  }
  if (
    output["DomainMemberships"] !== undefined &&
    output["DomainMemberships"]["DomainMembership"] !== undefined
  ) {
    contents.DomainMemberships = deserializeAws_queryDomainMembershipList(
      __getArrayIfSingleItem(output["DomainMemberships"]["DomainMembership"]),
      context
    );
  }
  if (output.EnabledCloudwatchLogsExports === "") {
    contents.EnabledCloudwatchLogsExports = [];
  }
  if (
    output["EnabledCloudwatchLogsExports"] !== undefined &&
    output["EnabledCloudwatchLogsExports"]["member"] !== undefined
  ) {
    contents.EnabledCloudwatchLogsExports = deserializeAws_queryLogTypeList(
      __getArrayIfSingleItem(output["EnabledCloudwatchLogsExports"]["member"]),
      context
    );
  }
  if (output["Endpoint"] !== undefined) {
    contents.Endpoint = deserializeAws_queryEndpoint(
      output["Endpoint"],
      context
    );
  }
  if (output["Engine"] !== undefined) {
    contents.Engine =
      output["Engine"]["#text"] !== undefined
        ? output["Engine"]["#text"]
        : output["Engine"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output["EnhancedMonitoringResourceArn"] !== undefined) {
    contents.EnhancedMonitoringResourceArn =
      output["EnhancedMonitoringResourceArn"]["#text"] !== undefined
        ? output["EnhancedMonitoringResourceArn"]["#text"]
        : output["EnhancedMonitoringResourceArn"];
  }
  if (output["IAMDatabaseAuthenticationEnabled"] !== undefined) {
    contents.IAMDatabaseAuthenticationEnabled =
      (output["IAMDatabaseAuthenticationEnabled"]["#text"] !== undefined
        ? output["IAMDatabaseAuthenticationEnabled"]["#text"]
        : output["IAMDatabaseAuthenticationEnabled"]) == "true";
  }
  if (output["InstanceCreateTime"] !== undefined) {
    contents.InstanceCreateTime = new Date(output["InstanceCreateTime"]);
  }
  if (output["Iops"] !== undefined) {
    contents.Iops = parseInt(
      output["Iops"]["#text"] !== undefined
        ? output["Iops"]["#text"]
        : output["Iops"]
    );
  }
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId =
      output["KmsKeyId"]["#text"] !== undefined
        ? output["KmsKeyId"]["#text"]
        : output["KmsKeyId"];
  }
  if (output["LatestRestorableTime"] !== undefined) {
    contents.LatestRestorableTime = new Date(output["LatestRestorableTime"]);
  }
  if (output["LicenseModel"] !== undefined) {
    contents.LicenseModel =
      output["LicenseModel"]["#text"] !== undefined
        ? output["LicenseModel"]["#text"]
        : output["LicenseModel"];
  }
  if (output["ListenerEndpoint"] !== undefined) {
    contents.ListenerEndpoint = deserializeAws_queryEndpoint(
      output["ListenerEndpoint"],
      context
    );
  }
  if (output["MasterUsername"] !== undefined) {
    contents.MasterUsername =
      output["MasterUsername"]["#text"] !== undefined
        ? output["MasterUsername"]["#text"]
        : output["MasterUsername"];
  }
  if (output["MaxAllocatedStorage"] !== undefined) {
    contents.MaxAllocatedStorage = parseInt(
      output["MaxAllocatedStorage"]["#text"] !== undefined
        ? output["MaxAllocatedStorage"]["#text"]
        : output["MaxAllocatedStorage"]
    );
  }
  if (output["MonitoringInterval"] !== undefined) {
    contents.MonitoringInterval = parseInt(
      output["MonitoringInterval"]["#text"] !== undefined
        ? output["MonitoringInterval"]["#text"]
        : output["MonitoringInterval"]
    );
  }
  if (output["MonitoringRoleArn"] !== undefined) {
    contents.MonitoringRoleArn =
      output["MonitoringRoleArn"]["#text"] !== undefined
        ? output["MonitoringRoleArn"]["#text"]
        : output["MonitoringRoleArn"];
  }
  if (output["MultiAZ"] !== undefined) {
    contents.MultiAZ =
      (output["MultiAZ"]["#text"] !== undefined
        ? output["MultiAZ"]["#text"]
        : output["MultiAZ"]) == "true";
  }
  if (output.OptionGroupMemberships === "") {
    contents.OptionGroupMemberships = [];
  }
  if (
    output["OptionGroupMemberships"] !== undefined &&
    output["OptionGroupMemberships"]["OptionGroupMembership"] !== undefined
  ) {
    contents.OptionGroupMemberships = deserializeAws_queryOptionGroupMembershipList(
      __getArrayIfSingleItem(
        output["OptionGroupMemberships"]["OptionGroupMembership"]
      ),
      context
    );
  }
  if (output["PendingModifiedValues"] !== undefined) {
    contents.PendingModifiedValues = deserializeAws_queryPendingModifiedValues(
      output["PendingModifiedValues"],
      context
    );
  }
  if (output["PerformanceInsightsEnabled"] !== undefined) {
    contents.PerformanceInsightsEnabled =
      (output["PerformanceInsightsEnabled"]["#text"] !== undefined
        ? output["PerformanceInsightsEnabled"]["#text"]
        : output["PerformanceInsightsEnabled"]) == "true";
  }
  if (output["PerformanceInsightsKMSKeyId"] !== undefined) {
    contents.PerformanceInsightsKMSKeyId =
      output["PerformanceInsightsKMSKeyId"]["#text"] !== undefined
        ? output["PerformanceInsightsKMSKeyId"]["#text"]
        : output["PerformanceInsightsKMSKeyId"];
  }
  if (output["PerformanceInsightsRetentionPeriod"] !== undefined) {
    contents.PerformanceInsightsRetentionPeriod = parseInt(
      output["PerformanceInsightsRetentionPeriod"]["#text"] !== undefined
        ? output["PerformanceInsightsRetentionPeriod"]["#text"]
        : output["PerformanceInsightsRetentionPeriod"]
    );
  }
  if (output["PreferredBackupWindow"] !== undefined) {
    contents.PreferredBackupWindow =
      output["PreferredBackupWindow"]["#text"] !== undefined
        ? output["PreferredBackupWindow"]["#text"]
        : output["PreferredBackupWindow"];
  }
  if (output["PreferredMaintenanceWindow"] !== undefined) {
    contents.PreferredMaintenanceWindow =
      output["PreferredMaintenanceWindow"]["#text"] !== undefined
        ? output["PreferredMaintenanceWindow"]["#text"]
        : output["PreferredMaintenanceWindow"];
  }
  if (output.ProcessorFeatures === "") {
    contents.ProcessorFeatures = [];
  }
  if (
    output["ProcessorFeatures"] !== undefined &&
    output["ProcessorFeatures"]["ProcessorFeature"] !== undefined
  ) {
    contents.ProcessorFeatures = deserializeAws_queryProcessorFeatureList(
      __getArrayIfSingleItem(output["ProcessorFeatures"]["ProcessorFeature"]),
      context
    );
  }
  if (output["PromotionTier"] !== undefined) {
    contents.PromotionTier = parseInt(
      output["PromotionTier"]["#text"] !== undefined
        ? output["PromotionTier"]["#text"]
        : output["PromotionTier"]
    );
  }
  if (output["PubliclyAccessible"] !== undefined) {
    contents.PubliclyAccessible =
      (output["PubliclyAccessible"]["#text"] !== undefined
        ? output["PubliclyAccessible"]["#text"]
        : output["PubliclyAccessible"]) == "true";
  }
  if (output.ReadReplicaDBClusterIdentifiers === "") {
    contents.ReadReplicaDBClusterIdentifiers = [];
  }
  if (
    output["ReadReplicaDBClusterIdentifiers"] !== undefined &&
    output["ReadReplicaDBClusterIdentifiers"][
      "ReadReplicaDBClusterIdentifier"
    ] !== undefined
  ) {
    contents.ReadReplicaDBClusterIdentifiers = deserializeAws_queryReadReplicaDBClusterIdentifierList(
      __getArrayIfSingleItem(
        output["ReadReplicaDBClusterIdentifiers"][
          "ReadReplicaDBClusterIdentifier"
        ]
      ),
      context
    );
  }
  if (output.ReadReplicaDBInstanceIdentifiers === "") {
    contents.ReadReplicaDBInstanceIdentifiers = [];
  }
  if (
    output["ReadReplicaDBInstanceIdentifiers"] !== undefined &&
    output["ReadReplicaDBInstanceIdentifiers"][
      "ReadReplicaDBInstanceIdentifier"
    ] !== undefined
  ) {
    contents.ReadReplicaDBInstanceIdentifiers = deserializeAws_queryReadReplicaDBInstanceIdentifierList(
      __getArrayIfSingleItem(
        output["ReadReplicaDBInstanceIdentifiers"][
          "ReadReplicaDBInstanceIdentifier"
        ]
      ),
      context
    );
  }
  if (output["ReadReplicaSourceDBInstanceIdentifier"] !== undefined) {
    contents.ReadReplicaSourceDBInstanceIdentifier =
      output["ReadReplicaSourceDBInstanceIdentifier"]["#text"] !== undefined
        ? output["ReadReplicaSourceDBInstanceIdentifier"]["#text"]
        : output["ReadReplicaSourceDBInstanceIdentifier"];
  }
  if (output["SecondaryAvailabilityZone"] !== undefined) {
    contents.SecondaryAvailabilityZone =
      output["SecondaryAvailabilityZone"]["#text"] !== undefined
        ? output["SecondaryAvailabilityZone"]["#text"]
        : output["SecondaryAvailabilityZone"];
  }
  if (output.StatusInfos === "") {
    contents.StatusInfos = [];
  }
  if (
    output["StatusInfos"] !== undefined &&
    output["StatusInfos"]["DBInstanceStatusInfo"] !== undefined
  ) {
    contents.StatusInfos = deserializeAws_queryDBInstanceStatusInfoList(
      __getArrayIfSingleItem(output["StatusInfos"]["DBInstanceStatusInfo"]),
      context
    );
  }
  if (output["StorageEncrypted"] !== undefined) {
    contents.StorageEncrypted =
      (output["StorageEncrypted"]["#text"] !== undefined
        ? output["StorageEncrypted"]["#text"]
        : output["StorageEncrypted"]) == "true";
  }
  if (output["StorageType"] !== undefined) {
    contents.StorageType =
      output["StorageType"]["#text"] !== undefined
        ? output["StorageType"]["#text"]
        : output["StorageType"];
  }
  if (output["TdeCredentialArn"] !== undefined) {
    contents.TdeCredentialArn =
      output["TdeCredentialArn"]["#text"] !== undefined
        ? output["TdeCredentialArn"]["#text"]
        : output["TdeCredentialArn"];
  }
  if (output["Timezone"] !== undefined) {
    contents.Timezone =
      output["Timezone"]["#text"] !== undefined
        ? output["Timezone"]["#text"]
        : output["Timezone"];
  }
  if (output.VpcSecurityGroups === "") {
    contents.VpcSecurityGroups = [];
  }
  if (
    output["VpcSecurityGroups"] !== undefined &&
    output["VpcSecurityGroups"]["VpcSecurityGroupMembership"] !== undefined
  ) {
    contents.VpcSecurityGroups = deserializeAws_queryVpcSecurityGroupMembershipList(
      __getArrayIfSingleItem(
        output["VpcSecurityGroups"]["VpcSecurityGroupMembership"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_queryDBInstanceAutomatedBackup = (
  output: any,
  context: __SerdeContext
): DBInstanceAutomatedBackup => {
  let contents: any = {
    __type: "DBInstanceAutomatedBackup",
    AllocatedStorage: undefined,
    AvailabilityZone: undefined,
    DBInstanceArn: undefined,
    DBInstanceIdentifier: undefined,
    DbiResourceId: undefined,
    Encrypted: undefined,
    Engine: undefined,
    EngineVersion: undefined,
    IAMDatabaseAuthenticationEnabled: undefined,
    InstanceCreateTime: undefined,
    Iops: undefined,
    KmsKeyId: undefined,
    LicenseModel: undefined,
    MasterUsername: undefined,
    OptionGroupName: undefined,
    Port: undefined,
    Region: undefined,
    RestoreWindow: undefined,
    Status: undefined,
    StorageType: undefined,
    TdeCredentialArn: undefined,
    Timezone: undefined,
    VpcId: undefined
  };
  if (output["AllocatedStorage"] !== undefined) {
    contents.AllocatedStorage = parseInt(
      output["AllocatedStorage"]["#text"] !== undefined
        ? output["AllocatedStorage"]["#text"]
        : output["AllocatedStorage"]
    );
  }
  if (output["AvailabilityZone"] !== undefined) {
    contents.AvailabilityZone =
      output["AvailabilityZone"]["#text"] !== undefined
        ? output["AvailabilityZone"]["#text"]
        : output["AvailabilityZone"];
  }
  if (output["DBInstanceArn"] !== undefined) {
    contents.DBInstanceArn =
      output["DBInstanceArn"]["#text"] !== undefined
        ? output["DBInstanceArn"]["#text"]
        : output["DBInstanceArn"];
  }
  if (output["DBInstanceIdentifier"] !== undefined) {
    contents.DBInstanceIdentifier =
      output["DBInstanceIdentifier"]["#text"] !== undefined
        ? output["DBInstanceIdentifier"]["#text"]
        : output["DBInstanceIdentifier"];
  }
  if (output["DbiResourceId"] !== undefined) {
    contents.DbiResourceId =
      output["DbiResourceId"]["#text"] !== undefined
        ? output["DbiResourceId"]["#text"]
        : output["DbiResourceId"];
  }
  if (output["Encrypted"] !== undefined) {
    contents.Encrypted =
      (output["Encrypted"]["#text"] !== undefined
        ? output["Encrypted"]["#text"]
        : output["Encrypted"]) == "true";
  }
  if (output["Engine"] !== undefined) {
    contents.Engine =
      output["Engine"]["#text"] !== undefined
        ? output["Engine"]["#text"]
        : output["Engine"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output["IAMDatabaseAuthenticationEnabled"] !== undefined) {
    contents.IAMDatabaseAuthenticationEnabled =
      (output["IAMDatabaseAuthenticationEnabled"]["#text"] !== undefined
        ? output["IAMDatabaseAuthenticationEnabled"]["#text"]
        : output["IAMDatabaseAuthenticationEnabled"]) == "true";
  }
  if (output["InstanceCreateTime"] !== undefined) {
    contents.InstanceCreateTime = new Date(output["InstanceCreateTime"]);
  }
  if (output["Iops"] !== undefined) {
    contents.Iops = parseInt(
      output["Iops"]["#text"] !== undefined
        ? output["Iops"]["#text"]
        : output["Iops"]
    );
  }
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId =
      output["KmsKeyId"]["#text"] !== undefined
        ? output["KmsKeyId"]["#text"]
        : output["KmsKeyId"];
  }
  if (output["LicenseModel"] !== undefined) {
    contents.LicenseModel =
      output["LicenseModel"]["#text"] !== undefined
        ? output["LicenseModel"]["#text"]
        : output["LicenseModel"];
  }
  if (output["MasterUsername"] !== undefined) {
    contents.MasterUsername =
      output["MasterUsername"]["#text"] !== undefined
        ? output["MasterUsername"]["#text"]
        : output["MasterUsername"];
  }
  if (output["OptionGroupName"] !== undefined) {
    contents.OptionGroupName =
      output["OptionGroupName"]["#text"] !== undefined
        ? output["OptionGroupName"]["#text"]
        : output["OptionGroupName"];
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(
      output["Port"]["#text"] !== undefined
        ? output["Port"]["#text"]
        : output["Port"]
    );
  }
  if (output["Region"] !== undefined) {
    contents.Region =
      output["Region"]["#text"] !== undefined
        ? output["Region"]["#text"]
        : output["Region"];
  }
  if (output["RestoreWindow"] !== undefined) {
    contents.RestoreWindow = deserializeAws_queryRestoreWindow(
      output["RestoreWindow"],
      context
    );
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output["StorageType"] !== undefined) {
    contents.StorageType =
      output["StorageType"]["#text"] !== undefined
        ? output["StorageType"]["#text"]
        : output["StorageType"];
  }
  if (output["TdeCredentialArn"] !== undefined) {
    contents.TdeCredentialArn =
      output["TdeCredentialArn"]["#text"] !== undefined
        ? output["TdeCredentialArn"]["#text"]
        : output["TdeCredentialArn"];
  }
  if (output["Timezone"] !== undefined) {
    contents.Timezone =
      output["Timezone"]["#text"] !== undefined
        ? output["Timezone"]["#text"]
        : output["Timezone"];
  }
  if (output["VpcId"] !== undefined) {
    contents.VpcId =
      output["VpcId"]["#text"] !== undefined
        ? output["VpcId"]["#text"]
        : output["VpcId"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceAutomatedBackupList = (
  output: any,
  context: __SerdeContext
): DBInstanceAutomatedBackup[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryDBInstanceAutomatedBackup(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryDBInstanceAutomatedBackupMessage = (
  output: any,
  context: __SerdeContext
): DBInstanceAutomatedBackupMessage => {
  let contents: any = {
    __type: "DBInstanceAutomatedBackupMessage",
    DBInstanceAutomatedBackups: undefined,
    Marker: undefined
  };
  if (output.DBInstanceAutomatedBackups === "") {
    contents.DBInstanceAutomatedBackups = [];
  }
  if (
    output["DBInstanceAutomatedBackups"] !== undefined &&
    output["DBInstanceAutomatedBackups"]["DBInstanceAutomatedBackup"] !==
      undefined
  ) {
    contents.DBInstanceAutomatedBackups = deserializeAws_queryDBInstanceAutomatedBackupList(
      __getArrayIfSingleItem(
        output["DBInstanceAutomatedBackups"]["DBInstanceAutomatedBackup"]
      ),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceList = (
  output: any,
  context: __SerdeContext
): DBInstance[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBInstance(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBInstanceMessage = (
  output: any,
  context: __SerdeContext
): DBInstanceMessage => {
  let contents: any = {
    __type: "DBInstanceMessage",
    DBInstances: undefined,
    Marker: undefined
  };
  if (output.DBInstances === "") {
    contents.DBInstances = [];
  }
  if (
    output["DBInstances"] !== undefined &&
    output["DBInstances"]["DBInstance"] !== undefined
  ) {
    contents.DBInstances = deserializeAws_queryDBInstanceList(
      __getArrayIfSingleItem(output["DBInstances"]["DBInstance"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceRole = (
  output: any,
  context: __SerdeContext
): DBInstanceRole => {
  let contents: any = {
    __type: "DBInstanceRole",
    FeatureName: undefined,
    RoleArn: undefined,
    Status: undefined
  };
  if (output["FeatureName"] !== undefined) {
    contents.FeatureName =
      output["FeatureName"]["#text"] !== undefined
        ? output["FeatureName"]["#text"]
        : output["FeatureName"];
  }
  if (output["RoleArn"] !== undefined) {
    contents.RoleArn =
      output["RoleArn"]["#text"] !== undefined
        ? output["RoleArn"]["#text"]
        : output["RoleArn"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceRoles = (
  output: any,
  context: __SerdeContext
): DBInstanceRole[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBInstanceRole(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBInstanceStatusInfo = (
  output: any,
  context: __SerdeContext
): DBInstanceStatusInfo => {
  let contents: any = {
    __type: "DBInstanceStatusInfo",
    Message: undefined,
    Normal: undefined,
    Status: undefined,
    StatusType: undefined
  };
  if (output["Message"] !== undefined) {
    contents.Message =
      output["Message"]["#text"] !== undefined
        ? output["Message"]["#text"]
        : output["Message"];
  }
  if (output["Normal"] !== undefined) {
    contents.Normal =
      (output["Normal"]["#text"] !== undefined
        ? output["Normal"]["#text"]
        : output["Normal"]) == "true";
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output["StatusType"] !== undefined) {
    contents.StatusType =
      output["StatusType"]["#text"] !== undefined
        ? output["StatusType"]["#text"]
        : output["StatusType"];
  }
  return contents;
};

const deserializeAws_queryDBInstanceStatusInfoList = (
  output: any,
  context: __SerdeContext
): DBInstanceStatusInfo[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBInstanceStatusInfo(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBParameterGroup = (
  output: any,
  context: __SerdeContext
): DBParameterGroup => {
  let contents: any = {
    __type: "DBParameterGroup",
    DBParameterGroupArn: undefined,
    DBParameterGroupFamily: undefined,
    DBParameterGroupName: undefined,
    Description: undefined
  };
  if (output["DBParameterGroupArn"] !== undefined) {
    contents.DBParameterGroupArn =
      output["DBParameterGroupArn"]["#text"] !== undefined
        ? output["DBParameterGroupArn"]["#text"]
        : output["DBParameterGroupArn"];
  }
  if (output["DBParameterGroupFamily"] !== undefined) {
    contents.DBParameterGroupFamily =
      output["DBParameterGroupFamily"]["#text"] !== undefined
        ? output["DBParameterGroupFamily"]["#text"]
        : output["DBParameterGroupFamily"];
  }
  if (output["DBParameterGroupName"] !== undefined) {
    contents.DBParameterGroupName =
      output["DBParameterGroupName"]["#text"] !== undefined
        ? output["DBParameterGroupName"]["#text"]
        : output["DBParameterGroupName"];
  }
  if (output["Description"] !== undefined) {
    contents.Description =
      output["Description"]["#text"] !== undefined
        ? output["Description"]["#text"]
        : output["Description"];
  }
  return contents;
};

const deserializeAws_queryDBParameterGroupDetails = (
  output: any,
  context: __SerdeContext
): DBParameterGroupDetails => {
  let contents: any = {
    __type: "DBParameterGroupDetails",
    Marker: undefined,
    Parameters: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.Parameters === "") {
    contents.Parameters = [];
  }
  if (
    output["Parameters"] !== undefined &&
    output["Parameters"]["Parameter"] !== undefined
  ) {
    contents.Parameters = deserializeAws_queryParametersList(
      __getArrayIfSingleItem(output["Parameters"]["Parameter"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryDBParameterGroupList = (
  output: any,
  context: __SerdeContext
): DBParameterGroup[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBParameterGroup(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBParameterGroupNameMessage = (
  output: any,
  context: __SerdeContext
): DBParameterGroupNameMessage => {
  let contents: any = {
    __type: "DBParameterGroupNameMessage",
    DBParameterGroupName: undefined
  };
  if (output["DBParameterGroupName"] !== undefined) {
    contents.DBParameterGroupName =
      output["DBParameterGroupName"]["#text"] !== undefined
        ? output["DBParameterGroupName"]["#text"]
        : output["DBParameterGroupName"];
  }
  return contents;
};

const deserializeAws_queryDBParameterGroupStatus = (
  output: any,
  context: __SerdeContext
): DBParameterGroupStatus => {
  let contents: any = {
    __type: "DBParameterGroupStatus",
    DBParameterGroupName: undefined,
    ParameterApplyStatus: undefined
  };
  if (output["DBParameterGroupName"] !== undefined) {
    contents.DBParameterGroupName =
      output["DBParameterGroupName"]["#text"] !== undefined
        ? output["DBParameterGroupName"]["#text"]
        : output["DBParameterGroupName"];
  }
  if (output["ParameterApplyStatus"] !== undefined) {
    contents.ParameterApplyStatus =
      output["ParameterApplyStatus"]["#text"] !== undefined
        ? output["ParameterApplyStatus"]["#text"]
        : output["ParameterApplyStatus"];
  }
  return contents;
};

const deserializeAws_queryDBParameterGroupStatusList = (
  output: any,
  context: __SerdeContext
): DBParameterGroupStatus[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBParameterGroupStatus(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBParameterGroupsMessage = (
  output: any,
  context: __SerdeContext
): DBParameterGroupsMessage => {
  let contents: any = {
    __type: "DBParameterGroupsMessage",
    DBParameterGroups: undefined,
    Marker: undefined
  };
  if (output.DBParameterGroups === "") {
    contents.DBParameterGroups = [];
  }
  if (
    output["DBParameterGroups"] !== undefined &&
    output["DBParameterGroups"]["DBParameterGroup"] !== undefined
  ) {
    contents.DBParameterGroups = deserializeAws_queryDBParameterGroupList(
      __getArrayIfSingleItem(output["DBParameterGroups"]["DBParameterGroup"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBProxy = (
  output: any,
  context: __SerdeContext
): DBProxy => {
  let contents: any = {
    __type: "DBProxy",
    Auth: undefined,
    CreatedDate: undefined,
    DBProxyArn: undefined,
    DBProxyName: undefined,
    DebugLogging: undefined,
    Endpoint: undefined,
    EngineFamily: undefined,
    IdleClientTimeout: undefined,
    RequireTLS: undefined,
    RoleArn: undefined,
    Status: undefined,
    UpdatedDate: undefined,
    VpcSecurityGroupIds: undefined,
    VpcSubnetIds: undefined
  };
  if (output.Auth === "") {
    contents.Auth = [];
  }
  if (output["Auth"] !== undefined && output["Auth"]["member"] !== undefined) {
    contents.Auth = deserializeAws_queryUserAuthConfigInfoList(
      __getArrayIfSingleItem(output["Auth"]["member"]),
      context
    );
  }
  if (output["CreatedDate"] !== undefined) {
    contents.CreatedDate = new Date(output["CreatedDate"]);
  }
  if (output["DBProxyArn"] !== undefined) {
    contents.DBProxyArn =
      output["DBProxyArn"]["#text"] !== undefined
        ? output["DBProxyArn"]["#text"]
        : output["DBProxyArn"];
  }
  if (output["DBProxyName"] !== undefined) {
    contents.DBProxyName =
      output["DBProxyName"]["#text"] !== undefined
        ? output["DBProxyName"]["#text"]
        : output["DBProxyName"];
  }
  if (output["DebugLogging"] !== undefined) {
    contents.DebugLogging =
      (output["DebugLogging"]["#text"] !== undefined
        ? output["DebugLogging"]["#text"]
        : output["DebugLogging"]) == "true";
  }
  if (output["Endpoint"] !== undefined) {
    contents.Endpoint =
      output["Endpoint"]["#text"] !== undefined
        ? output["Endpoint"]["#text"]
        : output["Endpoint"];
  }
  if (output["EngineFamily"] !== undefined) {
    contents.EngineFamily =
      output["EngineFamily"]["#text"] !== undefined
        ? output["EngineFamily"]["#text"]
        : output["EngineFamily"];
  }
  if (output["IdleClientTimeout"] !== undefined) {
    contents.IdleClientTimeout = parseInt(
      output["IdleClientTimeout"]["#text"] !== undefined
        ? output["IdleClientTimeout"]["#text"]
        : output["IdleClientTimeout"]
    );
  }
  if (output["RequireTLS"] !== undefined) {
    contents.RequireTLS =
      (output["RequireTLS"]["#text"] !== undefined
        ? output["RequireTLS"]["#text"]
        : output["RequireTLS"]) == "true";
  }
  if (output["RoleArn"] !== undefined) {
    contents.RoleArn =
      output["RoleArn"]["#text"] !== undefined
        ? output["RoleArn"]["#text"]
        : output["RoleArn"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output["UpdatedDate"] !== undefined) {
    contents.UpdatedDate = new Date(output["UpdatedDate"]);
  }
  if (output.VpcSecurityGroupIds === "") {
    contents.VpcSecurityGroupIds = [];
  }
  if (
    output["VpcSecurityGroupIds"] !== undefined &&
    output["VpcSecurityGroupIds"]["member"] !== undefined
  ) {
    contents.VpcSecurityGroupIds = deserializeAws_queryStringList(
      __getArrayIfSingleItem(output["VpcSecurityGroupIds"]["member"]),
      context
    );
  }
  if (output.VpcSubnetIds === "") {
    contents.VpcSubnetIds = [];
  }
  if (
    output["VpcSubnetIds"] !== undefined &&
    output["VpcSubnetIds"]["member"] !== undefined
  ) {
    contents.VpcSubnetIds = deserializeAws_queryStringList(
      __getArrayIfSingleItem(output["VpcSubnetIds"]["member"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryDBProxyList = (
  output: any,
  context: __SerdeContext
): DBProxy[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBProxy(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBProxyTarget = (
  output: any,
  context: __SerdeContext
): DBProxyTarget => {
  let contents: any = {
    __type: "DBProxyTarget",
    Endpoint: undefined,
    Port: undefined,
    RdsResourceId: undefined,
    TargetArn: undefined,
    TrackedClusterId: undefined,
    Type: undefined
  };
  if (output["Endpoint"] !== undefined) {
    contents.Endpoint =
      output["Endpoint"]["#text"] !== undefined
        ? output["Endpoint"]["#text"]
        : output["Endpoint"];
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(
      output["Port"]["#text"] !== undefined
        ? output["Port"]["#text"]
        : output["Port"]
    );
  }
  if (output["RdsResourceId"] !== undefined) {
    contents.RdsResourceId =
      output["RdsResourceId"]["#text"] !== undefined
        ? output["RdsResourceId"]["#text"]
        : output["RdsResourceId"];
  }
  if (output["TargetArn"] !== undefined) {
    contents.TargetArn =
      output["TargetArn"]["#text"] !== undefined
        ? output["TargetArn"]["#text"]
        : output["TargetArn"];
  }
  if (output["TrackedClusterId"] !== undefined) {
    contents.TrackedClusterId =
      output["TrackedClusterId"]["#text"] !== undefined
        ? output["TrackedClusterId"]["#text"]
        : output["TrackedClusterId"];
  }
  if (output["Type"] !== undefined) {
    contents.Type =
      output["Type"]["#text"] !== undefined
        ? output["Type"]["#text"]
        : output["Type"];
  }
  return contents;
};

const deserializeAws_queryDBProxyTargetGroup = (
  output: any,
  context: __SerdeContext
): DBProxyTargetGroup => {
  let contents: any = {
    __type: "DBProxyTargetGroup",
    ConnectionPoolConfig: undefined,
    CreatedDate: undefined,
    DBProxyName: undefined,
    IsDefault: undefined,
    Status: undefined,
    TargetGroupArn: undefined,
    TargetGroupName: undefined,
    UpdatedDate: undefined
  };
  if (output["ConnectionPoolConfig"] !== undefined) {
    contents.ConnectionPoolConfig = deserializeAws_queryConnectionPoolConfigurationInfo(
      output["ConnectionPoolConfig"],
      context
    );
  }
  if (output["CreatedDate"] !== undefined) {
    contents.CreatedDate = new Date(output["CreatedDate"]);
  }
  if (output["DBProxyName"] !== undefined) {
    contents.DBProxyName =
      output["DBProxyName"]["#text"] !== undefined
        ? output["DBProxyName"]["#text"]
        : output["DBProxyName"];
  }
  if (output["IsDefault"] !== undefined) {
    contents.IsDefault =
      (output["IsDefault"]["#text"] !== undefined
        ? output["IsDefault"]["#text"]
        : output["IsDefault"]) == "true";
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output["TargetGroupArn"] !== undefined) {
    contents.TargetGroupArn =
      output["TargetGroupArn"]["#text"] !== undefined
        ? output["TargetGroupArn"]["#text"]
        : output["TargetGroupArn"];
  }
  if (output["TargetGroupName"] !== undefined) {
    contents.TargetGroupName =
      output["TargetGroupName"]["#text"] !== undefined
        ? output["TargetGroupName"]["#text"]
        : output["TargetGroupName"];
  }
  if (output["UpdatedDate"] !== undefined) {
    contents.UpdatedDate = new Date(output["UpdatedDate"]);
  }
  return contents;
};

const deserializeAws_queryDBSecurityGroup = (
  output: any,
  context: __SerdeContext
): DBSecurityGroup => {
  let contents: any = {
    __type: "DBSecurityGroup",
    DBSecurityGroupArn: undefined,
    DBSecurityGroupDescription: undefined,
    DBSecurityGroupName: undefined,
    EC2SecurityGroups: undefined,
    IPRanges: undefined,
    OwnerId: undefined,
    VpcId: undefined
  };
  if (output["DBSecurityGroupArn"] !== undefined) {
    contents.DBSecurityGroupArn =
      output["DBSecurityGroupArn"]["#text"] !== undefined
        ? output["DBSecurityGroupArn"]["#text"]
        : output["DBSecurityGroupArn"];
  }
  if (output["DBSecurityGroupDescription"] !== undefined) {
    contents.DBSecurityGroupDescription =
      output["DBSecurityGroupDescription"]["#text"] !== undefined
        ? output["DBSecurityGroupDescription"]["#text"]
        : output["DBSecurityGroupDescription"];
  }
  if (output["DBSecurityGroupName"] !== undefined) {
    contents.DBSecurityGroupName =
      output["DBSecurityGroupName"]["#text"] !== undefined
        ? output["DBSecurityGroupName"]["#text"]
        : output["DBSecurityGroupName"];
  }
  if (output.EC2SecurityGroups === "") {
    contents.EC2SecurityGroups = [];
  }
  if (
    output["EC2SecurityGroups"] !== undefined &&
    output["EC2SecurityGroups"]["EC2SecurityGroup"] !== undefined
  ) {
    contents.EC2SecurityGroups = deserializeAws_queryEC2SecurityGroupList(
      __getArrayIfSingleItem(output["EC2SecurityGroups"]["EC2SecurityGroup"]),
      context
    );
  }
  if (output.IPRanges === "") {
    contents.IPRanges = [];
  }
  if (
    output["IPRanges"] !== undefined &&
    output["IPRanges"]["IPRange"] !== undefined
  ) {
    contents.IPRanges = deserializeAws_queryIPRangeList(
      __getArrayIfSingleItem(output["IPRanges"]["IPRange"]),
      context
    );
  }
  if (output["OwnerId"] !== undefined) {
    contents.OwnerId =
      output["OwnerId"]["#text"] !== undefined
        ? output["OwnerId"]["#text"]
        : output["OwnerId"];
  }
  if (output["VpcId"] !== undefined) {
    contents.VpcId =
      output["VpcId"]["#text"] !== undefined
        ? output["VpcId"]["#text"]
        : output["VpcId"];
  }
  return contents;
};

const deserializeAws_queryDBSecurityGroupMembership = (
  output: any,
  context: __SerdeContext
): DBSecurityGroupMembership => {
  let contents: any = {
    __type: "DBSecurityGroupMembership",
    DBSecurityGroupName: undefined,
    Status: undefined
  };
  if (output["DBSecurityGroupName"] !== undefined) {
    contents.DBSecurityGroupName =
      output["DBSecurityGroupName"]["#text"] !== undefined
        ? output["DBSecurityGroupName"]["#text"]
        : output["DBSecurityGroupName"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryDBSecurityGroupMembershipList = (
  output: any,
  context: __SerdeContext
): DBSecurityGroupMembership[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryDBSecurityGroupMembership(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryDBSecurityGroupMessage = (
  output: any,
  context: __SerdeContext
): DBSecurityGroupMessage => {
  let contents: any = {
    __type: "DBSecurityGroupMessage",
    DBSecurityGroups: undefined,
    Marker: undefined
  };
  if (output.DBSecurityGroups === "") {
    contents.DBSecurityGroups = [];
  }
  if (
    output["DBSecurityGroups"] !== undefined &&
    output["DBSecurityGroups"]["DBSecurityGroup"] !== undefined
  ) {
    contents.DBSecurityGroups = deserializeAws_queryDBSecurityGroups(
      __getArrayIfSingleItem(output["DBSecurityGroups"]["DBSecurityGroup"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBSecurityGroups = (
  output: any,
  context: __SerdeContext
): DBSecurityGroup[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBSecurityGroup(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBSnapshot = (
  output: any,
  context: __SerdeContext
): DBSnapshot => {
  let contents: any = {
    __type: "DBSnapshot",
    AllocatedStorage: undefined,
    AvailabilityZone: undefined,
    DBInstanceIdentifier: undefined,
    DBSnapshotArn: undefined,
    DBSnapshotIdentifier: undefined,
    DbiResourceId: undefined,
    Encrypted: undefined,
    Engine: undefined,
    EngineVersion: undefined,
    IAMDatabaseAuthenticationEnabled: undefined,
    InstanceCreateTime: undefined,
    Iops: undefined,
    KmsKeyId: undefined,
    LicenseModel: undefined,
    MasterUsername: undefined,
    OptionGroupName: undefined,
    PercentProgress: undefined,
    Port: undefined,
    ProcessorFeatures: undefined,
    SnapshotCreateTime: undefined,
    SnapshotType: undefined,
    SourceDBSnapshotIdentifier: undefined,
    SourceRegion: undefined,
    Status: undefined,
    StorageType: undefined,
    TdeCredentialArn: undefined,
    Timezone: undefined,
    VpcId: undefined
  };
  if (output["AllocatedStorage"] !== undefined) {
    contents.AllocatedStorage = parseInt(
      output["AllocatedStorage"]["#text"] !== undefined
        ? output["AllocatedStorage"]["#text"]
        : output["AllocatedStorage"]
    );
  }
  if (output["AvailabilityZone"] !== undefined) {
    contents.AvailabilityZone =
      output["AvailabilityZone"]["#text"] !== undefined
        ? output["AvailabilityZone"]["#text"]
        : output["AvailabilityZone"];
  }
  if (output["DBInstanceIdentifier"] !== undefined) {
    contents.DBInstanceIdentifier =
      output["DBInstanceIdentifier"]["#text"] !== undefined
        ? output["DBInstanceIdentifier"]["#text"]
        : output["DBInstanceIdentifier"];
  }
  if (output["DBSnapshotArn"] !== undefined) {
    contents.DBSnapshotArn =
      output["DBSnapshotArn"]["#text"] !== undefined
        ? output["DBSnapshotArn"]["#text"]
        : output["DBSnapshotArn"];
  }
  if (output["DBSnapshotIdentifier"] !== undefined) {
    contents.DBSnapshotIdentifier =
      output["DBSnapshotIdentifier"]["#text"] !== undefined
        ? output["DBSnapshotIdentifier"]["#text"]
        : output["DBSnapshotIdentifier"];
  }
  if (output["DbiResourceId"] !== undefined) {
    contents.DbiResourceId =
      output["DbiResourceId"]["#text"] !== undefined
        ? output["DbiResourceId"]["#text"]
        : output["DbiResourceId"];
  }
  if (output["Encrypted"] !== undefined) {
    contents.Encrypted =
      (output["Encrypted"]["#text"] !== undefined
        ? output["Encrypted"]["#text"]
        : output["Encrypted"]) == "true";
  }
  if (output["Engine"] !== undefined) {
    contents.Engine =
      output["Engine"]["#text"] !== undefined
        ? output["Engine"]["#text"]
        : output["Engine"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output["IAMDatabaseAuthenticationEnabled"] !== undefined) {
    contents.IAMDatabaseAuthenticationEnabled =
      (output["IAMDatabaseAuthenticationEnabled"]["#text"] !== undefined
        ? output["IAMDatabaseAuthenticationEnabled"]["#text"]
        : output["IAMDatabaseAuthenticationEnabled"]) == "true";
  }
  if (output["InstanceCreateTime"] !== undefined) {
    contents.InstanceCreateTime = new Date(output["InstanceCreateTime"]);
  }
  if (output["Iops"] !== undefined) {
    contents.Iops = parseInt(
      output["Iops"]["#text"] !== undefined
        ? output["Iops"]["#text"]
        : output["Iops"]
    );
  }
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId =
      output["KmsKeyId"]["#text"] !== undefined
        ? output["KmsKeyId"]["#text"]
        : output["KmsKeyId"];
  }
  if (output["LicenseModel"] !== undefined) {
    contents.LicenseModel =
      output["LicenseModel"]["#text"] !== undefined
        ? output["LicenseModel"]["#text"]
        : output["LicenseModel"];
  }
  if (output["MasterUsername"] !== undefined) {
    contents.MasterUsername =
      output["MasterUsername"]["#text"] !== undefined
        ? output["MasterUsername"]["#text"]
        : output["MasterUsername"];
  }
  if (output["OptionGroupName"] !== undefined) {
    contents.OptionGroupName =
      output["OptionGroupName"]["#text"] !== undefined
        ? output["OptionGroupName"]["#text"]
        : output["OptionGroupName"];
  }
  if (output["PercentProgress"] !== undefined) {
    contents.PercentProgress = parseInt(
      output["PercentProgress"]["#text"] !== undefined
        ? output["PercentProgress"]["#text"]
        : output["PercentProgress"]
    );
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(
      output["Port"]["#text"] !== undefined
        ? output["Port"]["#text"]
        : output["Port"]
    );
  }
  if (output.ProcessorFeatures === "") {
    contents.ProcessorFeatures = [];
  }
  if (
    output["ProcessorFeatures"] !== undefined &&
    output["ProcessorFeatures"]["ProcessorFeature"] !== undefined
  ) {
    contents.ProcessorFeatures = deserializeAws_queryProcessorFeatureList(
      __getArrayIfSingleItem(output["ProcessorFeatures"]["ProcessorFeature"]),
      context
    );
  }
  if (output["SnapshotCreateTime"] !== undefined) {
    contents.SnapshotCreateTime = new Date(output["SnapshotCreateTime"]);
  }
  if (output["SnapshotType"] !== undefined) {
    contents.SnapshotType =
      output["SnapshotType"]["#text"] !== undefined
        ? output["SnapshotType"]["#text"]
        : output["SnapshotType"];
  }
  if (output["SourceDBSnapshotIdentifier"] !== undefined) {
    contents.SourceDBSnapshotIdentifier =
      output["SourceDBSnapshotIdentifier"]["#text"] !== undefined
        ? output["SourceDBSnapshotIdentifier"]["#text"]
        : output["SourceDBSnapshotIdentifier"];
  }
  if (output["SourceRegion"] !== undefined) {
    contents.SourceRegion =
      output["SourceRegion"]["#text"] !== undefined
        ? output["SourceRegion"]["#text"]
        : output["SourceRegion"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output["StorageType"] !== undefined) {
    contents.StorageType =
      output["StorageType"]["#text"] !== undefined
        ? output["StorageType"]["#text"]
        : output["StorageType"];
  }
  if (output["TdeCredentialArn"] !== undefined) {
    contents.TdeCredentialArn =
      output["TdeCredentialArn"]["#text"] !== undefined
        ? output["TdeCredentialArn"]["#text"]
        : output["TdeCredentialArn"];
  }
  if (output["Timezone"] !== undefined) {
    contents.Timezone =
      output["Timezone"]["#text"] !== undefined
        ? output["Timezone"]["#text"]
        : output["Timezone"];
  }
  if (output["VpcId"] !== undefined) {
    contents.VpcId =
      output["VpcId"]["#text"] !== undefined
        ? output["VpcId"]["#text"]
        : output["VpcId"];
  }
  return contents;
};

const deserializeAws_queryDBSnapshotAttribute = (
  output: any,
  context: __SerdeContext
): DBSnapshotAttribute => {
  let contents: any = {
    __type: "DBSnapshotAttribute",
    AttributeName: undefined,
    AttributeValues: undefined
  };
  if (output["AttributeName"] !== undefined) {
    contents.AttributeName =
      output["AttributeName"]["#text"] !== undefined
        ? output["AttributeName"]["#text"]
        : output["AttributeName"];
  }
  if (output.AttributeValues === "") {
    contents.AttributeValues = [];
  }
  if (
    output["AttributeValues"] !== undefined &&
    output["AttributeValues"]["AttributeValue"] !== undefined
  ) {
    contents.AttributeValues = deserializeAws_queryAttributeValueList(
      __getArrayIfSingleItem(output["AttributeValues"]["AttributeValue"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryDBSnapshotAttributeList = (
  output: any,
  context: __SerdeContext
): DBSnapshotAttribute[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBSnapshotAttribute(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBSnapshotAttributesResult = (
  output: any,
  context: __SerdeContext
): DBSnapshotAttributesResult => {
  let contents: any = {
    __type: "DBSnapshotAttributesResult",
    DBSnapshotAttributes: undefined,
    DBSnapshotIdentifier: undefined
  };
  if (output.DBSnapshotAttributes === "") {
    contents.DBSnapshotAttributes = [];
  }
  if (
    output["DBSnapshotAttributes"] !== undefined &&
    output["DBSnapshotAttributes"]["DBSnapshotAttribute"] !== undefined
  ) {
    contents.DBSnapshotAttributes = deserializeAws_queryDBSnapshotAttributeList(
      __getArrayIfSingleItem(
        output["DBSnapshotAttributes"]["DBSnapshotAttribute"]
      ),
      context
    );
  }
  if (output["DBSnapshotIdentifier"] !== undefined) {
    contents.DBSnapshotIdentifier =
      output["DBSnapshotIdentifier"]["#text"] !== undefined
        ? output["DBSnapshotIdentifier"]["#text"]
        : output["DBSnapshotIdentifier"];
  }
  return contents;
};

const deserializeAws_queryDBSnapshotList = (
  output: any,
  context: __SerdeContext
): DBSnapshot[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBSnapshot(entry, context));
  });
  return contents;
};

const deserializeAws_queryDBSnapshotMessage = (
  output: any,
  context: __SerdeContext
): DBSnapshotMessage => {
  let contents: any = {
    __type: "DBSnapshotMessage",
    DBSnapshots: undefined,
    Marker: undefined
  };
  if (output.DBSnapshots === "") {
    contents.DBSnapshots = [];
  }
  if (
    output["DBSnapshots"] !== undefined &&
    output["DBSnapshots"]["DBSnapshot"] !== undefined
  ) {
    contents.DBSnapshots = deserializeAws_queryDBSnapshotList(
      __getArrayIfSingleItem(output["DBSnapshots"]["DBSnapshot"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBSubnetGroup = (
  output: any,
  context: __SerdeContext
): DBSubnetGroup => {
  let contents: any = {
    __type: "DBSubnetGroup",
    DBSubnetGroupArn: undefined,
    DBSubnetGroupDescription: undefined,
    DBSubnetGroupName: undefined,
    SubnetGroupStatus: undefined,
    Subnets: undefined,
    VpcId: undefined
  };
  if (output["DBSubnetGroupArn"] !== undefined) {
    contents.DBSubnetGroupArn =
      output["DBSubnetGroupArn"]["#text"] !== undefined
        ? output["DBSubnetGroupArn"]["#text"]
        : output["DBSubnetGroupArn"];
  }
  if (output["DBSubnetGroupDescription"] !== undefined) {
    contents.DBSubnetGroupDescription =
      output["DBSubnetGroupDescription"]["#text"] !== undefined
        ? output["DBSubnetGroupDescription"]["#text"]
        : output["DBSubnetGroupDescription"];
  }
  if (output["DBSubnetGroupName"] !== undefined) {
    contents.DBSubnetGroupName =
      output["DBSubnetGroupName"]["#text"] !== undefined
        ? output["DBSubnetGroupName"]["#text"]
        : output["DBSubnetGroupName"];
  }
  if (output["SubnetGroupStatus"] !== undefined) {
    contents.SubnetGroupStatus =
      output["SubnetGroupStatus"]["#text"] !== undefined
        ? output["SubnetGroupStatus"]["#text"]
        : output["SubnetGroupStatus"];
  }
  if (output.Subnets === "") {
    contents.Subnets = [];
  }
  if (
    output["Subnets"] !== undefined &&
    output["Subnets"]["Subnet"] !== undefined
  ) {
    contents.Subnets = deserializeAws_querySubnetList(
      __getArrayIfSingleItem(output["Subnets"]["Subnet"]),
      context
    );
  }
  if (output["VpcId"] !== undefined) {
    contents.VpcId =
      output["VpcId"]["#text"] !== undefined
        ? output["VpcId"]["#text"]
        : output["VpcId"];
  }
  return contents;
};

const deserializeAws_queryDBSubnetGroupMessage = (
  output: any,
  context: __SerdeContext
): DBSubnetGroupMessage => {
  let contents: any = {
    __type: "DBSubnetGroupMessage",
    DBSubnetGroups: undefined,
    Marker: undefined
  };
  if (output.DBSubnetGroups === "") {
    contents.DBSubnetGroups = [];
  }
  if (
    output["DBSubnetGroups"] !== undefined &&
    output["DBSubnetGroups"]["DBSubnetGroup"] !== undefined
  ) {
    contents.DBSubnetGroups = deserializeAws_queryDBSubnetGroups(
      __getArrayIfSingleItem(output["DBSubnetGroups"]["DBSubnetGroup"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDBSubnetGroups = (
  output: any,
  context: __SerdeContext
): DBSubnetGroup[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBSubnetGroup(entry, context));
  });
  return contents;
};

const deserializeAws_queryDeleteCustomAvailabilityZoneResult = (
  output: any,
  context: __SerdeContext
): DeleteCustomAvailabilityZoneResult => {
  let contents: any = {
    __type: "DeleteCustomAvailabilityZoneResult",
    CustomAvailabilityZone: undefined
  };
  if (output["CustomAvailabilityZone"] !== undefined) {
    contents.CustomAvailabilityZone = deserializeAws_queryCustomAvailabilityZone(
      output["CustomAvailabilityZone"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDeleteDBClusterResult = (
  output: any,
  context: __SerdeContext
): DeleteDBClusterResult => {
  let contents: any = {
    __type: "DeleteDBClusterResult",
    DBCluster: undefined
  };
  if (output["DBCluster"] !== undefined) {
    contents.DBCluster = deserializeAws_queryDBCluster(
      output["DBCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDeleteDBClusterSnapshotResult = (
  output: any,
  context: __SerdeContext
): DeleteDBClusterSnapshotResult => {
  let contents: any = {
    __type: "DeleteDBClusterSnapshotResult",
    DBClusterSnapshot: undefined
  };
  if (output["DBClusterSnapshot"] !== undefined) {
    contents.DBClusterSnapshot = deserializeAws_queryDBClusterSnapshot(
      output["DBClusterSnapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDeleteDBInstanceAutomatedBackupResult = (
  output: any,
  context: __SerdeContext
): DeleteDBInstanceAutomatedBackupResult => {
  let contents: any = {
    __type: "DeleteDBInstanceAutomatedBackupResult",
    DBInstanceAutomatedBackup: undefined
  };
  if (output["DBInstanceAutomatedBackup"] !== undefined) {
    contents.DBInstanceAutomatedBackup = deserializeAws_queryDBInstanceAutomatedBackup(
      output["DBInstanceAutomatedBackup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDeleteDBInstanceResult = (
  output: any,
  context: __SerdeContext
): DeleteDBInstanceResult => {
  let contents: any = {
    __type: "DeleteDBInstanceResult",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDeleteDBProxyResponse = (
  output: any,
  context: __SerdeContext
): DeleteDBProxyResponse => {
  let contents: any = {
    __type: "DeleteDBProxyResponse",
    DBProxy: undefined
  };
  if (output["DBProxy"] !== undefined) {
    contents.DBProxy = deserializeAws_queryDBProxy(output["DBProxy"], context);
  }
  return contents;
};

const deserializeAws_queryDeleteDBSnapshotResult = (
  output: any,
  context: __SerdeContext
): DeleteDBSnapshotResult => {
  let contents: any = {
    __type: "DeleteDBSnapshotResult",
    DBSnapshot: undefined
  };
  if (output["DBSnapshot"] !== undefined) {
    contents.DBSnapshot = deserializeAws_queryDBSnapshot(
      output["DBSnapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDeleteEventSubscriptionResult = (
  output: any,
  context: __SerdeContext
): DeleteEventSubscriptionResult => {
  let contents: any = {
    __type: "DeleteEventSubscriptionResult",
    EventSubscription: undefined
  };
  if (output["EventSubscription"] !== undefined) {
    contents.EventSubscription = deserializeAws_queryEventSubscription(
      output["EventSubscription"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDeleteGlobalClusterResult = (
  output: any,
  context: __SerdeContext
): DeleteGlobalClusterResult => {
  let contents: any = {
    __type: "DeleteGlobalClusterResult",
    GlobalCluster: undefined
  };
  if (output["GlobalCluster"] !== undefined) {
    contents.GlobalCluster = deserializeAws_queryGlobalCluster(
      output["GlobalCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDeregisterDBProxyTargetsResponse = (
  output: any,
  context: __SerdeContext
): DeregisterDBProxyTargetsResponse => {
  let contents: any = {
    __type: "DeregisterDBProxyTargetsResponse"
  };
  return contents;
};

const deserializeAws_queryDescribeDBClusterSnapshotAttributesResult = (
  output: any,
  context: __SerdeContext
): DescribeDBClusterSnapshotAttributesResult => {
  let contents: any = {
    __type: "DescribeDBClusterSnapshotAttributesResult",
    DBClusterSnapshotAttributesResult: undefined
  };
  if (output["DBClusterSnapshotAttributesResult"] !== undefined) {
    contents.DBClusterSnapshotAttributesResult = deserializeAws_queryDBClusterSnapshotAttributesResult(
      output["DBClusterSnapshotAttributesResult"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDescribeDBLogFilesDetails = (
  output: any,
  context: __SerdeContext
): DescribeDBLogFilesDetails => {
  let contents: any = {
    __type: "DescribeDBLogFilesDetails",
    LastWritten: undefined,
    LogFileName: undefined,
    Size: undefined
  };
  if (output["LastWritten"] !== undefined) {
    contents.LastWritten = parseInt(
      output["LastWritten"]["#text"] !== undefined
        ? output["LastWritten"]["#text"]
        : output["LastWritten"]
    );
  }
  if (output["LogFileName"] !== undefined) {
    contents.LogFileName =
      output["LogFileName"]["#text"] !== undefined
        ? output["LogFileName"]["#text"]
        : output["LogFileName"];
  }
  if (output["Size"] !== undefined) {
    contents.Size = parseInt(
      output["Size"]["#text"] !== undefined
        ? output["Size"]["#text"]
        : output["Size"]
    );
  }
  return contents;
};

const deserializeAws_queryDescribeDBLogFilesList = (
  output: any,
  context: __SerdeContext
): DescribeDBLogFilesDetails[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryDescribeDBLogFilesDetails(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryDescribeDBLogFilesResponse = (
  output: any,
  context: __SerdeContext
): DescribeDBLogFilesResponse => {
  let contents: any = {
    __type: "DescribeDBLogFilesResponse",
    DescribeDBLogFiles: undefined,
    Marker: undefined
  };
  if (output.DescribeDBLogFiles === "") {
    contents.DescribeDBLogFiles = [];
  }
  if (
    output["DescribeDBLogFiles"] !== undefined &&
    output["DescribeDBLogFiles"]["DescribeDBLogFilesDetails"] !== undefined
  ) {
    contents.DescribeDBLogFiles = deserializeAws_queryDescribeDBLogFilesList(
      __getArrayIfSingleItem(
        output["DescribeDBLogFiles"]["DescribeDBLogFilesDetails"]
      ),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDescribeDBProxiesResponse = (
  output: any,
  context: __SerdeContext
): DescribeDBProxiesResponse => {
  let contents: any = {
    __type: "DescribeDBProxiesResponse",
    DBProxies: undefined,
    Marker: undefined
  };
  if (output.DBProxies === "") {
    contents.DBProxies = [];
  }
  if (
    output["DBProxies"] !== undefined &&
    output["DBProxies"]["member"] !== undefined
  ) {
    contents.DBProxies = deserializeAws_queryDBProxyList(
      __getArrayIfSingleItem(output["DBProxies"]["member"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryDescribeDBProxyTargetGroupsResponse = (
  output: any,
  context: __SerdeContext
): DescribeDBProxyTargetGroupsResponse => {
  let contents: any = {
    __type: "DescribeDBProxyTargetGroupsResponse",
    Marker: undefined,
    TargetGroups: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.TargetGroups === "") {
    contents.TargetGroups = [];
  }
  if (
    output["TargetGroups"] !== undefined &&
    output["TargetGroups"]["member"] !== undefined
  ) {
    contents.TargetGroups = deserializeAws_queryTargetGroupList(
      __getArrayIfSingleItem(output["TargetGroups"]["member"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryDescribeDBProxyTargetsResponse = (
  output: any,
  context: __SerdeContext
): DescribeDBProxyTargetsResponse => {
  let contents: any = {
    __type: "DescribeDBProxyTargetsResponse",
    Marker: undefined,
    Targets: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.Targets === "") {
    contents.Targets = [];
  }
  if (
    output["Targets"] !== undefined &&
    output["Targets"]["member"] !== undefined
  ) {
    contents.Targets = deserializeAws_queryTargetList(
      __getArrayIfSingleItem(output["Targets"]["member"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryDescribeDBSnapshotAttributesResult = (
  output: any,
  context: __SerdeContext
): DescribeDBSnapshotAttributesResult => {
  let contents: any = {
    __type: "DescribeDBSnapshotAttributesResult",
    DBSnapshotAttributesResult: undefined
  };
  if (output["DBSnapshotAttributesResult"] !== undefined) {
    contents.DBSnapshotAttributesResult = deserializeAws_queryDBSnapshotAttributesResult(
      output["DBSnapshotAttributesResult"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDescribeEngineDefaultClusterParametersResult = (
  output: any,
  context: __SerdeContext
): DescribeEngineDefaultClusterParametersResult => {
  let contents: any = {
    __type: "DescribeEngineDefaultClusterParametersResult",
    EngineDefaults: undefined
  };
  if (output["EngineDefaults"] !== undefined) {
    contents.EngineDefaults = deserializeAws_queryEngineDefaults(
      output["EngineDefaults"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDescribeEngineDefaultParametersResult = (
  output: any,
  context: __SerdeContext
): DescribeEngineDefaultParametersResult => {
  let contents: any = {
    __type: "DescribeEngineDefaultParametersResult",
    EngineDefaults: undefined
  };
  if (output["EngineDefaults"] !== undefined) {
    contents.EngineDefaults = deserializeAws_queryEngineDefaults(
      output["EngineDefaults"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDescribeValidDBInstanceModificationsResult = (
  output: any,
  context: __SerdeContext
): DescribeValidDBInstanceModificationsResult => {
  let contents: any = {
    __type: "DescribeValidDBInstanceModificationsResult",
    ValidDBInstanceModificationsMessage: undefined
  };
  if (output["ValidDBInstanceModificationsMessage"] !== undefined) {
    contents.ValidDBInstanceModificationsMessage = deserializeAws_queryValidDBInstanceModificationsMessage(
      output["ValidDBInstanceModificationsMessage"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryDomainMembership = (
  output: any,
  context: __SerdeContext
): DomainMembership => {
  let contents: any = {
    __type: "DomainMembership",
    Domain: undefined,
    FQDN: undefined,
    IAMRoleName: undefined,
    Status: undefined
  };
  if (output["Domain"] !== undefined) {
    contents.Domain =
      output["Domain"]["#text"] !== undefined
        ? output["Domain"]["#text"]
        : output["Domain"];
  }
  if (output["FQDN"] !== undefined) {
    contents.FQDN =
      output["FQDN"]["#text"] !== undefined
        ? output["FQDN"]["#text"]
        : output["FQDN"];
  }
  if (output["IAMRoleName"] !== undefined) {
    contents.IAMRoleName =
      output["IAMRoleName"]["#text"] !== undefined
        ? output["IAMRoleName"]["#text"]
        : output["IAMRoleName"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryDomainMembershipList = (
  output: any,
  context: __SerdeContext
): DomainMembership[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDomainMembership(entry, context));
  });
  return contents;
};

const deserializeAws_queryDoubleRange = (
  output: any,
  context: __SerdeContext
): DoubleRange => {
  let contents: any = {
    __type: "DoubleRange",
    From: undefined,
    To: undefined
  };
  if (output["From"] !== undefined) {
    contents.From = parseFloat(
      output["From"]["#text"] !== undefined
        ? output["From"]["#text"]
        : output["From"]
    );
  }
  if (output["To"] !== undefined) {
    contents.To = parseFloat(
      output["To"]["#text"] !== undefined ? output["To"]["#text"] : output["To"]
    );
  }
  return contents;
};

const deserializeAws_queryDoubleRangeList = (
  output: any,
  context: __SerdeContext
): DoubleRange[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDoubleRange(entry, context));
  });
  return contents;
};

const deserializeAws_queryDownloadDBLogFilePortionDetails = (
  output: any,
  context: __SerdeContext
): DownloadDBLogFilePortionDetails => {
  let contents: any = {
    __type: "DownloadDBLogFilePortionDetails",
    AdditionalDataPending: undefined,
    LogFileData: undefined,
    Marker: undefined
  };
  if (output["AdditionalDataPending"] !== undefined) {
    contents.AdditionalDataPending =
      (output["AdditionalDataPending"]["#text"] !== undefined
        ? output["AdditionalDataPending"]["#text"]
        : output["AdditionalDataPending"]) == "true";
  }
  if (output["LogFileData"] !== undefined) {
    contents.LogFileData =
      output["LogFileData"]["#text"] !== undefined
        ? output["LogFileData"]["#text"]
        : output["LogFileData"];
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryEC2SecurityGroup = (
  output: any,
  context: __SerdeContext
): EC2SecurityGroup => {
  let contents: any = {
    __type: "EC2SecurityGroup",
    EC2SecurityGroupId: undefined,
    EC2SecurityGroupName: undefined,
    EC2SecurityGroupOwnerId: undefined,
    Status: undefined
  };
  if (output["EC2SecurityGroupId"] !== undefined) {
    contents.EC2SecurityGroupId =
      output["EC2SecurityGroupId"]["#text"] !== undefined
        ? output["EC2SecurityGroupId"]["#text"]
        : output["EC2SecurityGroupId"];
  }
  if (output["EC2SecurityGroupName"] !== undefined) {
    contents.EC2SecurityGroupName =
      output["EC2SecurityGroupName"]["#text"] !== undefined
        ? output["EC2SecurityGroupName"]["#text"]
        : output["EC2SecurityGroupName"];
  }
  if (output["EC2SecurityGroupOwnerId"] !== undefined) {
    contents.EC2SecurityGroupOwnerId =
      output["EC2SecurityGroupOwnerId"]["#text"] !== undefined
        ? output["EC2SecurityGroupOwnerId"]["#text"]
        : output["EC2SecurityGroupOwnerId"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryEC2SecurityGroupList = (
  output: any,
  context: __SerdeContext
): EC2SecurityGroup[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryEC2SecurityGroup(entry, context));
  });
  return contents;
};

const deserializeAws_queryEndpoint = (
  output: any,
  context: __SerdeContext
): Endpoint => {
  let contents: any = {
    __type: "Endpoint",
    Address: undefined,
    HostedZoneId: undefined,
    Port: undefined
  };
  if (output["Address"] !== undefined) {
    contents.Address =
      output["Address"]["#text"] !== undefined
        ? output["Address"]["#text"]
        : output["Address"];
  }
  if (output["HostedZoneId"] !== undefined) {
    contents.HostedZoneId =
      output["HostedZoneId"]["#text"] !== undefined
        ? output["HostedZoneId"]["#text"]
        : output["HostedZoneId"];
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(
      output["Port"]["#text"] !== undefined
        ? output["Port"]["#text"]
        : output["Port"]
    );
  }
  return contents;
};

const deserializeAws_queryEngineDefaults = (
  output: any,
  context: __SerdeContext
): EngineDefaults => {
  let contents: any = {
    __type: "EngineDefaults",
    DBParameterGroupFamily: undefined,
    Marker: undefined,
    Parameters: undefined
  };
  if (output["DBParameterGroupFamily"] !== undefined) {
    contents.DBParameterGroupFamily =
      output["DBParameterGroupFamily"]["#text"] !== undefined
        ? output["DBParameterGroupFamily"]["#text"]
        : output["DBParameterGroupFamily"];
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.Parameters === "") {
    contents.Parameters = [];
  }
  if (
    output["Parameters"] !== undefined &&
    output["Parameters"]["Parameter"] !== undefined
  ) {
    contents.Parameters = deserializeAws_queryParametersList(
      __getArrayIfSingleItem(output["Parameters"]["Parameter"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryEngineModeList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryEvent = (
  output: any,
  context: __SerdeContext
): Event => {
  let contents: any = {
    __type: "Event",
    Date: undefined,
    EventCategories: undefined,
    Message: undefined,
    SourceArn: undefined,
    SourceIdentifier: undefined,
    SourceType: undefined
  };
  if (output["Date"] !== undefined) {
    contents.Date = new Date(output["Date"]);
  }
  if (output.EventCategories === "") {
    contents.EventCategories = [];
  }
  if (
    output["EventCategories"] !== undefined &&
    output["EventCategories"]["EventCategory"] !== undefined
  ) {
    contents.EventCategories = deserializeAws_queryEventCategoriesList(
      __getArrayIfSingleItem(output["EventCategories"]["EventCategory"]),
      context
    );
  }
  if (output["Message"] !== undefined) {
    contents.Message =
      output["Message"]["#text"] !== undefined
        ? output["Message"]["#text"]
        : output["Message"];
  }
  if (output["SourceArn"] !== undefined) {
    contents.SourceArn =
      output["SourceArn"]["#text"] !== undefined
        ? output["SourceArn"]["#text"]
        : output["SourceArn"];
  }
  if (output["SourceIdentifier"] !== undefined) {
    contents.SourceIdentifier =
      output["SourceIdentifier"]["#text"] !== undefined
        ? output["SourceIdentifier"]["#text"]
        : output["SourceIdentifier"];
  }
  if (output["SourceType"] !== undefined) {
    contents.SourceType =
      output["SourceType"]["#text"] !== undefined
        ? output["SourceType"]["#text"]
        : output["SourceType"];
  }
  return contents;
};

const deserializeAws_queryEventCategoriesList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryEventCategoriesMap = (
  output: any,
  context: __SerdeContext
): EventCategoriesMap => {
  let contents: any = {
    __type: "EventCategoriesMap",
    EventCategories: undefined,
    SourceType: undefined
  };
  if (output.EventCategories === "") {
    contents.EventCategories = [];
  }
  if (
    output["EventCategories"] !== undefined &&
    output["EventCategories"]["EventCategory"] !== undefined
  ) {
    contents.EventCategories = deserializeAws_queryEventCategoriesList(
      __getArrayIfSingleItem(output["EventCategories"]["EventCategory"]),
      context
    );
  }
  if (output["SourceType"] !== undefined) {
    contents.SourceType =
      output["SourceType"]["#text"] !== undefined
        ? output["SourceType"]["#text"]
        : output["SourceType"];
  }
  return contents;
};

const deserializeAws_queryEventCategoriesMapList = (
  output: any,
  context: __SerdeContext
): EventCategoriesMap[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryEventCategoriesMap(entry, context));
  });
  return contents;
};

const deserializeAws_queryEventCategoriesMessage = (
  output: any,
  context: __SerdeContext
): EventCategoriesMessage => {
  let contents: any = {
    __type: "EventCategoriesMessage",
    EventCategoriesMapList: undefined
  };
  if (output.EventCategoriesMapList === "") {
    contents.EventCategoriesMapList = [];
  }
  if (
    output["EventCategoriesMapList"] !== undefined &&
    output["EventCategoriesMapList"]["EventCategoriesMap"] !== undefined
  ) {
    contents.EventCategoriesMapList = deserializeAws_queryEventCategoriesMapList(
      __getArrayIfSingleItem(
        output["EventCategoriesMapList"]["EventCategoriesMap"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_queryEventList = (
  output: any,
  context: __SerdeContext
): Event[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryEvent(entry, context));
  });
  return contents;
};

const deserializeAws_queryEventSubscription = (
  output: any,
  context: __SerdeContext
): EventSubscription => {
  let contents: any = {
    __type: "EventSubscription",
    CustSubscriptionId: undefined,
    CustomerAwsId: undefined,
    Enabled: undefined,
    EventCategoriesList: undefined,
    EventSubscriptionArn: undefined,
    SnsTopicArn: undefined,
    SourceIdsList: undefined,
    SourceType: undefined,
    Status: undefined,
    SubscriptionCreationTime: undefined
  };
  if (output["CustSubscriptionId"] !== undefined) {
    contents.CustSubscriptionId =
      output["CustSubscriptionId"]["#text"] !== undefined
        ? output["CustSubscriptionId"]["#text"]
        : output["CustSubscriptionId"];
  }
  if (output["CustomerAwsId"] !== undefined) {
    contents.CustomerAwsId =
      output["CustomerAwsId"]["#text"] !== undefined
        ? output["CustomerAwsId"]["#text"]
        : output["CustomerAwsId"];
  }
  if (output["Enabled"] !== undefined) {
    contents.Enabled =
      (output["Enabled"]["#text"] !== undefined
        ? output["Enabled"]["#text"]
        : output["Enabled"]) == "true";
  }
  if (output.EventCategoriesList === "") {
    contents.EventCategoriesList = [];
  }
  if (
    output["EventCategoriesList"] !== undefined &&
    output["EventCategoriesList"]["EventCategory"] !== undefined
  ) {
    contents.EventCategoriesList = deserializeAws_queryEventCategoriesList(
      __getArrayIfSingleItem(output["EventCategoriesList"]["EventCategory"]),
      context
    );
  }
  if (output["EventSubscriptionArn"] !== undefined) {
    contents.EventSubscriptionArn =
      output["EventSubscriptionArn"]["#text"] !== undefined
        ? output["EventSubscriptionArn"]["#text"]
        : output["EventSubscriptionArn"];
  }
  if (output["SnsTopicArn"] !== undefined) {
    contents.SnsTopicArn =
      output["SnsTopicArn"]["#text"] !== undefined
        ? output["SnsTopicArn"]["#text"]
        : output["SnsTopicArn"];
  }
  if (output.SourceIdsList === "") {
    contents.SourceIdsList = [];
  }
  if (
    output["SourceIdsList"] !== undefined &&
    output["SourceIdsList"]["SourceId"] !== undefined
  ) {
    contents.SourceIdsList = deserializeAws_querySourceIdsList(
      __getArrayIfSingleItem(output["SourceIdsList"]["SourceId"]),
      context
    );
  }
  if (output["SourceType"] !== undefined) {
    contents.SourceType =
      output["SourceType"]["#text"] !== undefined
        ? output["SourceType"]["#text"]
        : output["SourceType"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output["SubscriptionCreationTime"] !== undefined) {
    contents.SubscriptionCreationTime =
      output["SubscriptionCreationTime"]["#text"] !== undefined
        ? output["SubscriptionCreationTime"]["#text"]
        : output["SubscriptionCreationTime"];
  }
  return contents;
};

const deserializeAws_queryEventSubscriptionsList = (
  output: any,
  context: __SerdeContext
): EventSubscription[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryEventSubscription(entry, context));
  });
  return contents;
};

const deserializeAws_queryEventSubscriptionsMessage = (
  output: any,
  context: __SerdeContext
): EventSubscriptionsMessage => {
  let contents: any = {
    __type: "EventSubscriptionsMessage",
    EventSubscriptionsList: undefined,
    Marker: undefined
  };
  if (output.EventSubscriptionsList === "") {
    contents.EventSubscriptionsList = [];
  }
  if (
    output["EventSubscriptionsList"] !== undefined &&
    output["EventSubscriptionsList"]["EventSubscription"] !== undefined
  ) {
    contents.EventSubscriptionsList = deserializeAws_queryEventSubscriptionsList(
      __getArrayIfSingleItem(
        output["EventSubscriptionsList"]["EventSubscription"]
      ),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryEventsMessage = (
  output: any,
  context: __SerdeContext
): EventsMessage => {
  let contents: any = {
    __type: "EventsMessage",
    Events: undefined,
    Marker: undefined
  };
  if (output.Events === "") {
    contents.Events = [];
  }
  if (
    output["Events"] !== undefined &&
    output["Events"]["Event"] !== undefined
  ) {
    contents.Events = deserializeAws_queryEventList(
      __getArrayIfSingleItem(output["Events"]["Event"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryFailoverDBClusterResult = (
  output: any,
  context: __SerdeContext
): FailoverDBClusterResult => {
  let contents: any = {
    __type: "FailoverDBClusterResult",
    DBCluster: undefined
  };
  if (output["DBCluster"] !== undefined) {
    contents.DBCluster = deserializeAws_queryDBCluster(
      output["DBCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryFeatureNameList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryGlobalCluster = (
  output: any,
  context: __SerdeContext
): GlobalCluster => {
  let contents: any = {
    __type: "GlobalCluster",
    DatabaseName: undefined,
    DeletionProtection: undefined,
    Engine: undefined,
    EngineVersion: undefined,
    GlobalClusterArn: undefined,
    GlobalClusterIdentifier: undefined,
    GlobalClusterMembers: undefined,
    GlobalClusterResourceId: undefined,
    Status: undefined,
    StorageEncrypted: undefined
  };
  if (output["DatabaseName"] !== undefined) {
    contents.DatabaseName =
      output["DatabaseName"]["#text"] !== undefined
        ? output["DatabaseName"]["#text"]
        : output["DatabaseName"];
  }
  if (output["DeletionProtection"] !== undefined) {
    contents.DeletionProtection =
      (output["DeletionProtection"]["#text"] !== undefined
        ? output["DeletionProtection"]["#text"]
        : output["DeletionProtection"]) == "true";
  }
  if (output["Engine"] !== undefined) {
    contents.Engine =
      output["Engine"]["#text"] !== undefined
        ? output["Engine"]["#text"]
        : output["Engine"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output["GlobalClusterArn"] !== undefined) {
    contents.GlobalClusterArn =
      output["GlobalClusterArn"]["#text"] !== undefined
        ? output["GlobalClusterArn"]["#text"]
        : output["GlobalClusterArn"];
  }
  if (output["GlobalClusterIdentifier"] !== undefined) {
    contents.GlobalClusterIdentifier =
      output["GlobalClusterIdentifier"]["#text"] !== undefined
        ? output["GlobalClusterIdentifier"]["#text"]
        : output["GlobalClusterIdentifier"];
  }
  if (output.GlobalClusterMembers === "") {
    contents.GlobalClusterMembers = [];
  }
  if (
    output["GlobalClusterMembers"] !== undefined &&
    output["GlobalClusterMembers"]["GlobalClusterMember"] !== undefined
  ) {
    contents.GlobalClusterMembers = deserializeAws_queryGlobalClusterMemberList(
      __getArrayIfSingleItem(
        output["GlobalClusterMembers"]["GlobalClusterMember"]
      ),
      context
    );
  }
  if (output["GlobalClusterResourceId"] !== undefined) {
    contents.GlobalClusterResourceId =
      output["GlobalClusterResourceId"]["#text"] !== undefined
        ? output["GlobalClusterResourceId"]["#text"]
        : output["GlobalClusterResourceId"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output["StorageEncrypted"] !== undefined) {
    contents.StorageEncrypted =
      (output["StorageEncrypted"]["#text"] !== undefined
        ? output["StorageEncrypted"]["#text"]
        : output["StorageEncrypted"]) == "true";
  }
  return contents;
};

const deserializeAws_queryGlobalClusterList = (
  output: any,
  context: __SerdeContext
): GlobalCluster[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryGlobalCluster(entry, context));
  });
  return contents;
};

const deserializeAws_queryGlobalClusterMember = (
  output: any,
  context: __SerdeContext
): GlobalClusterMember => {
  let contents: any = {
    __type: "GlobalClusterMember",
    DBClusterArn: undefined,
    IsWriter: undefined,
    Readers: undefined
  };
  if (output["DBClusterArn"] !== undefined) {
    contents.DBClusterArn =
      output["DBClusterArn"]["#text"] !== undefined
        ? output["DBClusterArn"]["#text"]
        : output["DBClusterArn"];
  }
  if (output["IsWriter"] !== undefined) {
    contents.IsWriter =
      (output["IsWriter"]["#text"] !== undefined
        ? output["IsWriter"]["#text"]
        : output["IsWriter"]) == "true";
  }
  if (output.Readers === "") {
    contents.Readers = [];
  }
  if (
    output["Readers"] !== undefined &&
    output["Readers"]["member"] !== undefined
  ) {
    contents.Readers = deserializeAws_queryReadersArnList(
      __getArrayIfSingleItem(output["Readers"]["member"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryGlobalClusterMemberList = (
  output: any,
  context: __SerdeContext
): GlobalClusterMember[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryGlobalClusterMember(entry, context));
  });
  return contents;
};

const deserializeAws_queryGlobalClustersMessage = (
  output: any,
  context: __SerdeContext
): GlobalClustersMessage => {
  let contents: any = {
    __type: "GlobalClustersMessage",
    GlobalClusters: undefined,
    Marker: undefined
  };
  if (output.GlobalClusters === "") {
    contents.GlobalClusters = [];
  }
  if (
    output["GlobalClusters"] !== undefined &&
    output["GlobalClusters"]["GlobalClusterMember"] !== undefined
  ) {
    contents.GlobalClusters = deserializeAws_queryGlobalClusterList(
      __getArrayIfSingleItem(output["GlobalClusters"]["GlobalClusterMember"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryIPRange = (
  output: any,
  context: __SerdeContext
): IPRange => {
  let contents: any = {
    __type: "IPRange",
    CIDRIP: undefined,
    Status: undefined
  };
  if (output["CIDRIP"] !== undefined) {
    contents.CIDRIP =
      output["CIDRIP"]["#text"] !== undefined
        ? output["CIDRIP"]["#text"]
        : output["CIDRIP"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryIPRangeList = (
  output: any,
  context: __SerdeContext
): IPRange[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryIPRange(entry, context));
  });
  return contents;
};

const deserializeAws_queryInstallationMedia = (
  output: any,
  context: __SerdeContext
): InstallationMedia => {
  let contents: any = {
    __type: "InstallationMedia",
    CustomAvailabilityZoneId: undefined,
    Engine: undefined,
    EngineInstallationMediaPath: undefined,
    EngineVersion: undefined,
    FailureCause: undefined,
    InstallationMediaId: undefined,
    OSInstallationMediaPath: undefined,
    Status: undefined
  };
  if (output["CustomAvailabilityZoneId"] !== undefined) {
    contents.CustomAvailabilityZoneId =
      output["CustomAvailabilityZoneId"]["#text"] !== undefined
        ? output["CustomAvailabilityZoneId"]["#text"]
        : output["CustomAvailabilityZoneId"];
  }
  if (output["Engine"] !== undefined) {
    contents.Engine =
      output["Engine"]["#text"] !== undefined
        ? output["Engine"]["#text"]
        : output["Engine"];
  }
  if (output["EngineInstallationMediaPath"] !== undefined) {
    contents.EngineInstallationMediaPath =
      output["EngineInstallationMediaPath"]["#text"] !== undefined
        ? output["EngineInstallationMediaPath"]["#text"]
        : output["EngineInstallationMediaPath"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output["FailureCause"] !== undefined) {
    contents.FailureCause = deserializeAws_queryInstallationMediaFailureCause(
      output["FailureCause"],
      context
    );
  }
  if (output["InstallationMediaId"] !== undefined) {
    contents.InstallationMediaId =
      output["InstallationMediaId"]["#text"] !== undefined
        ? output["InstallationMediaId"]["#text"]
        : output["InstallationMediaId"];
  }
  if (output["OSInstallationMediaPath"] !== undefined) {
    contents.OSInstallationMediaPath =
      output["OSInstallationMediaPath"]["#text"] !== undefined
        ? output["OSInstallationMediaPath"]["#text"]
        : output["OSInstallationMediaPath"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryInstallationMediaFailureCause = (
  output: any,
  context: __SerdeContext
): InstallationMediaFailureCause => {
  let contents: any = {
    __type: "InstallationMediaFailureCause",
    Message: undefined
  };
  if (output["Message"] !== undefined) {
    contents.Message =
      output["Message"]["#text"] !== undefined
        ? output["Message"]["#text"]
        : output["Message"];
  }
  return contents;
};

const deserializeAws_queryInstallationMediaList = (
  output: any,
  context: __SerdeContext
): InstallationMedia[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryInstallationMedia(entry, context));
  });
  return contents;
};

const deserializeAws_queryInstallationMediaMessage = (
  output: any,
  context: __SerdeContext
): InstallationMediaMessage => {
  let contents: any = {
    __type: "InstallationMediaMessage",
    InstallationMedia: undefined,
    Marker: undefined
  };
  if (output.InstallationMedia === "") {
    contents.InstallationMedia = [];
  }
  if (
    output["InstallationMedia"] !== undefined &&
    output["InstallationMedia"]["InstallationMedia"] !== undefined
  ) {
    contents.InstallationMedia = deserializeAws_queryInstallationMediaList(
      __getArrayIfSingleItem(output["InstallationMedia"]["InstallationMedia"]),
      context
    );
  }
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  return contents;
};

const deserializeAws_queryLogTypeList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryMinimumEngineVersionPerAllowedValue = (
  output: any,
  context: __SerdeContext
): MinimumEngineVersionPerAllowedValue => {
  let contents: any = {
    __type: "MinimumEngineVersionPerAllowedValue",
    AllowedValue: undefined,
    MinimumEngineVersion: undefined
  };
  if (output["AllowedValue"] !== undefined) {
    contents.AllowedValue =
      output["AllowedValue"]["#text"] !== undefined
        ? output["AllowedValue"]["#text"]
        : output["AllowedValue"];
  }
  if (output["MinimumEngineVersion"] !== undefined) {
    contents.MinimumEngineVersion =
      output["MinimumEngineVersion"]["#text"] !== undefined
        ? output["MinimumEngineVersion"]["#text"]
        : output["MinimumEngineVersion"];
  }
  return contents;
};

const deserializeAws_queryMinimumEngineVersionPerAllowedValueList = (
  output: any,
  context: __SerdeContext
): MinimumEngineVersionPerAllowedValue[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryMinimumEngineVersionPerAllowedValue(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryModifyCertificatesResult = (
  output: any,
  context: __SerdeContext
): ModifyCertificatesResult => {
  let contents: any = {
    __type: "ModifyCertificatesResult",
    Certificate: undefined
  };
  if (output["Certificate"] !== undefined) {
    contents.Certificate = deserializeAws_queryCertificate(
      output["Certificate"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyDBClusterResult = (
  output: any,
  context: __SerdeContext
): ModifyDBClusterResult => {
  let contents: any = {
    __type: "ModifyDBClusterResult",
    DBCluster: undefined
  };
  if (output["DBCluster"] !== undefined) {
    contents.DBCluster = deserializeAws_queryDBCluster(
      output["DBCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyDBClusterSnapshotAttributeResult = (
  output: any,
  context: __SerdeContext
): ModifyDBClusterSnapshotAttributeResult => {
  let contents: any = {
    __type: "ModifyDBClusterSnapshotAttributeResult",
    DBClusterSnapshotAttributesResult: undefined
  };
  if (output["DBClusterSnapshotAttributesResult"] !== undefined) {
    contents.DBClusterSnapshotAttributesResult = deserializeAws_queryDBClusterSnapshotAttributesResult(
      output["DBClusterSnapshotAttributesResult"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyDBInstanceResult = (
  output: any,
  context: __SerdeContext
): ModifyDBInstanceResult => {
  let contents: any = {
    __type: "ModifyDBInstanceResult",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyDBProxyResponse = (
  output: any,
  context: __SerdeContext
): ModifyDBProxyResponse => {
  let contents: any = {
    __type: "ModifyDBProxyResponse",
    DBProxy: undefined
  };
  if (output["DBProxy"] !== undefined) {
    contents.DBProxy = deserializeAws_queryDBProxy(output["DBProxy"], context);
  }
  return contents;
};

const deserializeAws_queryModifyDBProxyTargetGroupResponse = (
  output: any,
  context: __SerdeContext
): ModifyDBProxyTargetGroupResponse => {
  let contents: any = {
    __type: "ModifyDBProxyTargetGroupResponse",
    DBProxyTargetGroup: undefined
  };
  if (output["DBProxyTargetGroup"] !== undefined) {
    contents.DBProxyTargetGroup = deserializeAws_queryDBProxyTargetGroup(
      output["DBProxyTargetGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyDBSnapshotAttributeResult = (
  output: any,
  context: __SerdeContext
): ModifyDBSnapshotAttributeResult => {
  let contents: any = {
    __type: "ModifyDBSnapshotAttributeResult",
    DBSnapshotAttributesResult: undefined
  };
  if (output["DBSnapshotAttributesResult"] !== undefined) {
    contents.DBSnapshotAttributesResult = deserializeAws_queryDBSnapshotAttributesResult(
      output["DBSnapshotAttributesResult"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyDBSnapshotResult = (
  output: any,
  context: __SerdeContext
): ModifyDBSnapshotResult => {
  let contents: any = {
    __type: "ModifyDBSnapshotResult",
    DBSnapshot: undefined
  };
  if (output["DBSnapshot"] !== undefined) {
    contents.DBSnapshot = deserializeAws_queryDBSnapshot(
      output["DBSnapshot"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyDBSubnetGroupResult = (
  output: any,
  context: __SerdeContext
): ModifyDBSubnetGroupResult => {
  let contents: any = {
    __type: "ModifyDBSubnetGroupResult",
    DBSubnetGroup: undefined
  };
  if (output["DBSubnetGroup"] !== undefined) {
    contents.DBSubnetGroup = deserializeAws_queryDBSubnetGroup(
      output["DBSubnetGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyEventSubscriptionResult = (
  output: any,
  context: __SerdeContext
): ModifyEventSubscriptionResult => {
  let contents: any = {
    __type: "ModifyEventSubscriptionResult",
    EventSubscription: undefined
  };
  if (output["EventSubscription"] !== undefined) {
    contents.EventSubscription = deserializeAws_queryEventSubscription(
      output["EventSubscription"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyGlobalClusterResult = (
  output: any,
  context: __SerdeContext
): ModifyGlobalClusterResult => {
  let contents: any = {
    __type: "ModifyGlobalClusterResult",
    GlobalCluster: undefined
  };
  if (output["GlobalCluster"] !== undefined) {
    contents.GlobalCluster = deserializeAws_queryGlobalCluster(
      output["GlobalCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryModifyOptionGroupResult = (
  output: any,
  context: __SerdeContext
): ModifyOptionGroupResult => {
  let contents: any = {
    __type: "ModifyOptionGroupResult",
    OptionGroup: undefined
  };
  if (output["OptionGroup"] !== undefined) {
    contents.OptionGroup = deserializeAws_queryOptionGroup(
      output["OptionGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryOption = (
  output: any,
  context: __SerdeContext
): Option => {
  let contents: any = {
    __type: "Option",
    DBSecurityGroupMemberships: undefined,
    OptionDescription: undefined,
    OptionName: undefined,
    OptionSettings: undefined,
    OptionVersion: undefined,
    Permanent: undefined,
    Persistent: undefined,
    Port: undefined,
    VpcSecurityGroupMemberships: undefined
  };
  if (output.DBSecurityGroupMemberships === "") {
    contents.DBSecurityGroupMemberships = [];
  }
  if (
    output["DBSecurityGroupMemberships"] !== undefined &&
    output["DBSecurityGroupMemberships"]["DBSecurityGroup"] !== undefined
  ) {
    contents.DBSecurityGroupMemberships = deserializeAws_queryDBSecurityGroupMembershipList(
      __getArrayIfSingleItem(
        output["DBSecurityGroupMemberships"]["DBSecurityGroup"]
      ),
      context
    );
  }
  if (output["OptionDescription"] !== undefined) {
    contents.OptionDescription =
      output["OptionDescription"]["#text"] !== undefined
        ? output["OptionDescription"]["#text"]
        : output["OptionDescription"];
  }
  if (output["OptionName"] !== undefined) {
    contents.OptionName =
      output["OptionName"]["#text"] !== undefined
        ? output["OptionName"]["#text"]
        : output["OptionName"];
  }
  if (output.OptionSettings === "") {
    contents.OptionSettings = [];
  }
  if (
    output["OptionSettings"] !== undefined &&
    output["OptionSettings"]["OptionSetting"] !== undefined
  ) {
    contents.OptionSettings = deserializeAws_queryOptionSettingConfigurationList(
      __getArrayIfSingleItem(output["OptionSettings"]["OptionSetting"]),
      context
    );
  }
  if (output["OptionVersion"] !== undefined) {
    contents.OptionVersion =
      output["OptionVersion"]["#text"] !== undefined
        ? output["OptionVersion"]["#text"]
        : output["OptionVersion"];
  }
  if (output["Permanent"] !== undefined) {
    contents.Permanent =
      (output["Permanent"]["#text"] !== undefined
        ? output["Permanent"]["#text"]
        : output["Permanent"]) == "true";
  }
  if (output["Persistent"] !== undefined) {
    contents.Persistent =
      (output["Persistent"]["#text"] !== undefined
        ? output["Persistent"]["#text"]
        : output["Persistent"]) == "true";
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(
      output["Port"]["#text"] !== undefined
        ? output["Port"]["#text"]
        : output["Port"]
    );
  }
  if (output.VpcSecurityGroupMemberships === "") {
    contents.VpcSecurityGroupMemberships = [];
  }
  if (
    output["VpcSecurityGroupMemberships"] !== undefined &&
    output["VpcSecurityGroupMemberships"]["VpcSecurityGroupMembership"] !==
      undefined
  ) {
    contents.VpcSecurityGroupMemberships = deserializeAws_queryVpcSecurityGroupMembershipList(
      __getArrayIfSingleItem(
        output["VpcSecurityGroupMemberships"]["VpcSecurityGroupMembership"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_queryOptionGroup = (
  output: any,
  context: __SerdeContext
): OptionGroup => {
  let contents: any = {
    __type: "OptionGroup",
    AllowsVpcAndNonVpcInstanceMemberships: undefined,
    EngineName: undefined,
    MajorEngineVersion: undefined,
    OptionGroupArn: undefined,
    OptionGroupDescription: undefined,
    OptionGroupName: undefined,
    Options: undefined,
    VpcId: undefined
  };
  if (output["AllowsVpcAndNonVpcInstanceMemberships"] !== undefined) {
    contents.AllowsVpcAndNonVpcInstanceMemberships =
      (output["AllowsVpcAndNonVpcInstanceMemberships"]["#text"] !== undefined
        ? output["AllowsVpcAndNonVpcInstanceMemberships"]["#text"]
        : output["AllowsVpcAndNonVpcInstanceMemberships"]) == "true";
  }
  if (output["EngineName"] !== undefined) {
    contents.EngineName =
      output["EngineName"]["#text"] !== undefined
        ? output["EngineName"]["#text"]
        : output["EngineName"];
  }
  if (output["MajorEngineVersion"] !== undefined) {
    contents.MajorEngineVersion =
      output["MajorEngineVersion"]["#text"] !== undefined
        ? output["MajorEngineVersion"]["#text"]
        : output["MajorEngineVersion"];
  }
  if (output["OptionGroupArn"] !== undefined) {
    contents.OptionGroupArn =
      output["OptionGroupArn"]["#text"] !== undefined
        ? output["OptionGroupArn"]["#text"]
        : output["OptionGroupArn"];
  }
  if (output["OptionGroupDescription"] !== undefined) {
    contents.OptionGroupDescription =
      output["OptionGroupDescription"]["#text"] !== undefined
        ? output["OptionGroupDescription"]["#text"]
        : output["OptionGroupDescription"];
  }
  if (output["OptionGroupName"] !== undefined) {
    contents.OptionGroupName =
      output["OptionGroupName"]["#text"] !== undefined
        ? output["OptionGroupName"]["#text"]
        : output["OptionGroupName"];
  }
  if (output.Options === "") {
    contents.Options = [];
  }
  if (
    output["Options"] !== undefined &&
    output["Options"]["Option"] !== undefined
  ) {
    contents.Options = deserializeAws_queryOptionsList(
      __getArrayIfSingleItem(output["Options"]["Option"]),
      context
    );
  }
  if (output["VpcId"] !== undefined) {
    contents.VpcId =
      output["VpcId"]["#text"] !== undefined
        ? output["VpcId"]["#text"]
        : output["VpcId"];
  }
  return contents;
};

const deserializeAws_queryOptionGroupMembership = (
  output: any,
  context: __SerdeContext
): OptionGroupMembership => {
  let contents: any = {
    __type: "OptionGroupMembership",
    OptionGroupName: undefined,
    Status: undefined
  };
  if (output["OptionGroupName"] !== undefined) {
    contents.OptionGroupName =
      output["OptionGroupName"]["#text"] !== undefined
        ? output["OptionGroupName"]["#text"]
        : output["OptionGroupName"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryOptionGroupMembershipList = (
  output: any,
  context: __SerdeContext
): OptionGroupMembership[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryOptionGroupMembership(entry, context));
  });
  return contents;
};

const deserializeAws_queryOptionGroupOption = (
  output: any,
  context: __SerdeContext
): OptionGroupOption => {
  let contents: any = {
    __type: "OptionGroupOption",
    DefaultPort: undefined,
    Description: undefined,
    EngineName: undefined,
    MajorEngineVersion: undefined,
    MinimumRequiredMinorEngineVersion: undefined,
    Name: undefined,
    OptionGroupOptionSettings: undefined,
    OptionGroupOptionVersions: undefined,
    OptionsConflictsWith: undefined,
    OptionsDependedOn: undefined,
    Permanent: undefined,
    Persistent: undefined,
    PortRequired: undefined,
    RequiresAutoMinorEngineVersionUpgrade: undefined,
    SupportsOptionVersionDowngrade: undefined,
    VpcOnly: undefined
  };
  if (output["DefaultPort"] !== undefined) {
    contents.DefaultPort = parseInt(
      output["DefaultPort"]["#text"] !== undefined
        ? output["DefaultPort"]["#text"]
        : output["DefaultPort"]
    );
  }
  if (output["Description"] !== undefined) {
    contents.Description =
      output["Description"]["#text"] !== undefined
        ? output["Description"]["#text"]
        : output["Description"];
  }
  if (output["EngineName"] !== undefined) {
    contents.EngineName =
      output["EngineName"]["#text"] !== undefined
        ? output["EngineName"]["#text"]
        : output["EngineName"];
  }
  if (output["MajorEngineVersion"] !== undefined) {
    contents.MajorEngineVersion =
      output["MajorEngineVersion"]["#text"] !== undefined
        ? output["MajorEngineVersion"]["#text"]
        : output["MajorEngineVersion"];
  }
  if (output["MinimumRequiredMinorEngineVersion"] !== undefined) {
    contents.MinimumRequiredMinorEngineVersion =
      output["MinimumRequiredMinorEngineVersion"]["#text"] !== undefined
        ? output["MinimumRequiredMinorEngineVersion"]["#text"]
        : output["MinimumRequiredMinorEngineVersion"];
  }
  if (output["Name"] !== undefined) {
    contents.Name =
      output["Name"]["#text"] !== undefined
        ? output["Name"]["#text"]
        : output["Name"];
  }
  if (output.OptionGroupOptionSettings === "") {
    contents.OptionGroupOptionSettings = [];
  }
  if (
    output["OptionGroupOptionSettings"] !== undefined &&
    output["OptionGroupOptionSettings"]["OptionGroupOptionSetting"] !==
      undefined
  ) {
    contents.OptionGroupOptionSettings = deserializeAws_queryOptionGroupOptionSettingsList(
      __getArrayIfSingleItem(
        output["OptionGroupOptionSettings"]["OptionGroupOptionSetting"]
      ),
      context
    );
  }
  if (output.OptionGroupOptionVersions === "") {
    contents.OptionGroupOptionVersions = [];
  }
  if (
    output["OptionGroupOptionVersions"] !== undefined &&
    output["OptionGroupOptionVersions"]["OptionVersion"] !== undefined
  ) {
    contents.OptionGroupOptionVersions = deserializeAws_queryOptionGroupOptionVersionsList(
      __getArrayIfSingleItem(
        output["OptionGroupOptionVersions"]["OptionVersion"]
      ),
      context
    );
  }
  if (output.OptionsConflictsWith === "") {
    contents.OptionsConflictsWith = [];
  }
  if (
    output["OptionsConflictsWith"] !== undefined &&
    output["OptionsConflictsWith"]["OptionConflictName"] !== undefined
  ) {
    contents.OptionsConflictsWith = deserializeAws_queryOptionsConflictsWith(
      __getArrayIfSingleItem(
        output["OptionsConflictsWith"]["OptionConflictName"]
      ),
      context
    );
  }
  if (output.OptionsDependedOn === "") {
    contents.OptionsDependedOn = [];
  }
  if (
    output["OptionsDependedOn"] !== undefined &&
    output["OptionsDependedOn"]["OptionName"] !== undefined
  ) {
    contents.OptionsDependedOn = deserializeAws_queryOptionsDependedOn(
      __getArrayIfSingleItem(output["OptionsDependedOn"]["OptionName"]),
      context
    );
  }
  if (output["Permanent"] !== undefined) {
    contents.Permanent =
      (output["Permanent"]["#text"] !== undefined
        ? output["Permanent"]["#text"]
        : output["Permanent"]) == "true";
  }
  if (output["Persistent"] !== undefined) {
    contents.Persistent =
      (output["Persistent"]["#text"] !== undefined
        ? output["Persistent"]["#text"]
        : output["Persistent"]) == "true";
  }
  if (output["PortRequired"] !== undefined) {
    contents.PortRequired =
      (output["PortRequired"]["#text"] !== undefined
        ? output["PortRequired"]["#text"]
        : output["PortRequired"]) == "true";
  }
  if (output["RequiresAutoMinorEngineVersionUpgrade"] !== undefined) {
    contents.RequiresAutoMinorEngineVersionUpgrade =
      (output["RequiresAutoMinorEngineVersionUpgrade"]["#text"] !== undefined
        ? output["RequiresAutoMinorEngineVersionUpgrade"]["#text"]
        : output["RequiresAutoMinorEngineVersionUpgrade"]) == "true";
  }
  if (output["SupportsOptionVersionDowngrade"] !== undefined) {
    contents.SupportsOptionVersionDowngrade =
      (output["SupportsOptionVersionDowngrade"]["#text"] !== undefined
        ? output["SupportsOptionVersionDowngrade"]["#text"]
        : output["SupportsOptionVersionDowngrade"]) == "true";
  }
  if (output["VpcOnly"] !== undefined) {
    contents.VpcOnly =
      (output["VpcOnly"]["#text"] !== undefined
        ? output["VpcOnly"]["#text"]
        : output["VpcOnly"]) == "true";
  }
  return contents;
};

const deserializeAws_queryOptionGroupOptionSetting = (
  output: any,
  context: __SerdeContext
): OptionGroupOptionSetting => {
  let contents: any = {
    __type: "OptionGroupOptionSetting",
    AllowedValues: undefined,
    ApplyType: undefined,
    DefaultValue: undefined,
    IsModifiable: undefined,
    IsRequired: undefined,
    MinimumEngineVersionPerAllowedValue: undefined,
    SettingDescription: undefined,
    SettingName: undefined
  };
  if (output["AllowedValues"] !== undefined) {
    contents.AllowedValues =
      output["AllowedValues"]["#text"] !== undefined
        ? output["AllowedValues"]["#text"]
        : output["AllowedValues"];
  }
  if (output["ApplyType"] !== undefined) {
    contents.ApplyType =
      output["ApplyType"]["#text"] !== undefined
        ? output["ApplyType"]["#text"]
        : output["ApplyType"];
  }
  if (output["DefaultValue"] !== undefined) {
    contents.DefaultValue =
      output["DefaultValue"]["#text"] !== undefined
        ? output["DefaultValue"]["#text"]
        : output["DefaultValue"];
  }
  if (output["IsModifiable"] !== undefined) {
    contents.IsModifiable =
      (output["IsModifiable"]["#text"] !== undefined
        ? output["IsModifiable"]["#text"]
        : output["IsModifiable"]) == "true";
  }
  if (output["IsRequired"] !== undefined) {
    contents.IsRequired =
      (output["IsRequired"]["#text"] !== undefined
        ? output["IsRequired"]["#text"]
        : output["IsRequired"]) == "true";
  }
  if (output.MinimumEngineVersionPerAllowedValue === "") {
    contents.MinimumEngineVersionPerAllowedValue = [];
  }
  if (
    output["MinimumEngineVersionPerAllowedValue"] !== undefined &&
    output["MinimumEngineVersionPerAllowedValue"][
      "MinimumEngineVersionPerAllowedValue"
    ] !== undefined
  ) {
    contents.MinimumEngineVersionPerAllowedValue = deserializeAws_queryMinimumEngineVersionPerAllowedValueList(
      __getArrayIfSingleItem(
        output["MinimumEngineVersionPerAllowedValue"][
          "MinimumEngineVersionPerAllowedValue"
        ]
      ),
      context
    );
  }
  if (output["SettingDescription"] !== undefined) {
    contents.SettingDescription =
      output["SettingDescription"]["#text"] !== undefined
        ? output["SettingDescription"]["#text"]
        : output["SettingDescription"];
  }
  if (output["SettingName"] !== undefined) {
    contents.SettingName =
      output["SettingName"]["#text"] !== undefined
        ? output["SettingName"]["#text"]
        : output["SettingName"];
  }
  return contents;
};

const deserializeAws_queryOptionGroupOptionSettingsList = (
  output: any,
  context: __SerdeContext
): OptionGroupOptionSetting[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryOptionGroupOptionSetting(entry, context));
  });
  return contents;
};

const deserializeAws_queryOptionGroupOptionVersionsList = (
  output: any,
  context: __SerdeContext
): OptionVersion[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryOptionVersion(entry, context));
  });
  return contents;
};

const deserializeAws_queryOptionGroupOptionsList = (
  output: any,
  context: __SerdeContext
): OptionGroupOption[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryOptionGroupOption(entry, context));
  });
  return contents;
};

const deserializeAws_queryOptionGroupOptionsMessage = (
  output: any,
  context: __SerdeContext
): OptionGroupOptionsMessage => {
  let contents: any = {
    __type: "OptionGroupOptionsMessage",
    Marker: undefined,
    OptionGroupOptions: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.OptionGroupOptions === "") {
    contents.OptionGroupOptions = [];
  }
  if (
    output["OptionGroupOptions"] !== undefined &&
    output["OptionGroupOptions"]["OptionGroupOption"] !== undefined
  ) {
    contents.OptionGroupOptions = deserializeAws_queryOptionGroupOptionsList(
      __getArrayIfSingleItem(output["OptionGroupOptions"]["OptionGroupOption"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryOptionGroups = (
  output: any,
  context: __SerdeContext
): OptionGroups => {
  let contents: any = {
    __type: "OptionGroups",
    Marker: undefined,
    OptionGroupsList: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.OptionGroupsList === "") {
    contents.OptionGroupsList = [];
  }
  if (
    output["OptionGroupsList"] !== undefined &&
    output["OptionGroupsList"]["OptionGroup"] !== undefined
  ) {
    contents.OptionGroupsList = deserializeAws_queryOptionGroupsList(
      __getArrayIfSingleItem(output["OptionGroupsList"]["OptionGroup"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryOptionGroupsList = (
  output: any,
  context: __SerdeContext
): OptionGroup[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryOptionGroup(entry, context));
  });
  return contents;
};

const deserializeAws_queryOptionSetting = (
  output: any,
  context: __SerdeContext
): OptionSetting => {
  let contents: any = {
    __type: "OptionSetting",
    AllowedValues: undefined,
    ApplyType: undefined,
    DataType: undefined,
    DefaultValue: undefined,
    Description: undefined,
    IsCollection: undefined,
    IsModifiable: undefined,
    Name: undefined,
    Value: undefined
  };
  if (output["AllowedValues"] !== undefined) {
    contents.AllowedValues =
      output["AllowedValues"]["#text"] !== undefined
        ? output["AllowedValues"]["#text"]
        : output["AllowedValues"];
  }
  if (output["ApplyType"] !== undefined) {
    contents.ApplyType =
      output["ApplyType"]["#text"] !== undefined
        ? output["ApplyType"]["#text"]
        : output["ApplyType"];
  }
  if (output["DataType"] !== undefined) {
    contents.DataType =
      output["DataType"]["#text"] !== undefined
        ? output["DataType"]["#text"]
        : output["DataType"];
  }
  if (output["DefaultValue"] !== undefined) {
    contents.DefaultValue =
      output["DefaultValue"]["#text"] !== undefined
        ? output["DefaultValue"]["#text"]
        : output["DefaultValue"];
  }
  if (output["Description"] !== undefined) {
    contents.Description =
      output["Description"]["#text"] !== undefined
        ? output["Description"]["#text"]
        : output["Description"];
  }
  if (output["IsCollection"] !== undefined) {
    contents.IsCollection =
      (output["IsCollection"]["#text"] !== undefined
        ? output["IsCollection"]["#text"]
        : output["IsCollection"]) == "true";
  }
  if (output["IsModifiable"] !== undefined) {
    contents.IsModifiable =
      (output["IsModifiable"]["#text"] !== undefined
        ? output["IsModifiable"]["#text"]
        : output["IsModifiable"]) == "true";
  }
  if (output["Name"] !== undefined) {
    contents.Name =
      output["Name"]["#text"] !== undefined
        ? output["Name"]["#text"]
        : output["Name"];
  }
  if (output["Value"] !== undefined) {
    contents.Value =
      output["Value"]["#text"] !== undefined
        ? output["Value"]["#text"]
        : output["Value"];
  }
  return contents;
};

const deserializeAws_queryOptionSettingConfigurationList = (
  output: any,
  context: __SerdeContext
): OptionSetting[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryOptionSetting(entry, context));
  });
  return contents;
};

const deserializeAws_queryOptionVersion = (
  output: any,
  context: __SerdeContext
): OptionVersion => {
  let contents: any = {
    __type: "OptionVersion",
    IsDefault: undefined,
    Version: undefined
  };
  if (output["IsDefault"] !== undefined) {
    contents.IsDefault =
      (output["IsDefault"]["#text"] !== undefined
        ? output["IsDefault"]["#text"]
        : output["IsDefault"]) == "true";
  }
  if (output["Version"] !== undefined) {
    contents.Version =
      output["Version"]["#text"] !== undefined
        ? output["Version"]["#text"]
        : output["Version"];
  }
  return contents;
};

const deserializeAws_queryOptionsConflictsWith = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryOptionsDependedOn = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryOptionsList = (
  output: any,
  context: __SerdeContext
): Option[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryOption(entry, context));
  });
  return contents;
};

const deserializeAws_queryOrderableDBInstanceOption = (
  output: any,
  context: __SerdeContext
): OrderableDBInstanceOption => {
  let contents: any = {
    __type: "OrderableDBInstanceOption",
    AvailabilityZones: undefined,
    AvailableProcessorFeatures: undefined,
    DBInstanceClass: undefined,
    Engine: undefined,
    EngineVersion: undefined,
    LicenseModel: undefined,
    MaxIopsPerDbInstance: undefined,
    MaxIopsPerGib: undefined,
    MaxStorageSize: undefined,
    MinIopsPerDbInstance: undefined,
    MinIopsPerGib: undefined,
    MinStorageSize: undefined,
    MultiAZCapable: undefined,
    ReadReplicaCapable: undefined,
    StorageType: undefined,
    SupportedEngineModes: undefined,
    SupportsEnhancedMonitoring: undefined,
    SupportsIAMDatabaseAuthentication: undefined,
    SupportsIops: undefined,
    SupportsKerberosAuthentication: undefined,
    SupportsPerformanceInsights: undefined,
    SupportsStorageAutoscaling: undefined,
    SupportsStorageEncryption: undefined,
    Vpc: undefined
  };
  if (output.AvailabilityZones === "") {
    contents.AvailabilityZones = [];
  }
  if (
    output["AvailabilityZones"] !== undefined &&
    output["AvailabilityZones"]["AvailabilityZone"] !== undefined
  ) {
    contents.AvailabilityZones = deserializeAws_queryAvailabilityZoneList(
      __getArrayIfSingleItem(output["AvailabilityZones"]["AvailabilityZone"]),
      context
    );
  }
  if (output.AvailableProcessorFeatures === "") {
    contents.AvailableProcessorFeatures = [];
  }
  if (
    output["AvailableProcessorFeatures"] !== undefined &&
    output["AvailableProcessorFeatures"]["AvailableProcessorFeature"] !==
      undefined
  ) {
    contents.AvailableProcessorFeatures = deserializeAws_queryAvailableProcessorFeatureList(
      __getArrayIfSingleItem(
        output["AvailableProcessorFeatures"]["AvailableProcessorFeature"]
      ),
      context
    );
  }
  if (output["DBInstanceClass"] !== undefined) {
    contents.DBInstanceClass =
      output["DBInstanceClass"]["#text"] !== undefined
        ? output["DBInstanceClass"]["#text"]
        : output["DBInstanceClass"];
  }
  if (output["Engine"] !== undefined) {
    contents.Engine =
      output["Engine"]["#text"] !== undefined
        ? output["Engine"]["#text"]
        : output["Engine"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output["LicenseModel"] !== undefined) {
    contents.LicenseModel =
      output["LicenseModel"]["#text"] !== undefined
        ? output["LicenseModel"]["#text"]
        : output["LicenseModel"];
  }
  if (output["MaxIopsPerDbInstance"] !== undefined) {
    contents.MaxIopsPerDbInstance = parseInt(
      output["MaxIopsPerDbInstance"]["#text"] !== undefined
        ? output["MaxIopsPerDbInstance"]["#text"]
        : output["MaxIopsPerDbInstance"]
    );
  }
  if (output["MaxIopsPerGib"] !== undefined) {
    contents.MaxIopsPerGib = parseFloat(
      output["MaxIopsPerGib"]["#text"] !== undefined
        ? output["MaxIopsPerGib"]["#text"]
        : output["MaxIopsPerGib"]
    );
  }
  if (output["MaxStorageSize"] !== undefined) {
    contents.MaxStorageSize = parseInt(
      output["MaxStorageSize"]["#text"] !== undefined
        ? output["MaxStorageSize"]["#text"]
        : output["MaxStorageSize"]
    );
  }
  if (output["MinIopsPerDbInstance"] !== undefined) {
    contents.MinIopsPerDbInstance = parseInt(
      output["MinIopsPerDbInstance"]["#text"] !== undefined
        ? output["MinIopsPerDbInstance"]["#text"]
        : output["MinIopsPerDbInstance"]
    );
  }
  if (output["MinIopsPerGib"] !== undefined) {
    contents.MinIopsPerGib = parseFloat(
      output["MinIopsPerGib"]["#text"] !== undefined
        ? output["MinIopsPerGib"]["#text"]
        : output["MinIopsPerGib"]
    );
  }
  if (output["MinStorageSize"] !== undefined) {
    contents.MinStorageSize = parseInt(
      output["MinStorageSize"]["#text"] !== undefined
        ? output["MinStorageSize"]["#text"]
        : output["MinStorageSize"]
    );
  }
  if (output["MultiAZCapable"] !== undefined) {
    contents.MultiAZCapable =
      (output["MultiAZCapable"]["#text"] !== undefined
        ? output["MultiAZCapable"]["#text"]
        : output["MultiAZCapable"]) == "true";
  }
  if (output["ReadReplicaCapable"] !== undefined) {
    contents.ReadReplicaCapable =
      (output["ReadReplicaCapable"]["#text"] !== undefined
        ? output["ReadReplicaCapable"]["#text"]
        : output["ReadReplicaCapable"]) == "true";
  }
  if (output["StorageType"] !== undefined) {
    contents.StorageType =
      output["StorageType"]["#text"] !== undefined
        ? output["StorageType"]["#text"]
        : output["StorageType"];
  }
  if (output.SupportedEngineModes === "") {
    contents.SupportedEngineModes = [];
  }
  if (
    output["SupportedEngineModes"] !== undefined &&
    output["SupportedEngineModes"]["member"] !== undefined
  ) {
    contents.SupportedEngineModes = deserializeAws_queryEngineModeList(
      __getArrayIfSingleItem(output["SupportedEngineModes"]["member"]),
      context
    );
  }
  if (output["SupportsEnhancedMonitoring"] !== undefined) {
    contents.SupportsEnhancedMonitoring =
      (output["SupportsEnhancedMonitoring"]["#text"] !== undefined
        ? output["SupportsEnhancedMonitoring"]["#text"]
        : output["SupportsEnhancedMonitoring"]) == "true";
  }
  if (output["SupportsIAMDatabaseAuthentication"] !== undefined) {
    contents.SupportsIAMDatabaseAuthentication =
      (output["SupportsIAMDatabaseAuthentication"]["#text"] !== undefined
        ? output["SupportsIAMDatabaseAuthentication"]["#text"]
        : output["SupportsIAMDatabaseAuthentication"]) == "true";
  }
  if (output["SupportsIops"] !== undefined) {
    contents.SupportsIops =
      (output["SupportsIops"]["#text"] !== undefined
        ? output["SupportsIops"]["#text"]
        : output["SupportsIops"]) == "true";
  }
  if (output["SupportsKerberosAuthentication"] !== undefined) {
    contents.SupportsKerberosAuthentication =
      (output["SupportsKerberosAuthentication"]["#text"] !== undefined
        ? output["SupportsKerberosAuthentication"]["#text"]
        : output["SupportsKerberosAuthentication"]) == "true";
  }
  if (output["SupportsPerformanceInsights"] !== undefined) {
    contents.SupportsPerformanceInsights =
      (output["SupportsPerformanceInsights"]["#text"] !== undefined
        ? output["SupportsPerformanceInsights"]["#text"]
        : output["SupportsPerformanceInsights"]) == "true";
  }
  if (output["SupportsStorageAutoscaling"] !== undefined) {
    contents.SupportsStorageAutoscaling =
      (output["SupportsStorageAutoscaling"]["#text"] !== undefined
        ? output["SupportsStorageAutoscaling"]["#text"]
        : output["SupportsStorageAutoscaling"]) == "true";
  }
  if (output["SupportsStorageEncryption"] !== undefined) {
    contents.SupportsStorageEncryption =
      (output["SupportsStorageEncryption"]["#text"] !== undefined
        ? output["SupportsStorageEncryption"]["#text"]
        : output["SupportsStorageEncryption"]) == "true";
  }
  if (output["Vpc"] !== undefined) {
    contents.Vpc =
      (output["Vpc"]["#text"] !== undefined
        ? output["Vpc"]["#text"]
        : output["Vpc"]) == "true";
  }
  return contents;
};

const deserializeAws_queryOrderableDBInstanceOptionsList = (
  output: any,
  context: __SerdeContext
): OrderableDBInstanceOption[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryOrderableDBInstanceOption(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryOrderableDBInstanceOptionsMessage = (
  output: any,
  context: __SerdeContext
): OrderableDBInstanceOptionsMessage => {
  let contents: any = {
    __type: "OrderableDBInstanceOptionsMessage",
    Marker: undefined,
    OrderableDBInstanceOptions: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.OrderableDBInstanceOptions === "") {
    contents.OrderableDBInstanceOptions = [];
  }
  if (
    output["OrderableDBInstanceOptions"] !== undefined &&
    output["OrderableDBInstanceOptions"]["OrderableDBInstanceOption"] !==
      undefined
  ) {
    contents.OrderableDBInstanceOptions = deserializeAws_queryOrderableDBInstanceOptionsList(
      __getArrayIfSingleItem(
        output["OrderableDBInstanceOptions"]["OrderableDBInstanceOption"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_queryParameter = (
  output: any,
  context: __SerdeContext
): Parameter => {
  let contents: any = {
    __type: "Parameter",
    AllowedValues: undefined,
    ApplyMethod: undefined,
    ApplyType: undefined,
    DataType: undefined,
    Description: undefined,
    IsModifiable: undefined,
    MinimumEngineVersion: undefined,
    ParameterName: undefined,
    ParameterValue: undefined,
    Source: undefined,
    SupportedEngineModes: undefined
  };
  if (output["AllowedValues"] !== undefined) {
    contents.AllowedValues =
      output["AllowedValues"]["#text"] !== undefined
        ? output["AllowedValues"]["#text"]
        : output["AllowedValues"];
  }
  if (output["ApplyMethod"] !== undefined) {
    contents.ApplyMethod =
      output["ApplyMethod"]["#text"] !== undefined
        ? output["ApplyMethod"]["#text"]
        : output["ApplyMethod"];
  }
  if (output["ApplyType"] !== undefined) {
    contents.ApplyType =
      output["ApplyType"]["#text"] !== undefined
        ? output["ApplyType"]["#text"]
        : output["ApplyType"];
  }
  if (output["DataType"] !== undefined) {
    contents.DataType =
      output["DataType"]["#text"] !== undefined
        ? output["DataType"]["#text"]
        : output["DataType"];
  }
  if (output["Description"] !== undefined) {
    contents.Description =
      output["Description"]["#text"] !== undefined
        ? output["Description"]["#text"]
        : output["Description"];
  }
  if (output["IsModifiable"] !== undefined) {
    contents.IsModifiable =
      (output["IsModifiable"]["#text"] !== undefined
        ? output["IsModifiable"]["#text"]
        : output["IsModifiable"]) == "true";
  }
  if (output["MinimumEngineVersion"] !== undefined) {
    contents.MinimumEngineVersion =
      output["MinimumEngineVersion"]["#text"] !== undefined
        ? output["MinimumEngineVersion"]["#text"]
        : output["MinimumEngineVersion"];
  }
  if (output["ParameterName"] !== undefined) {
    contents.ParameterName =
      output["ParameterName"]["#text"] !== undefined
        ? output["ParameterName"]["#text"]
        : output["ParameterName"];
  }
  if (output["ParameterValue"] !== undefined) {
    contents.ParameterValue =
      output["ParameterValue"]["#text"] !== undefined
        ? output["ParameterValue"]["#text"]
        : output["ParameterValue"];
  }
  if (output["Source"] !== undefined) {
    contents.Source =
      output["Source"]["#text"] !== undefined
        ? output["Source"]["#text"]
        : output["Source"];
  }
  if (output.SupportedEngineModes === "") {
    contents.SupportedEngineModes = [];
  }
  if (
    output["SupportedEngineModes"] !== undefined &&
    output["SupportedEngineModes"]["member"] !== undefined
  ) {
    contents.SupportedEngineModes = deserializeAws_queryEngineModeList(
      __getArrayIfSingleItem(output["SupportedEngineModes"]["member"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryParametersList = (
  output: any,
  context: __SerdeContext
): Parameter[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryParameter(entry, context));
  });
  return contents;
};

const deserializeAws_queryPendingCloudwatchLogsExports = (
  output: any,
  context: __SerdeContext
): PendingCloudwatchLogsExports => {
  let contents: any = {
    __type: "PendingCloudwatchLogsExports",
    LogTypesToDisable: undefined,
    LogTypesToEnable: undefined
  };
  if (output.LogTypesToDisable === "") {
    contents.LogTypesToDisable = [];
  }
  if (
    output["LogTypesToDisable"] !== undefined &&
    output["LogTypesToDisable"]["member"] !== undefined
  ) {
    contents.LogTypesToDisable = deserializeAws_queryLogTypeList(
      __getArrayIfSingleItem(output["LogTypesToDisable"]["member"]),
      context
    );
  }
  if (output.LogTypesToEnable === "") {
    contents.LogTypesToEnable = [];
  }
  if (
    output["LogTypesToEnable"] !== undefined &&
    output["LogTypesToEnable"]["member"] !== undefined
  ) {
    contents.LogTypesToEnable = deserializeAws_queryLogTypeList(
      __getArrayIfSingleItem(output["LogTypesToEnable"]["member"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryPendingMaintenanceAction = (
  output: any,
  context: __SerdeContext
): PendingMaintenanceAction => {
  let contents: any = {
    __type: "PendingMaintenanceAction",
    Action: undefined,
    AutoAppliedAfterDate: undefined,
    CurrentApplyDate: undefined,
    Description: undefined,
    ForcedApplyDate: undefined,
    OptInStatus: undefined
  };
  if (output["Action"] !== undefined) {
    contents.Action =
      output["Action"]["#text"] !== undefined
        ? output["Action"]["#text"]
        : output["Action"];
  }
  if (output["AutoAppliedAfterDate"] !== undefined) {
    contents.AutoAppliedAfterDate = new Date(output["AutoAppliedAfterDate"]);
  }
  if (output["CurrentApplyDate"] !== undefined) {
    contents.CurrentApplyDate = new Date(output["CurrentApplyDate"]);
  }
  if (output["Description"] !== undefined) {
    contents.Description =
      output["Description"]["#text"] !== undefined
        ? output["Description"]["#text"]
        : output["Description"];
  }
  if (output["ForcedApplyDate"] !== undefined) {
    contents.ForcedApplyDate = new Date(output["ForcedApplyDate"]);
  }
  if (output["OptInStatus"] !== undefined) {
    contents.OptInStatus =
      output["OptInStatus"]["#text"] !== undefined
        ? output["OptInStatus"]["#text"]
        : output["OptInStatus"];
  }
  return contents;
};

const deserializeAws_queryPendingMaintenanceActionDetails = (
  output: any,
  context: __SerdeContext
): PendingMaintenanceAction[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryPendingMaintenanceAction(entry, context));
  });
  return contents;
};

const deserializeAws_queryPendingMaintenanceActions = (
  output: any,
  context: __SerdeContext
): ResourcePendingMaintenanceActions[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryResourcePendingMaintenanceActions(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryPendingMaintenanceActionsMessage = (
  output: any,
  context: __SerdeContext
): PendingMaintenanceActionsMessage => {
  let contents: any = {
    __type: "PendingMaintenanceActionsMessage",
    Marker: undefined,
    PendingMaintenanceActions: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.PendingMaintenanceActions === "") {
    contents.PendingMaintenanceActions = [];
  }
  if (
    output["PendingMaintenanceActions"] !== undefined &&
    output["PendingMaintenanceActions"]["ResourcePendingMaintenanceActions"] !==
      undefined
  ) {
    contents.PendingMaintenanceActions = deserializeAws_queryPendingMaintenanceActions(
      __getArrayIfSingleItem(
        output["PendingMaintenanceActions"]["ResourcePendingMaintenanceActions"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_queryPendingModifiedValues = (
  output: any,
  context: __SerdeContext
): PendingModifiedValues => {
  let contents: any = {
    __type: "PendingModifiedValues",
    AllocatedStorage: undefined,
    BackupRetentionPeriod: undefined,
    CACertificateIdentifier: undefined,
    DBInstanceClass: undefined,
    DBInstanceIdentifier: undefined,
    DBSubnetGroupName: undefined,
    EngineVersion: undefined,
    Iops: undefined,
    LicenseModel: undefined,
    MasterUserPassword: undefined,
    MultiAZ: undefined,
    PendingCloudwatchLogsExports: undefined,
    Port: undefined,
    ProcessorFeatures: undefined,
    StorageType: undefined
  };
  if (output["AllocatedStorage"] !== undefined) {
    contents.AllocatedStorage = parseInt(
      output["AllocatedStorage"]["#text"] !== undefined
        ? output["AllocatedStorage"]["#text"]
        : output["AllocatedStorage"]
    );
  }
  if (output["BackupRetentionPeriod"] !== undefined) {
    contents.BackupRetentionPeriod = parseInt(
      output["BackupRetentionPeriod"]["#text"] !== undefined
        ? output["BackupRetentionPeriod"]["#text"]
        : output["BackupRetentionPeriod"]
    );
  }
  if (output["CACertificateIdentifier"] !== undefined) {
    contents.CACertificateIdentifier =
      output["CACertificateIdentifier"]["#text"] !== undefined
        ? output["CACertificateIdentifier"]["#text"]
        : output["CACertificateIdentifier"];
  }
  if (output["DBInstanceClass"] !== undefined) {
    contents.DBInstanceClass =
      output["DBInstanceClass"]["#text"] !== undefined
        ? output["DBInstanceClass"]["#text"]
        : output["DBInstanceClass"];
  }
  if (output["DBInstanceIdentifier"] !== undefined) {
    contents.DBInstanceIdentifier =
      output["DBInstanceIdentifier"]["#text"] !== undefined
        ? output["DBInstanceIdentifier"]["#text"]
        : output["DBInstanceIdentifier"];
  }
  if (output["DBSubnetGroupName"] !== undefined) {
    contents.DBSubnetGroupName =
      output["DBSubnetGroupName"]["#text"] !== undefined
        ? output["DBSubnetGroupName"]["#text"]
        : output["DBSubnetGroupName"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output["Iops"] !== undefined) {
    contents.Iops = parseInt(
      output["Iops"]["#text"] !== undefined
        ? output["Iops"]["#text"]
        : output["Iops"]
    );
  }
  if (output["LicenseModel"] !== undefined) {
    contents.LicenseModel =
      output["LicenseModel"]["#text"] !== undefined
        ? output["LicenseModel"]["#text"]
        : output["LicenseModel"];
  }
  if (output["MasterUserPassword"] !== undefined) {
    contents.MasterUserPassword =
      output["MasterUserPassword"]["#text"] !== undefined
        ? output["MasterUserPassword"]["#text"]
        : output["MasterUserPassword"];
  }
  if (output["MultiAZ"] !== undefined) {
    contents.MultiAZ =
      (output["MultiAZ"]["#text"] !== undefined
        ? output["MultiAZ"]["#text"]
        : output["MultiAZ"]) == "true";
  }
  if (output["PendingCloudwatchLogsExports"] !== undefined) {
    contents.PendingCloudwatchLogsExports = deserializeAws_queryPendingCloudwatchLogsExports(
      output["PendingCloudwatchLogsExports"],
      context
    );
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(
      output["Port"]["#text"] !== undefined
        ? output["Port"]["#text"]
        : output["Port"]
    );
  }
  if (output.ProcessorFeatures === "") {
    contents.ProcessorFeatures = [];
  }
  if (
    output["ProcessorFeatures"] !== undefined &&
    output["ProcessorFeatures"]["ProcessorFeature"] !== undefined
  ) {
    contents.ProcessorFeatures = deserializeAws_queryProcessorFeatureList(
      __getArrayIfSingleItem(output["ProcessorFeatures"]["ProcessorFeature"]),
      context
    );
  }
  if (output["StorageType"] !== undefined) {
    contents.StorageType =
      output["StorageType"]["#text"] !== undefined
        ? output["StorageType"]["#text"]
        : output["StorageType"];
  }
  return contents;
};

const deserializeAws_queryProcessorFeature = (
  output: any,
  context: __SerdeContext
): ProcessorFeature => {
  let contents: any = {
    __type: "ProcessorFeature",
    Name: undefined,
    Value: undefined
  };
  if (output["Name"] !== undefined) {
    contents.Name =
      output["Name"]["#text"] !== undefined
        ? output["Name"]["#text"]
        : output["Name"];
  }
  if (output["Value"] !== undefined) {
    contents.Value =
      output["Value"]["#text"] !== undefined
        ? output["Value"]["#text"]
        : output["Value"];
  }
  return contents;
};

const deserializeAws_queryProcessorFeatureList = (
  output: any,
  context: __SerdeContext
): ProcessorFeature[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryProcessorFeature(entry, context));
  });
  return contents;
};

const deserializeAws_queryPromoteReadReplicaDBClusterResult = (
  output: any,
  context: __SerdeContext
): PromoteReadReplicaDBClusterResult => {
  let contents: any = {
    __type: "PromoteReadReplicaDBClusterResult",
    DBCluster: undefined
  };
  if (output["DBCluster"] !== undefined) {
    contents.DBCluster = deserializeAws_queryDBCluster(
      output["DBCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryPromoteReadReplicaResult = (
  output: any,
  context: __SerdeContext
): PromoteReadReplicaResult => {
  let contents: any = {
    __type: "PromoteReadReplicaResult",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryPurchaseReservedDBInstancesOfferingResult = (
  output: any,
  context: __SerdeContext
): PurchaseReservedDBInstancesOfferingResult => {
  let contents: any = {
    __type: "PurchaseReservedDBInstancesOfferingResult",
    ReservedDBInstance: undefined
  };
  if (output["ReservedDBInstance"] !== undefined) {
    contents.ReservedDBInstance = deserializeAws_queryReservedDBInstance(
      output["ReservedDBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRange = (
  output: any,
  context: __SerdeContext
): Range => {
  let contents: any = {
    __type: "Range",
    From: undefined,
    Step: undefined,
    To: undefined
  };
  if (output["From"] !== undefined) {
    contents.From = parseInt(
      output["From"]["#text"] !== undefined
        ? output["From"]["#text"]
        : output["From"]
    );
  }
  if (output["Step"] !== undefined) {
    contents.Step = parseInt(
      output["Step"]["#text"] !== undefined
        ? output["Step"]["#text"]
        : output["Step"]
    );
  }
  if (output["To"] !== undefined) {
    contents.To = parseInt(
      output["To"]["#text"] !== undefined ? output["To"]["#text"] : output["To"]
    );
  }
  return contents;
};

const deserializeAws_queryRangeList = (
  output: any,
  context: __SerdeContext
): Range[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryRange(entry, context));
  });
  return contents;
};

const deserializeAws_queryReadReplicaDBClusterIdentifierList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryReadReplicaDBInstanceIdentifierList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryReadReplicaIdentifierList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryReadersArnList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_queryRebootDBInstanceResult = (
  output: any,
  context: __SerdeContext
): RebootDBInstanceResult => {
  let contents: any = {
    __type: "RebootDBInstanceResult",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRecurringCharge = (
  output: any,
  context: __SerdeContext
): RecurringCharge => {
  let contents: any = {
    __type: "RecurringCharge",
    RecurringChargeAmount: undefined,
    RecurringChargeFrequency: undefined
  };
  if (output["RecurringChargeAmount"] !== undefined) {
    contents.RecurringChargeAmount = parseFloat(
      output["RecurringChargeAmount"]["#text"] !== undefined
        ? output["RecurringChargeAmount"]["#text"]
        : output["RecurringChargeAmount"]
    );
  }
  if (output["RecurringChargeFrequency"] !== undefined) {
    contents.RecurringChargeFrequency =
      output["RecurringChargeFrequency"]["#text"] !== undefined
        ? output["RecurringChargeFrequency"]["#text"]
        : output["RecurringChargeFrequency"];
  }
  return contents;
};

const deserializeAws_queryRecurringChargeList = (
  output: any,
  context: __SerdeContext
): RecurringCharge[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryRecurringCharge(entry, context));
  });
  return contents;
};

const deserializeAws_queryRegisterDBProxyTargetsResponse = (
  output: any,
  context: __SerdeContext
): RegisterDBProxyTargetsResponse => {
  let contents: any = {
    __type: "RegisterDBProxyTargetsResponse",
    DBProxyTargets: undefined
  };
  if (output.DBProxyTargets === "") {
    contents.DBProxyTargets = [];
  }
  if (
    output["DBProxyTargets"] !== undefined &&
    output["DBProxyTargets"]["member"] !== undefined
  ) {
    contents.DBProxyTargets = deserializeAws_queryTargetList(
      __getArrayIfSingleItem(output["DBProxyTargets"]["member"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryRemoveFromGlobalClusterResult = (
  output: any,
  context: __SerdeContext
): RemoveFromGlobalClusterResult => {
  let contents: any = {
    __type: "RemoveFromGlobalClusterResult",
    GlobalCluster: undefined
  };
  if (output["GlobalCluster"] !== undefined) {
    contents.GlobalCluster = deserializeAws_queryGlobalCluster(
      output["GlobalCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRemoveSourceIdentifierFromSubscriptionResult = (
  output: any,
  context: __SerdeContext
): RemoveSourceIdentifierFromSubscriptionResult => {
  let contents: any = {
    __type: "RemoveSourceIdentifierFromSubscriptionResult",
    EventSubscription: undefined
  };
  if (output["EventSubscription"] !== undefined) {
    contents.EventSubscription = deserializeAws_queryEventSubscription(
      output["EventSubscription"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryReservedDBInstance = (
  output: any,
  context: __SerdeContext
): ReservedDBInstance => {
  let contents: any = {
    __type: "ReservedDBInstance",
    CurrencyCode: undefined,
    DBInstanceClass: undefined,
    DBInstanceCount: undefined,
    Duration: undefined,
    FixedPrice: undefined,
    LeaseId: undefined,
    MultiAZ: undefined,
    OfferingType: undefined,
    ProductDescription: undefined,
    RecurringCharges: undefined,
    ReservedDBInstanceArn: undefined,
    ReservedDBInstanceId: undefined,
    ReservedDBInstancesOfferingId: undefined,
    StartTime: undefined,
    State: undefined,
    UsagePrice: undefined
  };
  if (output["CurrencyCode"] !== undefined) {
    contents.CurrencyCode =
      output["CurrencyCode"]["#text"] !== undefined
        ? output["CurrencyCode"]["#text"]
        : output["CurrencyCode"];
  }
  if (output["DBInstanceClass"] !== undefined) {
    contents.DBInstanceClass =
      output["DBInstanceClass"]["#text"] !== undefined
        ? output["DBInstanceClass"]["#text"]
        : output["DBInstanceClass"];
  }
  if (output["DBInstanceCount"] !== undefined) {
    contents.DBInstanceCount = parseInt(
      output["DBInstanceCount"]["#text"] !== undefined
        ? output["DBInstanceCount"]["#text"]
        : output["DBInstanceCount"]
    );
  }
  if (output["Duration"] !== undefined) {
    contents.Duration = parseInt(
      output["Duration"]["#text"] !== undefined
        ? output["Duration"]["#text"]
        : output["Duration"]
    );
  }
  if (output["FixedPrice"] !== undefined) {
    contents.FixedPrice = parseFloat(
      output["FixedPrice"]["#text"] !== undefined
        ? output["FixedPrice"]["#text"]
        : output["FixedPrice"]
    );
  }
  if (output["LeaseId"] !== undefined) {
    contents.LeaseId =
      output["LeaseId"]["#text"] !== undefined
        ? output["LeaseId"]["#text"]
        : output["LeaseId"];
  }
  if (output["MultiAZ"] !== undefined) {
    contents.MultiAZ =
      (output["MultiAZ"]["#text"] !== undefined
        ? output["MultiAZ"]["#text"]
        : output["MultiAZ"]) == "true";
  }
  if (output["OfferingType"] !== undefined) {
    contents.OfferingType =
      output["OfferingType"]["#text"] !== undefined
        ? output["OfferingType"]["#text"]
        : output["OfferingType"];
  }
  if (output["ProductDescription"] !== undefined) {
    contents.ProductDescription =
      output["ProductDescription"]["#text"] !== undefined
        ? output["ProductDescription"]["#text"]
        : output["ProductDescription"];
  }
  if (output.RecurringCharges === "") {
    contents.RecurringCharges = [];
  }
  if (
    output["RecurringCharges"] !== undefined &&
    output["RecurringCharges"]["RecurringCharge"] !== undefined
  ) {
    contents.RecurringCharges = deserializeAws_queryRecurringChargeList(
      __getArrayIfSingleItem(output["RecurringCharges"]["RecurringCharge"]),
      context
    );
  }
  if (output["ReservedDBInstanceArn"] !== undefined) {
    contents.ReservedDBInstanceArn =
      output["ReservedDBInstanceArn"]["#text"] !== undefined
        ? output["ReservedDBInstanceArn"]["#text"]
        : output["ReservedDBInstanceArn"];
  }
  if (output["ReservedDBInstanceId"] !== undefined) {
    contents.ReservedDBInstanceId =
      output["ReservedDBInstanceId"]["#text"] !== undefined
        ? output["ReservedDBInstanceId"]["#text"]
        : output["ReservedDBInstanceId"];
  }
  if (output["ReservedDBInstancesOfferingId"] !== undefined) {
    contents.ReservedDBInstancesOfferingId =
      output["ReservedDBInstancesOfferingId"]["#text"] !== undefined
        ? output["ReservedDBInstancesOfferingId"]["#text"]
        : output["ReservedDBInstancesOfferingId"];
  }
  if (output["StartTime"] !== undefined) {
    contents.StartTime = new Date(output["StartTime"]);
  }
  if (output["State"] !== undefined) {
    contents.State =
      output["State"]["#text"] !== undefined
        ? output["State"]["#text"]
        : output["State"];
  }
  if (output["UsagePrice"] !== undefined) {
    contents.UsagePrice = parseFloat(
      output["UsagePrice"]["#text"] !== undefined
        ? output["UsagePrice"]["#text"]
        : output["UsagePrice"]
    );
  }
  return contents;
};

const deserializeAws_queryReservedDBInstanceList = (
  output: any,
  context: __SerdeContext
): ReservedDBInstance[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryReservedDBInstance(entry, context));
  });
  return contents;
};

const deserializeAws_queryReservedDBInstanceMessage = (
  output: any,
  context: __SerdeContext
): ReservedDBInstanceMessage => {
  let contents: any = {
    __type: "ReservedDBInstanceMessage",
    Marker: undefined,
    ReservedDBInstances: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.ReservedDBInstances === "") {
    contents.ReservedDBInstances = [];
  }
  if (
    output["ReservedDBInstances"] !== undefined &&
    output["ReservedDBInstances"]["ReservedDBInstance"] !== undefined
  ) {
    contents.ReservedDBInstances = deserializeAws_queryReservedDBInstanceList(
      __getArrayIfSingleItem(
        output["ReservedDBInstances"]["ReservedDBInstance"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_queryReservedDBInstancesOffering = (
  output: any,
  context: __SerdeContext
): ReservedDBInstancesOffering => {
  let contents: any = {
    __type: "ReservedDBInstancesOffering",
    CurrencyCode: undefined,
    DBInstanceClass: undefined,
    Duration: undefined,
    FixedPrice: undefined,
    MultiAZ: undefined,
    OfferingType: undefined,
    ProductDescription: undefined,
    RecurringCharges: undefined,
    ReservedDBInstancesOfferingId: undefined,
    UsagePrice: undefined
  };
  if (output["CurrencyCode"] !== undefined) {
    contents.CurrencyCode =
      output["CurrencyCode"]["#text"] !== undefined
        ? output["CurrencyCode"]["#text"]
        : output["CurrencyCode"];
  }
  if (output["DBInstanceClass"] !== undefined) {
    contents.DBInstanceClass =
      output["DBInstanceClass"]["#text"] !== undefined
        ? output["DBInstanceClass"]["#text"]
        : output["DBInstanceClass"];
  }
  if (output["Duration"] !== undefined) {
    contents.Duration = parseInt(
      output["Duration"]["#text"] !== undefined
        ? output["Duration"]["#text"]
        : output["Duration"]
    );
  }
  if (output["FixedPrice"] !== undefined) {
    contents.FixedPrice = parseFloat(
      output["FixedPrice"]["#text"] !== undefined
        ? output["FixedPrice"]["#text"]
        : output["FixedPrice"]
    );
  }
  if (output["MultiAZ"] !== undefined) {
    contents.MultiAZ =
      (output["MultiAZ"]["#text"] !== undefined
        ? output["MultiAZ"]["#text"]
        : output["MultiAZ"]) == "true";
  }
  if (output["OfferingType"] !== undefined) {
    contents.OfferingType =
      output["OfferingType"]["#text"] !== undefined
        ? output["OfferingType"]["#text"]
        : output["OfferingType"];
  }
  if (output["ProductDescription"] !== undefined) {
    contents.ProductDescription =
      output["ProductDescription"]["#text"] !== undefined
        ? output["ProductDescription"]["#text"]
        : output["ProductDescription"];
  }
  if (output.RecurringCharges === "") {
    contents.RecurringCharges = [];
  }
  if (
    output["RecurringCharges"] !== undefined &&
    output["RecurringCharges"]["RecurringCharge"] !== undefined
  ) {
    contents.RecurringCharges = deserializeAws_queryRecurringChargeList(
      __getArrayIfSingleItem(output["RecurringCharges"]["RecurringCharge"]),
      context
    );
  }
  if (output["ReservedDBInstancesOfferingId"] !== undefined) {
    contents.ReservedDBInstancesOfferingId =
      output["ReservedDBInstancesOfferingId"]["#text"] !== undefined
        ? output["ReservedDBInstancesOfferingId"]["#text"]
        : output["ReservedDBInstancesOfferingId"];
  }
  if (output["UsagePrice"] !== undefined) {
    contents.UsagePrice = parseFloat(
      output["UsagePrice"]["#text"] !== undefined
        ? output["UsagePrice"]["#text"]
        : output["UsagePrice"]
    );
  }
  return contents;
};

const deserializeAws_queryReservedDBInstancesOfferingList = (
  output: any,
  context: __SerdeContext
): ReservedDBInstancesOffering[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryReservedDBInstancesOffering(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryReservedDBInstancesOfferingMessage = (
  output: any,
  context: __SerdeContext
): ReservedDBInstancesOfferingMessage => {
  let contents: any = {
    __type: "ReservedDBInstancesOfferingMessage",
    Marker: undefined,
    ReservedDBInstancesOfferings: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.ReservedDBInstancesOfferings === "") {
    contents.ReservedDBInstancesOfferings = [];
  }
  if (
    output["ReservedDBInstancesOfferings"] !== undefined &&
    output["ReservedDBInstancesOfferings"]["ReservedDBInstancesOffering"] !==
      undefined
  ) {
    contents.ReservedDBInstancesOfferings = deserializeAws_queryReservedDBInstancesOfferingList(
      __getArrayIfSingleItem(
        output["ReservedDBInstancesOfferings"]["ReservedDBInstancesOffering"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_queryResourcePendingMaintenanceActions = (
  output: any,
  context: __SerdeContext
): ResourcePendingMaintenanceActions => {
  let contents: any = {
    __type: "ResourcePendingMaintenanceActions",
    PendingMaintenanceActionDetails: undefined,
    ResourceIdentifier: undefined
  };
  if (output.PendingMaintenanceActionDetails === "") {
    contents.PendingMaintenanceActionDetails = [];
  }
  if (
    output["PendingMaintenanceActionDetails"] !== undefined &&
    output["PendingMaintenanceActionDetails"]["PendingMaintenanceAction"] !==
      undefined
  ) {
    contents.PendingMaintenanceActionDetails = deserializeAws_queryPendingMaintenanceActionDetails(
      __getArrayIfSingleItem(
        output["PendingMaintenanceActionDetails"]["PendingMaintenanceAction"]
      ),
      context
    );
  }
  if (output["ResourceIdentifier"] !== undefined) {
    contents.ResourceIdentifier =
      output["ResourceIdentifier"]["#text"] !== undefined
        ? output["ResourceIdentifier"]["#text"]
        : output["ResourceIdentifier"];
  }
  return contents;
};

const deserializeAws_queryRestoreDBClusterFromS3Result = (
  output: any,
  context: __SerdeContext
): RestoreDBClusterFromS3Result => {
  let contents: any = {
    __type: "RestoreDBClusterFromS3Result",
    DBCluster: undefined
  };
  if (output["DBCluster"] !== undefined) {
    contents.DBCluster = deserializeAws_queryDBCluster(
      output["DBCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRestoreDBClusterFromSnapshotResult = (
  output: any,
  context: __SerdeContext
): RestoreDBClusterFromSnapshotResult => {
  let contents: any = {
    __type: "RestoreDBClusterFromSnapshotResult",
    DBCluster: undefined
  };
  if (output["DBCluster"] !== undefined) {
    contents.DBCluster = deserializeAws_queryDBCluster(
      output["DBCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRestoreDBClusterToPointInTimeResult = (
  output: any,
  context: __SerdeContext
): RestoreDBClusterToPointInTimeResult => {
  let contents: any = {
    __type: "RestoreDBClusterToPointInTimeResult",
    DBCluster: undefined
  };
  if (output["DBCluster"] !== undefined) {
    contents.DBCluster = deserializeAws_queryDBCluster(
      output["DBCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRestoreDBInstanceFromDBSnapshotResult = (
  output: any,
  context: __SerdeContext
): RestoreDBInstanceFromDBSnapshotResult => {
  let contents: any = {
    __type: "RestoreDBInstanceFromDBSnapshotResult",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRestoreDBInstanceFromS3Result = (
  output: any,
  context: __SerdeContext
): RestoreDBInstanceFromS3Result => {
  let contents: any = {
    __type: "RestoreDBInstanceFromS3Result",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRestoreDBInstanceToPointInTimeResult = (
  output: any,
  context: __SerdeContext
): RestoreDBInstanceToPointInTimeResult => {
  let contents: any = {
    __type: "RestoreDBInstanceToPointInTimeResult",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryRestoreWindow = (
  output: any,
  context: __SerdeContext
): RestoreWindow => {
  let contents: any = {
    __type: "RestoreWindow",
    EarliestTime: undefined,
    LatestTime: undefined
  };
  if (output["EarliestTime"] !== undefined) {
    contents.EarliestTime = new Date(output["EarliestTime"]);
  }
  if (output["LatestTime"] !== undefined) {
    contents.LatestTime = new Date(output["LatestTime"]);
  }
  return contents;
};

const deserializeAws_queryRevokeDBSecurityGroupIngressResult = (
  output: any,
  context: __SerdeContext
): RevokeDBSecurityGroupIngressResult => {
  let contents: any = {
    __type: "RevokeDBSecurityGroupIngressResult",
    DBSecurityGroup: undefined
  };
  if (output["DBSecurityGroup"] !== undefined) {
    contents.DBSecurityGroup = deserializeAws_queryDBSecurityGroup(
      output["DBSecurityGroup"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryScalingConfigurationInfo = (
  output: any,
  context: __SerdeContext
): ScalingConfigurationInfo => {
  let contents: any = {
    __type: "ScalingConfigurationInfo",
    AutoPause: undefined,
    MaxCapacity: undefined,
    MinCapacity: undefined,
    SecondsUntilAutoPause: undefined,
    TimeoutAction: undefined
  };
  if (output["AutoPause"] !== undefined) {
    contents.AutoPause =
      (output["AutoPause"]["#text"] !== undefined
        ? output["AutoPause"]["#text"]
        : output["AutoPause"]) == "true";
  }
  if (output["MaxCapacity"] !== undefined) {
    contents.MaxCapacity = parseInt(
      output["MaxCapacity"]["#text"] !== undefined
        ? output["MaxCapacity"]["#text"]
        : output["MaxCapacity"]
    );
  }
  if (output["MinCapacity"] !== undefined) {
    contents.MinCapacity = parseInt(
      output["MinCapacity"]["#text"] !== undefined
        ? output["MinCapacity"]["#text"]
        : output["MinCapacity"]
    );
  }
  if (output["SecondsUntilAutoPause"] !== undefined) {
    contents.SecondsUntilAutoPause = parseInt(
      output["SecondsUntilAutoPause"]["#text"] !== undefined
        ? output["SecondsUntilAutoPause"]["#text"]
        : output["SecondsUntilAutoPause"]
    );
  }
  if (output["TimeoutAction"] !== undefined) {
    contents.TimeoutAction =
      output["TimeoutAction"]["#text"] !== undefined
        ? output["TimeoutAction"]["#text"]
        : output["TimeoutAction"];
  }
  return contents;
};

const deserializeAws_querySourceIdsList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_querySourceRegion = (
  output: any,
  context: __SerdeContext
): SourceRegion => {
  let contents: any = {
    __type: "SourceRegion",
    Endpoint: undefined,
    RegionName: undefined,
    Status: undefined
  };
  if (output["Endpoint"] !== undefined) {
    contents.Endpoint =
      output["Endpoint"]["#text"] !== undefined
        ? output["Endpoint"]["#text"]
        : output["Endpoint"];
  }
  if (output["RegionName"] !== undefined) {
    contents.RegionName =
      output["RegionName"]["#text"] !== undefined
        ? output["RegionName"]["#text"]
        : output["RegionName"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_querySourceRegionList = (
  output: any,
  context: __SerdeContext
): SourceRegion[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_querySourceRegion(entry, context));
  });
  return contents;
};

const deserializeAws_querySourceRegionMessage = (
  output: any,
  context: __SerdeContext
): SourceRegionMessage => {
  let contents: any = {
    __type: "SourceRegionMessage",
    Marker: undefined,
    SourceRegions: undefined
  };
  if (output["Marker"] !== undefined) {
    contents.Marker =
      output["Marker"]["#text"] !== undefined
        ? output["Marker"]["#text"]
        : output["Marker"];
  }
  if (output.SourceRegions === "") {
    contents.SourceRegions = [];
  }
  if (
    output["SourceRegions"] !== undefined &&
    output["SourceRegions"]["SourceRegion"] !== undefined
  ) {
    contents.SourceRegions = deserializeAws_querySourceRegionList(
      __getArrayIfSingleItem(output["SourceRegions"]["SourceRegion"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryStartActivityStreamResponse = (
  output: any,
  context: __SerdeContext
): StartActivityStreamResponse => {
  let contents: any = {
    __type: "StartActivityStreamResponse",
    ApplyImmediately: undefined,
    KinesisStreamName: undefined,
    KmsKeyId: undefined,
    Mode: undefined,
    Status: undefined
  };
  if (output["ApplyImmediately"] !== undefined) {
    contents.ApplyImmediately =
      (output["ApplyImmediately"]["#text"] !== undefined
        ? output["ApplyImmediately"]["#text"]
        : output["ApplyImmediately"]) == "true";
  }
  if (output["KinesisStreamName"] !== undefined) {
    contents.KinesisStreamName =
      output["KinesisStreamName"]["#text"] !== undefined
        ? output["KinesisStreamName"]["#text"]
        : output["KinesisStreamName"];
  }
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId =
      output["KmsKeyId"]["#text"] !== undefined
        ? output["KmsKeyId"]["#text"]
        : output["KmsKeyId"];
  }
  if (output["Mode"] !== undefined) {
    contents.Mode =
      output["Mode"]["#text"] !== undefined
        ? output["Mode"]["#text"]
        : output["Mode"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryStartDBClusterResult = (
  output: any,
  context: __SerdeContext
): StartDBClusterResult => {
  let contents: any = {
    __type: "StartDBClusterResult",
    DBCluster: undefined
  };
  if (output["DBCluster"] !== undefined) {
    contents.DBCluster = deserializeAws_queryDBCluster(
      output["DBCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryStartDBInstanceResult = (
  output: any,
  context: __SerdeContext
): StartDBInstanceResult => {
  let contents: any = {
    __type: "StartDBInstanceResult",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryStopActivityStreamResponse = (
  output: any,
  context: __SerdeContext
): StopActivityStreamResponse => {
  let contents: any = {
    __type: "StopActivityStreamResponse",
    KinesisStreamName: undefined,
    KmsKeyId: undefined,
    Status: undefined
  };
  if (output["KinesisStreamName"] !== undefined) {
    contents.KinesisStreamName =
      output["KinesisStreamName"]["#text"] !== undefined
        ? output["KinesisStreamName"]["#text"]
        : output["KinesisStreamName"];
  }
  if (output["KmsKeyId"] !== undefined) {
    contents.KmsKeyId =
      output["KmsKeyId"]["#text"] !== undefined
        ? output["KmsKeyId"]["#text"]
        : output["KmsKeyId"];
  }
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  return contents;
};

const deserializeAws_queryStopDBClusterResult = (
  output: any,
  context: __SerdeContext
): StopDBClusterResult => {
  let contents: any = {
    __type: "StopDBClusterResult",
    DBCluster: undefined
  };
  if (output["DBCluster"] !== undefined) {
    contents.DBCluster = deserializeAws_queryDBCluster(
      output["DBCluster"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryStopDBInstanceResult = (
  output: any,
  context: __SerdeContext
): StopDBInstanceResult => {
  let contents: any = {
    __type: "StopDBInstanceResult",
    DBInstance: undefined
  };
  if (output["DBInstance"] !== undefined) {
    contents.DBInstance = deserializeAws_queryDBInstance(
      output["DBInstance"],
      context
    );
  }
  return contents;
};

const deserializeAws_queryStringList = (
  output: any,
  context: __SerdeContext
): string[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(entry["#text"] !== undefined ? entry["#text"] : entry);
  });
  return contents;
};

const deserializeAws_querySubnet = (
  output: any,
  context: __SerdeContext
): Subnet => {
  let contents: any = {
    __type: "Subnet",
    SubnetAvailabilityZone: undefined,
    SubnetIdentifier: undefined,
    SubnetStatus: undefined
  };
  if (output["SubnetAvailabilityZone"] !== undefined) {
    contents.SubnetAvailabilityZone = deserializeAws_queryAvailabilityZone(
      output["SubnetAvailabilityZone"],
      context
    );
  }
  if (output["SubnetIdentifier"] !== undefined) {
    contents.SubnetIdentifier =
      output["SubnetIdentifier"]["#text"] !== undefined
        ? output["SubnetIdentifier"]["#text"]
        : output["SubnetIdentifier"];
  }
  if (output["SubnetStatus"] !== undefined) {
    contents.SubnetStatus =
      output["SubnetStatus"]["#text"] !== undefined
        ? output["SubnetStatus"]["#text"]
        : output["SubnetStatus"];
  }
  return contents;
};

const deserializeAws_querySubnetList = (
  output: any,
  context: __SerdeContext
): Subnet[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_querySubnet(entry, context));
  });
  return contents;
};

const deserializeAws_querySupportedCharacterSetsList = (
  output: any,
  context: __SerdeContext
): CharacterSet[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryCharacterSet(entry, context));
  });
  return contents;
};

const deserializeAws_querySupportedTimezonesList = (
  output: any,
  context: __SerdeContext
): Timezone[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryTimezone(entry, context));
  });
  return contents;
};

const deserializeAws_queryTag = (output: any, context: __SerdeContext): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output["Key"] !== undefined) {
    contents.Key =
      output["Key"]["#text"] !== undefined
        ? output["Key"]["#text"]
        : output["Key"];
  }
  if (output["Value"] !== undefined) {
    contents.Value =
      output["Value"]["#text"] !== undefined
        ? output["Value"]["#text"]
        : output["Value"];
  }
  return contents;
};

const deserializeAws_queryTagList = (
  output: any,
  context: __SerdeContext
): Tag[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryTag(entry, context));
  });
  return contents;
};

const deserializeAws_queryTagListMessage = (
  output: any,
  context: __SerdeContext
): TagListMessage => {
  let contents: any = {
    __type: "TagListMessage",
    TagList: undefined
  };
  if (output.TagList === "") {
    contents.TagList = [];
  }
  if (
    output["TagList"] !== undefined &&
    output["TagList"]["Tag"] !== undefined
  ) {
    contents.TagList = deserializeAws_queryTagList(
      __getArrayIfSingleItem(output["TagList"]["Tag"]),
      context
    );
  }
  return contents;
};

const deserializeAws_queryTargetGroupList = (
  output: any,
  context: __SerdeContext
): DBProxyTargetGroup[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBProxyTargetGroup(entry, context));
  });
  return contents;
};

const deserializeAws_queryTargetList = (
  output: any,
  context: __SerdeContext
): DBProxyTarget[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryDBProxyTarget(entry, context));
  });
  return contents;
};

const deserializeAws_queryTimezone = (
  output: any,
  context: __SerdeContext
): Timezone => {
  let contents: any = {
    __type: "Timezone",
    TimezoneName: undefined
  };
  if (output["TimezoneName"] !== undefined) {
    contents.TimezoneName =
      output["TimezoneName"]["#text"] !== undefined
        ? output["TimezoneName"]["#text"]
        : output["TimezoneName"];
  }
  return contents;
};

const deserializeAws_queryUpgradeTarget = (
  output: any,
  context: __SerdeContext
): UpgradeTarget => {
  let contents: any = {
    __type: "UpgradeTarget",
    AutoUpgrade: undefined,
    Description: undefined,
    Engine: undefined,
    EngineVersion: undefined,
    IsMajorVersionUpgrade: undefined
  };
  if (output["AutoUpgrade"] !== undefined) {
    contents.AutoUpgrade =
      (output["AutoUpgrade"]["#text"] !== undefined
        ? output["AutoUpgrade"]["#text"]
        : output["AutoUpgrade"]) == "true";
  }
  if (output["Description"] !== undefined) {
    contents.Description =
      output["Description"]["#text"] !== undefined
        ? output["Description"]["#text"]
        : output["Description"];
  }
  if (output["Engine"] !== undefined) {
    contents.Engine =
      output["Engine"]["#text"] !== undefined
        ? output["Engine"]["#text"]
        : output["Engine"];
  }
  if (output["EngineVersion"] !== undefined) {
    contents.EngineVersion =
      output["EngineVersion"]["#text"] !== undefined
        ? output["EngineVersion"]["#text"]
        : output["EngineVersion"];
  }
  if (output["IsMajorVersionUpgrade"] !== undefined) {
    contents.IsMajorVersionUpgrade =
      (output["IsMajorVersionUpgrade"]["#text"] !== undefined
        ? output["IsMajorVersionUpgrade"]["#text"]
        : output["IsMajorVersionUpgrade"]) == "true";
  }
  return contents;
};

const deserializeAws_queryUserAuthConfigInfo = (
  output: any,
  context: __SerdeContext
): UserAuthConfigInfo => {
  let contents: any = {
    __type: "UserAuthConfigInfo",
    AuthScheme: undefined,
    Description: undefined,
    IAMAuth: undefined,
    SecretArn: undefined,
    UserName: undefined
  };
  if (output["AuthScheme"] !== undefined) {
    contents.AuthScheme =
      output["AuthScheme"]["#text"] !== undefined
        ? output["AuthScheme"]["#text"]
        : output["AuthScheme"];
  }
  if (output["Description"] !== undefined) {
    contents.Description =
      output["Description"]["#text"] !== undefined
        ? output["Description"]["#text"]
        : output["Description"];
  }
  if (output["IAMAuth"] !== undefined) {
    contents.IAMAuth =
      output["IAMAuth"]["#text"] !== undefined
        ? output["IAMAuth"]["#text"]
        : output["IAMAuth"];
  }
  if (output["SecretArn"] !== undefined) {
    contents.SecretArn =
      output["SecretArn"]["#text"] !== undefined
        ? output["SecretArn"]["#text"]
        : output["SecretArn"];
  }
  if (output["UserName"] !== undefined) {
    contents.UserName =
      output["UserName"]["#text"] !== undefined
        ? output["UserName"]["#text"]
        : output["UserName"];
  }
  return contents;
};

const deserializeAws_queryUserAuthConfigInfoList = (
  output: any,
  context: __SerdeContext
): UserAuthConfigInfo[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryUserAuthConfigInfo(entry, context));
  });
  return contents;
};

const deserializeAws_queryValidDBInstanceModificationsMessage = (
  output: any,
  context: __SerdeContext
): ValidDBInstanceModificationsMessage => {
  let contents: any = {
    __type: "ValidDBInstanceModificationsMessage",
    Storage: undefined,
    ValidProcessorFeatures: undefined
  };
  if (output.Storage === "") {
    contents.Storage = [];
  }
  if (
    output["Storage"] !== undefined &&
    output["Storage"]["ValidStorageOptions"] !== undefined
  ) {
    contents.Storage = deserializeAws_queryValidStorageOptionsList(
      __getArrayIfSingleItem(output["Storage"]["ValidStorageOptions"]),
      context
    );
  }
  if (output.ValidProcessorFeatures === "") {
    contents.ValidProcessorFeatures = [];
  }
  if (
    output["ValidProcessorFeatures"] !== undefined &&
    output["ValidProcessorFeatures"]["AvailableProcessorFeature"] !== undefined
  ) {
    contents.ValidProcessorFeatures = deserializeAws_queryAvailableProcessorFeatureList(
      __getArrayIfSingleItem(
        output["ValidProcessorFeatures"]["AvailableProcessorFeature"]
      ),
      context
    );
  }
  return contents;
};

const deserializeAws_queryValidStorageOptions = (
  output: any,
  context: __SerdeContext
): ValidStorageOptions => {
  let contents: any = {
    __type: "ValidStorageOptions",
    IopsToStorageRatio: undefined,
    ProvisionedIops: undefined,
    StorageSize: undefined,
    StorageType: undefined,
    SupportsStorageAutoscaling: undefined
  };
  if (output.IopsToStorageRatio === "") {
    contents.IopsToStorageRatio = [];
  }
  if (
    output["IopsToStorageRatio"] !== undefined &&
    output["IopsToStorageRatio"]["DoubleRange"] !== undefined
  ) {
    contents.IopsToStorageRatio = deserializeAws_queryDoubleRangeList(
      __getArrayIfSingleItem(output["IopsToStorageRatio"]["DoubleRange"]),
      context
    );
  }
  if (output.ProvisionedIops === "") {
    contents.ProvisionedIops = [];
  }
  if (
    output["ProvisionedIops"] !== undefined &&
    output["ProvisionedIops"]["Range"] !== undefined
  ) {
    contents.ProvisionedIops = deserializeAws_queryRangeList(
      __getArrayIfSingleItem(output["ProvisionedIops"]["Range"]),
      context
    );
  }
  if (output.StorageSize === "") {
    contents.StorageSize = [];
  }
  if (
    output["StorageSize"] !== undefined &&
    output["StorageSize"]["Range"] !== undefined
  ) {
    contents.StorageSize = deserializeAws_queryRangeList(
      __getArrayIfSingleItem(output["StorageSize"]["Range"]),
      context
    );
  }
  if (output["StorageType"] !== undefined) {
    contents.StorageType =
      output["StorageType"]["#text"] !== undefined
        ? output["StorageType"]["#text"]
        : output["StorageType"];
  }
  if (output["SupportsStorageAutoscaling"] !== undefined) {
    contents.SupportsStorageAutoscaling =
      (output["SupportsStorageAutoscaling"]["#text"] !== undefined
        ? output["SupportsStorageAutoscaling"]["#text"]
        : output["SupportsStorageAutoscaling"]) == "true";
  }
  return contents;
};

const deserializeAws_queryValidStorageOptionsList = (
  output: any,
  context: __SerdeContext
): ValidStorageOptions[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryValidStorageOptions(entry, context));
  });
  return contents;
};

const deserializeAws_queryValidUpgradeTargetList = (
  output: any,
  context: __SerdeContext
): UpgradeTarget[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(deserializeAws_queryUpgradeTarget(entry, context));
  });
  return contents;
};

const deserializeAws_queryVpcSecurityGroupMembership = (
  output: any,
  context: __SerdeContext
): VpcSecurityGroupMembership => {
  let contents: any = {
    __type: "VpcSecurityGroupMembership",
    Status: undefined,
    VpcSecurityGroupId: undefined
  };
  if (output["Status"] !== undefined) {
    contents.Status =
      output["Status"]["#text"] !== undefined
        ? output["Status"]["#text"]
        : output["Status"];
  }
  if (output["VpcSecurityGroupId"] !== undefined) {
    contents.VpcSecurityGroupId =
      output["VpcSecurityGroupId"]["#text"] !== undefined
        ? output["VpcSecurityGroupId"]["#text"]
        : output["VpcSecurityGroupId"];
  }
  return contents;
};

const deserializeAws_queryVpcSecurityGroupMembershipList = (
  output: any,
  context: __SerdeContext
): VpcSecurityGroupMembership[] => {
  const contents: any = [];
  (output || []).map((entry: any) => {
    contents.push(
      deserializeAws_queryVpcSecurityGroupMembership(entry, context)
    );
  });
  return contents;
};

const deserializeAws_queryVpnDetails = (
  output: any,
  context: __SerdeContext
): VpnDetails => {
  let contents: any = {
    __type: "VpnDetails",
    VpnGatewayIp: undefined,
    VpnId: undefined,
    VpnName: undefined,
    VpnPSK: undefined,
    VpnState: undefined,
    VpnTunnelOriginatorIP: undefined
  };
  if (output["VpnGatewayIp"] !== undefined) {
    contents.VpnGatewayIp =
      output["VpnGatewayIp"]["#text"] !== undefined
        ? output["VpnGatewayIp"]["#text"]
        : output["VpnGatewayIp"];
  }
  if (output["VpnId"] !== undefined) {
    contents.VpnId =
      output["VpnId"]["#text"] !== undefined
        ? output["VpnId"]["#text"]
        : output["VpnId"];
  }
  if (output["VpnName"] !== undefined) {
    contents.VpnName =
      output["VpnName"]["#text"] !== undefined
        ? output["VpnName"]["#text"]
        : output["VpnName"];
  }
  if (output["VpnPSK"] !== undefined) {
    contents.VpnPSK =
      output["VpnPSK"]["#text"] !== undefined
        ? output["VpnPSK"]["#text"]
        : output["VpnPSK"];
  }
  if (output["VpnState"] !== undefined) {
    contents.VpnState =
      output["VpnState"]["#text"] !== undefined
        ? output["VpnState"]["#text"]
        : output["VpnState"];
  }
  if (output["VpnTunnelOriginatorIP"] !== undefined) {
    contents.VpnTunnelOriginatorIP =
      output["VpnTunnelOriginatorIP"]["#text"] !== undefined
        ? output["VpnTunnelOriginatorIP"]["#text"]
        : output["VpnTunnelOriginatorIP"];
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any = new Uint8Array(),
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> =>
  collectBody(streamBody, context).then(body => context.utf8Encoder(body));

const buildHttpRpcRequest = async (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port } = await context.endpoint();
  const contents: any = {
    protocol,
    hostname,
    port,
    method: "POST",
    path,
    headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const decodeEscapedXML = (str: string) =>
  str
    .replace(/&amp;/g, "&")
    .replace(/&apos;/g, "'")
    .replace(/&quot;/g, '"')
    .replace(/&gt;/g, ">")
    .replace(/&lt;/g, "<");

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      const parsedObj = xmlParse(encoded, {
        attributeNamePrefix: "",
        ignoreAttributes: false,
        parseNodeValue: false,
        tagValueProcessor: (val, tagName) => decodeEscapedXML(val)
      });
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return parsedObjToReturn;
    }
    return {};
  });

const buildFormUrlencodedString = (entries: any): string =>
  Object.keys(entries)
    .map(
      key =>
        __extendedEncodeURIComponent(key) +
        "=" +
        __extendedEncodeURIComponent(entries[key])
    )
    .join("&");

const loadQueryErrorCode = (output: __HttpResponse, data: any): string => {
  if (data.Error.Code !== undefined) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
  return "";
};
