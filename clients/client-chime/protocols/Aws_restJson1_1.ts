import {
  AssociatePhoneNumberWithUserCommandInput,
  AssociatePhoneNumberWithUserCommandOutput
} from "../commands/AssociatePhoneNumberWithUserCommand";
import {
  AssociatePhoneNumbersWithVoiceConnectorCommandInput,
  AssociatePhoneNumbersWithVoiceConnectorCommandOutput
} from "../commands/AssociatePhoneNumbersWithVoiceConnectorCommand";
import {
  AssociatePhoneNumbersWithVoiceConnectorGroupCommandInput,
  AssociatePhoneNumbersWithVoiceConnectorGroupCommandOutput
} from "../commands/AssociatePhoneNumbersWithVoiceConnectorGroupCommand";
import {
  AssociateSigninDelegateGroupsWithAccountCommandInput,
  AssociateSigninDelegateGroupsWithAccountCommandOutput
} from "../commands/AssociateSigninDelegateGroupsWithAccountCommand";
import {
  BatchCreateAttendeeCommandInput,
  BatchCreateAttendeeCommandOutput
} from "../commands/BatchCreateAttendeeCommand";
import {
  BatchCreateRoomMembershipCommandInput,
  BatchCreateRoomMembershipCommandOutput
} from "../commands/BatchCreateRoomMembershipCommand";
import {
  BatchDeletePhoneNumberCommandInput,
  BatchDeletePhoneNumberCommandOutput
} from "../commands/BatchDeletePhoneNumberCommand";
import {
  BatchSuspendUserCommandInput,
  BatchSuspendUserCommandOutput
} from "../commands/BatchSuspendUserCommand";
import {
  BatchUnsuspendUserCommandInput,
  BatchUnsuspendUserCommandOutput
} from "../commands/BatchUnsuspendUserCommand";
import {
  BatchUpdatePhoneNumberCommandInput,
  BatchUpdatePhoneNumberCommandOutput
} from "../commands/BatchUpdatePhoneNumberCommand";
import {
  BatchUpdateUserCommandInput,
  BatchUpdateUserCommandOutput
} from "../commands/BatchUpdateUserCommand";
import {
  CreateAccountCommandInput,
  CreateAccountCommandOutput
} from "../commands/CreateAccountCommand";
import {
  CreateAttendeeCommandInput,
  CreateAttendeeCommandOutput
} from "../commands/CreateAttendeeCommand";
import {
  CreateBotCommandInput,
  CreateBotCommandOutput
} from "../commands/CreateBotCommand";
import {
  CreateMeetingCommandInput,
  CreateMeetingCommandOutput
} from "../commands/CreateMeetingCommand";
import {
  CreatePhoneNumberOrderCommandInput,
  CreatePhoneNumberOrderCommandOutput
} from "../commands/CreatePhoneNumberOrderCommand";
import {
  CreateRoomCommandInput,
  CreateRoomCommandOutput
} from "../commands/CreateRoomCommand";
import {
  CreateRoomMembershipCommandInput,
  CreateRoomMembershipCommandOutput
} from "../commands/CreateRoomMembershipCommand";
import {
  CreateUserCommandInput,
  CreateUserCommandOutput
} from "../commands/CreateUserCommand";
import {
  CreateVoiceConnectorCommandInput,
  CreateVoiceConnectorCommandOutput
} from "../commands/CreateVoiceConnectorCommand";
import {
  CreateVoiceConnectorGroupCommandInput,
  CreateVoiceConnectorGroupCommandOutput
} from "../commands/CreateVoiceConnectorGroupCommand";
import {
  DeleteAccountCommandInput,
  DeleteAccountCommandOutput
} from "../commands/DeleteAccountCommand";
import {
  DeleteAttendeeCommandInput,
  DeleteAttendeeCommandOutput
} from "../commands/DeleteAttendeeCommand";
import {
  DeleteEventsConfigurationCommandInput,
  DeleteEventsConfigurationCommandOutput
} from "../commands/DeleteEventsConfigurationCommand";
import {
  DeleteMeetingCommandInput,
  DeleteMeetingCommandOutput
} from "../commands/DeleteMeetingCommand";
import {
  DeletePhoneNumberCommandInput,
  DeletePhoneNumberCommandOutput
} from "../commands/DeletePhoneNumberCommand";
import {
  DeleteRoomCommandInput,
  DeleteRoomCommandOutput
} from "../commands/DeleteRoomCommand";
import {
  DeleteRoomMembershipCommandInput,
  DeleteRoomMembershipCommandOutput
} from "../commands/DeleteRoomMembershipCommand";
import {
  DeleteVoiceConnectorCommandInput,
  DeleteVoiceConnectorCommandOutput
} from "../commands/DeleteVoiceConnectorCommand";
import {
  DeleteVoiceConnectorGroupCommandInput,
  DeleteVoiceConnectorGroupCommandOutput
} from "../commands/DeleteVoiceConnectorGroupCommand";
import {
  DeleteVoiceConnectorOriginationCommandInput,
  DeleteVoiceConnectorOriginationCommandOutput
} from "../commands/DeleteVoiceConnectorOriginationCommand";
import {
  DeleteVoiceConnectorStreamingConfigurationCommandInput,
  DeleteVoiceConnectorStreamingConfigurationCommandOutput
} from "../commands/DeleteVoiceConnectorStreamingConfigurationCommand";
import {
  DeleteVoiceConnectorTerminationCommandInput,
  DeleteVoiceConnectorTerminationCommandOutput
} from "../commands/DeleteVoiceConnectorTerminationCommand";
import {
  DeleteVoiceConnectorTerminationCredentialsCommandInput,
  DeleteVoiceConnectorTerminationCredentialsCommandOutput
} from "../commands/DeleteVoiceConnectorTerminationCredentialsCommand";
import {
  DisassociatePhoneNumberFromUserCommandInput,
  DisassociatePhoneNumberFromUserCommandOutput
} from "../commands/DisassociatePhoneNumberFromUserCommand";
import {
  DisassociatePhoneNumbersFromVoiceConnectorCommandInput,
  DisassociatePhoneNumbersFromVoiceConnectorCommandOutput
} from "../commands/DisassociatePhoneNumbersFromVoiceConnectorCommand";
import {
  DisassociatePhoneNumbersFromVoiceConnectorGroupCommandInput,
  DisassociatePhoneNumbersFromVoiceConnectorGroupCommandOutput
} from "../commands/DisassociatePhoneNumbersFromVoiceConnectorGroupCommand";
import {
  DisassociateSigninDelegateGroupsFromAccountCommandInput,
  DisassociateSigninDelegateGroupsFromAccountCommandOutput
} from "../commands/DisassociateSigninDelegateGroupsFromAccountCommand";
import {
  GetAccountCommandInput,
  GetAccountCommandOutput
} from "../commands/GetAccountCommand";
import {
  GetAccountSettingsCommandInput,
  GetAccountSettingsCommandOutput
} from "../commands/GetAccountSettingsCommand";
import {
  GetAttendeeCommandInput,
  GetAttendeeCommandOutput
} from "../commands/GetAttendeeCommand";
import {
  GetBotCommandInput,
  GetBotCommandOutput
} from "../commands/GetBotCommand";
import {
  GetEventsConfigurationCommandInput,
  GetEventsConfigurationCommandOutput
} from "../commands/GetEventsConfigurationCommand";
import {
  GetGlobalSettingsCommandInput,
  GetGlobalSettingsCommandOutput
} from "../commands/GetGlobalSettingsCommand";
import {
  GetMeetingCommandInput,
  GetMeetingCommandOutput
} from "../commands/GetMeetingCommand";
import {
  GetPhoneNumberCommandInput,
  GetPhoneNumberCommandOutput
} from "../commands/GetPhoneNumberCommand";
import {
  GetPhoneNumberOrderCommandInput,
  GetPhoneNumberOrderCommandOutput
} from "../commands/GetPhoneNumberOrderCommand";
import {
  GetPhoneNumberSettingsCommandInput,
  GetPhoneNumberSettingsCommandOutput
} from "../commands/GetPhoneNumberSettingsCommand";
import {
  GetRoomCommandInput,
  GetRoomCommandOutput
} from "../commands/GetRoomCommand";
import {
  GetUserCommandInput,
  GetUserCommandOutput
} from "../commands/GetUserCommand";
import {
  GetUserSettingsCommandInput,
  GetUserSettingsCommandOutput
} from "../commands/GetUserSettingsCommand";
import {
  GetVoiceConnectorCommandInput,
  GetVoiceConnectorCommandOutput
} from "../commands/GetVoiceConnectorCommand";
import {
  GetVoiceConnectorGroupCommandInput,
  GetVoiceConnectorGroupCommandOutput
} from "../commands/GetVoiceConnectorGroupCommand";
import {
  GetVoiceConnectorLoggingConfigurationCommandInput,
  GetVoiceConnectorLoggingConfigurationCommandOutput
} from "../commands/GetVoiceConnectorLoggingConfigurationCommand";
import {
  GetVoiceConnectorOriginationCommandInput,
  GetVoiceConnectorOriginationCommandOutput
} from "../commands/GetVoiceConnectorOriginationCommand";
import {
  GetVoiceConnectorStreamingConfigurationCommandInput,
  GetVoiceConnectorStreamingConfigurationCommandOutput
} from "../commands/GetVoiceConnectorStreamingConfigurationCommand";
import {
  GetVoiceConnectorTerminationCommandInput,
  GetVoiceConnectorTerminationCommandOutput
} from "../commands/GetVoiceConnectorTerminationCommand";
import {
  GetVoiceConnectorTerminationHealthCommandInput,
  GetVoiceConnectorTerminationHealthCommandOutput
} from "../commands/GetVoiceConnectorTerminationHealthCommand";
import {
  InviteUsersCommandInput,
  InviteUsersCommandOutput
} from "../commands/InviteUsersCommand";
import {
  ListAccountsCommandInput,
  ListAccountsCommandOutput
} from "../commands/ListAccountsCommand";
import {
  ListAttendeesCommandInput,
  ListAttendeesCommandOutput
} from "../commands/ListAttendeesCommand";
import {
  ListBotsCommandInput,
  ListBotsCommandOutput
} from "../commands/ListBotsCommand";
import {
  ListMeetingsCommandInput,
  ListMeetingsCommandOutput
} from "../commands/ListMeetingsCommand";
import {
  ListPhoneNumberOrdersCommandInput,
  ListPhoneNumberOrdersCommandOutput
} from "../commands/ListPhoneNumberOrdersCommand";
import {
  ListPhoneNumbersCommandInput,
  ListPhoneNumbersCommandOutput
} from "../commands/ListPhoneNumbersCommand";
import {
  ListRoomMembershipsCommandInput,
  ListRoomMembershipsCommandOutput
} from "../commands/ListRoomMembershipsCommand";
import {
  ListRoomsCommandInput,
  ListRoomsCommandOutput
} from "../commands/ListRoomsCommand";
import {
  ListUsersCommandInput,
  ListUsersCommandOutput
} from "../commands/ListUsersCommand";
import {
  ListVoiceConnectorGroupsCommandInput,
  ListVoiceConnectorGroupsCommandOutput
} from "../commands/ListVoiceConnectorGroupsCommand";
import {
  ListVoiceConnectorTerminationCredentialsCommandInput,
  ListVoiceConnectorTerminationCredentialsCommandOutput
} from "../commands/ListVoiceConnectorTerminationCredentialsCommand";
import {
  ListVoiceConnectorsCommandInput,
  ListVoiceConnectorsCommandOutput
} from "../commands/ListVoiceConnectorsCommand";
import {
  LogoutUserCommandInput,
  LogoutUserCommandOutput
} from "../commands/LogoutUserCommand";
import {
  PutEventsConfigurationCommandInput,
  PutEventsConfigurationCommandOutput
} from "../commands/PutEventsConfigurationCommand";
import {
  PutVoiceConnectorLoggingConfigurationCommandInput,
  PutVoiceConnectorLoggingConfigurationCommandOutput
} from "../commands/PutVoiceConnectorLoggingConfigurationCommand";
import {
  PutVoiceConnectorOriginationCommandInput,
  PutVoiceConnectorOriginationCommandOutput
} from "../commands/PutVoiceConnectorOriginationCommand";
import {
  PutVoiceConnectorStreamingConfigurationCommandInput,
  PutVoiceConnectorStreamingConfigurationCommandOutput
} from "../commands/PutVoiceConnectorStreamingConfigurationCommand";
import {
  PutVoiceConnectorTerminationCommandInput,
  PutVoiceConnectorTerminationCommandOutput
} from "../commands/PutVoiceConnectorTerminationCommand";
import {
  PutVoiceConnectorTerminationCredentialsCommandInput,
  PutVoiceConnectorTerminationCredentialsCommandOutput
} from "../commands/PutVoiceConnectorTerminationCredentialsCommand";
import {
  RegenerateSecurityTokenCommandInput,
  RegenerateSecurityTokenCommandOutput
} from "../commands/RegenerateSecurityTokenCommand";
import {
  ResetPersonalPINCommandInput,
  ResetPersonalPINCommandOutput
} from "../commands/ResetPersonalPINCommand";
import {
  RestorePhoneNumberCommandInput,
  RestorePhoneNumberCommandOutput
} from "../commands/RestorePhoneNumberCommand";
import {
  SearchAvailablePhoneNumbersCommandInput,
  SearchAvailablePhoneNumbersCommandOutput
} from "../commands/SearchAvailablePhoneNumbersCommand";
import {
  UpdateAccountCommandInput,
  UpdateAccountCommandOutput
} from "../commands/UpdateAccountCommand";
import {
  UpdateAccountSettingsCommandInput,
  UpdateAccountSettingsCommandOutput
} from "../commands/UpdateAccountSettingsCommand";
import {
  UpdateBotCommandInput,
  UpdateBotCommandOutput
} from "../commands/UpdateBotCommand";
import {
  UpdateGlobalSettingsCommandInput,
  UpdateGlobalSettingsCommandOutput
} from "../commands/UpdateGlobalSettingsCommand";
import {
  UpdatePhoneNumberCommandInput,
  UpdatePhoneNumberCommandOutput
} from "../commands/UpdatePhoneNumberCommand";
import {
  UpdatePhoneNumberSettingsCommandInput,
  UpdatePhoneNumberSettingsCommandOutput
} from "../commands/UpdatePhoneNumberSettingsCommand";
import {
  UpdateRoomCommandInput,
  UpdateRoomCommandOutput
} from "../commands/UpdateRoomCommand";
import {
  UpdateRoomMembershipCommandInput,
  UpdateRoomMembershipCommandOutput
} from "../commands/UpdateRoomMembershipCommand";
import {
  UpdateUserCommandInput,
  UpdateUserCommandOutput
} from "../commands/UpdateUserCommand";
import {
  UpdateUserSettingsCommandInput,
  UpdateUserSettingsCommandOutput
} from "../commands/UpdateUserSettingsCommand";
import {
  UpdateVoiceConnectorCommandInput,
  UpdateVoiceConnectorCommandOutput
} from "../commands/UpdateVoiceConnectorCommand";
import {
  UpdateVoiceConnectorGroupCommandInput,
  UpdateVoiceConnectorGroupCommandOutput
} from "../commands/UpdateVoiceConnectorGroupCommand";
import {
  AccessDeniedException,
  Account,
  AccountSettings,
  AlexaForBusinessMetadata,
  Attendee,
  BadRequestException,
  Bot,
  BusinessCallingSettings,
  ConflictException,
  CreateAttendeeError,
  CreateAttendeeRequestItem,
  Credential,
  EventsConfiguration,
  ForbiddenException,
  Invite,
  License,
  LoggingConfiguration,
  MediaPlacement,
  Meeting,
  MeetingNotificationConfiguration,
  Member,
  MemberError,
  MembershipItem,
  NotFoundException,
  OrderedPhoneNumber,
  Origination,
  OriginationRoute,
  PhoneNumber,
  PhoneNumberAssociation,
  PhoneNumberCapabilities,
  PhoneNumberError,
  PhoneNumberOrder,
  ResourceLimitExceededException,
  Room,
  RoomMembership,
  ServiceFailureException,
  ServiceUnavailableException,
  SigninDelegateGroup,
  StreamingConfiguration,
  TelephonySettings,
  Termination,
  TerminationHealth,
  ThrottledClientException,
  UnauthorizedClientException,
  UnprocessableEntityException,
  UpdatePhoneNumberRequestItem,
  UpdateUserRequestItem,
  User,
  UserError,
  UserSettings,
  VoiceConnector,
  VoiceConnectorGroup,
  VoiceConnectorItem,
  VoiceConnectorSettings
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import { v4 as generateIdempotencyToken } from "uuid";

export async function serializeAws_restJson1_1AssociatePhoneNumberWithUserCommand(
  input: AssociatePhoneNumberWithUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue: string = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  const query: any = {
    operation: "associate-phone-number"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.E164PhoneNumber !== undefined) {
    bodyParams["E164PhoneNumber"] = input.E164PhoneNumber;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1AssociatePhoneNumbersWithVoiceConnectorCommand(
  input: AssociatePhoneNumbersWithVoiceConnectorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  const query: any = {
    operation: "associate-phone-numbers"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.E164PhoneNumbers !== undefined) {
    bodyParams[
      "E164PhoneNumbers"
    ] = serializeAws_restJson1_1E164PhoneNumberList(
      input.E164PhoneNumbers,
      context
    );
  }
  if (input.ForceAssociate !== undefined) {
    bodyParams["ForceAssociate"] = input.ForceAssociate;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1AssociatePhoneNumbersWithVoiceConnectorGroupCommand(
  input: AssociatePhoneNumbersWithVoiceConnectorGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/voice-connector-groups/{VoiceConnectorGroupId}";
  if (input.VoiceConnectorGroupId !== undefined) {
    const labelValue: string = input.VoiceConnectorGroupId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorGroupId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorGroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorGroupId."
    );
  }
  const query: any = {
    operation: "associate-phone-numbers"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.E164PhoneNumbers !== undefined) {
    bodyParams[
      "E164PhoneNumbers"
    ] = serializeAws_restJson1_1E164PhoneNumberList(
      input.E164PhoneNumbers,
      context
    );
  }
  if (input.ForceAssociate !== undefined) {
    bodyParams["ForceAssociate"] = input.ForceAssociate;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1AssociateSigninDelegateGroupsWithAccountCommand(
  input: AssociateSigninDelegateGroupsWithAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query: any = {
    operation: "associate-signin-delegate-groups"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.SigninDelegateGroups !== undefined) {
    bodyParams[
      "SigninDelegateGroups"
    ] = serializeAws_restJson1_1SigninDelegateGroupList(
      input.SigninDelegateGroups,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1BatchCreateAttendeeCommand(
  input: BatchCreateAttendeeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/meetings/{MeetingId}/attendees";
  if (input.MeetingId !== undefined) {
    const labelValue: string = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace(
      "{MeetingId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  const query: any = {
    operation: "batch-create"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.Attendees !== undefined) {
    bodyParams[
      "Attendees"
    ] = serializeAws_restJson1_1CreateAttendeeRequestItemList(
      input.Attendees,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1BatchCreateRoomMembershipCommand(
  input: BatchCreateRoomMembershipCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}/memberships";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue: string = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace(
      "{RoomId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  const query: any = {
    operation: "batch-create"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.MembershipItemList !== undefined) {
    bodyParams[
      "MembershipItemList"
    ] = serializeAws_restJson1_1MembershipItemList(
      input.MembershipItemList,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1BatchDeletePhoneNumberCommand(
  input: BatchDeletePhoneNumberCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/phone-numbers";
  const query: any = {
    operation: "batch-delete"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.PhoneNumberIds !== undefined) {
    bodyParams["PhoneNumberIds"] = serializeAws_restJson1_1NonEmptyStringList(
      input.PhoneNumberIds,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1BatchSuspendUserCommand(
  input: BatchSuspendUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query: any = {
    operation: "suspend"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.UserIdList !== undefined) {
    bodyParams["UserIdList"] = serializeAws_restJson1_1UserIdList(
      input.UserIdList,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1BatchUnsuspendUserCommand(
  input: BatchUnsuspendUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query: any = {
    operation: "unsuspend"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.UserIdList !== undefined) {
    bodyParams["UserIdList"] = serializeAws_restJson1_1UserIdList(
      input.UserIdList,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1BatchUpdatePhoneNumberCommand(
  input: BatchUpdatePhoneNumberCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/phone-numbers";
  const query: any = {
    operation: "batch-update"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.UpdatePhoneNumberRequestItems !== undefined) {
    bodyParams[
      "UpdatePhoneNumberRequestItems"
    ] = serializeAws_restJson1_1UpdatePhoneNumberRequestItemList(
      input.UpdatePhoneNumberRequestItems,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1BatchUpdateUserCommand(
  input: BatchUpdateUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.UpdateUserRequestItems !== undefined) {
    bodyParams[
      "UpdateUserRequestItems"
    ] = serializeAws_restJson1_1UpdateUserRequestItemList(
      input.UpdateUserRequestItems,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateAccountCommand(
  input: CreateAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts";
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateAttendeeCommand(
  input: CreateAttendeeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/meetings/{MeetingId}/attendees";
  if (input.MeetingId !== undefined) {
    const labelValue: string = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace(
      "{MeetingId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.ExternalUserId !== undefined) {
    bodyParams["ExternalUserId"] = input.ExternalUserId;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateBotCommand(
  input: CreateBotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/bots";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.DisplayName !== undefined) {
    bodyParams["DisplayName"] = input.DisplayName;
  }
  if (input.Domain !== undefined) {
    bodyParams["Domain"] = input.Domain;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateMeetingCommand(
  input: CreateMeetingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/meetings";
  let body: any;
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.MediaRegion !== undefined) {
    bodyParams["MediaRegion"] = input.MediaRegion;
  }
  if (input.MeetingHostId !== undefined) {
    bodyParams["MeetingHostId"] = input.MeetingHostId;
  }
  if (input.NotificationsConfiguration !== undefined) {
    bodyParams[
      "NotificationsConfiguration"
    ] = serializeAws_restJson1_1MeetingNotificationConfiguration(
      input.NotificationsConfiguration,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreatePhoneNumberOrderCommand(
  input: CreatePhoneNumberOrderCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/phone-number-orders";
  let body: any;
  const bodyParams: any = {};
  if (input.E164PhoneNumbers !== undefined) {
    bodyParams[
      "E164PhoneNumbers"
    ] = serializeAws_restJson1_1E164PhoneNumberList(
      input.E164PhoneNumbers,
      context
    );
  }
  if (input.ProductType !== undefined) {
    bodyParams["ProductType"] = input.ProductType;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateRoomCommand(
  input: CreateRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/rooms";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.ClientRequestToken === undefined) {
    input.ClientRequestToken = generateIdempotencyToken();
  }
  if (input.ClientRequestToken !== undefined) {
    bodyParams["ClientRequestToken"] = input.ClientRequestToken;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateRoomMembershipCommand(
  input: CreateRoomMembershipCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}/memberships";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue: string = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace(
      "{RoomId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.MemberId !== undefined) {
    bodyParams["MemberId"] = input.MemberId;
  }
  if (input.Role !== undefined) {
    bodyParams["Role"] = input.Role;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateUserCommand(
  input: CreateUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query: any = {
    operation: "create"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.Email !== undefined) {
    bodyParams["Email"] = input.Email;
  }
  if (input.UserType !== undefined) {
    bodyParams["UserType"] = input.UserType;
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateVoiceConnectorCommand(
  input: CreateVoiceConnectorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/voice-connectors";
  let body: any;
  const bodyParams: any = {};
  if (input.AwsRegion !== undefined) {
    bodyParams["AwsRegion"] = input.AwsRegion;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RequireEncryption !== undefined) {
    bodyParams["RequireEncryption"] = input.RequireEncryption;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateVoiceConnectorGroupCommand(
  input: CreateVoiceConnectorGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/voice-connector-groups";
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.VoiceConnectorItems !== undefined) {
    bodyParams[
      "VoiceConnectorItems"
    ] = serializeAws_restJson1_1VoiceConnectorItemList(
      input.VoiceConnectorItems,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteAccountCommand(
  input: DeleteAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteAttendeeCommand(
  input: DeleteAttendeeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/meetings/{MeetingId}/attendees/{AttendeeId}";
  if (input.AttendeeId !== undefined) {
    const labelValue: string = input.AttendeeId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AttendeeId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AttendeeId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AttendeeId.");
  }
  if (input.MeetingId !== undefined) {
    const labelValue: string = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace(
      "{MeetingId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteEventsConfigurationCommand(
  input: DeleteEventsConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}/events-configuration";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue: string = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace(
      "{BotId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteMeetingCommand(
  input: DeleteMeetingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/meetings/{MeetingId}";
  if (input.MeetingId !== undefined) {
    const labelValue: string = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace(
      "{MeetingId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeletePhoneNumberCommand(
  input: DeletePhoneNumberCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/phone-numbers/{PhoneNumberId}";
  if (input.PhoneNumberId !== undefined) {
    const labelValue: string = input.PhoneNumberId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: PhoneNumberId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{PhoneNumberId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: PhoneNumberId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteRoomCommand(
  input: DeleteRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue: string = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace(
      "{RoomId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteRoomMembershipCommand(
  input: DeleteRoomMembershipCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AccountId}/rooms/{RoomId}/memberships/{MemberId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.MemberId !== undefined) {
    const labelValue: string = input.MemberId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MemberId.");
    }
    resolvedPath = resolvedPath.replace(
      "{MemberId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MemberId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue: string = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace(
      "{RoomId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteVoiceConnectorCommand(
  input: DeleteVoiceConnectorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteVoiceConnectorGroupCommand(
  input: DeleteVoiceConnectorGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connector-groups/{VoiceConnectorGroupId}";
  if (input.VoiceConnectorGroupId !== undefined) {
    const labelValue: string = input.VoiceConnectorGroupId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorGroupId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorGroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorGroupId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteVoiceConnectorOriginationCommand(
  input: DeleteVoiceConnectorOriginationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/origination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteVoiceConnectorStreamingConfigurationCommand(
  input: DeleteVoiceConnectorStreamingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/voice-connectors/{VoiceConnectorId}/streaming-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteVoiceConnectorTerminationCommand(
  input: DeleteVoiceConnectorTerminationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteVoiceConnectorTerminationCredentialsCommand(
  input: DeleteVoiceConnectorTerminationCredentialsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/voice-connectors/{VoiceConnectorId}/termination/credentials";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  const query: any = {
    operation: "delete"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.Usernames !== undefined) {
    bodyParams["Usernames"] = serializeAws_restJson1_1SensitiveStringList(
      input.Usernames,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1DisassociatePhoneNumberFromUserCommand(
  input: DisassociatePhoneNumberFromUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue: string = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  const query: any = {
    operation: "disassociate-phone-number"
  };
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DisassociatePhoneNumbersFromVoiceConnectorCommand(
  input: DisassociatePhoneNumbersFromVoiceConnectorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  const query: any = {
    operation: "disassociate-phone-numbers"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.E164PhoneNumbers !== undefined) {
    bodyParams[
      "E164PhoneNumbers"
    ] = serializeAws_restJson1_1E164PhoneNumberList(
      input.E164PhoneNumbers,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1DisassociatePhoneNumbersFromVoiceConnectorGroupCommand(
  input: DisassociatePhoneNumbersFromVoiceConnectorGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/voice-connector-groups/{VoiceConnectorGroupId}";
  if (input.VoiceConnectorGroupId !== undefined) {
    const labelValue: string = input.VoiceConnectorGroupId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorGroupId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorGroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorGroupId."
    );
  }
  const query: any = {
    operation: "disassociate-phone-numbers"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.E164PhoneNumbers !== undefined) {
    bodyParams[
      "E164PhoneNumbers"
    ] = serializeAws_restJson1_1E164PhoneNumberList(
      input.E164PhoneNumbers,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1DisassociateSigninDelegateGroupsFromAccountCommand(
  input: DisassociateSigninDelegateGroupsFromAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query: any = {
    operation: "disassociate-signin-delegate-groups"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.GroupNames !== undefined) {
    bodyParams["GroupNames"] = serializeAws_restJson1_1NonEmptyStringList(
      input.GroupNames,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetAccountCommand(
  input: GetAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetAccountSettingsCommand(
  input: GetAccountSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/settings";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetAttendeeCommand(
  input: GetAttendeeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/meetings/{MeetingId}/attendees/{AttendeeId}";
  if (input.AttendeeId !== undefined) {
    const labelValue: string = input.AttendeeId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AttendeeId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AttendeeId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AttendeeId.");
  }
  if (input.MeetingId !== undefined) {
    const labelValue: string = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace(
      "{MeetingId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetBotCommand(
  input: GetBotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue: string = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace(
      "{BotId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetEventsConfigurationCommand(
  input: GetEventsConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}/events-configuration";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue: string = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace(
      "{BotId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetGlobalSettingsCommand(
  input: GetGlobalSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/settings";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetMeetingCommand(
  input: GetMeetingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/meetings/{MeetingId}";
  if (input.MeetingId !== undefined) {
    const labelValue: string = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace(
      "{MeetingId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetPhoneNumberCommand(
  input: GetPhoneNumberCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/phone-numbers/{PhoneNumberId}";
  if (input.PhoneNumberId !== undefined) {
    const labelValue: string = input.PhoneNumberId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: PhoneNumberId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{PhoneNumberId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: PhoneNumberId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetPhoneNumberOrderCommand(
  input: GetPhoneNumberOrderCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/phone-number-orders/{PhoneNumberOrderId}";
  if (input.PhoneNumberOrderId !== undefined) {
    const labelValue: string = input.PhoneNumberOrderId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: PhoneNumberOrderId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{PhoneNumberOrderId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: PhoneNumberOrderId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetPhoneNumberSettingsCommand(
  input: GetPhoneNumberSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/settings/phone-number";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetRoomCommand(
  input: GetRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue: string = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace(
      "{RoomId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetUserCommand(
  input: GetUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue: string = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetUserSettingsCommand(
  input: GetUserSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}/settings";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue: string = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetVoiceConnectorCommand(
  input: GetVoiceConnectorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetVoiceConnectorGroupCommand(
  input: GetVoiceConnectorGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connector-groups/{VoiceConnectorGroupId}";
  if (input.VoiceConnectorGroupId !== undefined) {
    const labelValue: string = input.VoiceConnectorGroupId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorGroupId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorGroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorGroupId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetVoiceConnectorLoggingConfigurationCommand(
  input: GetVoiceConnectorLoggingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/voice-connectors/{VoiceConnectorId}/logging-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetVoiceConnectorOriginationCommand(
  input: GetVoiceConnectorOriginationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/origination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetVoiceConnectorStreamingConfigurationCommand(
  input: GetVoiceConnectorStreamingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/voice-connectors/{VoiceConnectorId}/streaming-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetVoiceConnectorTerminationCommand(
  input: GetVoiceConnectorTerminationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetVoiceConnectorTerminationHealthCommand(
  input: GetVoiceConnectorTerminationHealthCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination/health";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1InviteUsersCommand(
  input: InviteUsersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query: any = {
    operation: "add"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.UserEmailList !== undefined) {
    bodyParams["UserEmailList"] = serializeAws_restJson1_1UserEmailList(
      input.UserEmailList,
      context
    );
  }
  if (input.UserType !== undefined) {
    bodyParams["UserType"] = input.UserType;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1ListAccountsCommand(
  input: ListAccountsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.Name !== undefined) {
    query["name"] = input.Name;
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.UserEmail !== undefined) {
    query["user-email"] = input.UserEmail;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListAttendeesCommand(
  input: ListAttendeesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/meetings/{MeetingId}/attendees";
  if (input.MeetingId !== undefined) {
    const labelValue: string = input.MeetingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MeetingId.");
    }
    resolvedPath = resolvedPath.replace(
      "{MeetingId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MeetingId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListBotsCommand(
  input: ListBotsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/bots";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListMeetingsCommand(
  input: ListMeetingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/meetings";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListPhoneNumberOrdersCommand(
  input: ListPhoneNumberOrdersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/phone-number-orders";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListPhoneNumbersCommand(
  input: ListPhoneNumbersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/phone-numbers";
  const query: any = {};
  if (input.FilterName !== undefined) {
    query["filter-name"] = input.FilterName;
  }
  if (input.FilterValue !== undefined) {
    query["filter-value"] = input.FilterValue;
  }
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.ProductType !== undefined) {
    query["product-type"] = input.ProductType;
  }
  if (input.Status !== undefined) {
    query["status"] = input.Status;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListRoomMembershipsCommand(
  input: ListRoomMembershipsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}/memberships";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue: string = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace(
      "{RoomId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListRoomsCommand(
  input: ListRoomsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/rooms";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.MemberId !== undefined) {
    query["member-id"] = input.MemberId;
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListUsersCommand(
  input: ListUsersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/users";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.UserEmail !== undefined) {
    query["user-email"] = input.UserEmail;
  }
  if (input.UserType !== undefined) {
    query["user-type"] = input.UserType;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListVoiceConnectorGroupsCommand(
  input: ListVoiceConnectorGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connector-groups";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListVoiceConnectorTerminationCredentialsCommand(
  input: ListVoiceConnectorTerminationCredentialsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/voice-connectors/{VoiceConnectorId}/termination/credentials";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ListVoiceConnectorsCommand(
  input: ListVoiceConnectorsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/voice-connectors";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1LogoutUserCommand(
  input: LogoutUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue: string = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  const query: any = {
    operation: "logout"
  };
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1PutEventsConfigurationCommand(
  input: PutEventsConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}/events-configuration";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue: string = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace(
      "{BotId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.LambdaFunctionArn !== undefined) {
    bodyParams["LambdaFunctionArn"] = input.LambdaFunctionArn;
  }
  if (input.OutboundEventsHTTPSEndpoint !== undefined) {
    bodyParams["OutboundEventsHTTPSEndpoint"] =
      input.OutboundEventsHTTPSEndpoint;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1PutVoiceConnectorLoggingConfigurationCommand(
  input: PutVoiceConnectorLoggingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/voice-connectors/{VoiceConnectorId}/logging-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.LoggingConfiguration !== undefined) {
    bodyParams[
      "LoggingConfiguration"
    ] = serializeAws_restJson1_1LoggingConfiguration(
      input.LoggingConfiguration,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1PutVoiceConnectorOriginationCommand(
  input: PutVoiceConnectorOriginationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/origination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Origination !== undefined) {
    bodyParams["Origination"] = serializeAws_restJson1_1Origination(
      input.Origination,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1PutVoiceConnectorStreamingConfigurationCommand(
  input: PutVoiceConnectorStreamingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/voice-connectors/{VoiceConnectorId}/streaming-configuration";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.StreamingConfiguration !== undefined) {
    bodyParams[
      "StreamingConfiguration"
    ] = serializeAws_restJson1_1StreamingConfiguration(
      input.StreamingConfiguration,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1PutVoiceConnectorTerminationCommand(
  input: PutVoiceConnectorTerminationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}/termination";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Termination !== undefined) {
    bodyParams["Termination"] = serializeAws_restJson1_1Termination(
      input.Termination,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1PutVoiceConnectorTerminationCredentialsCommand(
  input: PutVoiceConnectorTerminationCredentialsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/voice-connectors/{VoiceConnectorId}/termination/credentials";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  const query: any = {
    operation: "put"
  };
  let body: any;
  const bodyParams: any = {};
  if (input.Credentials !== undefined) {
    bodyParams["Credentials"] = serializeAws_restJson1_1CredentialList(
      input.Credentials,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1RegenerateSecurityTokenCommand(
  input: RegenerateSecurityTokenCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue: string = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace(
      "{BotId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  const query: any = {
    operation: "regenerate-security-token"
  };
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ResetPersonalPINCommand(
  input: ResetPersonalPINCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue: string = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  const query: any = {
    operation: "reset-personal-pin"
  };
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1RestorePhoneNumberCommand(
  input: RestorePhoneNumberCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/phone-numbers/{PhoneNumberId}";
  if (input.PhoneNumberId !== undefined) {
    const labelValue: string = input.PhoneNumberId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: PhoneNumberId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{PhoneNumberId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: PhoneNumberId.");
  }
  const query: any = {
    operation: "restore"
  };
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1SearchAvailablePhoneNumbersCommand(
  input: SearchAvailablePhoneNumbersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/search";
  const query: any = {
    type: "phone-numbers"
  };
  if (input.AreaCode !== undefined) {
    query["area-code"] = input.AreaCode;
  }
  if (input.City !== undefined) {
    query["city"] = input.City;
  }
  if (input.Country !== undefined) {
    query["country"] = input.Country;
  }
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  if (input.State !== undefined) {
    query["state"] = input.State;
  }
  if (input.TollFreePrefix !== undefined) {
    query["toll-free-prefix"] = input.TollFreePrefix;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1UpdateAccountCommand(
  input: UpdateAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateAccountSettingsCommand(
  input: UpdateAccountSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/settings";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.AccountSettings !== undefined) {
    bodyParams["AccountSettings"] = serializeAws_restJson1_1AccountSettings(
      input.AccountSettings,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateBotCommand(
  input: UpdateBotCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/bots/{BotId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.BotId !== undefined) {
    const labelValue: string = input.BotId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: BotId.");
    }
    resolvedPath = resolvedPath.replace(
      "{BotId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: BotId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Disabled !== undefined) {
    bodyParams["Disabled"] = input.Disabled;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateGlobalSettingsCommand(
  input: UpdateGlobalSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/settings";
  let body: any;
  const bodyParams: any = {};
  if (input.BusinessCalling !== undefined) {
    bodyParams[
      "BusinessCalling"
    ] = serializeAws_restJson1_1BusinessCallingSettings(
      input.BusinessCalling,
      context
    );
  }
  if (input.VoiceConnector !== undefined) {
    bodyParams[
      "VoiceConnector"
    ] = serializeAws_restJson1_1VoiceConnectorSettings(
      input.VoiceConnector,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdatePhoneNumberCommand(
  input: UpdatePhoneNumberCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/phone-numbers/{PhoneNumberId}";
  if (input.PhoneNumberId !== undefined) {
    const labelValue: string = input.PhoneNumberId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: PhoneNumberId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{PhoneNumberId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: PhoneNumberId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.CallingName !== undefined) {
    bodyParams["CallingName"] = input.CallingName;
  }
  if (input.ProductType !== undefined) {
    bodyParams["ProductType"] = input.ProductType;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdatePhoneNumberSettingsCommand(
  input: UpdatePhoneNumberSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/settings/phone-number";
  let body: any;
  const bodyParams: any = {};
  if (input.CallingName !== undefined) {
    bodyParams["CallingName"] = input.CallingName;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateRoomCommand(
  input: UpdateRoomCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/rooms/{RoomId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue: string = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace(
      "{RoomId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateRoomMembershipCommand(
  input: UpdateRoomMembershipCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AccountId}/rooms/{RoomId}/memberships/{MemberId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.MemberId !== undefined) {
    const labelValue: string = input.MemberId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MemberId.");
    }
    resolvedPath = resolvedPath.replace(
      "{MemberId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MemberId.");
  }
  if (input.RoomId !== undefined) {
    const labelValue: string = input.RoomId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: RoomId.");
    }
    resolvedPath = resolvedPath.replace(
      "{RoomId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: RoomId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Role !== undefined) {
    bodyParams["Role"] = input.Role;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateUserCommand(
  input: UpdateUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue: string = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.AlexaForBusinessMetadata !== undefined) {
    bodyParams[
      "AlexaForBusinessMetadata"
    ] = serializeAws_restJson1_1AlexaForBusinessMetadata(
      input.AlexaForBusinessMetadata,
      context
    );
  }
  if (input.LicenseType !== undefined) {
    bodyParams["LicenseType"] = input.LicenseType;
  }
  if (input.UserType !== undefined) {
    bodyParams["UserType"] = input.UserType;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateUserSettingsCommand(
  input: UpdateUserSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AccountId}/users/{UserId}/settings";
  if (input.AccountId !== undefined) {
    const labelValue: string = input.AccountId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AccountId.");
    }
    resolvedPath = resolvedPath.replace(
      "{AccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AccountId.");
  }
  if (input.UserId !== undefined) {
    const labelValue: string = input.UserId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserId.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.UserSettings !== undefined) {
    bodyParams["UserSettings"] = serializeAws_restJson1_1UserSettings(
      input.UserSettings,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateVoiceConnectorCommand(
  input: UpdateVoiceConnectorCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/voice-connectors/{VoiceConnectorId}";
  if (input.VoiceConnectorId !== undefined) {
    const labelValue: string = input.VoiceConnectorId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RequireEncryption !== undefined) {
    bodyParams["RequireEncryption"] = input.RequireEncryption;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateVoiceConnectorGroupCommand(
  input: UpdateVoiceConnectorGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/voice-connector-groups/{VoiceConnectorGroupId}";
  if (input.VoiceConnectorGroupId !== undefined) {
    const labelValue: string = input.VoiceConnectorGroupId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VoiceConnectorGroupId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VoiceConnectorGroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: VoiceConnectorGroupId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.VoiceConnectorItems !== undefined) {
    bodyParams[
      "VoiceConnectorItems"
    ] = serializeAws_restJson1_1VoiceConnectorItemList(
      input.VoiceConnectorItems,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function deserializeAws_restJson1_1AssociatePhoneNumberWithUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociatePhoneNumberWithUserCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AssociatePhoneNumberWithUserCommandError(
      output,
      context
    );
  }
  const contents: AssociatePhoneNumberWithUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociatePhoneNumberWithUserResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AssociatePhoneNumberWithUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociatePhoneNumberWithUserCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ucbuzzconsoleservice#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AssociatePhoneNumbersWithVoiceConnectorCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociatePhoneNumbersWithVoiceConnectorCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AssociatePhoneNumbersWithVoiceConnectorCommandError(
      output,
      context
    );
  }
  const contents: AssociatePhoneNumbersWithVoiceConnectorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociatePhoneNumbersWithVoiceConnectorResponse",
    PhoneNumberErrors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1_1PhoneNumberErrorList(
      data.PhoneNumberErrors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AssociatePhoneNumbersWithVoiceConnectorCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociatePhoneNumbersWithVoiceConnectorCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ucbuzzconsoleservice#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AssociatePhoneNumbersWithVoiceConnectorGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociatePhoneNumbersWithVoiceConnectorGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AssociatePhoneNumbersWithVoiceConnectorGroupCommandError(
      output,
      context
    );
  }
  const contents: AssociatePhoneNumbersWithVoiceConnectorGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociatePhoneNumbersWithVoiceConnectorGroupResponse",
    PhoneNumberErrors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1_1PhoneNumberErrorList(
      data.PhoneNumberErrors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AssociatePhoneNumbersWithVoiceConnectorGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociatePhoneNumbersWithVoiceConnectorGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ucbuzzconsoleservice#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AssociateSigninDelegateGroupsWithAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateSigninDelegateGroupsWithAccountCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AssociateSigninDelegateGroupsWithAccountCommandError(
      output,
      context
    );
  }
  const contents: AssociateSigninDelegateGroupsWithAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateSigninDelegateGroupsWithAccountResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AssociateSigninDelegateGroupsWithAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateSigninDelegateGroupsWithAccountCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1BatchCreateAttendeeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchCreateAttendeeCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1BatchCreateAttendeeCommandError(
      output,
      context
    );
  }
  const contents: BatchCreateAttendeeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchCreateAttendeeResponse",
    Attendees: undefined,
    Errors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Attendees !== undefined && data.Attendees !== null) {
    contents.Attendees = deserializeAws_restJson1_1AttendeeList(
      data.Attendees,
      context
    );
  }
  if (data.Errors !== undefined && data.Errors !== null) {
    contents.Errors = deserializeAws_restJson1_1BatchCreateAttendeeErrorList(
      data.Errors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1BatchCreateAttendeeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchCreateAttendeeCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1BatchCreateRoomMembershipCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchCreateRoomMembershipCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1BatchCreateRoomMembershipCommandError(
      output,
      context
    );
  }
  const contents: BatchCreateRoomMembershipCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchCreateRoomMembershipResponse",
    Errors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Errors !== undefined && data.Errors !== null) {
    contents.Errors = deserializeAws_restJson1_1MemberErrorList(
      data.Errors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1BatchCreateRoomMembershipCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchCreateRoomMembershipCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1BatchDeletePhoneNumberCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeletePhoneNumberCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1BatchDeletePhoneNumberCommandError(
      output,
      context
    );
  }
  const contents: BatchDeletePhoneNumberCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchDeletePhoneNumberResponse",
    PhoneNumberErrors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1_1PhoneNumberErrorList(
      data.PhoneNumberErrors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1BatchDeletePhoneNumberCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchDeletePhoneNumberCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1BatchSuspendUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchSuspendUserCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1BatchSuspendUserCommandError(
      output,
      context
    );
  }
  const contents: BatchSuspendUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchSuspendUserResponse",
    UserErrors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.UserErrors !== undefined && data.UserErrors !== null) {
    contents.UserErrors = deserializeAws_restJson1_1UserErrorList(
      data.UserErrors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1BatchSuspendUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchSuspendUserCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1BatchUnsuspendUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchUnsuspendUserCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1BatchUnsuspendUserCommandError(
      output,
      context
    );
  }
  const contents: BatchUnsuspendUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchUnsuspendUserResponse",
    UserErrors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.UserErrors !== undefined && data.UserErrors !== null) {
    contents.UserErrors = deserializeAws_restJson1_1UserErrorList(
      data.UserErrors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1BatchUnsuspendUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchUnsuspendUserCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1BatchUpdatePhoneNumberCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchUpdatePhoneNumberCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1BatchUpdatePhoneNumberCommandError(
      output,
      context
    );
  }
  const contents: BatchUpdatePhoneNumberCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchUpdatePhoneNumberResponse",
    PhoneNumberErrors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1_1PhoneNumberErrorList(
      data.PhoneNumberErrors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1BatchUpdatePhoneNumberCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchUpdatePhoneNumberCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1BatchUpdateUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchUpdateUserCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1BatchUpdateUserCommandError(
      output,
      context
    );
  }
  const contents: BatchUpdateUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "BatchUpdateUserResponse",
    UserErrors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.UserErrors !== undefined && data.UserErrors !== null) {
    contents.UserErrors = deserializeAws_restJson1_1UserErrorList(
      data.UserErrors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1BatchUpdateUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<BatchUpdateUserCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAccountCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateAccountCommandError(output, context);
  }
  const contents: CreateAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAccountResponse",
    Account: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Account !== undefined && data.Account !== null) {
    contents.Account = deserializeAws_restJson1_1Account(data.Account, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAccountCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateAttendeeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAttendeeCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateAttendeeCommandError(
      output,
      context
    );
  }
  const contents: CreateAttendeeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAttendeeResponse",
    Attendee: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Attendee !== undefined && data.Attendee !== null) {
    contents.Attendee = deserializeAws_restJson1_1Attendee(
      data.Attendee,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateAttendeeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAttendeeCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateBotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBotCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateBotCommandError(output, context);
  }
  const contents: CreateBotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateBotResponse",
    Bot: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Bot !== undefined && data.Bot !== null) {
    contents.Bot = deserializeAws_restJson1_1Bot(data.Bot, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateBotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBotCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateMeetingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMeetingCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateMeetingCommandError(output, context);
  }
  const contents: CreateMeetingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateMeetingResponse",
    Meeting: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Meeting !== undefined && data.Meeting !== null) {
    contents.Meeting = deserializeAws_restJson1_1Meeting(data.Meeting, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateMeetingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMeetingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreatePhoneNumberOrderCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePhoneNumberOrderCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreatePhoneNumberOrderCommandError(
      output,
      context
    );
  }
  const contents: CreatePhoneNumberOrderCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePhoneNumberOrderResponse",
    PhoneNumberOrder: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumberOrder !== undefined && data.PhoneNumberOrder !== null) {
    contents.PhoneNumberOrder = deserializeAws_restJson1_1PhoneNumberOrder(
      data.PhoneNumberOrder,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreatePhoneNumberOrderCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePhoneNumberOrderCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ucbuzzconsoleservice#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRoomCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateRoomCommandError(output, context);
  }
  const contents: CreateRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRoomResponse",
    Room: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Room !== undefined && data.Room !== null) {
    contents.Room = deserializeAws_restJson1_1Room(data.Room, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRoomCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateRoomMembershipCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRoomMembershipCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateRoomMembershipCommandError(
      output,
      context
    );
  }
  const contents: CreateRoomMembershipCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRoomMembershipResponse",
    RoomMembership: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RoomMembership !== undefined && data.RoomMembership !== null) {
    contents.RoomMembership = deserializeAws_restJson1_1RoomMembership(
      data.RoomMembership,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateRoomMembershipCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRoomMembershipCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.ucbuzzconsoleservice#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateUserCommandError(output, context);
  }
  const contents: CreateUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateUserResponse",
    User: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1_1User(data.User, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.ucbuzzconsoleservice#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateVoiceConnectorCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVoiceConnectorCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateVoiceConnectorCommandError(
      output,
      context
    );
  }
  const contents: CreateVoiceConnectorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVoiceConnectorResponse",
    VoiceConnector: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.VoiceConnector !== undefined && data.VoiceConnector !== null) {
    contents.VoiceConnector = deserializeAws_restJson1_1VoiceConnector(
      data.VoiceConnector,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateVoiceConnectorCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVoiceConnectorCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ucbuzzconsoleservice#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateVoiceConnectorGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVoiceConnectorGroupCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateVoiceConnectorGroupCommandError(
      output,
      context
    );
  }
  const contents: CreateVoiceConnectorGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVoiceConnectorGroupResponse",
    VoiceConnectorGroup: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.VoiceConnectorGroup !== undefined &&
    data.VoiceConnectorGroup !== null
  ) {
    contents.VoiceConnectorGroup = deserializeAws_restJson1_1VoiceConnectorGroup(
      data.VoiceConnectorGroup,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateVoiceConnectorGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVoiceConnectorGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ucbuzzconsoleservice#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAccountCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteAccountCommandError(output, context);
  }
  const contents: DeleteAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteAccountResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAccountCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnprocessableEntityException":
    case "com.amazonaws.ucbuzzconsoleservice#UnprocessableEntityException":
      response = {
        ...(await deserializeAws_restJson1_1UnprocessableEntityExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteAttendeeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAttendeeCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteAttendeeCommandError(
      output,
      context
    );
  }
  const contents: DeleteAttendeeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteAttendeeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAttendeeCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteEventsConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventsConfigurationCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteEventsConfigurationCommandError(
      output,
      context
    );
  }
  const contents: DeleteEventsConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteEventsConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventsConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteMeetingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMeetingCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteMeetingCommandError(output, context);
  }
  const contents: DeleteMeetingCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteMeetingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMeetingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeletePhoneNumberCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePhoneNumberCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeletePhoneNumberCommandError(
      output,
      context
    );
  }
  const contents: DeletePhoneNumberCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeletePhoneNumberCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePhoneNumberCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoomCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteRoomCommandError(output, context);
  }
  const contents: DeleteRoomCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoomCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteRoomMembershipCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoomMembershipCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteRoomMembershipCommandError(
      output,
      context
    );
  }
  const contents: DeleteRoomMembershipCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteRoomMembershipCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoomMembershipCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteVoiceConnectorCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteVoiceConnectorCommandError(
      output,
      context
    );
  }
  const contents: DeleteVoiceConnectorCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteVoiceConnectorCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.ucbuzzconsoleservice#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteVoiceConnectorGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorGroupCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteVoiceConnectorGroupCommandError(
      output,
      context
    );
  }
  const contents: DeleteVoiceConnectorGroupCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteVoiceConnectorGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.ucbuzzconsoleservice#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteVoiceConnectorOriginationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorOriginationCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteVoiceConnectorOriginationCommandError(
      output,
      context
    );
  }
  const contents: DeleteVoiceConnectorOriginationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteVoiceConnectorOriginationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorOriginationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteVoiceConnectorStreamingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorStreamingConfigurationCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteVoiceConnectorStreamingConfigurationCommandError(
      output,
      context
    );
  }
  const contents: DeleteVoiceConnectorStreamingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteVoiceConnectorStreamingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorStreamingConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteVoiceConnectorTerminationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorTerminationCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteVoiceConnectorTerminationCommandError(
      output,
      context
    );
  }
  const contents: DeleteVoiceConnectorTerminationCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteVoiceConnectorTerminationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorTerminationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteVoiceConnectorTerminationCredentialsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorTerminationCredentialsCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteVoiceConnectorTerminationCredentialsCommandError(
      output,
      context
    );
  }
  const contents: DeleteVoiceConnectorTerminationCredentialsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteVoiceConnectorTerminationCredentialsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVoiceConnectorTerminationCredentialsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DisassociatePhoneNumberFromUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociatePhoneNumberFromUserCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DisassociatePhoneNumberFromUserCommandError(
      output,
      context
    );
  }
  const contents: DisassociatePhoneNumberFromUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociatePhoneNumberFromUserResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DisassociatePhoneNumberFromUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociatePhoneNumberFromUserCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DisassociatePhoneNumbersFromVoiceConnectorCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociatePhoneNumbersFromVoiceConnectorCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DisassociatePhoneNumbersFromVoiceConnectorCommandError(
      output,
      context
    );
  }
  const contents: DisassociatePhoneNumbersFromVoiceConnectorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociatePhoneNumbersFromVoiceConnectorResponse",
    PhoneNumberErrors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1_1PhoneNumberErrorList(
      data.PhoneNumberErrors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DisassociatePhoneNumbersFromVoiceConnectorCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociatePhoneNumbersFromVoiceConnectorCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DisassociatePhoneNumbersFromVoiceConnectorGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociatePhoneNumbersFromVoiceConnectorGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DisassociatePhoneNumbersFromVoiceConnectorGroupCommandError(
      output,
      context
    );
  }
  const contents: DisassociatePhoneNumbersFromVoiceConnectorGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociatePhoneNumbersFromVoiceConnectorGroupResponse",
    PhoneNumberErrors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumberErrors !== undefined && data.PhoneNumberErrors !== null) {
    contents.PhoneNumberErrors = deserializeAws_restJson1_1PhoneNumberErrorList(
      data.PhoneNumberErrors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DisassociatePhoneNumbersFromVoiceConnectorGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociatePhoneNumbersFromVoiceConnectorGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DisassociateSigninDelegateGroupsFromAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateSigninDelegateGroupsFromAccountCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DisassociateSigninDelegateGroupsFromAccountCommandError(
      output,
      context
    );
  }
  const contents: DisassociateSigninDelegateGroupsFromAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateSigninDelegateGroupsFromAccountResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DisassociateSigninDelegateGroupsFromAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateSigninDelegateGroupsFromAccountCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetAccountCommandError(output, context);
  }
  const contents: GetAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAccountResponse",
    Account: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Account !== undefined && data.Account !== null) {
    contents.Account = deserializeAws_restJson1_1Account(data.Account, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetAccountSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountSettingsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetAccountSettingsCommandError(
      output,
      context
    );
  }
  const contents: GetAccountSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAccountSettingsResponse",
    AccountSettings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AccountSettings !== undefined && data.AccountSettings !== null) {
    contents.AccountSettings = deserializeAws_restJson1_1AccountSettings(
      data.AccountSettings,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetAccountSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountSettingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetAttendeeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAttendeeCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetAttendeeCommandError(output, context);
  }
  const contents: GetAttendeeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAttendeeResponse",
    Attendee: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Attendee !== undefined && data.Attendee !== null) {
    contents.Attendee = deserializeAws_restJson1_1Attendee(
      data.Attendee,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetAttendeeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAttendeeCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetBotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBotCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetBotCommandError(output, context);
  }
  const contents: GetBotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBotResponse",
    Bot: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Bot !== undefined && data.Bot !== null) {
    contents.Bot = deserializeAws_restJson1_1Bot(data.Bot, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetBotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBotCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetEventsConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEventsConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetEventsConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetEventsConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetEventsConfigurationResponse",
    EventsConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.EventsConfiguration !== undefined &&
    data.EventsConfiguration !== null
  ) {
    contents.EventsConfiguration = deserializeAws_restJson1_1EventsConfiguration(
      data.EventsConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetEventsConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEventsConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetGlobalSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGlobalSettingsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetGlobalSettingsCommandError(
      output,
      context
    );
  }
  const contents: GetGlobalSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGlobalSettingsResponse",
    BusinessCalling: undefined,
    VoiceConnector: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.BusinessCalling !== undefined && data.BusinessCalling !== null) {
    contents.BusinessCalling = deserializeAws_restJson1_1BusinessCallingSettings(
      data.BusinessCalling,
      context
    );
  }
  if (data.VoiceConnector !== undefined && data.VoiceConnector !== null) {
    contents.VoiceConnector = deserializeAws_restJson1_1VoiceConnectorSettings(
      data.VoiceConnector,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetGlobalSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGlobalSettingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetMeetingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMeetingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetMeetingCommandError(output, context);
  }
  const contents: GetMeetingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetMeetingResponse",
    Meeting: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Meeting !== undefined && data.Meeting !== null) {
    contents.Meeting = deserializeAws_restJson1_1Meeting(data.Meeting, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetMeetingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetMeetingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetPhoneNumberCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPhoneNumberCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetPhoneNumberCommandError(
      output,
      context
    );
  }
  const contents: GetPhoneNumberCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPhoneNumberResponse",
    PhoneNumber: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumber !== undefined && data.PhoneNumber !== null) {
    contents.PhoneNumber = deserializeAws_restJson1_1PhoneNumber(
      data.PhoneNumber,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetPhoneNumberCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPhoneNumberCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetPhoneNumberOrderCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPhoneNumberOrderCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetPhoneNumberOrderCommandError(
      output,
      context
    );
  }
  const contents: GetPhoneNumberOrderCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPhoneNumberOrderResponse",
    PhoneNumberOrder: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumberOrder !== undefined && data.PhoneNumberOrder !== null) {
    contents.PhoneNumberOrder = deserializeAws_restJson1_1PhoneNumberOrder(
      data.PhoneNumberOrder,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetPhoneNumberOrderCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPhoneNumberOrderCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetPhoneNumberSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPhoneNumberSettingsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetPhoneNumberSettingsCommandError(
      output,
      context
    );
  }
  const contents: GetPhoneNumberSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPhoneNumberSettingsResponse",
    CallingName: undefined,
    CallingNameUpdatedTimestamp: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.CallingName !== undefined && data.CallingName !== null) {
    contents.CallingName = data.CallingName;
  }
  if (
    data.CallingNameUpdatedTimestamp !== undefined &&
    data.CallingNameUpdatedTimestamp !== null
  ) {
    contents.CallingNameUpdatedTimestamp = new Date(
      data.CallingNameUpdatedTimestamp
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetPhoneNumberSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPhoneNumberSettingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRoomCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetRoomCommandError(output, context);
  }
  const contents: GetRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRoomResponse",
    Room: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Room !== undefined && data.Room !== null) {
    contents.Room = deserializeAws_restJson1_1Room(data.Room, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRoomCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetUserCommandError(output, context);
  }
  const contents: GetUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetUserResponse",
    User: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1_1User(data.User, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetUserSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserSettingsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetUserSettingsCommandError(
      output,
      context
    );
  }
  const contents: GetUserSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetUserSettingsResponse",
    UserSettings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.UserSettings !== undefined && data.UserSettings !== null) {
    contents.UserSettings = deserializeAws_restJson1_1UserSettings(
      data.UserSettings,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetUserSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetUserSettingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetVoiceConnectorCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetVoiceConnectorCommandError(
      output,
      context
    );
  }
  const contents: GetVoiceConnectorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetVoiceConnectorResponse",
    VoiceConnector: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.VoiceConnector !== undefined && data.VoiceConnector !== null) {
    contents.VoiceConnector = deserializeAws_restJson1_1VoiceConnector(
      data.VoiceConnector,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVoiceConnectorCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetVoiceConnectorGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetVoiceConnectorGroupCommandError(
      output,
      context
    );
  }
  const contents: GetVoiceConnectorGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetVoiceConnectorGroupResponse",
    VoiceConnectorGroup: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.VoiceConnectorGroup !== undefined &&
    data.VoiceConnectorGroup !== null
  ) {
    contents.VoiceConnectorGroup = deserializeAws_restJson1_1VoiceConnectorGroup(
      data.VoiceConnectorGroup,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVoiceConnectorGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetVoiceConnectorLoggingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorLoggingConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetVoiceConnectorLoggingConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetVoiceConnectorLoggingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetVoiceConnectorLoggingConfigurationResponse",
    LoggingConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.LoggingConfiguration !== undefined &&
    data.LoggingConfiguration !== null
  ) {
    contents.LoggingConfiguration = deserializeAws_restJson1_1LoggingConfiguration(
      data.LoggingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVoiceConnectorLoggingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorLoggingConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetVoiceConnectorOriginationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorOriginationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetVoiceConnectorOriginationCommandError(
      output,
      context
    );
  }
  const contents: GetVoiceConnectorOriginationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetVoiceConnectorOriginationResponse",
    Origination: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Origination !== undefined && data.Origination !== null) {
    contents.Origination = deserializeAws_restJson1_1Origination(
      data.Origination,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVoiceConnectorOriginationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorOriginationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetVoiceConnectorStreamingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorStreamingConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetVoiceConnectorStreamingConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetVoiceConnectorStreamingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetVoiceConnectorStreamingConfigurationResponse",
    StreamingConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.StreamingConfiguration !== undefined &&
    data.StreamingConfiguration !== null
  ) {
    contents.StreamingConfiguration = deserializeAws_restJson1_1StreamingConfiguration(
      data.StreamingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVoiceConnectorStreamingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorStreamingConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetVoiceConnectorTerminationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorTerminationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetVoiceConnectorTerminationCommandError(
      output,
      context
    );
  }
  const contents: GetVoiceConnectorTerminationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetVoiceConnectorTerminationResponse",
    Termination: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Termination !== undefined && data.Termination !== null) {
    contents.Termination = deserializeAws_restJson1_1Termination(
      data.Termination,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVoiceConnectorTerminationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorTerminationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetVoiceConnectorTerminationHealthCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorTerminationHealthCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetVoiceConnectorTerminationHealthCommandError(
      output,
      context
    );
  }
  const contents: GetVoiceConnectorTerminationHealthCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetVoiceConnectorTerminationHealthResponse",
    TerminationHealth: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.TerminationHealth !== undefined && data.TerminationHealth !== null) {
    contents.TerminationHealth = deserializeAws_restJson1_1TerminationHealth(
      data.TerminationHealth,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetVoiceConnectorTerminationHealthCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetVoiceConnectorTerminationHealthCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1InviteUsersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<InviteUsersCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1InviteUsersCommandError(output, context);
  }
  const contents: InviteUsersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "InviteUsersResponse",
    Invites: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Invites !== undefined && data.Invites !== null) {
    contents.Invites = deserializeAws_restJson1_1InviteList(
      data.Invites,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1InviteUsersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<InviteUsersCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListAccountsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAccountsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListAccountsCommandError(output, context);
  }
  const contents: ListAccountsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAccountsResponse",
    Accounts: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Accounts !== undefined && data.Accounts !== null) {
    contents.Accounts = deserializeAws_restJson1_1AccountList(
      data.Accounts,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListAccountsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAccountsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListAttendeesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAttendeesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListAttendeesCommandError(output, context);
  }
  const contents: ListAttendeesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAttendeesResponse",
    Attendees: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Attendees !== undefined && data.Attendees !== null) {
    contents.Attendees = deserializeAws_restJson1_1AttendeeList(
      data.Attendees,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListAttendeesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAttendeesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListBotsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBotsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListBotsCommandError(output, context);
  }
  const contents: ListBotsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBotsResponse",
    Bots: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Bots !== undefined && data.Bots !== null) {
    contents.Bots = deserializeAws_restJson1_1BotList(data.Bots, context);
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListBotsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBotsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListMeetingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMeetingsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListMeetingsCommandError(output, context);
  }
  const contents: ListMeetingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListMeetingsResponse",
    Meetings: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Meetings !== undefined && data.Meetings !== null) {
    contents.Meetings = deserializeAws_restJson1_1MeetingList(
      data.Meetings,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListMeetingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMeetingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListPhoneNumberOrdersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPhoneNumberOrdersCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListPhoneNumberOrdersCommandError(
      output,
      context
    );
  }
  const contents: ListPhoneNumberOrdersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPhoneNumberOrdersResponse",
    NextToken: undefined,
    PhoneNumberOrders: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.PhoneNumberOrders !== undefined && data.PhoneNumberOrders !== null) {
    contents.PhoneNumberOrders = deserializeAws_restJson1_1PhoneNumberOrderList(
      data.PhoneNumberOrders,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListPhoneNumberOrdersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPhoneNumberOrdersCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListPhoneNumbersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPhoneNumbersCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListPhoneNumbersCommandError(
      output,
      context
    );
  }
  const contents: ListPhoneNumbersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPhoneNumbersResponse",
    NextToken: undefined,
    PhoneNumbers: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.PhoneNumbers !== undefined && data.PhoneNumbers !== null) {
    contents.PhoneNumbers = deserializeAws_restJson1_1PhoneNumberList(
      data.PhoneNumbers,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListPhoneNumbersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPhoneNumbersCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListRoomMembershipsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRoomMembershipsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListRoomMembershipsCommandError(
      output,
      context
    );
  }
  const contents: ListRoomMembershipsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRoomMembershipsResponse",
    NextToken: undefined,
    RoomMemberships: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RoomMemberships !== undefined && data.RoomMemberships !== null) {
    contents.RoomMemberships = deserializeAws_restJson1_1RoomMembershipList(
      data.RoomMemberships,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListRoomMembershipsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRoomMembershipsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListRoomsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRoomsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListRoomsCommandError(output, context);
  }
  const contents: ListRoomsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRoomsResponse",
    NextToken: undefined,
    Rooms: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Rooms !== undefined && data.Rooms !== null) {
    contents.Rooms = deserializeAws_restJson1_1RoomList(data.Rooms, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListRoomsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRoomsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListUsersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListUsersCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListUsersCommandError(output, context);
  }
  const contents: ListUsersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListUsersResponse",
    NextToken: undefined,
    Users: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Users !== undefined && data.Users !== null) {
    contents.Users = deserializeAws_restJson1_1UserList(data.Users, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListUsersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListUsersCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListVoiceConnectorGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVoiceConnectorGroupsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListVoiceConnectorGroupsCommandError(
      output,
      context
    );
  }
  const contents: ListVoiceConnectorGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListVoiceConnectorGroupsResponse",
    NextToken: undefined,
    VoiceConnectorGroups: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (
    data.VoiceConnectorGroups !== undefined &&
    data.VoiceConnectorGroups !== null
  ) {
    contents.VoiceConnectorGroups = deserializeAws_restJson1_1VoiceConnectorGroupList(
      data.VoiceConnectorGroups,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListVoiceConnectorGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVoiceConnectorGroupsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListVoiceConnectorTerminationCredentialsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVoiceConnectorTerminationCredentialsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListVoiceConnectorTerminationCredentialsCommandError(
      output,
      context
    );
  }
  const contents: ListVoiceConnectorTerminationCredentialsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListVoiceConnectorTerminationCredentialsResponse",
    Usernames: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Usernames !== undefined && data.Usernames !== null) {
    contents.Usernames = deserializeAws_restJson1_1SensitiveStringList(
      data.Usernames,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListVoiceConnectorTerminationCredentialsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVoiceConnectorTerminationCredentialsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListVoiceConnectorsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVoiceConnectorsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListVoiceConnectorsCommandError(
      output,
      context
    );
  }
  const contents: ListVoiceConnectorsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListVoiceConnectorsResponse",
    NextToken: undefined,
    VoiceConnectors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.VoiceConnectors !== undefined && data.VoiceConnectors !== null) {
    contents.VoiceConnectors = deserializeAws_restJson1_1VoiceConnectorList(
      data.VoiceConnectors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListVoiceConnectorsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVoiceConnectorsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1LogoutUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<LogoutUserCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1LogoutUserCommandError(output, context);
  }
  const contents: LogoutUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "LogoutUserResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1LogoutUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<LogoutUserCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1PutEventsConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutEventsConfigurationCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1PutEventsConfigurationCommandError(
      output,
      context
    );
  }
  const contents: PutEventsConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutEventsConfigurationResponse",
    EventsConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.EventsConfiguration !== undefined &&
    data.EventsConfiguration !== null
  ) {
    contents.EventsConfiguration = deserializeAws_restJson1_1EventsConfiguration(
      data.EventsConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutEventsConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutEventsConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1PutVoiceConnectorLoggingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutVoiceConnectorLoggingConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1PutVoiceConnectorLoggingConfigurationCommandError(
      output,
      context
    );
  }
  const contents: PutVoiceConnectorLoggingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutVoiceConnectorLoggingConfigurationResponse",
    LoggingConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.LoggingConfiguration !== undefined &&
    data.LoggingConfiguration !== null
  ) {
    contents.LoggingConfiguration = deserializeAws_restJson1_1LoggingConfiguration(
      data.LoggingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutVoiceConnectorLoggingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutVoiceConnectorLoggingConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1PutVoiceConnectorOriginationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutVoiceConnectorOriginationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1PutVoiceConnectorOriginationCommandError(
      output,
      context
    );
  }
  const contents: PutVoiceConnectorOriginationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutVoiceConnectorOriginationResponse",
    Origination: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Origination !== undefined && data.Origination !== null) {
    contents.Origination = deserializeAws_restJson1_1Origination(
      data.Origination,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutVoiceConnectorOriginationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutVoiceConnectorOriginationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1PutVoiceConnectorStreamingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutVoiceConnectorStreamingConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1PutVoiceConnectorStreamingConfigurationCommandError(
      output,
      context
    );
  }
  const contents: PutVoiceConnectorStreamingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutVoiceConnectorStreamingConfigurationResponse",
    StreamingConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.StreamingConfiguration !== undefined &&
    data.StreamingConfiguration !== null
  ) {
    contents.StreamingConfiguration = deserializeAws_restJson1_1StreamingConfiguration(
      data.StreamingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutVoiceConnectorStreamingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutVoiceConnectorStreamingConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1PutVoiceConnectorTerminationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutVoiceConnectorTerminationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1PutVoiceConnectorTerminationCommandError(
      output,
      context
    );
  }
  const contents: PutVoiceConnectorTerminationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutVoiceConnectorTerminationResponse",
    Termination: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Termination !== undefined && data.Termination !== null) {
    contents.Termination = deserializeAws_restJson1_1Termination(
      data.Termination,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutVoiceConnectorTerminationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutVoiceConnectorTerminationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ucbuzzconsoleservice#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1PutVoiceConnectorTerminationCredentialsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutVoiceConnectorTerminationCredentialsCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1PutVoiceConnectorTerminationCredentialsCommandError(
      output,
      context
    );
  }
  const contents: PutVoiceConnectorTerminationCredentialsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1PutVoiceConnectorTerminationCredentialsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutVoiceConnectorTerminationCredentialsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1RegenerateSecurityTokenCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegenerateSecurityTokenCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1RegenerateSecurityTokenCommandError(
      output,
      context
    );
  }
  const contents: RegenerateSecurityTokenCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegenerateSecurityTokenResponse",
    Bot: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Bot !== undefined && data.Bot !== null) {
    contents.Bot = deserializeAws_restJson1_1Bot(data.Bot, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1RegenerateSecurityTokenCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegenerateSecurityTokenCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ResetPersonalPINCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetPersonalPINCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ResetPersonalPINCommandError(
      output,
      context
    );
  }
  const contents: ResetPersonalPINCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResetPersonalPINResponse",
    User: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1_1User(data.User, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ResetPersonalPINCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetPersonalPINCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1RestorePhoneNumberCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestorePhoneNumberCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1RestorePhoneNumberCommandError(
      output,
      context
    );
  }
  const contents: RestorePhoneNumberCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RestorePhoneNumberResponse",
    PhoneNumber: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumber !== undefined && data.PhoneNumber !== null) {
    contents.PhoneNumber = deserializeAws_restJson1_1PhoneNumber(
      data.PhoneNumber,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1RestorePhoneNumberCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RestorePhoneNumberCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceLimitExceededException":
    case "com.amazonaws.ucbuzzconsoleservice#ResourceLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1SearchAvailablePhoneNumbersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchAvailablePhoneNumbersCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1SearchAvailablePhoneNumbersCommandError(
      output,
      context
    );
  }
  const contents: SearchAvailablePhoneNumbersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchAvailablePhoneNumbersResponse",
    E164PhoneNumbers: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.E164PhoneNumbers !== undefined && data.E164PhoneNumbers !== null) {
    contents.E164PhoneNumbers = deserializeAws_restJson1_1E164PhoneNumberList(
      data.E164PhoneNumbers,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1SearchAvailablePhoneNumbersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchAvailablePhoneNumbersCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.ucbuzzconsoleservice#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateAccountCommandError(output, context);
  }
  const contents: UpdateAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateAccountResponse",
    Account: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Account !== undefined && data.Account !== null) {
    contents.Account = deserializeAws_restJson1_1Account(data.Account, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateAccountSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountSettingsCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateAccountSettingsCommandError(
      output,
      context
    );
  }
  const contents: UpdateAccountSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateAccountSettingsResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateAccountSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountSettingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.ucbuzzconsoleservice#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateBotCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBotCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateBotCommandError(output, context);
  }
  const contents: UpdateBotCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateBotResponse",
    Bot: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Bot !== undefined && data.Bot !== null) {
    contents.Bot = deserializeAws_restJson1_1Bot(data.Bot, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateBotCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBotCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateGlobalSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGlobalSettingsCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateGlobalSettingsCommandError(
      output,
      context
    );
  }
  const contents: UpdateGlobalSettingsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateGlobalSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGlobalSettingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdatePhoneNumberCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePhoneNumberCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdatePhoneNumberCommandError(
      output,
      context
    );
  }
  const contents: UpdatePhoneNumberCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdatePhoneNumberResponse",
    PhoneNumber: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.PhoneNumber !== undefined && data.PhoneNumber !== null) {
    contents.PhoneNumber = deserializeAws_restJson1_1PhoneNumber(
      data.PhoneNumber,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdatePhoneNumberCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePhoneNumberCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdatePhoneNumberSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePhoneNumberSettingsCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdatePhoneNumberSettingsCommandError(
      output,
      context
    );
  }
  const contents: UpdatePhoneNumberSettingsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdatePhoneNumberSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdatePhoneNumberSettingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateRoomCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRoomCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateRoomCommandError(output, context);
  }
  const contents: UpdateRoomCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRoomResponse",
    Room: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Room !== undefined && data.Room !== null) {
    contents.Room = deserializeAws_restJson1_1Room(data.Room, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateRoomCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRoomCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateRoomMembershipCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRoomMembershipCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateRoomMembershipCommandError(
      output,
      context
    );
  }
  const contents: UpdateRoomMembershipCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRoomMembershipResponse",
    RoomMembership: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RoomMembership !== undefined && data.RoomMembership !== null) {
    contents.RoomMembership = deserializeAws_restJson1_1RoomMembership(
      data.RoomMembership,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateRoomMembershipCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRoomMembershipCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateUserCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateUserCommandError(output, context);
  }
  const contents: UpdateUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateUserResponse",
    User: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1_1User(data.User, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateUserCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateUserSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserSettingsCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateUserSettingsCommandError(
      output,
      context
    );
  }
  const contents: UpdateUserSettingsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateUserSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserSettingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateVoiceConnectorCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVoiceConnectorCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateVoiceConnectorCommandError(
      output,
      context
    );
  }
  const contents: UpdateVoiceConnectorCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateVoiceConnectorResponse",
    VoiceConnector: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.VoiceConnector !== undefined && data.VoiceConnector !== null) {
    contents.VoiceConnector = deserializeAws_restJson1_1VoiceConnector(
      data.VoiceConnector,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateVoiceConnectorCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVoiceConnectorCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateVoiceConnectorGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVoiceConnectorGroupCommandOutput> {
  if (output.statusCode !== 202 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateVoiceConnectorGroupCommandError(
      output,
      context
    );
  }
  const contents: UpdateVoiceConnectorGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateVoiceConnectorGroupResponse",
    VoiceConnectorGroup: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.VoiceConnectorGroup !== undefined &&
    data.VoiceConnectorGroup !== null
  ) {
    contents.VoiceConnectorGroup = deserializeAws_restJson1_1VoiceConnectorGroup(
      data.VoiceConnectorGroup,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateVoiceConnectorGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVoiceConnectorGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.ucbuzzconsoleservice#BadRequestException":
      response = {
        ...(await deserializeAws_restJson1_1BadRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.ucbuzzconsoleservice#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ForbiddenException":
    case "com.amazonaws.ucbuzzconsoleservice#ForbiddenException":
      response = {
        ...(await deserializeAws_restJson1_1ForbiddenExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.ucbuzzconsoleservice#NotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1NotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceFailureException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.ucbuzzconsoleservice#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottledClientException":
    case "com.amazonaws.ucbuzzconsoleservice#ThrottledClientException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottledClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedClientException":
    case "com.amazonaws.ucbuzzconsoleservice#UnauthorizedClientException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedClientExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_restJson1_1AccessDeniedExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<AccessDeniedException> => {
  const contents: AccessDeniedException = {
    name: "AccessDeniedException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1BadRequestExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<BadRequestException> => {
  const contents: BadRequestException = {
    name: "BadRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1ConflictExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ConflictException> => {
  const contents: ConflictException = {
    name: "ConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1ForbiddenExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ForbiddenException> => {
  const contents: ForbiddenException = {
    name: "ForbiddenException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1NotFoundExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<NotFoundException> => {
  const contents: NotFoundException = {
    name: "NotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceLimitExceededExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceLimitExceededException> => {
  const contents: ResourceLimitExceededException = {
    name: "ResourceLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1ServiceFailureExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ServiceFailureException> => {
  const contents: ServiceFailureException = {
    name: "ServiceFailureException",
    $fault: "server",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1ServiceUnavailableExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ServiceUnavailableException> => {
  const contents: ServiceUnavailableException = {
    name: "ServiceUnavailableException",
    $fault: "server",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1ThrottledClientExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ThrottledClientException> => {
  const contents: ThrottledClientException = {
    name: "ThrottledClientException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1UnauthorizedClientExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<UnauthorizedClientException> => {
  const contents: UnauthorizedClientException = {
    name: "UnauthorizedClientException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1UnprocessableEntityExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<UnprocessableEntityException> => {
  const contents: UnprocessableEntityException = {
    name: "UnprocessableEntityException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    Code: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Code !== undefined && data.Code !== null) {
    contents.Code = data.Code;
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const serializeAws_restJson1_1AccountSettings = (
  input: AccountSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DisableRemoteControl !== undefined) {
    bodyParams["DisableRemoteControl"] = input.DisableRemoteControl;
  }
  if (input.EnableDialOut !== undefined) {
    bodyParams["EnableDialOut"] = input.EnableDialOut;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AlexaForBusinessMetadata = (
  input: AlexaForBusinessMetadata,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AlexaForBusinessRoomArn !== undefined) {
    bodyParams["AlexaForBusinessRoomArn"] = input.AlexaForBusinessRoomArn;
  }
  if (input.IsAlexaForBusinessEnabled !== undefined) {
    bodyParams["IsAlexaForBusinessEnabled"] = input.IsAlexaForBusinessEnabled;
  }
  return bodyParams;
};

const serializeAws_restJson1_1BusinessCallingSettings = (
  input: BusinessCallingSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CdrBucket !== undefined) {
    bodyParams["CdrBucket"] = input.CdrBucket;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CallingRegionList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1CreateAttendeeRequestItem = (
  input: CreateAttendeeRequestItem,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ExternalUserId !== undefined) {
    bodyParams["ExternalUserId"] = input.ExternalUserId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CreateAttendeeRequestItemList = (
  input: Array<CreateAttendeeRequestItem>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_restJson1_1CreateAttendeeRequestItem(entry, context)
    );
  }
  return contents;
};

const serializeAws_restJson1_1Credential = (
  input: Credential,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CredentialList = (
  input: Array<Credential>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1Credential(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1E164PhoneNumberList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1LoggingConfiguration = (
  input: LoggingConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EnableSIPLogs !== undefined) {
    bodyParams["EnableSIPLogs"] = input.EnableSIPLogs;
  }
  return bodyParams;
};

const serializeAws_restJson1_1MeetingNotificationConfiguration = (
  input: MeetingNotificationConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SnsTopicArn !== undefined) {
    bodyParams["SnsTopicArn"] = input.SnsTopicArn;
  }
  if (input.SqsQueueArn !== undefined) {
    bodyParams["SqsQueueArn"] = input.SqsQueueArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1MembershipItem = (
  input: MembershipItem,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MemberId !== undefined) {
    bodyParams["MemberId"] = input.MemberId;
  }
  if (input.Role !== undefined) {
    bodyParams["Role"] = input.Role;
  }
  return bodyParams;
};

const serializeAws_restJson1_1MembershipItemList = (
  input: Array<MembershipItem>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1MembershipItem(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1NonEmptyStringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1Origination = (
  input: Origination,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Disabled !== undefined) {
    bodyParams["Disabled"] = input.Disabled;
  }
  if (input.Routes !== undefined) {
    bodyParams["Routes"] = serializeAws_restJson1_1OriginationRouteList(
      input.Routes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1OriginationRoute = (
  input: OriginationRoute,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  if (input.Priority !== undefined) {
    bodyParams["Priority"] = input.Priority;
  }
  if (input.Protocol !== undefined) {
    bodyParams["Protocol"] = input.Protocol;
  }
  if (input.Weight !== undefined) {
    bodyParams["Weight"] = input.Weight;
  }
  return bodyParams;
};

const serializeAws_restJson1_1OriginationRouteList = (
  input: Array<OriginationRoute>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1OriginationRoute(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1SensitiveStringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1SigninDelegateGroup = (
  input: SigninDelegateGroup,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GroupName !== undefined) {
    bodyParams["GroupName"] = input.GroupName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SigninDelegateGroupList = (
  input: Array<SigninDelegateGroup>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1SigninDelegateGroup(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1StreamingConfiguration = (
  input: StreamingConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DataRetentionInHours !== undefined) {
    bodyParams["DataRetentionInHours"] = input.DataRetentionInHours;
  }
  if (input.Disabled !== undefined) {
    bodyParams["Disabled"] = input.Disabled;
  }
  return bodyParams;
};

const serializeAws_restJson1_1StringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1TelephonySettings = (
  input: TelephonySettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.InboundCalling !== undefined) {
    bodyParams["InboundCalling"] = input.InboundCalling;
  }
  if (input.OutboundCalling !== undefined) {
    bodyParams["OutboundCalling"] = input.OutboundCalling;
  }
  if (input.SMS !== undefined) {
    bodyParams["SMS"] = input.SMS;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Termination = (
  input: Termination,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CallingRegions !== undefined) {
    bodyParams["CallingRegions"] = serializeAws_restJson1_1CallingRegionList(
      input.CallingRegions,
      context
    );
  }
  if (input.CidrAllowedList !== undefined) {
    bodyParams["CidrAllowedList"] = serializeAws_restJson1_1StringList(
      input.CidrAllowedList,
      context
    );
  }
  if (input.CpsLimit !== undefined) {
    bodyParams["CpsLimit"] = input.CpsLimit;
  }
  if (input.DefaultPhoneNumber !== undefined) {
    bodyParams["DefaultPhoneNumber"] = input.DefaultPhoneNumber;
  }
  if (input.Disabled !== undefined) {
    bodyParams["Disabled"] = input.Disabled;
  }
  return bodyParams;
};

const serializeAws_restJson1_1UpdatePhoneNumberRequestItem = (
  input: UpdatePhoneNumberRequestItem,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CallingName !== undefined) {
    bodyParams["CallingName"] = input.CallingName;
  }
  if (input.PhoneNumberId !== undefined) {
    bodyParams["PhoneNumberId"] = input.PhoneNumberId;
  }
  if (input.ProductType !== undefined) {
    bodyParams["ProductType"] = input.ProductType;
  }
  return bodyParams;
};

const serializeAws_restJson1_1UpdatePhoneNumberRequestItemList = (
  input: Array<UpdatePhoneNumberRequestItem>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_restJson1_1UpdatePhoneNumberRequestItem(entry, context)
    );
  }
  return contents;
};

const serializeAws_restJson1_1UpdateUserRequestItem = (
  input: UpdateUserRequestItem,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AlexaForBusinessMetadata !== undefined) {
    bodyParams[
      "AlexaForBusinessMetadata"
    ] = serializeAws_restJson1_1AlexaForBusinessMetadata(
      input.AlexaForBusinessMetadata,
      context
    );
  }
  if (input.LicenseType !== undefined) {
    bodyParams["LicenseType"] = input.LicenseType;
  }
  if (input.UserId !== undefined) {
    bodyParams["UserId"] = input.UserId;
  }
  if (input.UserType !== undefined) {
    bodyParams["UserType"] = input.UserType;
  }
  return bodyParams;
};

const serializeAws_restJson1_1UpdateUserRequestItemList = (
  input: Array<UpdateUserRequestItem>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_restJson1_1UpdateUserRequestItem(entry, context)
    );
  }
  return contents;
};

const serializeAws_restJson1_1UserEmailList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1UserIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1UserSettings = (
  input: UserSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Telephony !== undefined) {
    bodyParams["Telephony"] = serializeAws_restJson1_1TelephonySettings(
      input.Telephony,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1VoiceConnectorItem = (
  input: VoiceConnectorItem,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Priority !== undefined) {
    bodyParams["Priority"] = input.Priority;
  }
  if (input.VoiceConnectorId !== undefined) {
    bodyParams["VoiceConnectorId"] = input.VoiceConnectorId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1VoiceConnectorItemList = (
  input: Array<VoiceConnectorItem>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1VoiceConnectorItem(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1VoiceConnectorSettings = (
  input: VoiceConnectorSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CdrBucket !== undefined) {
    bodyParams["CdrBucket"] = input.CdrBucket;
  }
  return bodyParams;
};

const deserializeAws_restJson1_1Account = (
  output: any,
  context: __SerdeContext
): Account => {
  let contents: any = {
    __type: "Account",
    AccountId: undefined,
    AccountType: undefined,
    AwsAccountId: undefined,
    CreatedTimestamp: undefined,
    DefaultLicense: undefined,
    Name: undefined,
    SigninDelegateGroups: undefined,
    SupportedLicenses: undefined
  };
  if (output.AccountId !== undefined && output.AccountId !== null) {
    contents.AccountId = output.AccountId;
  }
  if (output.AccountType !== undefined && output.AccountType !== null) {
    contents.AccountType = output.AccountType;
  }
  if (output.AwsAccountId !== undefined && output.AwsAccountId !== null) {
    contents.AwsAccountId = output.AwsAccountId;
  }
  if (
    output.CreatedTimestamp !== undefined &&
    output.CreatedTimestamp !== null
  ) {
    contents.CreatedTimestamp = new Date(output.CreatedTimestamp);
  }
  if (output.DefaultLicense !== undefined && output.DefaultLicense !== null) {
    contents.DefaultLicense = output.DefaultLicense;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.SigninDelegateGroups !== undefined &&
    output.SigninDelegateGroups !== null
  ) {
    contents.SigninDelegateGroups = deserializeAws_restJson1_1SigninDelegateGroupList(
      output.SigninDelegateGroups,
      context
    );
  }
  if (
    output.SupportedLicenses !== undefined &&
    output.SupportedLicenses !== null
  ) {
    contents.SupportedLicenses = deserializeAws_restJson1_1LicenseList(
      output.SupportedLicenses,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1AccountList = (
  output: any,
  context: __SerdeContext
): Array<Account> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Account(entry, context)
  );
};

const deserializeAws_restJson1_1AccountSettings = (
  output: any,
  context: __SerdeContext
): AccountSettings => {
  let contents: any = {
    __type: "AccountSettings",
    DisableRemoteControl: undefined,
    EnableDialOut: undefined
  };
  if (
    output.DisableRemoteControl !== undefined &&
    output.DisableRemoteControl !== null
  ) {
    contents.DisableRemoteControl = output.DisableRemoteControl;
  }
  if (output.EnableDialOut !== undefined && output.EnableDialOut !== null) {
    contents.EnableDialOut = output.EnableDialOut;
  }
  return contents;
};

const deserializeAws_restJson1_1AlexaForBusinessMetadata = (
  output: any,
  context: __SerdeContext
): AlexaForBusinessMetadata => {
  let contents: any = {
    __type: "AlexaForBusinessMetadata",
    AlexaForBusinessRoomArn: undefined,
    IsAlexaForBusinessEnabled: undefined
  };
  if (
    output.AlexaForBusinessRoomArn !== undefined &&
    output.AlexaForBusinessRoomArn !== null
  ) {
    contents.AlexaForBusinessRoomArn = output.AlexaForBusinessRoomArn;
  }
  if (
    output.IsAlexaForBusinessEnabled !== undefined &&
    output.IsAlexaForBusinessEnabled !== null
  ) {
    contents.IsAlexaForBusinessEnabled = output.IsAlexaForBusinessEnabled;
  }
  return contents;
};

const deserializeAws_restJson1_1Attendee = (
  output: any,
  context: __SerdeContext
): Attendee => {
  let contents: any = {
    __type: "Attendee",
    AttendeeId: undefined,
    ExternalUserId: undefined,
    JoinToken: undefined
  };
  if (output.AttendeeId !== undefined && output.AttendeeId !== null) {
    contents.AttendeeId = output.AttendeeId;
  }
  if (output.ExternalUserId !== undefined && output.ExternalUserId !== null) {
    contents.ExternalUserId = output.ExternalUserId;
  }
  if (output.JoinToken !== undefined && output.JoinToken !== null) {
    contents.JoinToken = output.JoinToken;
  }
  return contents;
};

const deserializeAws_restJson1_1AttendeeList = (
  output: any,
  context: __SerdeContext
): Array<Attendee> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Attendee(entry, context)
  );
};

const deserializeAws_restJson1_1BatchCreateAttendeeErrorList = (
  output: any,
  context: __SerdeContext
): Array<CreateAttendeeError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1CreateAttendeeError(entry, context)
  );
};

const deserializeAws_restJson1_1Bot = (
  output: any,
  context: __SerdeContext
): Bot => {
  let contents: any = {
    __type: "Bot",
    BotEmail: undefined,
    BotId: undefined,
    BotType: undefined,
    CreatedTimestamp: undefined,
    Disabled: undefined,
    DisplayName: undefined,
    SecurityToken: undefined,
    UpdatedTimestamp: undefined,
    UserId: undefined
  };
  if (output.BotEmail !== undefined && output.BotEmail !== null) {
    contents.BotEmail = output.BotEmail;
  }
  if (output.BotId !== undefined && output.BotId !== null) {
    contents.BotId = output.BotId;
  }
  if (output.BotType !== undefined && output.BotType !== null) {
    contents.BotType = output.BotType;
  }
  if (
    output.CreatedTimestamp !== undefined &&
    output.CreatedTimestamp !== null
  ) {
    contents.CreatedTimestamp = new Date(output.CreatedTimestamp);
  }
  if (output.Disabled !== undefined && output.Disabled !== null) {
    contents.Disabled = output.Disabled;
  }
  if (output.DisplayName !== undefined && output.DisplayName !== null) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.SecurityToken !== undefined && output.SecurityToken !== null) {
    contents.SecurityToken = output.SecurityToken;
  }
  if (
    output.UpdatedTimestamp !== undefined &&
    output.UpdatedTimestamp !== null
  ) {
    contents.UpdatedTimestamp = new Date(output.UpdatedTimestamp);
  }
  if (output.UserId !== undefined && output.UserId !== null) {
    contents.UserId = output.UserId;
  }
  return contents;
};

const deserializeAws_restJson1_1BotList = (
  output: any,
  context: __SerdeContext
): Array<Bot> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Bot(entry, context)
  );
};

const deserializeAws_restJson1_1BusinessCallingSettings = (
  output: any,
  context: __SerdeContext
): BusinessCallingSettings => {
  let contents: any = {
    __type: "BusinessCallingSettings",
    CdrBucket: undefined
  };
  if (output.CdrBucket !== undefined && output.CdrBucket !== null) {
    contents.CdrBucket = output.CdrBucket;
  }
  return contents;
};

const deserializeAws_restJson1_1CallingRegionList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1CreateAttendeeError = (
  output: any,
  context: __SerdeContext
): CreateAttendeeError => {
  let contents: any = {
    __type: "CreateAttendeeError",
    ErrorCode: undefined,
    ErrorMessage: undefined,
    ExternalUserId: undefined
  };
  if (output.ErrorCode !== undefined && output.ErrorCode !== null) {
    contents.ErrorCode = output.ErrorCode;
  }
  if (output.ErrorMessage !== undefined && output.ErrorMessage !== null) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  if (output.ExternalUserId !== undefined && output.ExternalUserId !== null) {
    contents.ExternalUserId = output.ExternalUserId;
  }
  return contents;
};

const deserializeAws_restJson1_1E164PhoneNumberList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1EventsConfiguration = (
  output: any,
  context: __SerdeContext
): EventsConfiguration => {
  let contents: any = {
    __type: "EventsConfiguration",
    BotId: undefined,
    LambdaFunctionArn: undefined,
    OutboundEventsHTTPSEndpoint: undefined
  };
  if (output.BotId !== undefined && output.BotId !== null) {
    contents.BotId = output.BotId;
  }
  if (
    output.LambdaFunctionArn !== undefined &&
    output.LambdaFunctionArn !== null
  ) {
    contents.LambdaFunctionArn = output.LambdaFunctionArn;
  }
  if (
    output.OutboundEventsHTTPSEndpoint !== undefined &&
    output.OutboundEventsHTTPSEndpoint !== null
  ) {
    contents.OutboundEventsHTTPSEndpoint = output.OutboundEventsHTTPSEndpoint;
  }
  return contents;
};

const deserializeAws_restJson1_1Invite = (
  output: any,
  context: __SerdeContext
): Invite => {
  let contents: any = {
    __type: "Invite",
    EmailAddress: undefined,
    EmailStatus: undefined,
    InviteId: undefined,
    Status: undefined
  };
  if (output.EmailAddress !== undefined && output.EmailAddress !== null) {
    contents.EmailAddress = output.EmailAddress;
  }
  if (output.EmailStatus !== undefined && output.EmailStatus !== null) {
    contents.EmailStatus = output.EmailStatus;
  }
  if (output.InviteId !== undefined && output.InviteId !== null) {
    contents.InviteId = output.InviteId;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_restJson1_1InviteList = (
  output: any,
  context: __SerdeContext
): Array<Invite> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Invite(entry, context)
  );
};

const deserializeAws_restJson1_1LicenseList = (
  output: any,
  context: __SerdeContext
): Array<License | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1LoggingConfiguration = (
  output: any,
  context: __SerdeContext
): LoggingConfiguration => {
  let contents: any = {
    __type: "LoggingConfiguration",
    EnableSIPLogs: undefined
  };
  if (output.EnableSIPLogs !== undefined && output.EnableSIPLogs !== null) {
    contents.EnableSIPLogs = output.EnableSIPLogs;
  }
  return contents;
};

const deserializeAws_restJson1_1MediaPlacement = (
  output: any,
  context: __SerdeContext
): MediaPlacement => {
  let contents: any = {
    __type: "MediaPlacement",
    AudioHostUrl: undefined,
    ScreenDataUrl: undefined,
    ScreenSharingUrl: undefined,
    ScreenViewingUrl: undefined,
    SignalingUrl: undefined,
    TurnControlUrl: undefined
  };
  if (output.AudioHostUrl !== undefined && output.AudioHostUrl !== null) {
    contents.AudioHostUrl = output.AudioHostUrl;
  }
  if (output.ScreenDataUrl !== undefined && output.ScreenDataUrl !== null) {
    contents.ScreenDataUrl = output.ScreenDataUrl;
  }
  if (
    output.ScreenSharingUrl !== undefined &&
    output.ScreenSharingUrl !== null
  ) {
    contents.ScreenSharingUrl = output.ScreenSharingUrl;
  }
  if (
    output.ScreenViewingUrl !== undefined &&
    output.ScreenViewingUrl !== null
  ) {
    contents.ScreenViewingUrl = output.ScreenViewingUrl;
  }
  if (output.SignalingUrl !== undefined && output.SignalingUrl !== null) {
    contents.SignalingUrl = output.SignalingUrl;
  }
  if (output.TurnControlUrl !== undefined && output.TurnControlUrl !== null) {
    contents.TurnControlUrl = output.TurnControlUrl;
  }
  return contents;
};

const deserializeAws_restJson1_1Meeting = (
  output: any,
  context: __SerdeContext
): Meeting => {
  let contents: any = {
    __type: "Meeting",
    MediaPlacement: undefined,
    MediaRegion: undefined,
    MeetingId: undefined
  };
  if (output.MediaPlacement !== undefined && output.MediaPlacement !== null) {
    contents.MediaPlacement = deserializeAws_restJson1_1MediaPlacement(
      output.MediaPlacement,
      context
    );
  }
  if (output.MediaRegion !== undefined && output.MediaRegion !== null) {
    contents.MediaRegion = output.MediaRegion;
  }
  if (output.MeetingId !== undefined && output.MeetingId !== null) {
    contents.MeetingId = output.MeetingId;
  }
  return contents;
};

const deserializeAws_restJson1_1MeetingList = (
  output: any,
  context: __SerdeContext
): Array<Meeting> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Meeting(entry, context)
  );
};

const deserializeAws_restJson1_1Member = (
  output: any,
  context: __SerdeContext
): Member => {
  let contents: any = {
    __type: "Member",
    AccountId: undefined,
    Email: undefined,
    FullName: undefined,
    MemberId: undefined,
    MemberType: undefined
  };
  if (output.AccountId !== undefined && output.AccountId !== null) {
    contents.AccountId = output.AccountId;
  }
  if (output.Email !== undefined && output.Email !== null) {
    contents.Email = output.Email;
  }
  if (output.FullName !== undefined && output.FullName !== null) {
    contents.FullName = output.FullName;
  }
  if (output.MemberId !== undefined && output.MemberId !== null) {
    contents.MemberId = output.MemberId;
  }
  if (output.MemberType !== undefined && output.MemberType !== null) {
    contents.MemberType = output.MemberType;
  }
  return contents;
};

const deserializeAws_restJson1_1MemberError = (
  output: any,
  context: __SerdeContext
): MemberError => {
  let contents: any = {
    __type: "MemberError",
    ErrorCode: undefined,
    ErrorMessage: undefined,
    MemberId: undefined
  };
  if (output.ErrorCode !== undefined && output.ErrorCode !== null) {
    contents.ErrorCode = output.ErrorCode;
  }
  if (output.ErrorMessage !== undefined && output.ErrorMessage !== null) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  if (output.MemberId !== undefined && output.MemberId !== null) {
    contents.MemberId = output.MemberId;
  }
  return contents;
};

const deserializeAws_restJson1_1MemberErrorList = (
  output: any,
  context: __SerdeContext
): Array<MemberError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1MemberError(entry, context)
  );
};

const deserializeAws_restJson1_1OrderedPhoneNumber = (
  output: any,
  context: __SerdeContext
): OrderedPhoneNumber => {
  let contents: any = {
    __type: "OrderedPhoneNumber",
    E164PhoneNumber: undefined,
    Status: undefined
  };
  if (output.E164PhoneNumber !== undefined && output.E164PhoneNumber !== null) {
    contents.E164PhoneNumber = output.E164PhoneNumber;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_restJson1_1OrderedPhoneNumberList = (
  output: any,
  context: __SerdeContext
): Array<OrderedPhoneNumber> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1OrderedPhoneNumber(entry, context)
  );
};

const deserializeAws_restJson1_1Origination = (
  output: any,
  context: __SerdeContext
): Origination => {
  let contents: any = {
    __type: "Origination",
    Disabled: undefined,
    Routes: undefined
  };
  if (output.Disabled !== undefined && output.Disabled !== null) {
    contents.Disabled = output.Disabled;
  }
  if (output.Routes !== undefined && output.Routes !== null) {
    contents.Routes = deserializeAws_restJson1_1OriginationRouteList(
      output.Routes,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1OriginationRoute = (
  output: any,
  context: __SerdeContext
): OriginationRoute => {
  let contents: any = {
    __type: "OriginationRoute",
    Host: undefined,
    Port: undefined,
    Priority: undefined,
    Protocol: undefined,
    Weight: undefined
  };
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  if (output.Priority !== undefined && output.Priority !== null) {
    contents.Priority = output.Priority;
  }
  if (output.Protocol !== undefined && output.Protocol !== null) {
    contents.Protocol = output.Protocol;
  }
  if (output.Weight !== undefined && output.Weight !== null) {
    contents.Weight = output.Weight;
  }
  return contents;
};

const deserializeAws_restJson1_1OriginationRouteList = (
  output: any,
  context: __SerdeContext
): Array<OriginationRoute> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1OriginationRoute(entry, context)
  );
};

const deserializeAws_restJson1_1PhoneNumber = (
  output: any,
  context: __SerdeContext
): PhoneNumber => {
  let contents: any = {
    __type: "PhoneNumber",
    Associations: undefined,
    CallingName: undefined,
    CallingNameStatus: undefined,
    Capabilities: undefined,
    CreatedTimestamp: undefined,
    DeletionTimestamp: undefined,
    E164PhoneNumber: undefined,
    PhoneNumberId: undefined,
    ProductType: undefined,
    Status: undefined,
    Type: undefined,
    UpdatedTimestamp: undefined
  };
  if (output.Associations !== undefined && output.Associations !== null) {
    contents.Associations = deserializeAws_restJson1_1PhoneNumberAssociationList(
      output.Associations,
      context
    );
  }
  if (output.CallingName !== undefined && output.CallingName !== null) {
    contents.CallingName = output.CallingName;
  }
  if (
    output.CallingNameStatus !== undefined &&
    output.CallingNameStatus !== null
  ) {
    contents.CallingNameStatus = output.CallingNameStatus;
  }
  if (output.Capabilities !== undefined && output.Capabilities !== null) {
    contents.Capabilities = deserializeAws_restJson1_1PhoneNumberCapabilities(
      output.Capabilities,
      context
    );
  }
  if (
    output.CreatedTimestamp !== undefined &&
    output.CreatedTimestamp !== null
  ) {
    contents.CreatedTimestamp = new Date(output.CreatedTimestamp);
  }
  if (
    output.DeletionTimestamp !== undefined &&
    output.DeletionTimestamp !== null
  ) {
    contents.DeletionTimestamp = new Date(output.DeletionTimestamp);
  }
  if (output.E164PhoneNumber !== undefined && output.E164PhoneNumber !== null) {
    contents.E164PhoneNumber = output.E164PhoneNumber;
  }
  if (output.PhoneNumberId !== undefined && output.PhoneNumberId !== null) {
    contents.PhoneNumberId = output.PhoneNumberId;
  }
  if (output.ProductType !== undefined && output.ProductType !== null) {
    contents.ProductType = output.ProductType;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (
    output.UpdatedTimestamp !== undefined &&
    output.UpdatedTimestamp !== null
  ) {
    contents.UpdatedTimestamp = new Date(output.UpdatedTimestamp);
  }
  return contents;
};

const deserializeAws_restJson1_1PhoneNumberAssociation = (
  output: any,
  context: __SerdeContext
): PhoneNumberAssociation => {
  let contents: any = {
    __type: "PhoneNumberAssociation",
    AssociatedTimestamp: undefined,
    Name: undefined,
    Value: undefined
  };
  if (
    output.AssociatedTimestamp !== undefined &&
    output.AssociatedTimestamp !== null
  ) {
    contents.AssociatedTimestamp = new Date(output.AssociatedTimestamp);
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_restJson1_1PhoneNumberAssociationList = (
  output: any,
  context: __SerdeContext
): Array<PhoneNumberAssociation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1PhoneNumberAssociation(entry, context)
  );
};

const deserializeAws_restJson1_1PhoneNumberCapabilities = (
  output: any,
  context: __SerdeContext
): PhoneNumberCapabilities => {
  let contents: any = {
    __type: "PhoneNumberCapabilities",
    InboundCall: undefined,
    InboundMMS: undefined,
    InboundSMS: undefined,
    OutboundCall: undefined,
    OutboundMMS: undefined,
    OutboundSMS: undefined
  };
  if (output.InboundCall !== undefined && output.InboundCall !== null) {
    contents.InboundCall = output.InboundCall;
  }
  if (output.InboundMMS !== undefined && output.InboundMMS !== null) {
    contents.InboundMMS = output.InboundMMS;
  }
  if (output.InboundSMS !== undefined && output.InboundSMS !== null) {
    contents.InboundSMS = output.InboundSMS;
  }
  if (output.OutboundCall !== undefined && output.OutboundCall !== null) {
    contents.OutboundCall = output.OutboundCall;
  }
  if (output.OutboundMMS !== undefined && output.OutboundMMS !== null) {
    contents.OutboundMMS = output.OutboundMMS;
  }
  if (output.OutboundSMS !== undefined && output.OutboundSMS !== null) {
    contents.OutboundSMS = output.OutboundSMS;
  }
  return contents;
};

const deserializeAws_restJson1_1PhoneNumberError = (
  output: any,
  context: __SerdeContext
): PhoneNumberError => {
  let contents: any = {
    __type: "PhoneNumberError",
    ErrorCode: undefined,
    ErrorMessage: undefined,
    PhoneNumberId: undefined
  };
  if (output.ErrorCode !== undefined && output.ErrorCode !== null) {
    contents.ErrorCode = output.ErrorCode;
  }
  if (output.ErrorMessage !== undefined && output.ErrorMessage !== null) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  if (output.PhoneNumberId !== undefined && output.PhoneNumberId !== null) {
    contents.PhoneNumberId = output.PhoneNumberId;
  }
  return contents;
};

const deserializeAws_restJson1_1PhoneNumberErrorList = (
  output: any,
  context: __SerdeContext
): Array<PhoneNumberError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1PhoneNumberError(entry, context)
  );
};

const deserializeAws_restJson1_1PhoneNumberList = (
  output: any,
  context: __SerdeContext
): Array<PhoneNumber> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1PhoneNumber(entry, context)
  );
};

const deserializeAws_restJson1_1PhoneNumberOrder = (
  output: any,
  context: __SerdeContext
): PhoneNumberOrder => {
  let contents: any = {
    __type: "PhoneNumberOrder",
    CreatedTimestamp: undefined,
    OrderedPhoneNumbers: undefined,
    PhoneNumberOrderId: undefined,
    ProductType: undefined,
    Status: undefined,
    UpdatedTimestamp: undefined
  };
  if (
    output.CreatedTimestamp !== undefined &&
    output.CreatedTimestamp !== null
  ) {
    contents.CreatedTimestamp = new Date(output.CreatedTimestamp);
  }
  if (
    output.OrderedPhoneNumbers !== undefined &&
    output.OrderedPhoneNumbers !== null
  ) {
    contents.OrderedPhoneNumbers = deserializeAws_restJson1_1OrderedPhoneNumberList(
      output.OrderedPhoneNumbers,
      context
    );
  }
  if (
    output.PhoneNumberOrderId !== undefined &&
    output.PhoneNumberOrderId !== null
  ) {
    contents.PhoneNumberOrderId = output.PhoneNumberOrderId;
  }
  if (output.ProductType !== undefined && output.ProductType !== null) {
    contents.ProductType = output.ProductType;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (
    output.UpdatedTimestamp !== undefined &&
    output.UpdatedTimestamp !== null
  ) {
    contents.UpdatedTimestamp = new Date(output.UpdatedTimestamp);
  }
  return contents;
};

const deserializeAws_restJson1_1PhoneNumberOrderList = (
  output: any,
  context: __SerdeContext
): Array<PhoneNumberOrder> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1PhoneNumberOrder(entry, context)
  );
};

const deserializeAws_restJson1_1Room = (
  output: any,
  context: __SerdeContext
): Room => {
  let contents: any = {
    __type: "Room",
    AccountId: undefined,
    CreatedBy: undefined,
    CreatedTimestamp: undefined,
    Name: undefined,
    RoomId: undefined,
    UpdatedTimestamp: undefined
  };
  if (output.AccountId !== undefined && output.AccountId !== null) {
    contents.AccountId = output.AccountId;
  }
  if (output.CreatedBy !== undefined && output.CreatedBy !== null) {
    contents.CreatedBy = output.CreatedBy;
  }
  if (
    output.CreatedTimestamp !== undefined &&
    output.CreatedTimestamp !== null
  ) {
    contents.CreatedTimestamp = new Date(output.CreatedTimestamp);
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.RoomId !== undefined && output.RoomId !== null) {
    contents.RoomId = output.RoomId;
  }
  if (
    output.UpdatedTimestamp !== undefined &&
    output.UpdatedTimestamp !== null
  ) {
    contents.UpdatedTimestamp = new Date(output.UpdatedTimestamp);
  }
  return contents;
};

const deserializeAws_restJson1_1RoomList = (
  output: any,
  context: __SerdeContext
): Array<Room> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Room(entry, context)
  );
};

const deserializeAws_restJson1_1RoomMembership = (
  output: any,
  context: __SerdeContext
): RoomMembership => {
  let contents: any = {
    __type: "RoomMembership",
    InvitedBy: undefined,
    Member: undefined,
    Role: undefined,
    RoomId: undefined,
    UpdatedTimestamp: undefined
  };
  if (output.InvitedBy !== undefined && output.InvitedBy !== null) {
    contents.InvitedBy = output.InvitedBy;
  }
  if (output.Member !== undefined && output.Member !== null) {
    contents.Member = deserializeAws_restJson1_1Member(output.Member, context);
  }
  if (output.Role !== undefined && output.Role !== null) {
    contents.Role = output.Role;
  }
  if (output.RoomId !== undefined && output.RoomId !== null) {
    contents.RoomId = output.RoomId;
  }
  if (
    output.UpdatedTimestamp !== undefined &&
    output.UpdatedTimestamp !== null
  ) {
    contents.UpdatedTimestamp = new Date(output.UpdatedTimestamp);
  }
  return contents;
};

const deserializeAws_restJson1_1RoomMembershipList = (
  output: any,
  context: __SerdeContext
): Array<RoomMembership> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1RoomMembership(entry, context)
  );
};

const deserializeAws_restJson1_1SensitiveStringList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1SigninDelegateGroup = (
  output: any,
  context: __SerdeContext
): SigninDelegateGroup => {
  let contents: any = {
    __type: "SigninDelegateGroup",
    GroupName: undefined
  };
  if (output.GroupName !== undefined && output.GroupName !== null) {
    contents.GroupName = output.GroupName;
  }
  return contents;
};

const deserializeAws_restJson1_1SigninDelegateGroupList = (
  output: any,
  context: __SerdeContext
): Array<SigninDelegateGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SigninDelegateGroup(entry, context)
  );
};

const deserializeAws_restJson1_1StreamingConfiguration = (
  output: any,
  context: __SerdeContext
): StreamingConfiguration => {
  let contents: any = {
    __type: "StreamingConfiguration",
    DataRetentionInHours: undefined,
    Disabled: undefined
  };
  if (
    output.DataRetentionInHours !== undefined &&
    output.DataRetentionInHours !== null
  ) {
    contents.DataRetentionInHours = output.DataRetentionInHours;
  }
  if (output.Disabled !== undefined && output.Disabled !== null) {
    contents.Disabled = output.Disabled;
  }
  return contents;
};

const deserializeAws_restJson1_1StringList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1TelephonySettings = (
  output: any,
  context: __SerdeContext
): TelephonySettings => {
  let contents: any = {
    __type: "TelephonySettings",
    InboundCalling: undefined,
    OutboundCalling: undefined,
    SMS: undefined
  };
  if (output.InboundCalling !== undefined && output.InboundCalling !== null) {
    contents.InboundCalling = output.InboundCalling;
  }
  if (output.OutboundCalling !== undefined && output.OutboundCalling !== null) {
    contents.OutboundCalling = output.OutboundCalling;
  }
  if (output.SMS !== undefined && output.SMS !== null) {
    contents.SMS = output.SMS;
  }
  return contents;
};

const deserializeAws_restJson1_1Termination = (
  output: any,
  context: __SerdeContext
): Termination => {
  let contents: any = {
    __type: "Termination",
    CallingRegions: undefined,
    CidrAllowedList: undefined,
    CpsLimit: undefined,
    DefaultPhoneNumber: undefined,
    Disabled: undefined
  };
  if (output.CallingRegions !== undefined && output.CallingRegions !== null) {
    contents.CallingRegions = deserializeAws_restJson1_1CallingRegionList(
      output.CallingRegions,
      context
    );
  }
  if (output.CidrAllowedList !== undefined && output.CidrAllowedList !== null) {
    contents.CidrAllowedList = deserializeAws_restJson1_1StringList(
      output.CidrAllowedList,
      context
    );
  }
  if (output.CpsLimit !== undefined && output.CpsLimit !== null) {
    contents.CpsLimit = output.CpsLimit;
  }
  if (
    output.DefaultPhoneNumber !== undefined &&
    output.DefaultPhoneNumber !== null
  ) {
    contents.DefaultPhoneNumber = output.DefaultPhoneNumber;
  }
  if (output.Disabled !== undefined && output.Disabled !== null) {
    contents.Disabled = output.Disabled;
  }
  return contents;
};

const deserializeAws_restJson1_1TerminationHealth = (
  output: any,
  context: __SerdeContext
): TerminationHealth => {
  let contents: any = {
    __type: "TerminationHealth",
    Source: undefined,
    Timestamp: undefined
  };
  if (output.Source !== undefined && output.Source !== null) {
    contents.Source = output.Source;
  }
  if (output.Timestamp !== undefined && output.Timestamp !== null) {
    contents.Timestamp = new Date(output.Timestamp);
  }
  return contents;
};

const deserializeAws_restJson1_1User = (
  output: any,
  context: __SerdeContext
): User => {
  let contents: any = {
    __type: "User",
    AccountId: undefined,
    AlexaForBusinessMetadata: undefined,
    DisplayName: undefined,
    InvitedOn: undefined,
    LicenseType: undefined,
    PersonalPIN: undefined,
    PrimaryEmail: undefined,
    PrimaryProvisionedNumber: undefined,
    RegisteredOn: undefined,
    UserId: undefined,
    UserInvitationStatus: undefined,
    UserRegistrationStatus: undefined,
    UserType: undefined
  };
  if (output.AccountId !== undefined && output.AccountId !== null) {
    contents.AccountId = output.AccountId;
  }
  if (
    output.AlexaForBusinessMetadata !== undefined &&
    output.AlexaForBusinessMetadata !== null
  ) {
    contents.AlexaForBusinessMetadata = deserializeAws_restJson1_1AlexaForBusinessMetadata(
      output.AlexaForBusinessMetadata,
      context
    );
  }
  if (output.DisplayName !== undefined && output.DisplayName !== null) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.InvitedOn !== undefined && output.InvitedOn !== null) {
    contents.InvitedOn = new Date(output.InvitedOn);
  }
  if (output.LicenseType !== undefined && output.LicenseType !== null) {
    contents.LicenseType = output.LicenseType;
  }
  if (output.PersonalPIN !== undefined && output.PersonalPIN !== null) {
    contents.PersonalPIN = output.PersonalPIN;
  }
  if (output.PrimaryEmail !== undefined && output.PrimaryEmail !== null) {
    contents.PrimaryEmail = output.PrimaryEmail;
  }
  if (
    output.PrimaryProvisionedNumber !== undefined &&
    output.PrimaryProvisionedNumber !== null
  ) {
    contents.PrimaryProvisionedNumber = output.PrimaryProvisionedNumber;
  }
  if (output.RegisteredOn !== undefined && output.RegisteredOn !== null) {
    contents.RegisteredOn = new Date(output.RegisteredOn);
  }
  if (output.UserId !== undefined && output.UserId !== null) {
    contents.UserId = output.UserId;
  }
  if (
    output.UserInvitationStatus !== undefined &&
    output.UserInvitationStatus !== null
  ) {
    contents.UserInvitationStatus = output.UserInvitationStatus;
  }
  if (
    output.UserRegistrationStatus !== undefined &&
    output.UserRegistrationStatus !== null
  ) {
    contents.UserRegistrationStatus = output.UserRegistrationStatus;
  }
  if (output.UserType !== undefined && output.UserType !== null) {
    contents.UserType = output.UserType;
  }
  return contents;
};

const deserializeAws_restJson1_1UserError = (
  output: any,
  context: __SerdeContext
): UserError => {
  let contents: any = {
    __type: "UserError",
    ErrorCode: undefined,
    ErrorMessage: undefined,
    UserId: undefined
  };
  if (output.ErrorCode !== undefined && output.ErrorCode !== null) {
    contents.ErrorCode = output.ErrorCode;
  }
  if (output.ErrorMessage !== undefined && output.ErrorMessage !== null) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  if (output.UserId !== undefined && output.UserId !== null) {
    contents.UserId = output.UserId;
  }
  return contents;
};

const deserializeAws_restJson1_1UserErrorList = (
  output: any,
  context: __SerdeContext
): Array<UserError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1UserError(entry, context)
  );
};

const deserializeAws_restJson1_1UserList = (
  output: any,
  context: __SerdeContext
): Array<User> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1User(entry, context)
  );
};

const deserializeAws_restJson1_1UserSettings = (
  output: any,
  context: __SerdeContext
): UserSettings => {
  let contents: any = {
    __type: "UserSettings",
    Telephony: undefined
  };
  if (output.Telephony !== undefined && output.Telephony !== null) {
    contents.Telephony = deserializeAws_restJson1_1TelephonySettings(
      output.Telephony,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1VoiceConnector = (
  output: any,
  context: __SerdeContext
): VoiceConnector => {
  let contents: any = {
    __type: "VoiceConnector",
    AwsRegion: undefined,
    CreatedTimestamp: undefined,
    Name: undefined,
    OutboundHostName: undefined,
    RequireEncryption: undefined,
    UpdatedTimestamp: undefined,
    VoiceConnectorId: undefined
  };
  if (output.AwsRegion !== undefined && output.AwsRegion !== null) {
    contents.AwsRegion = output.AwsRegion;
  }
  if (
    output.CreatedTimestamp !== undefined &&
    output.CreatedTimestamp !== null
  ) {
    contents.CreatedTimestamp = new Date(output.CreatedTimestamp);
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.OutboundHostName !== undefined &&
    output.OutboundHostName !== null
  ) {
    contents.OutboundHostName = output.OutboundHostName;
  }
  if (
    output.RequireEncryption !== undefined &&
    output.RequireEncryption !== null
  ) {
    contents.RequireEncryption = output.RequireEncryption;
  }
  if (
    output.UpdatedTimestamp !== undefined &&
    output.UpdatedTimestamp !== null
  ) {
    contents.UpdatedTimestamp = new Date(output.UpdatedTimestamp);
  }
  if (
    output.VoiceConnectorId !== undefined &&
    output.VoiceConnectorId !== null
  ) {
    contents.VoiceConnectorId = output.VoiceConnectorId;
  }
  return contents;
};

const deserializeAws_restJson1_1VoiceConnectorGroup = (
  output: any,
  context: __SerdeContext
): VoiceConnectorGroup => {
  let contents: any = {
    __type: "VoiceConnectorGroup",
    CreatedTimestamp: undefined,
    Name: undefined,
    UpdatedTimestamp: undefined,
    VoiceConnectorGroupId: undefined,
    VoiceConnectorItems: undefined
  };
  if (
    output.CreatedTimestamp !== undefined &&
    output.CreatedTimestamp !== null
  ) {
    contents.CreatedTimestamp = new Date(output.CreatedTimestamp);
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.UpdatedTimestamp !== undefined &&
    output.UpdatedTimestamp !== null
  ) {
    contents.UpdatedTimestamp = new Date(output.UpdatedTimestamp);
  }
  if (
    output.VoiceConnectorGroupId !== undefined &&
    output.VoiceConnectorGroupId !== null
  ) {
    contents.VoiceConnectorGroupId = output.VoiceConnectorGroupId;
  }
  if (
    output.VoiceConnectorItems !== undefined &&
    output.VoiceConnectorItems !== null
  ) {
    contents.VoiceConnectorItems = deserializeAws_restJson1_1VoiceConnectorItemList(
      output.VoiceConnectorItems,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1VoiceConnectorGroupList = (
  output: any,
  context: __SerdeContext
): Array<VoiceConnectorGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1VoiceConnectorGroup(entry, context)
  );
};

const deserializeAws_restJson1_1VoiceConnectorItem = (
  output: any,
  context: __SerdeContext
): VoiceConnectorItem => {
  let contents: any = {
    __type: "VoiceConnectorItem",
    Priority: undefined,
    VoiceConnectorId: undefined
  };
  if (output.Priority !== undefined && output.Priority !== null) {
    contents.Priority = output.Priority;
  }
  if (
    output.VoiceConnectorId !== undefined &&
    output.VoiceConnectorId !== null
  ) {
    contents.VoiceConnectorId = output.VoiceConnectorId;
  }
  return contents;
};

const deserializeAws_restJson1_1VoiceConnectorItemList = (
  output: any,
  context: __SerdeContext
): Array<VoiceConnectorItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1VoiceConnectorItem(entry, context)
  );
};

const deserializeAws_restJson1_1VoiceConnectorList = (
  output: any,
  context: __SerdeContext
): Array<VoiceConnector> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1VoiceConnector(entry, context)
  );
};

const deserializeAws_restJson1_1VoiceConnectorSettings = (
  output: any,
  context: __SerdeContext
): VoiceConnectorSettings => {
  let contents: any = {
    __type: "VoiceConnectorSettings",
    CdrBucket: undefined
  };
  if (output.CdrBucket !== undefined && output.CdrBucket !== null) {
    contents.CdrBucket = output.CdrBucket;
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
