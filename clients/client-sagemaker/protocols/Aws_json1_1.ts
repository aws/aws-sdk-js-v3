import {
  AddTagsCommandInput,
  AddTagsCommandOutput
} from "../commands/AddTagsCommand";
import {
  AssociateTrialComponentCommandInput,
  AssociateTrialComponentCommandOutput
} from "../commands/AssociateTrialComponentCommand";
import {
  CreateAlgorithmCommandInput,
  CreateAlgorithmCommandOutput
} from "../commands/CreateAlgorithmCommand";
import {
  CreateAppCommandInput,
  CreateAppCommandOutput
} from "../commands/CreateAppCommand";
import {
  CreateAutoMLJobCommandInput,
  CreateAutoMLJobCommandOutput
} from "../commands/CreateAutoMLJobCommand";
import {
  CreateCodeRepositoryCommandInput,
  CreateCodeRepositoryCommandOutput
} from "../commands/CreateCodeRepositoryCommand";
import {
  CreateCompilationJobCommandInput,
  CreateCompilationJobCommandOutput
} from "../commands/CreateCompilationJobCommand";
import {
  CreateDomainCommandInput,
  CreateDomainCommandOutput
} from "../commands/CreateDomainCommand";
import {
  CreateEndpointCommandInput,
  CreateEndpointCommandOutput
} from "../commands/CreateEndpointCommand";
import {
  CreateEndpointConfigCommandInput,
  CreateEndpointConfigCommandOutput
} from "../commands/CreateEndpointConfigCommand";
import {
  CreateExperimentCommandInput,
  CreateExperimentCommandOutput
} from "../commands/CreateExperimentCommand";
import {
  CreateFlowDefinitionCommandInput,
  CreateFlowDefinitionCommandOutput
} from "../commands/CreateFlowDefinitionCommand";
import {
  CreateHumanTaskUiCommandInput,
  CreateHumanTaskUiCommandOutput
} from "../commands/CreateHumanTaskUiCommand";
import {
  CreateHyperParameterTuningJobCommandInput,
  CreateHyperParameterTuningJobCommandOutput
} from "../commands/CreateHyperParameterTuningJobCommand";
import {
  CreateLabelingJobCommandInput,
  CreateLabelingJobCommandOutput
} from "../commands/CreateLabelingJobCommand";
import {
  CreateModelCommandInput,
  CreateModelCommandOutput
} from "../commands/CreateModelCommand";
import {
  CreateModelPackageCommandInput,
  CreateModelPackageCommandOutput
} from "../commands/CreateModelPackageCommand";
import {
  CreateMonitoringScheduleCommandInput,
  CreateMonitoringScheduleCommandOutput
} from "../commands/CreateMonitoringScheduleCommand";
import {
  CreateNotebookInstanceCommandInput,
  CreateNotebookInstanceCommandOutput
} from "../commands/CreateNotebookInstanceCommand";
import {
  CreateNotebookInstanceLifecycleConfigCommandInput,
  CreateNotebookInstanceLifecycleConfigCommandOutput
} from "../commands/CreateNotebookInstanceLifecycleConfigCommand";
import {
  CreatePresignedDomainUrlCommandInput,
  CreatePresignedDomainUrlCommandOutput
} from "../commands/CreatePresignedDomainUrlCommand";
import {
  CreatePresignedNotebookInstanceUrlCommandInput,
  CreatePresignedNotebookInstanceUrlCommandOutput
} from "../commands/CreatePresignedNotebookInstanceUrlCommand";
import {
  CreateProcessingJobCommandInput,
  CreateProcessingJobCommandOutput
} from "../commands/CreateProcessingJobCommand";
import {
  CreateTrainingJobCommandInput,
  CreateTrainingJobCommandOutput
} from "../commands/CreateTrainingJobCommand";
import {
  CreateTransformJobCommandInput,
  CreateTransformJobCommandOutput
} from "../commands/CreateTransformJobCommand";
import {
  CreateTrialCommandInput,
  CreateTrialCommandOutput
} from "../commands/CreateTrialCommand";
import {
  CreateTrialComponentCommandInput,
  CreateTrialComponentCommandOutput
} from "../commands/CreateTrialComponentCommand";
import {
  CreateUserProfileCommandInput,
  CreateUserProfileCommandOutput
} from "../commands/CreateUserProfileCommand";
import {
  CreateWorkteamCommandInput,
  CreateWorkteamCommandOutput
} from "../commands/CreateWorkteamCommand";
import {
  DeleteAlgorithmCommandInput,
  DeleteAlgorithmCommandOutput
} from "../commands/DeleteAlgorithmCommand";
import {
  DeleteAppCommandInput,
  DeleteAppCommandOutput
} from "../commands/DeleteAppCommand";
import {
  DeleteCodeRepositoryCommandInput,
  DeleteCodeRepositoryCommandOutput
} from "../commands/DeleteCodeRepositoryCommand";
import {
  DeleteDomainCommandInput,
  DeleteDomainCommandOutput
} from "../commands/DeleteDomainCommand";
import {
  DeleteEndpointCommandInput,
  DeleteEndpointCommandOutput
} from "../commands/DeleteEndpointCommand";
import {
  DeleteEndpointConfigCommandInput,
  DeleteEndpointConfigCommandOutput
} from "../commands/DeleteEndpointConfigCommand";
import {
  DeleteExperimentCommandInput,
  DeleteExperimentCommandOutput
} from "../commands/DeleteExperimentCommand";
import {
  DeleteFlowDefinitionCommandInput,
  DeleteFlowDefinitionCommandOutput
} from "../commands/DeleteFlowDefinitionCommand";
import {
  DeleteModelCommandInput,
  DeleteModelCommandOutput
} from "../commands/DeleteModelCommand";
import {
  DeleteModelPackageCommandInput,
  DeleteModelPackageCommandOutput
} from "../commands/DeleteModelPackageCommand";
import {
  DeleteMonitoringScheduleCommandInput,
  DeleteMonitoringScheduleCommandOutput
} from "../commands/DeleteMonitoringScheduleCommand";
import {
  DeleteNotebookInstanceCommandInput,
  DeleteNotebookInstanceCommandOutput
} from "../commands/DeleteNotebookInstanceCommand";
import {
  DeleteNotebookInstanceLifecycleConfigCommandInput,
  DeleteNotebookInstanceLifecycleConfigCommandOutput
} from "../commands/DeleteNotebookInstanceLifecycleConfigCommand";
import {
  DeleteTagsCommandInput,
  DeleteTagsCommandOutput
} from "../commands/DeleteTagsCommand";
import {
  DeleteTrialCommandInput,
  DeleteTrialCommandOutput
} from "../commands/DeleteTrialCommand";
import {
  DeleteTrialComponentCommandInput,
  DeleteTrialComponentCommandOutput
} from "../commands/DeleteTrialComponentCommand";
import {
  DeleteUserProfileCommandInput,
  DeleteUserProfileCommandOutput
} from "../commands/DeleteUserProfileCommand";
import {
  DeleteWorkteamCommandInput,
  DeleteWorkteamCommandOutput
} from "../commands/DeleteWorkteamCommand";
import {
  DescribeAlgorithmCommandInput,
  DescribeAlgorithmCommandOutput
} from "../commands/DescribeAlgorithmCommand";
import {
  DescribeAppCommandInput,
  DescribeAppCommandOutput
} from "../commands/DescribeAppCommand";
import {
  DescribeAutoMLJobCommandInput,
  DescribeAutoMLJobCommandOutput
} from "../commands/DescribeAutoMLJobCommand";
import {
  DescribeCodeRepositoryCommandInput,
  DescribeCodeRepositoryCommandOutput
} from "../commands/DescribeCodeRepositoryCommand";
import {
  DescribeCompilationJobCommandInput,
  DescribeCompilationJobCommandOutput
} from "../commands/DescribeCompilationJobCommand";
import {
  DescribeDomainCommandInput,
  DescribeDomainCommandOutput
} from "../commands/DescribeDomainCommand";
import {
  DescribeEndpointCommandInput,
  DescribeEndpointCommandOutput
} from "../commands/DescribeEndpointCommand";
import {
  DescribeEndpointConfigCommandInput,
  DescribeEndpointConfigCommandOutput
} from "../commands/DescribeEndpointConfigCommand";
import {
  DescribeExperimentCommandInput,
  DescribeExperimentCommandOutput
} from "../commands/DescribeExperimentCommand";
import {
  DescribeFlowDefinitionCommandInput,
  DescribeFlowDefinitionCommandOutput
} from "../commands/DescribeFlowDefinitionCommand";
import {
  DescribeHumanTaskUiCommandInput,
  DescribeHumanTaskUiCommandOutput
} from "../commands/DescribeHumanTaskUiCommand";
import {
  DescribeHyperParameterTuningJobCommandInput,
  DescribeHyperParameterTuningJobCommandOutput
} from "../commands/DescribeHyperParameterTuningJobCommand";
import {
  DescribeLabelingJobCommandInput,
  DescribeLabelingJobCommandOutput
} from "../commands/DescribeLabelingJobCommand";
import {
  DescribeModelCommandInput,
  DescribeModelCommandOutput
} from "../commands/DescribeModelCommand";
import {
  DescribeModelPackageCommandInput,
  DescribeModelPackageCommandOutput
} from "../commands/DescribeModelPackageCommand";
import {
  DescribeMonitoringScheduleCommandInput,
  DescribeMonitoringScheduleCommandOutput
} from "../commands/DescribeMonitoringScheduleCommand";
import {
  DescribeNotebookInstanceCommandInput,
  DescribeNotebookInstanceCommandOutput
} from "../commands/DescribeNotebookInstanceCommand";
import {
  DescribeNotebookInstanceLifecycleConfigCommandInput,
  DescribeNotebookInstanceLifecycleConfigCommandOutput
} from "../commands/DescribeNotebookInstanceLifecycleConfigCommand";
import {
  DescribeProcessingJobCommandInput,
  DescribeProcessingJobCommandOutput
} from "../commands/DescribeProcessingJobCommand";
import {
  DescribeSubscribedWorkteamCommandInput,
  DescribeSubscribedWorkteamCommandOutput
} from "../commands/DescribeSubscribedWorkteamCommand";
import {
  DescribeTrainingJobCommandInput,
  DescribeTrainingJobCommandOutput
} from "../commands/DescribeTrainingJobCommand";
import {
  DescribeTransformJobCommandInput,
  DescribeTransformJobCommandOutput
} from "../commands/DescribeTransformJobCommand";
import {
  DescribeTrialCommandInput,
  DescribeTrialCommandOutput
} from "../commands/DescribeTrialCommand";
import {
  DescribeTrialComponentCommandInput,
  DescribeTrialComponentCommandOutput
} from "../commands/DescribeTrialComponentCommand";
import {
  DescribeUserProfileCommandInput,
  DescribeUserProfileCommandOutput
} from "../commands/DescribeUserProfileCommand";
import {
  DescribeWorkforceCommandInput,
  DescribeWorkforceCommandOutput
} from "../commands/DescribeWorkforceCommand";
import {
  DescribeWorkteamCommandInput,
  DescribeWorkteamCommandOutput
} from "../commands/DescribeWorkteamCommand";
import {
  DisassociateTrialComponentCommandInput,
  DisassociateTrialComponentCommandOutput
} from "../commands/DisassociateTrialComponentCommand";
import {
  GetSearchSuggestionsCommandInput,
  GetSearchSuggestionsCommandOutput
} from "../commands/GetSearchSuggestionsCommand";
import {
  ListAlgorithmsCommandInput,
  ListAlgorithmsCommandOutput
} from "../commands/ListAlgorithmsCommand";
import {
  ListAppsCommandInput,
  ListAppsCommandOutput
} from "../commands/ListAppsCommand";
import {
  ListAutoMLJobsCommandInput,
  ListAutoMLJobsCommandOutput
} from "../commands/ListAutoMLJobsCommand";
import {
  ListCandidatesForAutoMLJobCommandInput,
  ListCandidatesForAutoMLJobCommandOutput
} from "../commands/ListCandidatesForAutoMLJobCommand";
import {
  ListCodeRepositoriesCommandInput,
  ListCodeRepositoriesCommandOutput
} from "../commands/ListCodeRepositoriesCommand";
import {
  ListCompilationJobsCommandInput,
  ListCompilationJobsCommandOutput
} from "../commands/ListCompilationJobsCommand";
import {
  ListDomainsCommandInput,
  ListDomainsCommandOutput
} from "../commands/ListDomainsCommand";
import {
  ListEndpointConfigsCommandInput,
  ListEndpointConfigsCommandOutput
} from "../commands/ListEndpointConfigsCommand";
import {
  ListEndpointsCommandInput,
  ListEndpointsCommandOutput
} from "../commands/ListEndpointsCommand";
import {
  ListExperimentsCommandInput,
  ListExperimentsCommandOutput
} from "../commands/ListExperimentsCommand";
import {
  ListFlowDefinitionsCommandInput,
  ListFlowDefinitionsCommandOutput
} from "../commands/ListFlowDefinitionsCommand";
import {
  ListHumanTaskUisCommandInput,
  ListHumanTaskUisCommandOutput
} from "../commands/ListHumanTaskUisCommand";
import {
  ListHyperParameterTuningJobsCommandInput,
  ListHyperParameterTuningJobsCommandOutput
} from "../commands/ListHyperParameterTuningJobsCommand";
import {
  ListLabelingJobsCommandInput,
  ListLabelingJobsCommandOutput
} from "../commands/ListLabelingJobsCommand";
import {
  ListLabelingJobsForWorkteamCommandInput,
  ListLabelingJobsForWorkteamCommandOutput
} from "../commands/ListLabelingJobsForWorkteamCommand";
import {
  ListModelPackagesCommandInput,
  ListModelPackagesCommandOutput
} from "../commands/ListModelPackagesCommand";
import {
  ListModelsCommandInput,
  ListModelsCommandOutput
} from "../commands/ListModelsCommand";
import {
  ListMonitoringExecutionsCommandInput,
  ListMonitoringExecutionsCommandOutput
} from "../commands/ListMonitoringExecutionsCommand";
import {
  ListMonitoringSchedulesCommandInput,
  ListMonitoringSchedulesCommandOutput
} from "../commands/ListMonitoringSchedulesCommand";
import {
  ListNotebookInstanceLifecycleConfigsCommandInput,
  ListNotebookInstanceLifecycleConfigsCommandOutput
} from "../commands/ListNotebookInstanceLifecycleConfigsCommand";
import {
  ListNotebookInstancesCommandInput,
  ListNotebookInstancesCommandOutput
} from "../commands/ListNotebookInstancesCommand";
import {
  ListProcessingJobsCommandInput,
  ListProcessingJobsCommandOutput
} from "../commands/ListProcessingJobsCommand";
import {
  ListSubscribedWorkteamsCommandInput,
  ListSubscribedWorkteamsCommandOutput
} from "../commands/ListSubscribedWorkteamsCommand";
import {
  ListTagsCommandInput,
  ListTagsCommandOutput
} from "../commands/ListTagsCommand";
import {
  ListTrainingJobsCommandInput,
  ListTrainingJobsCommandOutput
} from "../commands/ListTrainingJobsCommand";
import {
  ListTrainingJobsForHyperParameterTuningJobCommandInput,
  ListTrainingJobsForHyperParameterTuningJobCommandOutput
} from "../commands/ListTrainingJobsForHyperParameterTuningJobCommand";
import {
  ListTransformJobsCommandInput,
  ListTransformJobsCommandOutput
} from "../commands/ListTransformJobsCommand";
import {
  ListTrialComponentsCommandInput,
  ListTrialComponentsCommandOutput
} from "../commands/ListTrialComponentsCommand";
import {
  ListTrialsCommandInput,
  ListTrialsCommandOutput
} from "../commands/ListTrialsCommand";
import {
  ListUserProfilesCommandInput,
  ListUserProfilesCommandOutput
} from "../commands/ListUserProfilesCommand";
import {
  ListWorkteamsCommandInput,
  ListWorkteamsCommandOutput
} from "../commands/ListWorkteamsCommand";
import {
  RenderUiTemplateCommandInput,
  RenderUiTemplateCommandOutput
} from "../commands/RenderUiTemplateCommand";
import {
  SearchCommandInput,
  SearchCommandOutput
} from "../commands/SearchCommand";
import {
  StartMonitoringScheduleCommandInput,
  StartMonitoringScheduleCommandOutput
} from "../commands/StartMonitoringScheduleCommand";
import {
  StartNotebookInstanceCommandInput,
  StartNotebookInstanceCommandOutput
} from "../commands/StartNotebookInstanceCommand";
import {
  StopAutoMLJobCommandInput,
  StopAutoMLJobCommandOutput
} from "../commands/StopAutoMLJobCommand";
import {
  StopCompilationJobCommandInput,
  StopCompilationJobCommandOutput
} from "../commands/StopCompilationJobCommand";
import {
  StopHyperParameterTuningJobCommandInput,
  StopHyperParameterTuningJobCommandOutput
} from "../commands/StopHyperParameterTuningJobCommand";
import {
  StopLabelingJobCommandInput,
  StopLabelingJobCommandOutput
} from "../commands/StopLabelingJobCommand";
import {
  StopMonitoringScheduleCommandInput,
  StopMonitoringScheduleCommandOutput
} from "../commands/StopMonitoringScheduleCommand";
import {
  StopNotebookInstanceCommandInput,
  StopNotebookInstanceCommandOutput
} from "../commands/StopNotebookInstanceCommand";
import {
  StopProcessingJobCommandInput,
  StopProcessingJobCommandOutput
} from "../commands/StopProcessingJobCommand";
import {
  StopTrainingJobCommandInput,
  StopTrainingJobCommandOutput
} from "../commands/StopTrainingJobCommand";
import {
  StopTransformJobCommandInput,
  StopTransformJobCommandOutput
} from "../commands/StopTransformJobCommand";
import {
  UpdateCodeRepositoryCommandInput,
  UpdateCodeRepositoryCommandOutput
} from "../commands/UpdateCodeRepositoryCommand";
import {
  UpdateDomainCommandInput,
  UpdateDomainCommandOutput
} from "../commands/UpdateDomainCommand";
import {
  UpdateEndpointCommandInput,
  UpdateEndpointCommandOutput
} from "../commands/UpdateEndpointCommand";
import {
  UpdateEndpointWeightsAndCapacitiesCommandInput,
  UpdateEndpointWeightsAndCapacitiesCommandOutput
} from "../commands/UpdateEndpointWeightsAndCapacitiesCommand";
import {
  UpdateExperimentCommandInput,
  UpdateExperimentCommandOutput
} from "../commands/UpdateExperimentCommand";
import {
  UpdateMonitoringScheduleCommandInput,
  UpdateMonitoringScheduleCommandOutput
} from "../commands/UpdateMonitoringScheduleCommand";
import {
  UpdateNotebookInstanceCommandInput,
  UpdateNotebookInstanceCommandOutput
} from "../commands/UpdateNotebookInstanceCommand";
import {
  UpdateNotebookInstanceLifecycleConfigCommandInput,
  UpdateNotebookInstanceLifecycleConfigCommandOutput
} from "../commands/UpdateNotebookInstanceLifecycleConfigCommand";
import {
  UpdateTrialCommandInput,
  UpdateTrialCommandOutput
} from "../commands/UpdateTrialCommand";
import {
  UpdateTrialComponentCommandInput,
  UpdateTrialComponentCommandOutput
} from "../commands/UpdateTrialComponentCommand";
import {
  UpdateUserProfileCommandInput,
  UpdateUserProfileCommandOutput
} from "../commands/UpdateUserProfileCommand";
import {
  UpdateWorkforceCommandInput,
  UpdateWorkforceCommandOutput
} from "../commands/UpdateWorkforceCommand";
import {
  UpdateWorkteamCommandInput,
  UpdateWorkteamCommandOutput
} from "../commands/UpdateWorkteamCommand";
import {
  AddTagsInput,
  AddTagsOutput,
  AlgorithmSpecification,
  AlgorithmStatusDetails,
  AlgorithmStatusItem,
  AlgorithmSummary,
  AlgorithmValidationProfile,
  AlgorithmValidationSpecification,
  AnnotationConsolidationConfig,
  AppDetails,
  AppSpecification,
  AssociateTrialComponentRequest,
  AssociateTrialComponentResponse,
  AutoMLCandidate,
  AutoMLCandidateStep,
  AutoMLChannel,
  AutoMLContainerDefinition,
  AutoMLDataSource,
  AutoMLJobArtifacts,
  AutoMLJobCompletionCriteria,
  AutoMLJobConfig,
  AutoMLJobObjective,
  AutoMLJobSummary,
  AutoMLOutputDataConfig,
  AutoMLS3DataSource,
  AutoMLSecurityConfig,
  CaptureContentTypeHeader,
  CaptureOption,
  CategoricalParameterRange,
  CategoricalParameterRangeSpecification,
  Channel,
  ChannelSpecification,
  CheckpointConfig,
  CodeRepositorySummary,
  CognitoMemberDefinition,
  CollectionConfiguration,
  CompilationJobSummary,
  CompressionType,
  ConflictException,
  ContainerDefinition,
  ContentClassifier,
  ContinuousParameterRange,
  ContinuousParameterRangeSpecification,
  CreateAlgorithmInput,
  CreateAlgorithmOutput,
  CreateAppRequest,
  CreateAppResponse,
  CreateAutoMLJobRequest,
  CreateAutoMLJobResponse,
  CreateCodeRepositoryInput,
  CreateCodeRepositoryOutput,
  CreateCompilationJobRequest,
  CreateCompilationJobResponse,
  CreateDomainRequest,
  CreateDomainResponse,
  CreateEndpointConfigInput,
  CreateEndpointConfigOutput,
  CreateEndpointInput,
  CreateEndpointOutput,
  CreateExperimentRequest,
  CreateExperimentResponse,
  CreateFlowDefinitionRequest,
  CreateFlowDefinitionResponse,
  CreateHumanTaskUiRequest,
  CreateHumanTaskUiResponse,
  CreateHyperParameterTuningJobRequest,
  CreateHyperParameterTuningJobResponse,
  CreateLabelingJobRequest,
  CreateLabelingJobResponse,
  CreateModelInput,
  CreateModelOutput,
  CreateModelPackageInput,
  CreateModelPackageOutput,
  CreateMonitoringScheduleRequest,
  CreateMonitoringScheduleResponse,
  CreateNotebookInstanceInput,
  CreateNotebookInstanceLifecycleConfigInput,
  CreateNotebookInstanceLifecycleConfigOutput,
  CreateNotebookInstanceOutput,
  CreatePresignedDomainUrlRequest,
  CreatePresignedDomainUrlResponse,
  CreatePresignedNotebookInstanceUrlInput,
  CreatePresignedNotebookInstanceUrlOutput,
  CreateProcessingJobRequest,
  CreateProcessingJobResponse,
  CreateTrainingJobRequest,
  CreateTrainingJobResponse,
  CreateTransformJobRequest,
  CreateTransformJobResponse,
  CreateTrialComponentRequest,
  CreateTrialComponentResponse,
  CreateTrialRequest,
  CreateTrialResponse,
  CreateUserProfileRequest,
  CreateUserProfileResponse,
  CreateWorkteamRequest,
  CreateWorkteamResponse,
  DataCaptureConfig,
  DataCaptureConfigSummary,
  DataProcessing,
  DataSource,
  DebugHookConfig,
  DebugRuleConfiguration,
  DebugRuleEvaluationStatus,
  DeleteAlgorithmInput,
  DeleteAppRequest,
  DeleteCodeRepositoryInput,
  DeleteDomainRequest,
  DeleteEndpointConfigInput,
  DeleteEndpointInput,
  DeleteExperimentRequest,
  DeleteExperimentResponse,
  DeleteFlowDefinitionRequest,
  DeleteFlowDefinitionResponse,
  DeleteModelInput,
  DeleteModelPackageInput,
  DeleteMonitoringScheduleRequest,
  DeleteNotebookInstanceInput,
  DeleteNotebookInstanceLifecycleConfigInput,
  DeleteTagsInput,
  DeleteTagsOutput,
  DeleteTrialComponentRequest,
  DeleteTrialComponentResponse,
  DeleteTrialRequest,
  DeleteTrialResponse,
  DeleteUserProfileRequest,
  DeleteWorkteamRequest,
  DeleteWorkteamResponse,
  DeployedImage,
  DescribeAlgorithmInput,
  DescribeAlgorithmOutput,
  DescribeAppRequest,
  DescribeAppResponse,
  DescribeAutoMLJobRequest,
  DescribeAutoMLJobResponse,
  DescribeCodeRepositoryInput,
  DescribeCodeRepositoryOutput,
  DescribeCompilationJobRequest,
  DescribeCompilationJobResponse,
  DescribeDomainRequest,
  DescribeDomainResponse,
  DescribeEndpointConfigInput,
  DescribeEndpointConfigOutput,
  DescribeEndpointInput,
  DescribeEndpointOutput,
  DescribeExperimentRequest,
  DescribeExperimentResponse,
  DescribeFlowDefinitionRequest,
  DescribeFlowDefinitionResponse,
  DescribeHumanTaskUiRequest,
  DescribeHumanTaskUiResponse,
  DescribeHyperParameterTuningJobRequest,
  DescribeHyperParameterTuningJobResponse,
  DescribeLabelingJobRequest,
  DescribeLabelingJobResponse,
  DescribeModelInput,
  DescribeModelOutput,
  DescribeModelPackageInput,
  DescribeModelPackageOutput,
  DescribeMonitoringScheduleRequest,
  DescribeMonitoringScheduleResponse,
  DescribeNotebookInstanceInput,
  DescribeNotebookInstanceLifecycleConfigInput,
  DescribeNotebookInstanceLifecycleConfigOutput,
  DescribeNotebookInstanceOutput,
  DescribeProcessingJobRequest,
  DescribeProcessingJobResponse,
  DescribeSubscribedWorkteamRequest,
  DescribeSubscribedWorkteamResponse,
  DescribeTrainingJobRequest,
  DescribeTrainingJobResponse,
  DescribeTransformJobRequest,
  DescribeTransformJobResponse,
  DescribeTrialComponentRequest,
  DescribeTrialComponentResponse,
  DescribeTrialRequest,
  DescribeTrialResponse,
  DescribeUserProfileRequest,
  DescribeUserProfileResponse,
  DescribeWorkforceRequest,
  DescribeWorkforceResponse,
  DescribeWorkteamRequest,
  DescribeWorkteamResponse,
  DesiredWeightAndCapacity,
  DisassociateTrialComponentRequest,
  DisassociateTrialComponentResponse,
  DomainDetails,
  EndpointConfigSummary,
  EndpointInput,
  EndpointSummary,
  Experiment,
  ExperimentConfig,
  ExperimentSource,
  ExperimentSummary,
  FileSystemDataSource,
  Filter,
  FinalAutoMLJobObjectiveMetric,
  FinalHyperParameterTuningJobObjectiveMetric,
  FlowDefinitionOutputConfig,
  FlowDefinitionSummary,
  GetSearchSuggestionsRequest,
  GetSearchSuggestionsResponse,
  GitConfig,
  GitConfigForUpdate,
  HumanLoopActivationConditionsConfig,
  HumanLoopActivationConfig,
  HumanLoopConfig,
  HumanLoopRequestSource,
  HumanTaskConfig,
  HumanTaskUiSummary,
  HyperParameterAlgorithmSpecification,
  HyperParameterSpecification,
  HyperParameterTrainingJobDefinition,
  HyperParameterTrainingJobSummary,
  HyperParameterTuningJobConfig,
  HyperParameterTuningJobObjective,
  HyperParameterTuningJobSummary,
  HyperParameterTuningJobWarmStartConfig,
  InferenceSpecification,
  InputConfig,
  IntegerParameterRange,
  IntegerParameterRangeSpecification,
  JupyterServerAppSettings,
  KernelGatewayAppSettings,
  LabelCounters,
  LabelCountersForWorkteam,
  LabelingJobAlgorithmsConfig,
  LabelingJobDataAttributes,
  LabelingJobDataSource,
  LabelingJobForWorkteamSummary,
  LabelingJobInputConfig,
  LabelingJobOutput,
  LabelingJobOutputConfig,
  LabelingJobResourceConfig,
  LabelingJobS3DataSource,
  LabelingJobStoppingConditions,
  LabelingJobSummary,
  ListAlgorithmsInput,
  ListAlgorithmsOutput,
  ListAppsRequest,
  ListAppsResponse,
  ListAutoMLJobsRequest,
  ListAutoMLJobsResponse,
  ListCandidatesForAutoMLJobRequest,
  ListCandidatesForAutoMLJobResponse,
  ListCodeRepositoriesInput,
  ListCodeRepositoriesOutput,
  ListCompilationJobsRequest,
  ListCompilationJobsResponse,
  ListDomainsRequest,
  ListDomainsResponse,
  ListEndpointConfigsInput,
  ListEndpointConfigsOutput,
  ListEndpointsInput,
  ListEndpointsOutput,
  ListExperimentsRequest,
  ListExperimentsResponse,
  ListFlowDefinitionsRequest,
  ListFlowDefinitionsResponse,
  ListHumanTaskUisRequest,
  ListHumanTaskUisResponse,
  ListHyperParameterTuningJobsRequest,
  ListHyperParameterTuningJobsResponse,
  ListLabelingJobsForWorkteamRequest,
  ListLabelingJobsForWorkteamResponse,
  ListLabelingJobsRequest,
  ListLabelingJobsResponse,
  ListModelPackagesInput,
  ListModelPackagesOutput,
  ListModelsInput,
  ListModelsOutput,
  ListMonitoringExecutionsRequest,
  ListMonitoringExecutionsResponse,
  ListMonitoringSchedulesRequest,
  ListMonitoringSchedulesResponse,
  ListNotebookInstanceLifecycleConfigsInput,
  ListNotebookInstanceLifecycleConfigsOutput,
  ListNotebookInstancesInput,
  ListNotebookInstancesOutput,
  ListProcessingJobsRequest,
  ListProcessingJobsResponse,
  ListSubscribedWorkteamsRequest,
  ListSubscribedWorkteamsResponse,
  ListTagsInput,
  ListTagsOutput,
  ListTrainingJobsForHyperParameterTuningJobRequest,
  ListTrainingJobsForHyperParameterTuningJobResponse,
  ListTrainingJobsRequest,
  ListTrainingJobsResponse,
  ListTransformJobsRequest,
  ListTransformJobsResponse,
  ListTrialComponentsRequest,
  ListTrialComponentsResponse,
  ListTrialsRequest,
  ListTrialsResponse,
  ListUserProfilesRequest,
  ListUserProfilesResponse,
  ListWorkteamsRequest,
  ListWorkteamsResponse,
  MemberDefinition,
  MetricData,
  MetricDefinition,
  ModelArtifacts,
  ModelPackageContainerDefinition,
  ModelPackageStatusDetails,
  ModelPackageStatusItem,
  ModelPackageSummary,
  ModelPackageValidationProfile,
  ModelPackageValidationSpecification,
  ModelSummary,
  MonitoringAppSpecification,
  MonitoringBaselineConfig,
  MonitoringClusterConfig,
  MonitoringConstraintsResource,
  MonitoringExecutionSummary,
  MonitoringInput,
  MonitoringJobDefinition,
  MonitoringOutput,
  MonitoringOutputConfig,
  MonitoringResources,
  MonitoringS3Output,
  MonitoringScheduleConfig,
  MonitoringScheduleSummary,
  MonitoringStatisticsResource,
  MonitoringStoppingCondition,
  NestedFilters,
  NetworkConfig,
  NotebookInstanceAcceleratorType,
  NotebookInstanceLifecycleConfigSummary,
  NotebookInstanceLifecycleHook,
  NotebookInstanceSummary,
  NotificationConfiguration,
  ObjectiveStatusCounters,
  OutputConfig,
  OutputDataConfig,
  ParameterRange,
  ParameterRanges,
  Parent,
  ParentHyperParameterTuningJob,
  ProcessingClusterConfig,
  ProcessingInput,
  ProcessingJobSummary,
  ProcessingOutput,
  ProcessingOutputConfig,
  ProcessingResources,
  ProcessingS3Input,
  ProcessingS3Output,
  ProcessingStoppingCondition,
  ProductionVariant,
  ProductionVariantInstanceType,
  ProductionVariantSummary,
  PropertyNameQuery,
  PropertyNameSuggestion,
  PublicWorkforceTaskPrice,
  RenderUiTemplateRequest,
  RenderUiTemplateResponse,
  RenderableTask,
  RenderingError,
  ResolvedAttributes,
  ResourceConfig,
  ResourceInUse,
  ResourceLimitExceeded,
  ResourceLimits,
  ResourceNotFound,
  ResourceSpec,
  RetentionPolicy,
  S3DataSource,
  ScheduleConfig,
  SearchExpression,
  SearchRecord,
  SearchRequest,
  SearchResponse,
  SecondaryStatusTransition,
  SharingSettings,
  ShuffleConfig,
  SourceAlgorithm,
  SourceAlgorithmSpecification,
  SourceIpConfig,
  StartMonitoringScheduleRequest,
  StartNotebookInstanceInput,
  StopAutoMLJobRequest,
  StopCompilationJobRequest,
  StopHyperParameterTuningJobRequest,
  StopLabelingJobRequest,
  StopMonitoringScheduleRequest,
  StopNotebookInstanceInput,
  StopProcessingJobRequest,
  StopTrainingJobRequest,
  StopTransformJobRequest,
  StoppingCondition,
  SubscribedWorkteam,
  SuggestionQuery,
  Tag,
  TensorBoardAppSettings,
  TensorBoardOutputConfig,
  TrainingInputMode,
  TrainingInstanceType,
  TrainingJob,
  TrainingJobDefinition,
  TrainingJobStatusCounters,
  TrainingJobSummary,
  TrainingSpecification,
  TransformDataSource,
  TransformInput,
  TransformInstanceType,
  TransformJobDefinition,
  TransformJobSummary,
  TransformOutput,
  TransformResources,
  TransformS3DataSource,
  Trial,
  TrialComponent,
  TrialComponentArtifact,
  TrialComponentMetricSummary,
  TrialComponentParameterValue,
  TrialComponentSimpleSummary,
  TrialComponentSource,
  TrialComponentSourceDetail,
  TrialComponentStatus,
  TrialComponentSummary,
  TrialSource,
  TrialSummary,
  TuningJobCompletionCriteria,
  USD,
  UiConfig,
  UiTemplate,
  UiTemplateInfo,
  UpdateCodeRepositoryInput,
  UpdateCodeRepositoryOutput,
  UpdateDomainRequest,
  UpdateDomainResponse,
  UpdateEndpointInput,
  UpdateEndpointOutput,
  UpdateEndpointWeightsAndCapacitiesInput,
  UpdateEndpointWeightsAndCapacitiesOutput,
  UpdateExperimentRequest,
  UpdateExperimentResponse,
  UpdateMonitoringScheduleRequest,
  UpdateMonitoringScheduleResponse,
  UpdateNotebookInstanceInput,
  UpdateNotebookInstanceLifecycleConfigInput,
  UpdateNotebookInstanceLifecycleConfigOutput,
  UpdateNotebookInstanceOutput,
  UpdateTrialComponentRequest,
  UpdateTrialComponentResponse,
  UpdateTrialRequest,
  UpdateTrialResponse,
  UpdateUserProfileRequest,
  UpdateUserProfileResponse,
  UpdateWorkforceRequest,
  UpdateWorkforceResponse,
  UpdateWorkteamRequest,
  UpdateWorkteamResponse,
  UserContext,
  UserProfileDetails,
  UserSettings,
  VpcConfig,
  Workforce,
  Workteam
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_json1_1AddTagsCommand(
  input: AddTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.AddTags";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1AddTagsInput(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1AssociateTrialComponentCommand(
  input: AssociateTrialComponentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.AssociateTrialComponent";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1AssociateTrialComponentRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateAlgorithmCommand(
  input: CreateAlgorithmCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateAlgorithm";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateAlgorithmInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateAppCommand(
  input: CreateAppCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateApp";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1CreateAppRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateAutoMLJobCommand(
  input: CreateAutoMLJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateAutoMLJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateAutoMLJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateCodeRepositoryCommand(
  input: CreateCodeRepositoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateCodeRepository";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateCodeRepositoryInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateCompilationJobCommand(
  input: CreateCompilationJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateCompilationJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateCompilationJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateDomainCommand(
  input: CreateDomainCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateDomain";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateDomainRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateEndpointCommand(
  input: CreateEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateEndpoint";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateEndpointInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateEndpointConfigCommand(
  input: CreateEndpointConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateEndpointConfig";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateEndpointConfigInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateExperimentCommand(
  input: CreateExperimentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateExperiment";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateExperimentRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateFlowDefinitionCommand(
  input: CreateFlowDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateFlowDefinition";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateFlowDefinitionRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateHumanTaskUiCommand(
  input: CreateHumanTaskUiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateHumanTaskUi";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateHumanTaskUiRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateHyperParameterTuningJobCommand(
  input: CreateHyperParameterTuningJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateHyperParameterTuningJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateHyperParameterTuningJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateLabelingJobCommand(
  input: CreateLabelingJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateLabelingJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateLabelingJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateModelCommand(
  input: CreateModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateModel";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1CreateModelInput(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateModelPackageCommand(
  input: CreateModelPackageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateModelPackage";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateModelPackageInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateMonitoringScheduleCommand(
  input: CreateMonitoringScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateMonitoringSchedule";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateMonitoringScheduleRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateNotebookInstanceCommand(
  input: CreateNotebookInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateNotebookInstance";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateNotebookInstanceInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateNotebookInstanceLifecycleConfigCommand(
  input: CreateNotebookInstanceLifecycleConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateNotebookInstanceLifecycleConfig";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateNotebookInstanceLifecycleConfigInput(
      input,
      context
    )
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreatePresignedDomainUrlCommand(
  input: CreatePresignedDomainUrlCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreatePresignedDomainUrl";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreatePresignedDomainUrlRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreatePresignedNotebookInstanceUrlCommand(
  input: CreatePresignedNotebookInstanceUrlCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreatePresignedNotebookInstanceUrl";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreatePresignedNotebookInstanceUrlInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateProcessingJobCommand(
  input: CreateProcessingJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateProcessingJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateProcessingJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateTrainingJobCommand(
  input: CreateTrainingJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateTrainingJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateTrainingJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateTransformJobCommand(
  input: CreateTransformJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateTransformJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateTransformJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateTrialCommand(
  input: CreateTrialCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateTrial";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1CreateTrialRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateTrialComponentCommand(
  input: CreateTrialComponentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateTrialComponent";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateTrialComponentRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateUserProfileCommand(
  input: CreateUserProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateUserProfile";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateUserProfileRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateWorkteamCommand(
  input: CreateWorkteamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.CreateWorkteam";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateWorkteamRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteAlgorithmCommand(
  input: DeleteAlgorithmCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteAlgorithm";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteAlgorithmInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteAppCommand(
  input: DeleteAppCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteApp";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1DeleteAppRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteCodeRepositoryCommand(
  input: DeleteCodeRepositoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteCodeRepository";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteCodeRepositoryInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteDomainCommand(
  input: DeleteDomainCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteDomain";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteDomainRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteEndpointCommand(
  input: DeleteEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteEndpoint";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteEndpointInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteEndpointConfigCommand(
  input: DeleteEndpointConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteEndpointConfig";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteEndpointConfigInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteExperimentCommand(
  input: DeleteExperimentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteExperiment";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteExperimentRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteFlowDefinitionCommand(
  input: DeleteFlowDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteFlowDefinition";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteFlowDefinitionRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteModelCommand(
  input: DeleteModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteModel";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1DeleteModelInput(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteModelPackageCommand(
  input: DeleteModelPackageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteModelPackage";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteModelPackageInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteMonitoringScheduleCommand(
  input: DeleteMonitoringScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteMonitoringSchedule";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteMonitoringScheduleRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteNotebookInstanceCommand(
  input: DeleteNotebookInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteNotebookInstance";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteNotebookInstanceInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteNotebookInstanceLifecycleConfigCommand(
  input: DeleteNotebookInstanceLifecycleConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteNotebookInstanceLifecycleConfig";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteNotebookInstanceLifecycleConfigInput(
      input,
      context
    )
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteTagsCommand(
  input: DeleteTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteTags";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1DeleteTagsInput(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteTrialCommand(
  input: DeleteTrialCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteTrial";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1DeleteTrialRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteTrialComponentCommand(
  input: DeleteTrialComponentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteTrialComponent";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteTrialComponentRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteUserProfileCommand(
  input: DeleteUserProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteUserProfile";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteUserProfileRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteWorkteamCommand(
  input: DeleteWorkteamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DeleteWorkteam";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteWorkteamRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeAlgorithmCommand(
  input: DescribeAlgorithmCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeAlgorithm";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeAlgorithmInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeAppCommand(
  input: DescribeAppCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeApp";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1DescribeAppRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeAutoMLJobCommand(
  input: DescribeAutoMLJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeAutoMLJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeAutoMLJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeCodeRepositoryCommand(
  input: DescribeCodeRepositoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeCodeRepository";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeCodeRepositoryInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeCompilationJobCommand(
  input: DescribeCompilationJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeCompilationJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeCompilationJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeDomainCommand(
  input: DescribeDomainCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeDomain";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeDomainRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeEndpointCommand(
  input: DescribeEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeEndpoint";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeEndpointInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeEndpointConfigCommand(
  input: DescribeEndpointConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeEndpointConfig";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeEndpointConfigInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeExperimentCommand(
  input: DescribeExperimentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeExperiment";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeExperimentRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeFlowDefinitionCommand(
  input: DescribeFlowDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeFlowDefinition";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeFlowDefinitionRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeHumanTaskUiCommand(
  input: DescribeHumanTaskUiCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeHumanTaskUi";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeHumanTaskUiRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeHyperParameterTuningJobCommand(
  input: DescribeHyperParameterTuningJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeHyperParameterTuningJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeHyperParameterTuningJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeLabelingJobCommand(
  input: DescribeLabelingJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeLabelingJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeLabelingJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeModelCommand(
  input: DescribeModelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeModel";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1DescribeModelInput(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeModelPackageCommand(
  input: DescribeModelPackageCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeModelPackage";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeModelPackageInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeMonitoringScheduleCommand(
  input: DescribeMonitoringScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeMonitoringSchedule";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeMonitoringScheduleRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeNotebookInstanceCommand(
  input: DescribeNotebookInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeNotebookInstance";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeNotebookInstanceInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeNotebookInstanceLifecycleConfigCommand(
  input: DescribeNotebookInstanceLifecycleConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeNotebookInstanceLifecycleConfig";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeNotebookInstanceLifecycleConfigInput(
      input,
      context
    )
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeProcessingJobCommand(
  input: DescribeProcessingJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeProcessingJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeProcessingJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeSubscribedWorkteamCommand(
  input: DescribeSubscribedWorkteamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeSubscribedWorkteam";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeSubscribedWorkteamRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeTrainingJobCommand(
  input: DescribeTrainingJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeTrainingJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeTrainingJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeTransformJobCommand(
  input: DescribeTransformJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeTransformJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeTransformJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeTrialCommand(
  input: DescribeTrialCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeTrial";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeTrialRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeTrialComponentCommand(
  input: DescribeTrialComponentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeTrialComponent";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeTrialComponentRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeUserProfileCommand(
  input: DescribeUserProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeUserProfile";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeUserProfileRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeWorkforceCommand(
  input: DescribeWorkforceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeWorkforce";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeWorkforceRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeWorkteamCommand(
  input: DescribeWorkteamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DescribeWorkteam";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DescribeWorkteamRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DisassociateTrialComponentCommand(
  input: DisassociateTrialComponentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.DisassociateTrialComponent";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DisassociateTrialComponentRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetSearchSuggestionsCommand(
  input: GetSearchSuggestionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.GetSearchSuggestions";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetSearchSuggestionsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListAlgorithmsCommand(
  input: ListAlgorithmsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListAlgorithms";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListAlgorithmsInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListAppsCommand(
  input: ListAppsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListApps";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1ListAppsRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListAutoMLJobsCommand(
  input: ListAutoMLJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListAutoMLJobs";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListAutoMLJobsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListCandidatesForAutoMLJobCommand(
  input: ListCandidatesForAutoMLJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListCandidatesForAutoMLJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListCandidatesForAutoMLJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListCodeRepositoriesCommand(
  input: ListCodeRepositoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListCodeRepositories";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListCodeRepositoriesInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListCompilationJobsCommand(
  input: ListCompilationJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListCompilationJobs";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListCompilationJobsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListDomainsCommand(
  input: ListDomainsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListDomains";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1ListDomainsRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListEndpointConfigsCommand(
  input: ListEndpointConfigsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListEndpointConfigs";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListEndpointConfigsInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListEndpointsCommand(
  input: ListEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListEndpoints";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1ListEndpointsInput(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListExperimentsCommand(
  input: ListExperimentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListExperiments";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListExperimentsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListFlowDefinitionsCommand(
  input: ListFlowDefinitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListFlowDefinitions";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListFlowDefinitionsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListHumanTaskUisCommand(
  input: ListHumanTaskUisCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListHumanTaskUis";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListHumanTaskUisRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListHyperParameterTuningJobsCommand(
  input: ListHyperParameterTuningJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListHyperParameterTuningJobs";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListHyperParameterTuningJobsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListLabelingJobsCommand(
  input: ListLabelingJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListLabelingJobs";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListLabelingJobsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListLabelingJobsForWorkteamCommand(
  input: ListLabelingJobsForWorkteamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListLabelingJobsForWorkteam";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListLabelingJobsForWorkteamRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListModelPackagesCommand(
  input: ListModelPackagesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListModelPackages";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListModelPackagesInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListModelsCommand(
  input: ListModelsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListModels";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1ListModelsInput(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListMonitoringExecutionsCommand(
  input: ListMonitoringExecutionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListMonitoringExecutions";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListMonitoringExecutionsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListMonitoringSchedulesCommand(
  input: ListMonitoringSchedulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListMonitoringSchedules";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListMonitoringSchedulesRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListNotebookInstanceLifecycleConfigsCommand(
  input: ListNotebookInstanceLifecycleConfigsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListNotebookInstanceLifecycleConfigs";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListNotebookInstanceLifecycleConfigsInput(
      input,
      context
    )
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListNotebookInstancesCommand(
  input: ListNotebookInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListNotebookInstances";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListNotebookInstancesInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListProcessingJobsCommand(
  input: ListProcessingJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListProcessingJobs";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListProcessingJobsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListSubscribedWorkteamsCommand(
  input: ListSubscribedWorkteamsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListSubscribedWorkteams";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListSubscribedWorkteamsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListTagsCommand(
  input: ListTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListTags";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1ListTagsInput(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListTrainingJobsCommand(
  input: ListTrainingJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListTrainingJobs";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListTrainingJobsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListTrainingJobsForHyperParameterTuningJobCommand(
  input: ListTrainingJobsForHyperParameterTuningJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "SageMaker.ListTrainingJobsForHyperParameterTuningJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListTrainingJobsForHyperParameterTuningJobRequest(
      input,
      context
    )
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListTransformJobsCommand(
  input: ListTransformJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListTransformJobs";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListTransformJobsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListTrialComponentsCommand(
  input: ListTrialComponentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListTrialComponents";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListTrialComponentsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListTrialsCommand(
  input: ListTrialsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListTrials";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1ListTrialsRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListUserProfilesCommand(
  input: ListUserProfilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListUserProfiles";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListUserProfilesRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListWorkteamsCommand(
  input: ListWorkteamsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.ListWorkteams";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListWorkteamsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1RenderUiTemplateCommand(
  input: RenderUiTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.RenderUiTemplate";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1RenderUiTemplateRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1SearchCommand(
  input: SearchCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.Search";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1SearchRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StartMonitoringScheduleCommand(
  input: StartMonitoringScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StartMonitoringSchedule";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StartMonitoringScheduleRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StartNotebookInstanceCommand(
  input: StartNotebookInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StartNotebookInstance";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StartNotebookInstanceInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopAutoMLJobCommand(
  input: StopAutoMLJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StopAutoMLJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StopAutoMLJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopCompilationJobCommand(
  input: StopCompilationJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StopCompilationJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StopCompilationJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopHyperParameterTuningJobCommand(
  input: StopHyperParameterTuningJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StopHyperParameterTuningJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StopHyperParameterTuningJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopLabelingJobCommand(
  input: StopLabelingJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StopLabelingJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StopLabelingJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopMonitoringScheduleCommand(
  input: StopMonitoringScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StopMonitoringSchedule";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StopMonitoringScheduleRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopNotebookInstanceCommand(
  input: StopNotebookInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StopNotebookInstance";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StopNotebookInstanceInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopProcessingJobCommand(
  input: StopProcessingJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StopProcessingJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StopProcessingJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopTrainingJobCommand(
  input: StopTrainingJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StopTrainingJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StopTrainingJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopTransformJobCommand(
  input: StopTransformJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.StopTransformJob";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1StopTransformJobRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateCodeRepositoryCommand(
  input: UpdateCodeRepositoryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateCodeRepository";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateCodeRepositoryInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateDomainCommand(
  input: UpdateDomainCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateDomain";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateDomainRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateEndpointCommand(
  input: UpdateEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateEndpoint";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateEndpointInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateEndpointWeightsAndCapacitiesCommand(
  input: UpdateEndpointWeightsAndCapacitiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateEndpointWeightsAndCapacities";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateEndpointWeightsAndCapacitiesInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateExperimentCommand(
  input: UpdateExperimentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateExperiment";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateExperimentRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateMonitoringScheduleCommand(
  input: UpdateMonitoringScheduleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateMonitoringSchedule";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateMonitoringScheduleRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateNotebookInstanceCommand(
  input: UpdateNotebookInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateNotebookInstance";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateNotebookInstanceInput(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateNotebookInstanceLifecycleConfigCommand(
  input: UpdateNotebookInstanceLifecycleConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateNotebookInstanceLifecycleConfig";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateNotebookInstanceLifecycleConfigInput(
      input,
      context
    )
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateTrialCommand(
  input: UpdateTrialCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateTrial";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1UpdateTrialRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateTrialComponentCommand(
  input: UpdateTrialComponentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateTrialComponent";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateTrialComponentRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateUserProfileCommand(
  input: UpdateUserProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateUserProfile";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateUserProfileRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateWorkforceCommand(
  input: UpdateWorkforceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateWorkforce";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateWorkforceRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateWorkteamCommand(
  input: UpdateWorkteamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "SageMaker.UpdateWorkteam";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateWorkteamRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function deserializeAws_json1_1AddTagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AddTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AddTagsOutput(data, context);
  const response: AddTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AddTagsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AddTagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1AssociateTrialComponentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateTrialComponentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateTrialComponentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AssociateTrialComponentResponse(
    data,
    context
  );
  const response: AssociateTrialComponentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateTrialComponentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AssociateTrialComponentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateTrialComponentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateAlgorithmCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAlgorithmCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateAlgorithmCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateAlgorithmOutput(data, context);
  const response: CreateAlgorithmCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAlgorithmOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateAlgorithmCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAlgorithmCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateAppCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAppCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateAppCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateAppResponse(data, context);
  const response: CreateAppCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAppResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateAppCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAppCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateAutoMLJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAutoMLJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateAutoMLJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateAutoMLJobResponse(data, context);
  const response: CreateAutoMLJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAutoMLJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateAutoMLJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAutoMLJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateCodeRepositoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCodeRepositoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateCodeRepositoryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateCodeRepositoryOutput(data, context);
  const response: CreateCodeRepositoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCodeRepositoryOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateCodeRepositoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCodeRepositoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateCompilationJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCompilationJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateCompilationJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateCompilationJobResponse(data, context);
  const response: CreateCompilationJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCompilationJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateCompilationJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCompilationJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateDomainCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDomainCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDomainCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDomainResponse(data, context);
  const response: CreateDomainCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDomainResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateDomainCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDomainCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEndpointOutput(data, context);
  const response: CreateEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEndpointOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateEndpointConfigCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointConfigCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEndpointConfigCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEndpointConfigOutput(data, context);
  const response: CreateEndpointConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEndpointConfigOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateEndpointConfigCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointConfigCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateExperimentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateExperimentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateExperimentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateExperimentResponse(data, context);
  const response: CreateExperimentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateExperimentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateExperimentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateExperimentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateFlowDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFlowDefinitionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateFlowDefinitionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateFlowDefinitionResponse(data, context);
  const response: CreateFlowDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFlowDefinitionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateFlowDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFlowDefinitionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateHumanTaskUiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHumanTaskUiCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateHumanTaskUiCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateHumanTaskUiResponse(data, context);
  const response: CreateHumanTaskUiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateHumanTaskUiResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateHumanTaskUiCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHumanTaskUiCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateHyperParameterTuningJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHyperParameterTuningJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateHyperParameterTuningJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateHyperParameterTuningJobResponse(
    data,
    context
  );
  const response: CreateHyperParameterTuningJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateHyperParameterTuningJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateHyperParameterTuningJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHyperParameterTuningJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateLabelingJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLabelingJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateLabelingJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateLabelingJobResponse(data, context);
  const response: CreateLabelingJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateLabelingJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateLabelingJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLabelingJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateModelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateModelCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateModelCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateModelOutput(data, context);
  const response: CreateModelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateModelOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateModelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateModelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateModelPackageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateModelPackageCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateModelPackageCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateModelPackageOutput(data, context);
  const response: CreateModelPackageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateModelPackageOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateModelPackageCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateModelPackageCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateMonitoringScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMonitoringScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateMonitoringScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateMonitoringScheduleResponse(
    data,
    context
  );
  const response: CreateMonitoringScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateMonitoringScheduleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateMonitoringScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMonitoringScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateNotebookInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNotebookInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateNotebookInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateNotebookInstanceOutput(data, context);
  const response: CreateNotebookInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateNotebookInstanceOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateNotebookInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNotebookInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateNotebookInstanceLifecycleConfigCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNotebookInstanceLifecycleConfigCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateNotebookInstanceLifecycleConfigCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateNotebookInstanceLifecycleConfigOutput(
    data,
    context
  );
  const response: CreateNotebookInstanceLifecycleConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateNotebookInstanceLifecycleConfigOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateNotebookInstanceLifecycleConfigCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateNotebookInstanceLifecycleConfigCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreatePresignedDomainUrlCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePresignedDomainUrlCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePresignedDomainUrlCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreatePresignedDomainUrlResponse(
    data,
    context
  );
  const response: CreatePresignedDomainUrlCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePresignedDomainUrlResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreatePresignedDomainUrlCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePresignedDomainUrlCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreatePresignedNotebookInstanceUrlCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePresignedNotebookInstanceUrlCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePresignedNotebookInstanceUrlCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreatePresignedNotebookInstanceUrlOutput(
    data,
    context
  );
  const response: CreatePresignedNotebookInstanceUrlCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePresignedNotebookInstanceUrlOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreatePresignedNotebookInstanceUrlCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePresignedNotebookInstanceUrlCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateProcessingJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProcessingJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateProcessingJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateProcessingJobResponse(data, context);
  const response: CreateProcessingJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateProcessingJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateProcessingJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProcessingJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateTrainingJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrainingJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateTrainingJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTrainingJobResponse(data, context);
  const response: CreateTrainingJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrainingJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateTrainingJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrainingJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateTransformJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransformJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateTransformJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTransformJobResponse(data, context);
  const response: CreateTransformJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTransformJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateTransformJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTransformJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateTrialCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrialCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateTrialCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTrialResponse(data, context);
  const response: CreateTrialCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrialResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateTrialCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrialCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateTrialComponentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrialComponentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateTrialComponentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateTrialComponentResponse(data, context);
  const response: CreateTrialComponentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrialComponentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateTrialComponentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrialComponentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateUserProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateUserProfileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateUserProfileResponse(data, context);
  const response: CreateUserProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateUserProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateUserProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateWorkteamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWorkteamCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateWorkteamCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateWorkteamResponse(data, context);
  const response: CreateWorkteamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateWorkteamResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateWorkteamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWorkteamCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteAlgorithmCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAlgorithmCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteAlgorithmCommandError(output, context);
  }
  const response: DeleteAlgorithmCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteAlgorithmCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAlgorithmCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteAppCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAppCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteAppCommandError(output, context);
  }
  const response: DeleteAppCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteAppCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAppCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteCodeRepositoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCodeRepositoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteCodeRepositoryCommandError(
      output,
      context
    );
  }
  const response: DeleteCodeRepositoryCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteCodeRepositoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCodeRepositoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteDomainCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDomainCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteDomainCommandError(output, context);
  }
  const response: DeleteDomainCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteDomainCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDomainCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEndpointCommandError(output, context);
  }
  const response: DeleteEndpointCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteEndpointConfigCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointConfigCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEndpointConfigCommandError(
      output,
      context
    );
  }
  const response: DeleteEndpointConfigCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteEndpointConfigCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointConfigCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteExperimentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteExperimentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteExperimentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteExperimentResponse(data, context);
  const response: DeleteExperimentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteExperimentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteExperimentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteExperimentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteFlowDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFlowDefinitionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteFlowDefinitionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteFlowDefinitionResponse(data, context);
  const response: DeleteFlowDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteFlowDefinitionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteFlowDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFlowDefinitionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteModelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteModelCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteModelCommandError(output, context);
  }
  const response: DeleteModelCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteModelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteModelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteModelPackageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteModelPackageCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteModelPackageCommandError(
      output,
      context
    );
  }
  const response: DeleteModelPackageCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteModelPackageCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteModelPackageCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteMonitoringScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMonitoringScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteMonitoringScheduleCommandError(
      output,
      context
    );
  }
  const response: DeleteMonitoringScheduleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteMonitoringScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMonitoringScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteNotebookInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNotebookInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteNotebookInstanceCommandError(
      output,
      context
    );
  }
  const response: DeleteNotebookInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteNotebookInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNotebookInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteNotebookInstanceLifecycleConfigCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNotebookInstanceLifecycleConfigCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteNotebookInstanceLifecycleConfigCommandError(
      output,
      context
    );
  }
  const response: DeleteNotebookInstanceLifecycleConfigCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteNotebookInstanceLifecycleConfigCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteNotebookInstanceLifecycleConfigCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteTagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTagsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteTagsOutput(data, context);
  const response: DeleteTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTagsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteTagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTagsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteTrialCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrialCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteTrialCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteTrialResponse(data, context);
  const response: DeleteTrialCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrialResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteTrialCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrialCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteTrialComponentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrialComponentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteTrialComponentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteTrialComponentResponse(data, context);
  const response: DeleteTrialComponentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrialComponentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteTrialComponentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrialComponentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteUserProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteUserProfileCommandError(output, context);
  }
  const response: DeleteUserProfileCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteUserProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteWorkteamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWorkteamCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteWorkteamCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteWorkteamResponse(data, context);
  const response: DeleteWorkteamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteWorkteamResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteWorkteamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWorkteamCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAlgorithmCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAlgorithmCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAlgorithmCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAlgorithmOutput(data, context);
  const response: DescribeAlgorithmCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAlgorithmOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAlgorithmCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAlgorithmCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAppCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAppCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAppCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAppResponse(data, context);
  const response: DescribeAppCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAppResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAppCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAppCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAutoMLJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAutoMLJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAutoMLJobCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAutoMLJobResponse(data, context);
  const response: DescribeAutoMLJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAutoMLJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAutoMLJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAutoMLJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeCodeRepositoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCodeRepositoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeCodeRepositoryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeCodeRepositoryOutput(data, context);
  const response: DescribeCodeRepositoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCodeRepositoryOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeCodeRepositoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCodeRepositoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeCompilationJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCompilationJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeCompilationJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeCompilationJobResponse(
    data,
    context
  );
  const response: DescribeCompilationJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCompilationJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeCompilationJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCompilationJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeDomainCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDomainCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDomainCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDomainResponse(data, context);
  const response: DescribeDomainCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDomainResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeDomainCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDomainCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEndpointOutput(data, context);
  const response: DescribeEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEndpointConfigCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointConfigCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEndpointConfigCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEndpointConfigOutput(data, context);
  const response: DescribeEndpointConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointConfigOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEndpointConfigCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointConfigCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeExperimentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeExperimentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeExperimentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeExperimentResponse(data, context);
  const response: DescribeExperimentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeExperimentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeExperimentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeExperimentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeFlowDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFlowDefinitionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeFlowDefinitionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeFlowDefinitionResponse(
    data,
    context
  );
  const response: DescribeFlowDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFlowDefinitionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeFlowDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFlowDefinitionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeHumanTaskUiCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHumanTaskUiCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeHumanTaskUiCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeHumanTaskUiResponse(data, context);
  const response: DescribeHumanTaskUiCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeHumanTaskUiResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeHumanTaskUiCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHumanTaskUiCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeHyperParameterTuningJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHyperParameterTuningJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeHyperParameterTuningJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeHyperParameterTuningJobResponse(
    data,
    context
  );
  const response: DescribeHyperParameterTuningJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeHyperParameterTuningJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeHyperParameterTuningJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeHyperParameterTuningJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeLabelingJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLabelingJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeLabelingJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeLabelingJobResponse(data, context);
  const response: DescribeLabelingJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLabelingJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeLabelingJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLabelingJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeModelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeModelCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeModelCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeModelOutput(data, context);
  const response: DescribeModelCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeModelOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeModelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeModelCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeModelPackageCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeModelPackageCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeModelPackageCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeModelPackageOutput(data, context);
  const response: DescribeModelPackageCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeModelPackageOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeModelPackageCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeModelPackageCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMonitoringScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMonitoringScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMonitoringScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMonitoringScheduleResponse(
    data,
    context
  );
  const response: DescribeMonitoringScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMonitoringScheduleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMonitoringScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMonitoringScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeNotebookInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNotebookInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeNotebookInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeNotebookInstanceOutput(
    data,
    context
  );
  const response: DescribeNotebookInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeNotebookInstanceOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeNotebookInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNotebookInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeNotebookInstanceLifecycleConfigCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNotebookInstanceLifecycleConfigCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeNotebookInstanceLifecycleConfigCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeNotebookInstanceLifecycleConfigOutput(
    data,
    context
  );
  const response: DescribeNotebookInstanceLifecycleConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeNotebookInstanceLifecycleConfigOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeNotebookInstanceLifecycleConfigCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeNotebookInstanceLifecycleConfigCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeProcessingJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeProcessingJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeProcessingJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeProcessingJobResponse(data, context);
  const response: DescribeProcessingJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeProcessingJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeProcessingJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeProcessingJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeSubscribedWorkteamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSubscribedWorkteamCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeSubscribedWorkteamCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeSubscribedWorkteamResponse(
    data,
    context
  );
  const response: DescribeSubscribedWorkteamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSubscribedWorkteamResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeSubscribedWorkteamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSubscribedWorkteamCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeTrainingJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrainingJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTrainingJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTrainingJobResponse(data, context);
  const response: DescribeTrainingJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTrainingJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeTrainingJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrainingJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeTransformJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransformJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTransformJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTransformJobResponse(data, context);
  const response: DescribeTransformJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTransformJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeTransformJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTransformJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeTrialCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrialCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTrialCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTrialResponse(data, context);
  const response: DescribeTrialCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTrialResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeTrialCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrialCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeTrialComponentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrialComponentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTrialComponentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTrialComponentResponse(
    data,
    context
  );
  const response: DescribeTrialComponentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTrialComponentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeTrialComponentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTrialComponentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeUserProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeUserProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeUserProfileCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeUserProfileResponse(data, context);
  const response: DescribeUserProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeUserProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeUserProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeUserProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeWorkforceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeWorkforceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeWorkforceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeWorkforceResponse(data, context);
  const response: DescribeWorkforceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeWorkforceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeWorkforceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeWorkforceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeWorkteamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeWorkteamCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeWorkteamCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeWorkteamResponse(data, context);
  const response: DescribeWorkteamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeWorkteamResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeWorkteamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeWorkteamCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DisassociateTrialComponentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateTrialComponentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisassociateTrialComponentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DisassociateTrialComponentResponse(
    data,
    context
  );
  const response: DisassociateTrialComponentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateTrialComponentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DisassociateTrialComponentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateTrialComponentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetSearchSuggestionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSearchSuggestionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSearchSuggestionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSearchSuggestionsResponse(data, context);
  const response: GetSearchSuggestionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSearchSuggestionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetSearchSuggestionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSearchSuggestionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListAlgorithmsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAlgorithmsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListAlgorithmsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListAlgorithmsOutput(data, context);
  const response: ListAlgorithmsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAlgorithmsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListAlgorithmsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAlgorithmsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListAppsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAppsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListAppsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListAppsResponse(data, context);
  const response: ListAppsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAppsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListAppsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAppsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListAutoMLJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAutoMLJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListAutoMLJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListAutoMLJobsResponse(data, context);
  const response: ListAutoMLJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAutoMLJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListAutoMLJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAutoMLJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListCandidatesForAutoMLJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCandidatesForAutoMLJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListCandidatesForAutoMLJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListCandidatesForAutoMLJobResponse(
    data,
    context
  );
  const response: ListCandidatesForAutoMLJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCandidatesForAutoMLJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListCandidatesForAutoMLJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCandidatesForAutoMLJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListCodeRepositoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCodeRepositoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListCodeRepositoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListCodeRepositoriesOutput(data, context);
  const response: ListCodeRepositoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCodeRepositoriesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListCodeRepositoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCodeRepositoriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListCompilationJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCompilationJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListCompilationJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListCompilationJobsResponse(data, context);
  const response: ListCompilationJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCompilationJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListCompilationJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCompilationJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListDomainsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDomainsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListDomainsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListDomainsResponse(data, context);
  const response: ListDomainsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDomainsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListDomainsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDomainsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListEndpointConfigsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEndpointConfigsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListEndpointConfigsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListEndpointConfigsOutput(data, context);
  const response: ListEndpointConfigsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListEndpointConfigsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListEndpointConfigsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEndpointConfigsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListEndpointsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEndpointsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListEndpointsOutput(data, context);
  const response: ListEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListEndpointsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListEndpointsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListEndpointsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListExperimentsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListExperimentsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListExperimentsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListExperimentsResponse(data, context);
  const response: ListExperimentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListExperimentsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListExperimentsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListExperimentsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListFlowDefinitionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFlowDefinitionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListFlowDefinitionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListFlowDefinitionsResponse(data, context);
  const response: ListFlowDefinitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListFlowDefinitionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListFlowDefinitionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFlowDefinitionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListHumanTaskUisCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHumanTaskUisCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListHumanTaskUisCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListHumanTaskUisResponse(data, context);
  const response: ListHumanTaskUisCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListHumanTaskUisResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListHumanTaskUisCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHumanTaskUisCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListHyperParameterTuningJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHyperParameterTuningJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListHyperParameterTuningJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListHyperParameterTuningJobsResponse(
    data,
    context
  );
  const response: ListHyperParameterTuningJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListHyperParameterTuningJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListHyperParameterTuningJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHyperParameterTuningJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListLabelingJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLabelingJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListLabelingJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListLabelingJobsResponse(data, context);
  const response: ListLabelingJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListLabelingJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListLabelingJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLabelingJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListLabelingJobsForWorkteamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLabelingJobsForWorkteamCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListLabelingJobsForWorkteamCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListLabelingJobsForWorkteamResponse(
    data,
    context
  );
  const response: ListLabelingJobsForWorkteamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListLabelingJobsForWorkteamResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListLabelingJobsForWorkteamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLabelingJobsForWorkteamCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListModelPackagesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListModelPackagesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListModelPackagesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListModelPackagesOutput(data, context);
  const response: ListModelPackagesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListModelPackagesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListModelPackagesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListModelPackagesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListModelsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListModelsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListModelsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListModelsOutput(data, context);
  const response: ListModelsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListModelsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListModelsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListModelsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListMonitoringExecutionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMonitoringExecutionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListMonitoringExecutionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListMonitoringExecutionsResponse(
    data,
    context
  );
  const response: ListMonitoringExecutionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListMonitoringExecutionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListMonitoringExecutionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMonitoringExecutionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListMonitoringSchedulesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMonitoringSchedulesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListMonitoringSchedulesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListMonitoringSchedulesResponse(
    data,
    context
  );
  const response: ListMonitoringSchedulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListMonitoringSchedulesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListMonitoringSchedulesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMonitoringSchedulesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListNotebookInstanceLifecycleConfigsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListNotebookInstanceLifecycleConfigsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListNotebookInstanceLifecycleConfigsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListNotebookInstanceLifecycleConfigsOutput(
    data,
    context
  );
  const response: ListNotebookInstanceLifecycleConfigsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListNotebookInstanceLifecycleConfigsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListNotebookInstanceLifecycleConfigsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListNotebookInstanceLifecycleConfigsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListNotebookInstancesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListNotebookInstancesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListNotebookInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListNotebookInstancesOutput(data, context);
  const response: ListNotebookInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListNotebookInstancesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListNotebookInstancesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListNotebookInstancesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListProcessingJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListProcessingJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListProcessingJobsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListProcessingJobsResponse(data, context);
  const response: ListProcessingJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListProcessingJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListProcessingJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListProcessingJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListSubscribedWorkteamsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSubscribedWorkteamsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSubscribedWorkteamsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSubscribedWorkteamsResponse(
    data,
    context
  );
  const response: ListSubscribedWorkteamsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSubscribedWorkteamsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSubscribedWorkteamsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSubscribedWorkteamsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTagsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsOutput(data, context);
  const response: ListTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTrainingJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrainingJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTrainingJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTrainingJobsResponse(data, context);
  const response: ListTrainingJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrainingJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTrainingJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrainingJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTrainingJobsForHyperParameterTuningJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrainingJobsForHyperParameterTuningJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTrainingJobsForHyperParameterTuningJobCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTrainingJobsForHyperParameterTuningJobResponse(
    data,
    context
  );
  const response: ListTrainingJobsForHyperParameterTuningJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrainingJobsForHyperParameterTuningJobResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTrainingJobsForHyperParameterTuningJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrainingJobsForHyperParameterTuningJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTransformJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTransformJobsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTransformJobsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTransformJobsResponse(data, context);
  const response: ListTransformJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTransformJobsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTransformJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTransformJobsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTrialComponentsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrialComponentsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTrialComponentsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTrialComponentsResponse(data, context);
  const response: ListTrialComponentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrialComponentsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTrialComponentsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrialComponentsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTrialsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrialsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTrialsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTrialsResponse(data, context);
  const response: ListTrialsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrialsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTrialsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrialsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListUserProfilesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListUserProfilesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListUserProfilesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListUserProfilesResponse(data, context);
  const response: ListUserProfilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListUserProfilesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListUserProfilesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListUserProfilesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListWorkteamsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWorkteamsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListWorkteamsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListWorkteamsResponse(data, context);
  const response: ListWorkteamsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListWorkteamsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListWorkteamsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWorkteamsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RenderUiTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RenderUiTemplateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RenderUiTemplateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RenderUiTemplateResponse(data, context);
  const response: RenderUiTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RenderUiTemplateResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RenderUiTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RenderUiTemplateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchResponse(data, context);
  const response: SearchCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartMonitoringScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMonitoringScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartMonitoringScheduleCommandError(
      output,
      context
    );
  }
  const response: StartMonitoringScheduleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartMonitoringScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMonitoringScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartNotebookInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartNotebookInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartNotebookInstanceCommandError(
      output,
      context
    );
  }
  const response: StartNotebookInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartNotebookInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartNotebookInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopAutoMLJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopAutoMLJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopAutoMLJobCommandError(output, context);
  }
  const response: StopAutoMLJobCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopAutoMLJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopAutoMLJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopCompilationJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCompilationJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopCompilationJobCommandError(
      output,
      context
    );
  }
  const response: StopCompilationJobCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopCompilationJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopCompilationJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopHyperParameterTuningJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopHyperParameterTuningJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopHyperParameterTuningJobCommandError(
      output,
      context
    );
  }
  const response: StopHyperParameterTuningJobCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopHyperParameterTuningJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopHyperParameterTuningJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopLabelingJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopLabelingJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopLabelingJobCommandError(output, context);
  }
  const response: StopLabelingJobCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopLabelingJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopLabelingJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopMonitoringScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopMonitoringScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopMonitoringScheduleCommandError(
      output,
      context
    );
  }
  const response: StopMonitoringScheduleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopMonitoringScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopMonitoringScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopNotebookInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopNotebookInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopNotebookInstanceCommandError(
      output,
      context
    );
  }
  const response: StopNotebookInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopNotebookInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopNotebookInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopProcessingJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopProcessingJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopProcessingJobCommandError(output, context);
  }
  const response: StopProcessingJobCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopProcessingJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopProcessingJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopTrainingJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTrainingJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopTrainingJobCommandError(output, context);
  }
  const response: StopTrainingJobCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopTrainingJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTrainingJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopTransformJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTransformJobCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopTransformJobCommandError(output, context);
  }
  const response: StopTransformJobCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopTransformJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopTransformJobCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateCodeRepositoryCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCodeRepositoryCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateCodeRepositoryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateCodeRepositoryOutput(data, context);
  const response: UpdateCodeRepositoryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateCodeRepositoryOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateCodeRepositoryCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCodeRepositoryCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateDomainCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDomainCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateDomainCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateDomainResponse(data, context);
  const response: UpdateDomainCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDomainResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateDomainCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDomainCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateEndpointOutput(data, context);
  const response: UpdateEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateEndpointOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateEndpointWeightsAndCapacitiesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointWeightsAndCapacitiesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateEndpointWeightsAndCapacitiesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateEndpointWeightsAndCapacitiesOutput(
    data,
    context
  );
  const response: UpdateEndpointWeightsAndCapacitiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateEndpointWeightsAndCapacitiesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateEndpointWeightsAndCapacitiesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEndpointWeightsAndCapacitiesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateExperimentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateExperimentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateExperimentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateExperimentResponse(data, context);
  const response: UpdateExperimentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateExperimentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateExperimentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateExperimentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.sagemaker.api#ConflictException":
      response = await deserializeAws_json1_1ConflictExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateMonitoringScheduleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMonitoringScheduleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateMonitoringScheduleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateMonitoringScheduleResponse(
    data,
    context
  );
  const response: UpdateMonitoringScheduleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateMonitoringScheduleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateMonitoringScheduleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMonitoringScheduleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateNotebookInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateNotebookInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateNotebookInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateNotebookInstanceOutput(data, context);
  const response: UpdateNotebookInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateNotebookInstanceOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateNotebookInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateNotebookInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateNotebookInstanceLifecycleConfigCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateNotebookInstanceLifecycleConfigCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateNotebookInstanceLifecycleConfigCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateNotebookInstanceLifecycleConfigOutput(
    data,
    context
  );
  const response: UpdateNotebookInstanceLifecycleConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateNotebookInstanceLifecycleConfigOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateNotebookInstanceLifecycleConfigCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateNotebookInstanceLifecycleConfigCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateTrialCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrialCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateTrialCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateTrialResponse(data, context);
  const response: UpdateTrialCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTrialResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateTrialCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrialCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.sagemaker.api#ConflictException":
      response = await deserializeAws_json1_1ConflictExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateTrialComponentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrialComponentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateTrialComponentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateTrialComponentResponse(data, context);
  const response: UpdateTrialComponentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTrialComponentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateTrialComponentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrialComponentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.sagemaker.api#ConflictException":
      response = await deserializeAws_json1_1ConflictExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateUserProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserProfileCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateUserProfileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateUserProfileResponse(data, context);
  const response: UpdateUserProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateUserProfileResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateUserProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserProfileCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceInUse":
    case "com.amazonaws.sagemaker.api#ResourceInUse":
      response = await deserializeAws_json1_1ResourceInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFound":
    case "com.amazonaws.sagemaker.api#ResourceNotFound":
      response = await deserializeAws_json1_1ResourceNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateWorkforceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWorkforceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateWorkforceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateWorkforceResponse(data, context);
  const response: UpdateWorkforceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateWorkforceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateWorkforceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWorkforceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateWorkteamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWorkteamCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateWorkteamCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateWorkteamResponse(data, context);
  const response: UpdateWorkteamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateWorkteamResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateWorkteamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWorkteamCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceLimitExceeded":
    case "com.amazonaws.sagemaker.api#ResourceLimitExceeded":
      response = await deserializeAws_json1_1ResourceLimitExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1ConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConflictException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConflictException(
    body,
    context
  );
  const contents: ConflictException = {
    name: "ConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceInUse> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceInUse(body, context);
  const contents: ResourceInUse = {
    name: "ResourceInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceLimitExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceLimitExceeded> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceLimitExceeded(
    body,
    context
  );
  const contents: ResourceLimitExceeded = {
    name: "ResourceLimitExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceNotFoundResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNotFound> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceNotFound(
    body,
    context
  );
  const contents: ResourceNotFound = {
    name: "ResourceNotFound",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1AddTagsInput = (
  input: AddTagsInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1AdditionalCodeRepositoryNamesOrUrls = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1AlgorithmSpecification = (
  input: AlgorithmSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AlgorithmName !== undefined) {
    bodyParams["AlgorithmName"] = input.AlgorithmName;
  }
  if (input.EnableSageMakerMetricsTimeSeries !== undefined) {
    bodyParams["EnableSageMakerMetricsTimeSeries"] =
      input.EnableSageMakerMetricsTimeSeries;
  }
  if (input.MetricDefinitions !== undefined) {
    bodyParams["MetricDefinitions"] = serializeAws_json1_1MetricDefinitionList(
      input.MetricDefinitions,
      context
    );
  }
  if (input.TrainingImage !== undefined) {
    bodyParams["TrainingImage"] = input.TrainingImage;
  }
  if (input.TrainingInputMode !== undefined) {
    bodyParams["TrainingInputMode"] = input.TrainingInputMode;
  }
  return bodyParams;
};

const serializeAws_json1_1AlgorithmValidationProfile = (
  input: AlgorithmValidationProfile,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ProfileName !== undefined) {
    bodyParams["ProfileName"] = input.ProfileName;
  }
  if (input.TrainingJobDefinition !== undefined) {
    bodyParams[
      "TrainingJobDefinition"
    ] = serializeAws_json1_1TrainingJobDefinition(
      input.TrainingJobDefinition,
      context
    );
  }
  if (input.TransformJobDefinition !== undefined) {
    bodyParams[
      "TransformJobDefinition"
    ] = serializeAws_json1_1TransformJobDefinition(
      input.TransformJobDefinition,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1AlgorithmValidationProfiles = (
  input: Array<AlgorithmValidationProfile>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1AlgorithmValidationProfile(entry, context)
  );
};

const serializeAws_json1_1AlgorithmValidationSpecification = (
  input: AlgorithmValidationSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ValidationProfiles !== undefined) {
    bodyParams[
      "ValidationProfiles"
    ] = serializeAws_json1_1AlgorithmValidationProfiles(
      input.ValidationProfiles,
      context
    );
  }
  if (input.ValidationRole !== undefined) {
    bodyParams["ValidationRole"] = input.ValidationRole;
  }
  return bodyParams;
};

const serializeAws_json1_1AnnotationConsolidationConfig = (
  input: AnnotationConsolidationConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AnnotationConsolidationLambdaArn !== undefined) {
    bodyParams["AnnotationConsolidationLambdaArn"] =
      input.AnnotationConsolidationLambdaArn;
  }
  return bodyParams;
};

const serializeAws_json1_1AppSpecification = (
  input: AppSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ContainerArguments !== undefined) {
    bodyParams["ContainerArguments"] = serializeAws_json1_1ContainerArguments(
      input.ContainerArguments,
      context
    );
  }
  if (input.ContainerEntrypoint !== undefined) {
    bodyParams["ContainerEntrypoint"] = serializeAws_json1_1ContainerEntrypoint(
      input.ContainerEntrypoint,
      context
    );
  }
  if (input.ImageUri !== undefined) {
    bodyParams["ImageUri"] = input.ImageUri;
  }
  return bodyParams;
};

const serializeAws_json1_1AssociateTrialComponentRequest = (
  input: AssociateTrialComponentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TrialComponentName !== undefined) {
    bodyParams["TrialComponentName"] = input.TrialComponentName;
  }
  if (input.TrialName !== undefined) {
    bodyParams["TrialName"] = input.TrialName;
  }
  return bodyParams;
};

const serializeAws_json1_1AttributeNames = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1AutoMLChannel = (
  input: AutoMLChannel,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CompressionType !== undefined) {
    bodyParams["CompressionType"] = input.CompressionType;
  }
  if (input.DataSource !== undefined) {
    bodyParams["DataSource"] = serializeAws_json1_1AutoMLDataSource(
      input.DataSource,
      context
    );
  }
  if (input.TargetAttributeName !== undefined) {
    bodyParams["TargetAttributeName"] = input.TargetAttributeName;
  }
  return bodyParams;
};

const serializeAws_json1_1AutoMLDataSource = (
  input: AutoMLDataSource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3DataSource !== undefined) {
    bodyParams["S3DataSource"] = serializeAws_json1_1AutoMLS3DataSource(
      input.S3DataSource,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1AutoMLInputDataConfig = (
  input: Array<AutoMLChannel>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1AutoMLChannel(entry, context)
  );
};

const serializeAws_json1_1AutoMLJobCompletionCriteria = (
  input: AutoMLJobCompletionCriteria,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxAutoMLJobRuntimeInSeconds !== undefined) {
    bodyParams["MaxAutoMLJobRuntimeInSeconds"] =
      input.MaxAutoMLJobRuntimeInSeconds;
  }
  if (input.MaxCandidates !== undefined) {
    bodyParams["MaxCandidates"] = input.MaxCandidates;
  }
  if (input.MaxRuntimePerTrainingJobInSeconds !== undefined) {
    bodyParams["MaxRuntimePerTrainingJobInSeconds"] =
      input.MaxRuntimePerTrainingJobInSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1AutoMLJobConfig = (
  input: AutoMLJobConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CompletionCriteria !== undefined) {
    bodyParams[
      "CompletionCriteria"
    ] = serializeAws_json1_1AutoMLJobCompletionCriteria(
      input.CompletionCriteria,
      context
    );
  }
  if (input.SecurityConfig !== undefined) {
    bodyParams["SecurityConfig"] = serializeAws_json1_1AutoMLSecurityConfig(
      input.SecurityConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1AutoMLJobObjective = (
  input: AutoMLJobObjective,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MetricName !== undefined) {
    bodyParams["MetricName"] = input.MetricName;
  }
  return bodyParams;
};

const serializeAws_json1_1AutoMLOutputDataConfig = (
  input: AutoMLOutputDataConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.S3OutputPath !== undefined) {
    bodyParams["S3OutputPath"] = input.S3OutputPath;
  }
  return bodyParams;
};

const serializeAws_json1_1AutoMLS3DataSource = (
  input: AutoMLS3DataSource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3DataType !== undefined) {
    bodyParams["S3DataType"] = input.S3DataType;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1AutoMLSecurityConfig = (
  input: AutoMLSecurityConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EnableInterContainerTrafficEncryption !== undefined) {
    bodyParams["EnableInterContainerTrafficEncryption"] =
      input.EnableInterContainerTrafficEncryption;
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CaptureContentTypeHeader = (
  input: CaptureContentTypeHeader,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CsvContentTypes !== undefined) {
    bodyParams["CsvContentTypes"] = serializeAws_json1_1CsvContentTypes(
      input.CsvContentTypes,
      context
    );
  }
  if (input.JsonContentTypes !== undefined) {
    bodyParams["JsonContentTypes"] = serializeAws_json1_1JsonContentTypes(
      input.JsonContentTypes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CaptureOption = (
  input: CaptureOption,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CaptureMode !== undefined) {
    bodyParams["CaptureMode"] = input.CaptureMode;
  }
  return bodyParams;
};

const serializeAws_json1_1CaptureOptionList = (
  input: Array<CaptureOption>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1CaptureOption(entry, context)
  );
};

const serializeAws_json1_1CategoricalParameterRange = (
  input: CategoricalParameterRange,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1ParameterValues(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CategoricalParameterRangeSpecification = (
  input: CategoricalParameterRangeSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1ParameterValues(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CategoricalParameterRanges = (
  input: Array<CategoricalParameterRange>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1CategoricalParameterRange(entry, context)
  );
};

const serializeAws_json1_1Channel = (
  input: Channel,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChannelName !== undefined) {
    bodyParams["ChannelName"] = input.ChannelName;
  }
  if (input.CompressionType !== undefined) {
    bodyParams["CompressionType"] = input.CompressionType;
  }
  if (input.ContentType !== undefined) {
    bodyParams["ContentType"] = input.ContentType;
  }
  if (input.DataSource !== undefined) {
    bodyParams["DataSource"] = serializeAws_json1_1DataSource(
      input.DataSource,
      context
    );
  }
  if (input.InputMode !== undefined) {
    bodyParams["InputMode"] = input.InputMode;
  }
  if (input.RecordWrapperType !== undefined) {
    bodyParams["RecordWrapperType"] = input.RecordWrapperType;
  }
  if (input.ShuffleConfig !== undefined) {
    bodyParams["ShuffleConfig"] = serializeAws_json1_1ShuffleConfig(
      input.ShuffleConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ChannelSpecification = (
  input: ChannelSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.IsRequired !== undefined) {
    bodyParams["IsRequired"] = input.IsRequired;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.SupportedCompressionTypes !== undefined) {
    bodyParams[
      "SupportedCompressionTypes"
    ] = serializeAws_json1_1CompressionTypes(
      input.SupportedCompressionTypes,
      context
    );
  }
  if (input.SupportedContentTypes !== undefined) {
    bodyParams["SupportedContentTypes"] = serializeAws_json1_1ContentTypes(
      input.SupportedContentTypes,
      context
    );
  }
  if (input.SupportedInputModes !== undefined) {
    bodyParams["SupportedInputModes"] = serializeAws_json1_1InputModes(
      input.SupportedInputModes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ChannelSpecifications = (
  input: Array<ChannelSpecification>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ChannelSpecification(entry, context)
  );
};

const serializeAws_json1_1CheckpointConfig = (
  input: CheckpointConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LocalPath !== undefined) {
    bodyParams["LocalPath"] = input.LocalPath;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1Cidrs = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1CognitoMemberDefinition = (
  input: CognitoMemberDefinition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClientId !== undefined) {
    bodyParams["ClientId"] = input.ClientId;
  }
  if (input.UserGroup !== undefined) {
    bodyParams["UserGroup"] = input.UserGroup;
  }
  if (input.UserPool !== undefined) {
    bodyParams["UserPool"] = input.UserPool;
  }
  return bodyParams;
};

const serializeAws_json1_1CollectionConfiguration = (
  input: CollectionConfiguration,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CollectionName !== undefined) {
    bodyParams["CollectionName"] = input.CollectionName;
  }
  if (input.CollectionParameters !== undefined) {
    bodyParams[
      "CollectionParameters"
    ] = serializeAws_json1_1CollectionParameters(
      input.CollectionParameters,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CollectionConfigurations = (
  input: Array<CollectionConfiguration>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1CollectionConfiguration(entry, context)
  );
};

const serializeAws_json1_1CollectionParameters = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1CompressionTypes = (
  input: Array<CompressionType | string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ContainerArguments = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ContainerDefinition = (
  input: ContainerDefinition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ContainerHostname !== undefined) {
    bodyParams["ContainerHostname"] = input.ContainerHostname;
  }
  if (input.Environment !== undefined) {
    bodyParams["Environment"] = serializeAws_json1_1EnvironmentMap(
      input.Environment,
      context
    );
  }
  if (input.Image !== undefined) {
    bodyParams["Image"] = input.Image;
  }
  if (input.Mode !== undefined) {
    bodyParams["Mode"] = input.Mode;
  }
  if (input.ModelDataUrl !== undefined) {
    bodyParams["ModelDataUrl"] = input.ModelDataUrl;
  }
  if (input.ModelPackageName !== undefined) {
    bodyParams["ModelPackageName"] = input.ModelPackageName;
  }
  return bodyParams;
};

const serializeAws_json1_1ContainerDefinitionList = (
  input: Array<ContainerDefinition>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ContainerDefinition(entry, context)
  );
};

const serializeAws_json1_1ContainerEntrypoint = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ContentClassifiers = (
  input: Array<ContentClassifier | string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ContentTypes = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ContinuousParameterRange = (
  input: ContinuousParameterRange,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxValue !== undefined) {
    bodyParams["MaxValue"] = input.MaxValue;
  }
  if (input.MinValue !== undefined) {
    bodyParams["MinValue"] = input.MinValue;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.ScalingType !== undefined) {
    bodyParams["ScalingType"] = input.ScalingType;
  }
  return bodyParams;
};

const serializeAws_json1_1ContinuousParameterRangeSpecification = (
  input: ContinuousParameterRangeSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxValue !== undefined) {
    bodyParams["MaxValue"] = input.MaxValue;
  }
  if (input.MinValue !== undefined) {
    bodyParams["MinValue"] = input.MinValue;
  }
  return bodyParams;
};

const serializeAws_json1_1ContinuousParameterRanges = (
  input: Array<ContinuousParameterRange>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ContinuousParameterRange(entry, context)
  );
};

const serializeAws_json1_1CreateAlgorithmInput = (
  input: CreateAlgorithmInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AlgorithmDescription !== undefined) {
    bodyParams["AlgorithmDescription"] = input.AlgorithmDescription;
  }
  if (input.AlgorithmName !== undefined) {
    bodyParams["AlgorithmName"] = input.AlgorithmName;
  }
  if (input.CertifyForMarketplace !== undefined) {
    bodyParams["CertifyForMarketplace"] = input.CertifyForMarketplace;
  }
  if (input.InferenceSpecification !== undefined) {
    bodyParams[
      "InferenceSpecification"
    ] = serializeAws_json1_1InferenceSpecification(
      input.InferenceSpecification,
      context
    );
  }
  if (input.TrainingSpecification !== undefined) {
    bodyParams[
      "TrainingSpecification"
    ] = serializeAws_json1_1TrainingSpecification(
      input.TrainingSpecification,
      context
    );
  }
  if (input.ValidationSpecification !== undefined) {
    bodyParams[
      "ValidationSpecification"
    ] = serializeAws_json1_1AlgorithmValidationSpecification(
      input.ValidationSpecification,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateAppRequest = (
  input: CreateAppRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AppName !== undefined) {
    bodyParams["AppName"] = input.AppName;
  }
  if (input.AppType !== undefined) {
    bodyParams["AppType"] = input.AppType;
  }
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  if (input.ResourceSpec !== undefined) {
    bodyParams["ResourceSpec"] = serializeAws_json1_1ResourceSpec(
      input.ResourceSpec,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.UserProfileName !== undefined) {
    bodyParams["UserProfileName"] = input.UserProfileName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateAutoMLJobRequest = (
  input: CreateAutoMLJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AutoMLJobConfig !== undefined) {
    bodyParams["AutoMLJobConfig"] = serializeAws_json1_1AutoMLJobConfig(
      input.AutoMLJobConfig,
      context
    );
  }
  if (input.AutoMLJobName !== undefined) {
    bodyParams["AutoMLJobName"] = input.AutoMLJobName;
  }
  if (input.AutoMLJobObjective !== undefined) {
    bodyParams["AutoMLJobObjective"] = serializeAws_json1_1AutoMLJobObjective(
      input.AutoMLJobObjective,
      context
    );
  }
  if (input.GenerateCandidateDefinitionsOnly !== undefined) {
    bodyParams["GenerateCandidateDefinitionsOnly"] =
      input.GenerateCandidateDefinitionsOnly;
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1AutoMLInputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1AutoMLOutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.ProblemType !== undefined) {
    bodyParams["ProblemType"] = input.ProblemType;
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateCodeRepositoryInput = (
  input: CreateCodeRepositoryInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CodeRepositoryName !== undefined) {
    bodyParams["CodeRepositoryName"] = input.CodeRepositoryName;
  }
  if (input.GitConfig !== undefined) {
    bodyParams["GitConfig"] = serializeAws_json1_1GitConfig(
      input.GitConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateCompilationJobRequest = (
  input: CreateCompilationJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CompilationJobName !== undefined) {
    bodyParams["CompilationJobName"] = input.CompilationJobName;
  }
  if (input.InputConfig !== undefined) {
    bodyParams["InputConfig"] = serializeAws_json1_1InputConfig(
      input.InputConfig,
      context
    );
  }
  if (input.OutputConfig !== undefined) {
    bodyParams["OutputConfig"] = serializeAws_json1_1OutputConfig(
      input.OutputConfig,
      context
    );
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.StoppingCondition !== undefined) {
    bodyParams["StoppingCondition"] = serializeAws_json1_1StoppingCondition(
      input.StoppingCondition,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateDomainRequest = (
  input: CreateDomainRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AuthMode !== undefined) {
    bodyParams["AuthMode"] = input.AuthMode;
  }
  if (input.DefaultUserSettings !== undefined) {
    bodyParams["DefaultUserSettings"] = serializeAws_json1_1UserSettings(
      input.DefaultUserSettings,
      context
    );
  }
  if (input.DomainName !== undefined) {
    bodyParams["DomainName"] = input.DomainName;
  }
  if (input.HomeEfsFileSystemKmsKeyId !== undefined) {
    bodyParams["HomeEfsFileSystemKmsKeyId"] = input.HomeEfsFileSystemKmsKeyId;
  }
  if (input.SubnetIds !== undefined) {
    bodyParams["SubnetIds"] = serializeAws_json1_1Subnets(
      input.SubnetIds,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.VpcId !== undefined) {
    bodyParams["VpcId"] = input.VpcId;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEndpointConfigInput = (
  input: CreateEndpointConfigInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DataCaptureConfig !== undefined) {
    bodyParams["DataCaptureConfig"] = serializeAws_json1_1DataCaptureConfig(
      input.DataCaptureConfig,
      context
    );
  }
  if (input.EndpointConfigName !== undefined) {
    bodyParams["EndpointConfigName"] = input.EndpointConfigName;
  }
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.ProductionVariants !== undefined) {
    bodyParams[
      "ProductionVariants"
    ] = serializeAws_json1_1ProductionVariantList(
      input.ProductionVariants,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEndpointInput = (
  input: CreateEndpointInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointConfigName !== undefined) {
    bodyParams["EndpointConfigName"] = input.EndpointConfigName;
  }
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateExperimentRequest = (
  input: CreateExperimentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.DisplayName !== undefined) {
    bodyParams["DisplayName"] = input.DisplayName;
  }
  if (input.ExperimentName !== undefined) {
    bodyParams["ExperimentName"] = input.ExperimentName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateFlowDefinitionRequest = (
  input: CreateFlowDefinitionRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.FlowDefinitionName !== undefined) {
    bodyParams["FlowDefinitionName"] = input.FlowDefinitionName;
  }
  if (input.HumanLoopActivationConfig !== undefined) {
    bodyParams[
      "HumanLoopActivationConfig"
    ] = serializeAws_json1_1HumanLoopActivationConfig(
      input.HumanLoopActivationConfig,
      context
    );
  }
  if (input.HumanLoopConfig !== undefined) {
    bodyParams["HumanLoopConfig"] = serializeAws_json1_1HumanLoopConfig(
      input.HumanLoopConfig,
      context
    );
  }
  if (input.OutputConfig !== undefined) {
    bodyParams["OutputConfig"] = serializeAws_json1_1FlowDefinitionOutputConfig(
      input.OutputConfig,
      context
    );
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateHumanTaskUiRequest = (
  input: CreateHumanTaskUiRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HumanTaskUiName !== undefined) {
    bodyParams["HumanTaskUiName"] = input.HumanTaskUiName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.UiTemplate !== undefined) {
    bodyParams["UiTemplate"] = serializeAws_json1_1UiTemplate(
      input.UiTemplate,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateHyperParameterTuningJobRequest = (
  input: CreateHyperParameterTuningJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HyperParameterTuningJobConfig !== undefined) {
    bodyParams[
      "HyperParameterTuningJobConfig"
    ] = serializeAws_json1_1HyperParameterTuningJobConfig(
      input.HyperParameterTuningJobConfig,
      context
    );
  }
  if (input.HyperParameterTuningJobName !== undefined) {
    bodyParams["HyperParameterTuningJobName"] =
      input.HyperParameterTuningJobName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.TrainingJobDefinition !== undefined) {
    bodyParams[
      "TrainingJobDefinition"
    ] = serializeAws_json1_1HyperParameterTrainingJobDefinition(
      input.TrainingJobDefinition,
      context
    );
  }
  if (input.TrainingJobDefinitions !== undefined) {
    bodyParams[
      "TrainingJobDefinitions"
    ] = serializeAws_json1_1HyperParameterTrainingJobDefinitions(
      input.TrainingJobDefinitions,
      context
    );
  }
  if (input.WarmStartConfig !== undefined) {
    bodyParams[
      "WarmStartConfig"
    ] = serializeAws_json1_1HyperParameterTuningJobWarmStartConfig(
      input.WarmStartConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateLabelingJobRequest = (
  input: CreateLabelingJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HumanTaskConfig !== undefined) {
    bodyParams["HumanTaskConfig"] = serializeAws_json1_1HumanTaskConfig(
      input.HumanTaskConfig,
      context
    );
  }
  if (input.InputConfig !== undefined) {
    bodyParams["InputConfig"] = serializeAws_json1_1LabelingJobInputConfig(
      input.InputConfig,
      context
    );
  }
  if (input.LabelAttributeName !== undefined) {
    bodyParams["LabelAttributeName"] = input.LabelAttributeName;
  }
  if (input.LabelCategoryConfigS3Uri !== undefined) {
    bodyParams["LabelCategoryConfigS3Uri"] = input.LabelCategoryConfigS3Uri;
  }
  if (input.LabelingJobAlgorithmsConfig !== undefined) {
    bodyParams[
      "LabelingJobAlgorithmsConfig"
    ] = serializeAws_json1_1LabelingJobAlgorithmsConfig(
      input.LabelingJobAlgorithmsConfig,
      context
    );
  }
  if (input.LabelingJobName !== undefined) {
    bodyParams["LabelingJobName"] = input.LabelingJobName;
  }
  if (input.OutputConfig !== undefined) {
    bodyParams["OutputConfig"] = serializeAws_json1_1LabelingJobOutputConfig(
      input.OutputConfig,
      context
    );
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.StoppingConditions !== undefined) {
    bodyParams[
      "StoppingConditions"
    ] = serializeAws_json1_1LabelingJobStoppingConditions(
      input.StoppingConditions,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateModelInput = (
  input: CreateModelInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Containers !== undefined) {
    bodyParams["Containers"] = serializeAws_json1_1ContainerDefinitionList(
      input.Containers,
      context
    );
  }
  if (input.EnableNetworkIsolation !== undefined) {
    bodyParams["EnableNetworkIsolation"] = input.EnableNetworkIsolation;
  }
  if (input.ExecutionRoleArn !== undefined) {
    bodyParams["ExecutionRoleArn"] = input.ExecutionRoleArn;
  }
  if (input.ModelName !== undefined) {
    bodyParams["ModelName"] = input.ModelName;
  }
  if (input.PrimaryContainer !== undefined) {
    bodyParams["PrimaryContainer"] = serializeAws_json1_1ContainerDefinition(
      input.PrimaryContainer,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateModelPackageInput = (
  input: CreateModelPackageInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CertifyForMarketplace !== undefined) {
    bodyParams["CertifyForMarketplace"] = input.CertifyForMarketplace;
  }
  if (input.InferenceSpecification !== undefined) {
    bodyParams[
      "InferenceSpecification"
    ] = serializeAws_json1_1InferenceSpecification(
      input.InferenceSpecification,
      context
    );
  }
  if (input.ModelPackageDescription !== undefined) {
    bodyParams["ModelPackageDescription"] = input.ModelPackageDescription;
  }
  if (input.ModelPackageName !== undefined) {
    bodyParams["ModelPackageName"] = input.ModelPackageName;
  }
  if (input.SourceAlgorithmSpecification !== undefined) {
    bodyParams[
      "SourceAlgorithmSpecification"
    ] = serializeAws_json1_1SourceAlgorithmSpecification(
      input.SourceAlgorithmSpecification,
      context
    );
  }
  if (input.ValidationSpecification !== undefined) {
    bodyParams[
      "ValidationSpecification"
    ] = serializeAws_json1_1ModelPackageValidationSpecification(
      input.ValidationSpecification,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateMonitoringScheduleRequest = (
  input: CreateMonitoringScheduleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MonitoringScheduleConfig !== undefined) {
    bodyParams[
      "MonitoringScheduleConfig"
    ] = serializeAws_json1_1MonitoringScheduleConfig(
      input.MonitoringScheduleConfig,
      context
    );
  }
  if (input.MonitoringScheduleName !== undefined) {
    bodyParams["MonitoringScheduleName"] = input.MonitoringScheduleName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateNotebookInstanceInput = (
  input: CreateNotebookInstanceInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AcceleratorTypes !== undefined) {
    bodyParams[
      "AcceleratorTypes"
    ] = serializeAws_json1_1NotebookInstanceAcceleratorTypes(
      input.AcceleratorTypes,
      context
    );
  }
  if (input.AdditionalCodeRepositories !== undefined) {
    bodyParams[
      "AdditionalCodeRepositories"
    ] = serializeAws_json1_1AdditionalCodeRepositoryNamesOrUrls(
      input.AdditionalCodeRepositories,
      context
    );
  }
  if (input.DefaultCodeRepository !== undefined) {
    bodyParams["DefaultCodeRepository"] = input.DefaultCodeRepository;
  }
  if (input.DirectInternetAccess !== undefined) {
    bodyParams["DirectInternetAccess"] = input.DirectInternetAccess;
  }
  if (input.InstanceType !== undefined) {
    bodyParams["InstanceType"] = input.InstanceType;
  }
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.LifecycleConfigName !== undefined) {
    bodyParams["LifecycleConfigName"] = input.LifecycleConfigName;
  }
  if (input.NotebookInstanceName !== undefined) {
    bodyParams["NotebookInstanceName"] = input.NotebookInstanceName;
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.RootAccess !== undefined) {
    bodyParams["RootAccess"] = input.RootAccess;
  }
  if (input.SecurityGroupIds !== undefined) {
    bodyParams["SecurityGroupIds"] = serializeAws_json1_1SecurityGroupIds(
      input.SecurityGroupIds,
      context
    );
  }
  if (input.SubnetId !== undefined) {
    bodyParams["SubnetId"] = input.SubnetId;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.VolumeSizeInGB !== undefined) {
    bodyParams["VolumeSizeInGB"] = input.VolumeSizeInGB;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateNotebookInstanceLifecycleConfigInput = (
  input: CreateNotebookInstanceLifecycleConfigInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotebookInstanceLifecycleConfigName !== undefined) {
    bodyParams["NotebookInstanceLifecycleConfigName"] =
      input.NotebookInstanceLifecycleConfigName;
  }
  if (input.OnCreate !== undefined) {
    bodyParams[
      "OnCreate"
    ] = serializeAws_json1_1NotebookInstanceLifecycleConfigList(
      input.OnCreate,
      context
    );
  }
  if (input.OnStart !== undefined) {
    bodyParams[
      "OnStart"
    ] = serializeAws_json1_1NotebookInstanceLifecycleConfigList(
      input.OnStart,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreatePresignedDomainUrlRequest = (
  input: CreatePresignedDomainUrlRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  if (input.SessionExpirationDurationInSeconds !== undefined) {
    bodyParams["SessionExpirationDurationInSeconds"] =
      input.SessionExpirationDurationInSeconds;
  }
  if (input.UserProfileName !== undefined) {
    bodyParams["UserProfileName"] = input.UserProfileName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreatePresignedNotebookInstanceUrlInput = (
  input: CreatePresignedNotebookInstanceUrlInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotebookInstanceName !== undefined) {
    bodyParams["NotebookInstanceName"] = input.NotebookInstanceName;
  }
  if (input.SessionExpirationDurationInSeconds !== undefined) {
    bodyParams["SessionExpirationDurationInSeconds"] =
      input.SessionExpirationDurationInSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateProcessingJobRequest = (
  input: CreateProcessingJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AppSpecification !== undefined) {
    bodyParams["AppSpecification"] = serializeAws_json1_1AppSpecification(
      input.AppSpecification,
      context
    );
  }
  if (input.Environment !== undefined) {
    bodyParams["Environment"] = serializeAws_json1_1ProcessingEnvironmentMap(
      input.Environment,
      context
    );
  }
  if (input.ExperimentConfig !== undefined) {
    bodyParams["ExperimentConfig"] = serializeAws_json1_1ExperimentConfig(
      input.ExperimentConfig,
      context
    );
  }
  if (input.NetworkConfig !== undefined) {
    bodyParams["NetworkConfig"] = serializeAws_json1_1NetworkConfig(
      input.NetworkConfig,
      context
    );
  }
  if (input.ProcessingInputs !== undefined) {
    bodyParams["ProcessingInputs"] = serializeAws_json1_1ProcessingInputs(
      input.ProcessingInputs,
      context
    );
  }
  if (input.ProcessingJobName !== undefined) {
    bodyParams["ProcessingJobName"] = input.ProcessingJobName;
  }
  if (input.ProcessingOutputConfig !== undefined) {
    bodyParams[
      "ProcessingOutputConfig"
    ] = serializeAws_json1_1ProcessingOutputConfig(
      input.ProcessingOutputConfig,
      context
    );
  }
  if (input.ProcessingResources !== undefined) {
    bodyParams["ProcessingResources"] = serializeAws_json1_1ProcessingResources(
      input.ProcessingResources,
      context
    );
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.StoppingCondition !== undefined) {
    bodyParams[
      "StoppingCondition"
    ] = serializeAws_json1_1ProcessingStoppingCondition(
      input.StoppingCondition,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateTrainingJobRequest = (
  input: CreateTrainingJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AlgorithmSpecification !== undefined) {
    bodyParams[
      "AlgorithmSpecification"
    ] = serializeAws_json1_1AlgorithmSpecification(
      input.AlgorithmSpecification,
      context
    );
  }
  if (input.CheckpointConfig !== undefined) {
    bodyParams["CheckpointConfig"] = serializeAws_json1_1CheckpointConfig(
      input.CheckpointConfig,
      context
    );
  }
  if (input.DebugHookConfig !== undefined) {
    bodyParams["DebugHookConfig"] = serializeAws_json1_1DebugHookConfig(
      input.DebugHookConfig,
      context
    );
  }
  if (input.DebugRuleConfigurations !== undefined) {
    bodyParams[
      "DebugRuleConfigurations"
    ] = serializeAws_json1_1DebugRuleConfigurations(
      input.DebugRuleConfigurations,
      context
    );
  }
  if (input.EnableInterContainerTrafficEncryption !== undefined) {
    bodyParams["EnableInterContainerTrafficEncryption"] =
      input.EnableInterContainerTrafficEncryption;
  }
  if (input.EnableManagedSpotTraining !== undefined) {
    bodyParams["EnableManagedSpotTraining"] = input.EnableManagedSpotTraining;
  }
  if (input.EnableNetworkIsolation !== undefined) {
    bodyParams["EnableNetworkIsolation"] = input.EnableNetworkIsolation;
  }
  if (input.ExperimentConfig !== undefined) {
    bodyParams["ExperimentConfig"] = serializeAws_json1_1ExperimentConfig(
      input.ExperimentConfig,
      context
    );
  }
  if (input.HyperParameters !== undefined) {
    bodyParams["HyperParameters"] = serializeAws_json1_1HyperParameters(
      input.HyperParameters,
      context
    );
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.ResourceConfig !== undefined) {
    bodyParams["ResourceConfig"] = serializeAws_json1_1ResourceConfig(
      input.ResourceConfig,
      context
    );
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.StoppingCondition !== undefined) {
    bodyParams["StoppingCondition"] = serializeAws_json1_1StoppingCondition(
      input.StoppingCondition,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.TensorBoardOutputConfig !== undefined) {
    bodyParams[
      "TensorBoardOutputConfig"
    ] = serializeAws_json1_1TensorBoardOutputConfig(
      input.TensorBoardOutputConfig,
      context
    );
  }
  if (input.TrainingJobName !== undefined) {
    bodyParams["TrainingJobName"] = input.TrainingJobName;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateTransformJobRequest = (
  input: CreateTransformJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.BatchStrategy !== undefined) {
    bodyParams["BatchStrategy"] = input.BatchStrategy;
  }
  if (input.DataProcessing !== undefined) {
    bodyParams["DataProcessing"] = serializeAws_json1_1DataProcessing(
      input.DataProcessing,
      context
    );
  }
  if (input.Environment !== undefined) {
    bodyParams["Environment"] = serializeAws_json1_1TransformEnvironmentMap(
      input.Environment,
      context
    );
  }
  if (input.ExperimentConfig !== undefined) {
    bodyParams["ExperimentConfig"] = serializeAws_json1_1ExperimentConfig(
      input.ExperimentConfig,
      context
    );
  }
  if (input.MaxConcurrentTransforms !== undefined) {
    bodyParams["MaxConcurrentTransforms"] = input.MaxConcurrentTransforms;
  }
  if (input.MaxPayloadInMB !== undefined) {
    bodyParams["MaxPayloadInMB"] = input.MaxPayloadInMB;
  }
  if (input.ModelName !== undefined) {
    bodyParams["ModelName"] = input.ModelName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.TransformInput !== undefined) {
    bodyParams["TransformInput"] = serializeAws_json1_1TransformInput(
      input.TransformInput,
      context
    );
  }
  if (input.TransformJobName !== undefined) {
    bodyParams["TransformJobName"] = input.TransformJobName;
  }
  if (input.TransformOutput !== undefined) {
    bodyParams["TransformOutput"] = serializeAws_json1_1TransformOutput(
      input.TransformOutput,
      context
    );
  }
  if (input.TransformResources !== undefined) {
    bodyParams["TransformResources"] = serializeAws_json1_1TransformResources(
      input.TransformResources,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateTrialComponentRequest = (
  input: CreateTrialComponentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DisplayName !== undefined) {
    bodyParams["DisplayName"] = input.DisplayName;
  }
  if (input.EndTime !== undefined) {
    bodyParams["EndTime"] = Math.round(input.EndTime.getTime() / 1000);
  }
  if (input.InputArtifacts !== undefined) {
    bodyParams["InputArtifacts"] = serializeAws_json1_1TrialComponentArtifacts(
      input.InputArtifacts,
      context
    );
  }
  if (input.OutputArtifacts !== undefined) {
    bodyParams["OutputArtifacts"] = serializeAws_json1_1TrialComponentArtifacts(
      input.OutputArtifacts,
      context
    );
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1TrialComponentParameters(
      input.Parameters,
      context
    );
  }
  if (input.StartTime !== undefined) {
    bodyParams["StartTime"] = Math.round(input.StartTime.getTime() / 1000);
  }
  if (input.Status !== undefined) {
    bodyParams["Status"] = serializeAws_json1_1TrialComponentStatus(
      input.Status,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.TrialComponentName !== undefined) {
    bodyParams["TrialComponentName"] = input.TrialComponentName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateTrialRequest = (
  input: CreateTrialRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DisplayName !== undefined) {
    bodyParams["DisplayName"] = input.DisplayName;
  }
  if (input.ExperimentName !== undefined) {
    bodyParams["ExperimentName"] = input.ExperimentName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.TrialName !== undefined) {
    bodyParams["TrialName"] = input.TrialName;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateUserProfileRequest = (
  input: CreateUserProfileRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  if (input.SingleSignOnUserIdentifier !== undefined) {
    bodyParams["SingleSignOnUserIdentifier"] = input.SingleSignOnUserIdentifier;
  }
  if (input.SingleSignOnUserValue !== undefined) {
    bodyParams["SingleSignOnUserValue"] = input.SingleSignOnUserValue;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.UserProfileName !== undefined) {
    bodyParams["UserProfileName"] = input.UserProfileName;
  }
  if (input.UserSettings !== undefined) {
    bodyParams["UserSettings"] = serializeAws_json1_1UserSettings(
      input.UserSettings,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateWorkteamRequest = (
  input: CreateWorkteamRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.MemberDefinitions !== undefined) {
    bodyParams["MemberDefinitions"] = serializeAws_json1_1MemberDefinitions(
      input.MemberDefinitions,
      context
    );
  }
  if (input.NotificationConfiguration !== undefined) {
    bodyParams[
      "NotificationConfiguration"
    ] = serializeAws_json1_1NotificationConfiguration(
      input.NotificationConfiguration,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.WorkteamName !== undefined) {
    bodyParams["WorkteamName"] = input.WorkteamName;
  }
  return bodyParams;
};

const serializeAws_json1_1CsvContentTypes = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1DataCaptureConfig = (
  input: DataCaptureConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CaptureContentTypeHeader !== undefined) {
    bodyParams[
      "CaptureContentTypeHeader"
    ] = serializeAws_json1_1CaptureContentTypeHeader(
      input.CaptureContentTypeHeader,
      context
    );
  }
  if (input.CaptureOptions !== undefined) {
    bodyParams["CaptureOptions"] = serializeAws_json1_1CaptureOptionList(
      input.CaptureOptions,
      context
    );
  }
  if (input.DestinationS3Uri !== undefined) {
    bodyParams["DestinationS3Uri"] = input.DestinationS3Uri;
  }
  if (input.EnableCapture !== undefined) {
    bodyParams["EnableCapture"] = input.EnableCapture;
  }
  if (input.InitialSamplingPercentage !== undefined) {
    bodyParams["InitialSamplingPercentage"] = input.InitialSamplingPercentage;
  }
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  return bodyParams;
};

const serializeAws_json1_1DataProcessing = (
  input: DataProcessing,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.InputFilter !== undefined) {
    bodyParams["InputFilter"] = input.InputFilter;
  }
  if (input.JoinSource !== undefined) {
    bodyParams["JoinSource"] = input.JoinSource;
  }
  if (input.OutputFilter !== undefined) {
    bodyParams["OutputFilter"] = input.OutputFilter;
  }
  return bodyParams;
};

const serializeAws_json1_1DataSource = (
  input: DataSource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.FileSystemDataSource !== undefined) {
    bodyParams[
      "FileSystemDataSource"
    ] = serializeAws_json1_1FileSystemDataSource(
      input.FileSystemDataSource,
      context
    );
  }
  if (input.S3DataSource !== undefined) {
    bodyParams["S3DataSource"] = serializeAws_json1_1S3DataSource(
      input.S3DataSource,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DebugHookConfig = (
  input: DebugHookConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CollectionConfigurations !== undefined) {
    bodyParams[
      "CollectionConfigurations"
    ] = serializeAws_json1_1CollectionConfigurations(
      input.CollectionConfigurations,
      context
    );
  }
  if (input.HookParameters !== undefined) {
    bodyParams["HookParameters"] = serializeAws_json1_1HookParameters(
      input.HookParameters,
      context
    );
  }
  if (input.LocalPath !== undefined) {
    bodyParams["LocalPath"] = input.LocalPath;
  }
  if (input.S3OutputPath !== undefined) {
    bodyParams["S3OutputPath"] = input.S3OutputPath;
  }
  return bodyParams;
};

const serializeAws_json1_1DebugRuleConfiguration = (
  input: DebugRuleConfiguration,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.InstanceType !== undefined) {
    bodyParams["InstanceType"] = input.InstanceType;
  }
  if (input.LocalPath !== undefined) {
    bodyParams["LocalPath"] = input.LocalPath;
  }
  if (input.RuleConfigurationName !== undefined) {
    bodyParams["RuleConfigurationName"] = input.RuleConfigurationName;
  }
  if (input.RuleEvaluatorImage !== undefined) {
    bodyParams["RuleEvaluatorImage"] = input.RuleEvaluatorImage;
  }
  if (input.RuleParameters !== undefined) {
    bodyParams["RuleParameters"] = serializeAws_json1_1RuleParameters(
      input.RuleParameters,
      context
    );
  }
  if (input.S3OutputPath !== undefined) {
    bodyParams["S3OutputPath"] = input.S3OutputPath;
  }
  if (input.VolumeSizeInGB !== undefined) {
    bodyParams["VolumeSizeInGB"] = input.VolumeSizeInGB;
  }
  return bodyParams;
};

const serializeAws_json1_1DebugRuleConfigurations = (
  input: Array<DebugRuleConfiguration>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1DebugRuleConfiguration(entry, context)
  );
};

const serializeAws_json1_1DeleteAlgorithmInput = (
  input: DeleteAlgorithmInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AlgorithmName !== undefined) {
    bodyParams["AlgorithmName"] = input.AlgorithmName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteAppRequest = (
  input: DeleteAppRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AppName !== undefined) {
    bodyParams["AppName"] = input.AppName;
  }
  if (input.AppType !== undefined) {
    bodyParams["AppType"] = input.AppType;
  }
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  if (input.UserProfileName !== undefined) {
    bodyParams["UserProfileName"] = input.UserProfileName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteCodeRepositoryInput = (
  input: DeleteCodeRepositoryInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CodeRepositoryName !== undefined) {
    bodyParams["CodeRepositoryName"] = input.CodeRepositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteDomainRequest = (
  input: DeleteDomainRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  if (input.RetentionPolicy !== undefined) {
    bodyParams["RetentionPolicy"] = serializeAws_json1_1RetentionPolicy(
      input.RetentionPolicy,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteEndpointConfigInput = (
  input: DeleteEndpointConfigInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointConfigName !== undefined) {
    bodyParams["EndpointConfigName"] = input.EndpointConfigName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteEndpointInput = (
  input: DeleteEndpointInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteExperimentRequest = (
  input: DeleteExperimentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ExperimentName !== undefined) {
    bodyParams["ExperimentName"] = input.ExperimentName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteFlowDefinitionRequest = (
  input: DeleteFlowDefinitionRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.FlowDefinitionName !== undefined) {
    bodyParams["FlowDefinitionName"] = input.FlowDefinitionName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteModelInput = (
  input: DeleteModelInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ModelName !== undefined) {
    bodyParams["ModelName"] = input.ModelName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteModelPackageInput = (
  input: DeleteModelPackageInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ModelPackageName !== undefined) {
    bodyParams["ModelPackageName"] = input.ModelPackageName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteMonitoringScheduleRequest = (
  input: DeleteMonitoringScheduleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MonitoringScheduleName !== undefined) {
    bodyParams["MonitoringScheduleName"] = input.MonitoringScheduleName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteNotebookInstanceInput = (
  input: DeleteNotebookInstanceInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotebookInstanceName !== undefined) {
    bodyParams["NotebookInstanceName"] = input.NotebookInstanceName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteNotebookInstanceLifecycleConfigInput = (
  input: DeleteNotebookInstanceLifecycleConfigInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotebookInstanceLifecycleConfigName !== undefined) {
    bodyParams["NotebookInstanceLifecycleConfigName"] =
      input.NotebookInstanceLifecycleConfigName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteTagsInput = (
  input: DeleteTagsInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.TagKeys !== undefined) {
    bodyParams["TagKeys"] = serializeAws_json1_1TagKeyList(
      input.TagKeys,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteTrialComponentRequest = (
  input: DeleteTrialComponentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TrialComponentName !== undefined) {
    bodyParams["TrialComponentName"] = input.TrialComponentName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteTrialRequest = (
  input: DeleteTrialRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TrialName !== undefined) {
    bodyParams["TrialName"] = input.TrialName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteUserProfileRequest = (
  input: DeleteUserProfileRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  if (input.UserProfileName !== undefined) {
    bodyParams["UserProfileName"] = input.UserProfileName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteWorkteamRequest = (
  input: DeleteWorkteamRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.WorkteamName !== undefined) {
    bodyParams["WorkteamName"] = input.WorkteamName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAlgorithmInput = (
  input: DescribeAlgorithmInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AlgorithmName !== undefined) {
    bodyParams["AlgorithmName"] = input.AlgorithmName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAppRequest = (
  input: DescribeAppRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AppName !== undefined) {
    bodyParams["AppName"] = input.AppName;
  }
  if (input.AppType !== undefined) {
    bodyParams["AppType"] = input.AppType;
  }
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  if (input.UserProfileName !== undefined) {
    bodyParams["UserProfileName"] = input.UserProfileName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAutoMLJobRequest = (
  input: DescribeAutoMLJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AutoMLJobName !== undefined) {
    bodyParams["AutoMLJobName"] = input.AutoMLJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeCodeRepositoryInput = (
  input: DescribeCodeRepositoryInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CodeRepositoryName !== undefined) {
    bodyParams["CodeRepositoryName"] = input.CodeRepositoryName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeCompilationJobRequest = (
  input: DescribeCompilationJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CompilationJobName !== undefined) {
    bodyParams["CompilationJobName"] = input.CompilationJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeDomainRequest = (
  input: DescribeDomainRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEndpointConfigInput = (
  input: DescribeEndpointConfigInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointConfigName !== undefined) {
    bodyParams["EndpointConfigName"] = input.EndpointConfigName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEndpointInput = (
  input: DescribeEndpointInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeExperimentRequest = (
  input: DescribeExperimentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ExperimentName !== undefined) {
    bodyParams["ExperimentName"] = input.ExperimentName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeFlowDefinitionRequest = (
  input: DescribeFlowDefinitionRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.FlowDefinitionName !== undefined) {
    bodyParams["FlowDefinitionName"] = input.FlowDefinitionName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeHumanTaskUiRequest = (
  input: DescribeHumanTaskUiRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HumanTaskUiName !== undefined) {
    bodyParams["HumanTaskUiName"] = input.HumanTaskUiName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeHyperParameterTuningJobRequest = (
  input: DescribeHyperParameterTuningJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HyperParameterTuningJobName !== undefined) {
    bodyParams["HyperParameterTuningJobName"] =
      input.HyperParameterTuningJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeLabelingJobRequest = (
  input: DescribeLabelingJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LabelingJobName !== undefined) {
    bodyParams["LabelingJobName"] = input.LabelingJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeModelInput = (
  input: DescribeModelInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ModelName !== undefined) {
    bodyParams["ModelName"] = input.ModelName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeModelPackageInput = (
  input: DescribeModelPackageInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ModelPackageName !== undefined) {
    bodyParams["ModelPackageName"] = input.ModelPackageName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMonitoringScheduleRequest = (
  input: DescribeMonitoringScheduleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MonitoringScheduleName !== undefined) {
    bodyParams["MonitoringScheduleName"] = input.MonitoringScheduleName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeNotebookInstanceInput = (
  input: DescribeNotebookInstanceInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotebookInstanceName !== undefined) {
    bodyParams["NotebookInstanceName"] = input.NotebookInstanceName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeNotebookInstanceLifecycleConfigInput = (
  input: DescribeNotebookInstanceLifecycleConfigInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotebookInstanceLifecycleConfigName !== undefined) {
    bodyParams["NotebookInstanceLifecycleConfigName"] =
      input.NotebookInstanceLifecycleConfigName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeProcessingJobRequest = (
  input: DescribeProcessingJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ProcessingJobName !== undefined) {
    bodyParams["ProcessingJobName"] = input.ProcessingJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeSubscribedWorkteamRequest = (
  input: DescribeSubscribedWorkteamRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.WorkteamArn !== undefined) {
    bodyParams["WorkteamArn"] = input.WorkteamArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeTrainingJobRequest = (
  input: DescribeTrainingJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TrainingJobName !== undefined) {
    bodyParams["TrainingJobName"] = input.TrainingJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeTransformJobRequest = (
  input: DescribeTransformJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TransformJobName !== undefined) {
    bodyParams["TransformJobName"] = input.TransformJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeTrialComponentRequest = (
  input: DescribeTrialComponentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TrialComponentName !== undefined) {
    bodyParams["TrialComponentName"] = input.TrialComponentName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeTrialRequest = (
  input: DescribeTrialRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TrialName !== undefined) {
    bodyParams["TrialName"] = input.TrialName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeUserProfileRequest = (
  input: DescribeUserProfileRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  if (input.UserProfileName !== undefined) {
    bodyParams["UserProfileName"] = input.UserProfileName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeWorkforceRequest = (
  input: DescribeWorkforceRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.WorkforceName !== undefined) {
    bodyParams["WorkforceName"] = input.WorkforceName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeWorkteamRequest = (
  input: DescribeWorkteamRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.WorkteamName !== undefined) {
    bodyParams["WorkteamName"] = input.WorkteamName;
  }
  return bodyParams;
};

const serializeAws_json1_1DesiredWeightAndCapacity = (
  input: DesiredWeightAndCapacity,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DesiredInstanceCount !== undefined) {
    bodyParams["DesiredInstanceCount"] = input.DesiredInstanceCount;
  }
  if (input.DesiredWeight !== undefined) {
    bodyParams["DesiredWeight"] = input.DesiredWeight;
  }
  if (input.VariantName !== undefined) {
    bodyParams["VariantName"] = input.VariantName;
  }
  return bodyParams;
};

const serializeAws_json1_1DesiredWeightAndCapacityList = (
  input: Array<DesiredWeightAndCapacity>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1DesiredWeightAndCapacity(entry, context)
  );
};

const serializeAws_json1_1DisassociateTrialComponentRequest = (
  input: DisassociateTrialComponentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TrialComponentName !== undefined) {
    bodyParams["TrialComponentName"] = input.TrialComponentName;
  }
  if (input.TrialName !== undefined) {
    bodyParams["TrialName"] = input.TrialName;
  }
  return bodyParams;
};

const serializeAws_json1_1EndpointInput = (
  input: EndpointInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  if (input.LocalPath !== undefined) {
    bodyParams["LocalPath"] = input.LocalPath;
  }
  if (input.S3DataDistributionType !== undefined) {
    bodyParams["S3DataDistributionType"] = input.S3DataDistributionType;
  }
  if (input.S3InputMode !== undefined) {
    bodyParams["S3InputMode"] = input.S3InputMode;
  }
  return bodyParams;
};

const serializeAws_json1_1EnvironmentMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1ExperimentConfig = (
  input: ExperimentConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ExperimentName !== undefined) {
    bodyParams["ExperimentName"] = input.ExperimentName;
  }
  if (input.TrialComponentDisplayName !== undefined) {
    bodyParams["TrialComponentDisplayName"] = input.TrialComponentDisplayName;
  }
  if (input.TrialName !== undefined) {
    bodyParams["TrialName"] = input.TrialName;
  }
  return bodyParams;
};

const serializeAws_json1_1FileSystemDataSource = (
  input: FileSystemDataSource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DirectoryPath !== undefined) {
    bodyParams["DirectoryPath"] = input.DirectoryPath;
  }
  if (input.FileSystemAccessMode !== undefined) {
    bodyParams["FileSystemAccessMode"] = input.FileSystemAccessMode;
  }
  if (input.FileSystemId !== undefined) {
    bodyParams["FileSystemId"] = input.FileSystemId;
  }
  if (input.FileSystemType !== undefined) {
    bodyParams["FileSystemType"] = input.FileSystemType;
  }
  return bodyParams;
};

const serializeAws_json1_1Filter = (
  input: Filter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Operator !== undefined) {
    bodyParams["Operator"] = input.Operator;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1FilterList = (
  input: Array<Filter>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => serializeAws_json1_1Filter(entry, context));
};

const serializeAws_json1_1FlowDefinitionOutputConfig = (
  input: FlowDefinitionOutputConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.S3OutputPath !== undefined) {
    bodyParams["S3OutputPath"] = input.S3OutputPath;
  }
  return bodyParams;
};

const serializeAws_json1_1FlowDefinitionTaskKeywords = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1GetSearchSuggestionsRequest = (
  input: GetSearchSuggestionsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Resource !== undefined) {
    bodyParams["Resource"] = input.Resource;
  }
  if (input.SuggestionQuery !== undefined) {
    bodyParams["SuggestionQuery"] = serializeAws_json1_1SuggestionQuery(
      input.SuggestionQuery,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1GitConfig = (
  input: GitConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Branch !== undefined) {
    bodyParams["Branch"] = input.Branch;
  }
  if (input.RepositoryUrl !== undefined) {
    bodyParams["RepositoryUrl"] = input.RepositoryUrl;
  }
  if (input.SecretArn !== undefined) {
    bodyParams["SecretArn"] = input.SecretArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GitConfigForUpdate = (
  input: GitConfigForUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.SecretArn !== undefined) {
    bodyParams["SecretArn"] = input.SecretArn;
  }
  return bodyParams;
};

const serializeAws_json1_1HookParameters = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1HumanLoopActivationConditionsConfig = (
  input: HumanLoopActivationConditionsConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HumanLoopActivationConditions !== undefined) {
    bodyParams["HumanLoopActivationConditions"] =
      input.HumanLoopActivationConditions;
  }
  return bodyParams;
};

const serializeAws_json1_1HumanLoopActivationConfig = (
  input: HumanLoopActivationConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HumanLoopActivationConditionsConfig !== undefined) {
    bodyParams[
      "HumanLoopActivationConditionsConfig"
    ] = serializeAws_json1_1HumanLoopActivationConditionsConfig(
      input.HumanLoopActivationConditionsConfig,
      context
    );
  }
  if (input.HumanLoopRequestSource !== undefined) {
    bodyParams[
      "HumanLoopRequestSource"
    ] = serializeAws_json1_1HumanLoopRequestSource(
      input.HumanLoopRequestSource,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1HumanLoopConfig = (
  input: HumanLoopConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HumanTaskUiArn !== undefined) {
    bodyParams["HumanTaskUiArn"] = input.HumanTaskUiArn;
  }
  if (input.PublicWorkforceTaskPrice !== undefined) {
    bodyParams[
      "PublicWorkforceTaskPrice"
    ] = serializeAws_json1_1PublicWorkforceTaskPrice(
      input.PublicWorkforceTaskPrice,
      context
    );
  }
  if (input.TaskAvailabilityLifetimeInSeconds !== undefined) {
    bodyParams["TaskAvailabilityLifetimeInSeconds"] =
      input.TaskAvailabilityLifetimeInSeconds;
  }
  if (input.TaskCount !== undefined) {
    bodyParams["TaskCount"] = input.TaskCount;
  }
  if (input.TaskDescription !== undefined) {
    bodyParams["TaskDescription"] = input.TaskDescription;
  }
  if (input.TaskKeywords !== undefined) {
    bodyParams["TaskKeywords"] = serializeAws_json1_1FlowDefinitionTaskKeywords(
      input.TaskKeywords,
      context
    );
  }
  if (input.TaskTimeLimitInSeconds !== undefined) {
    bodyParams["TaskTimeLimitInSeconds"] = input.TaskTimeLimitInSeconds;
  }
  if (input.TaskTitle !== undefined) {
    bodyParams["TaskTitle"] = input.TaskTitle;
  }
  if (input.WorkteamArn !== undefined) {
    bodyParams["WorkteamArn"] = input.WorkteamArn;
  }
  return bodyParams;
};

const serializeAws_json1_1HumanLoopRequestSource = (
  input: HumanLoopRequestSource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AwsManagedHumanLoopRequestSource !== undefined) {
    bodyParams["AwsManagedHumanLoopRequestSource"] =
      input.AwsManagedHumanLoopRequestSource;
  }
  return bodyParams;
};

const serializeAws_json1_1HumanTaskConfig = (
  input: HumanTaskConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AnnotationConsolidationConfig !== undefined) {
    bodyParams[
      "AnnotationConsolidationConfig"
    ] = serializeAws_json1_1AnnotationConsolidationConfig(
      input.AnnotationConsolidationConfig,
      context
    );
  }
  if (input.MaxConcurrentTaskCount !== undefined) {
    bodyParams["MaxConcurrentTaskCount"] = input.MaxConcurrentTaskCount;
  }
  if (input.NumberOfHumanWorkersPerDataObject !== undefined) {
    bodyParams["NumberOfHumanWorkersPerDataObject"] =
      input.NumberOfHumanWorkersPerDataObject;
  }
  if (input.PreHumanTaskLambdaArn !== undefined) {
    bodyParams["PreHumanTaskLambdaArn"] = input.PreHumanTaskLambdaArn;
  }
  if (input.PublicWorkforceTaskPrice !== undefined) {
    bodyParams[
      "PublicWorkforceTaskPrice"
    ] = serializeAws_json1_1PublicWorkforceTaskPrice(
      input.PublicWorkforceTaskPrice,
      context
    );
  }
  if (input.TaskAvailabilityLifetimeInSeconds !== undefined) {
    bodyParams["TaskAvailabilityLifetimeInSeconds"] =
      input.TaskAvailabilityLifetimeInSeconds;
  }
  if (input.TaskDescription !== undefined) {
    bodyParams["TaskDescription"] = input.TaskDescription;
  }
  if (input.TaskKeywords !== undefined) {
    bodyParams["TaskKeywords"] = serializeAws_json1_1TaskKeywords(
      input.TaskKeywords,
      context
    );
  }
  if (input.TaskTimeLimitInSeconds !== undefined) {
    bodyParams["TaskTimeLimitInSeconds"] = input.TaskTimeLimitInSeconds;
  }
  if (input.TaskTitle !== undefined) {
    bodyParams["TaskTitle"] = input.TaskTitle;
  }
  if (input.UiConfig !== undefined) {
    bodyParams["UiConfig"] = serializeAws_json1_1UiConfig(
      input.UiConfig,
      context
    );
  }
  if (input.WorkteamArn !== undefined) {
    bodyParams["WorkteamArn"] = input.WorkteamArn;
  }
  return bodyParams;
};

const serializeAws_json1_1HyperParameterAlgorithmSpecification = (
  input: HyperParameterAlgorithmSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AlgorithmName !== undefined) {
    bodyParams["AlgorithmName"] = input.AlgorithmName;
  }
  if (input.MetricDefinitions !== undefined) {
    bodyParams["MetricDefinitions"] = serializeAws_json1_1MetricDefinitionList(
      input.MetricDefinitions,
      context
    );
  }
  if (input.TrainingImage !== undefined) {
    bodyParams["TrainingImage"] = input.TrainingImage;
  }
  if (input.TrainingInputMode !== undefined) {
    bodyParams["TrainingInputMode"] = input.TrainingInputMode;
  }
  return bodyParams;
};

const serializeAws_json1_1HyperParameterSpecification = (
  input: HyperParameterSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DefaultValue !== undefined) {
    bodyParams["DefaultValue"] = input.DefaultValue;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.IsRequired !== undefined) {
    bodyParams["IsRequired"] = input.IsRequired;
  }
  if (input.IsTunable !== undefined) {
    bodyParams["IsTunable"] = input.IsTunable;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Range !== undefined) {
    bodyParams["Range"] = serializeAws_json1_1ParameterRange(
      input.Range,
      context
    );
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1HyperParameterSpecifications = (
  input: Array<HyperParameterSpecification>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1HyperParameterSpecification(entry, context)
  );
};

const serializeAws_json1_1HyperParameterTrainingJobDefinition = (
  input: HyperParameterTrainingJobDefinition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AlgorithmSpecification !== undefined) {
    bodyParams[
      "AlgorithmSpecification"
    ] = serializeAws_json1_1HyperParameterAlgorithmSpecification(
      input.AlgorithmSpecification,
      context
    );
  }
  if (input.CheckpointConfig !== undefined) {
    bodyParams["CheckpointConfig"] = serializeAws_json1_1CheckpointConfig(
      input.CheckpointConfig,
      context
    );
  }
  if (input.DefinitionName !== undefined) {
    bodyParams["DefinitionName"] = input.DefinitionName;
  }
  if (input.EnableInterContainerTrafficEncryption !== undefined) {
    bodyParams["EnableInterContainerTrafficEncryption"] =
      input.EnableInterContainerTrafficEncryption;
  }
  if (input.EnableManagedSpotTraining !== undefined) {
    bodyParams["EnableManagedSpotTraining"] = input.EnableManagedSpotTraining;
  }
  if (input.EnableNetworkIsolation !== undefined) {
    bodyParams["EnableNetworkIsolation"] = input.EnableNetworkIsolation;
  }
  if (input.HyperParameterRanges !== undefined) {
    bodyParams["HyperParameterRanges"] = serializeAws_json1_1ParameterRanges(
      input.HyperParameterRanges,
      context
    );
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.ResourceConfig !== undefined) {
    bodyParams["ResourceConfig"] = serializeAws_json1_1ResourceConfig(
      input.ResourceConfig,
      context
    );
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.StaticHyperParameters !== undefined) {
    bodyParams["StaticHyperParameters"] = serializeAws_json1_1HyperParameters(
      input.StaticHyperParameters,
      context
    );
  }
  if (input.StoppingCondition !== undefined) {
    bodyParams["StoppingCondition"] = serializeAws_json1_1StoppingCondition(
      input.StoppingCondition,
      context
    );
  }
  if (input.TuningObjective !== undefined) {
    bodyParams[
      "TuningObjective"
    ] = serializeAws_json1_1HyperParameterTuningJobObjective(
      input.TuningObjective,
      context
    );
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1HyperParameterTrainingJobDefinitions = (
  input: Array<HyperParameterTrainingJobDefinition>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1HyperParameterTrainingJobDefinition(entry, context)
  );
};

const serializeAws_json1_1HyperParameterTuningJobConfig = (
  input: HyperParameterTuningJobConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HyperParameterTuningJobObjective !== undefined) {
    bodyParams[
      "HyperParameterTuningJobObjective"
    ] = serializeAws_json1_1HyperParameterTuningJobObjective(
      input.HyperParameterTuningJobObjective,
      context
    );
  }
  if (input.ParameterRanges !== undefined) {
    bodyParams["ParameterRanges"] = serializeAws_json1_1ParameterRanges(
      input.ParameterRanges,
      context
    );
  }
  if (input.ResourceLimits !== undefined) {
    bodyParams["ResourceLimits"] = serializeAws_json1_1ResourceLimits(
      input.ResourceLimits,
      context
    );
  }
  if (input.Strategy !== undefined) {
    bodyParams["Strategy"] = input.Strategy;
  }
  if (input.TrainingJobEarlyStoppingType !== undefined) {
    bodyParams["TrainingJobEarlyStoppingType"] =
      input.TrainingJobEarlyStoppingType;
  }
  if (input.TuningJobCompletionCriteria !== undefined) {
    bodyParams[
      "TuningJobCompletionCriteria"
    ] = serializeAws_json1_1TuningJobCompletionCriteria(
      input.TuningJobCompletionCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1HyperParameterTuningJobObjective = (
  input: HyperParameterTuningJobObjective,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MetricName !== undefined) {
    bodyParams["MetricName"] = input.MetricName;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1HyperParameterTuningJobObjectives = (
  input: Array<HyperParameterTuningJobObjective>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1HyperParameterTuningJobObjective(entry, context)
  );
};

const serializeAws_json1_1HyperParameterTuningJobWarmStartConfig = (
  input: HyperParameterTuningJobWarmStartConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ParentHyperParameterTuningJobs !== undefined) {
    bodyParams[
      "ParentHyperParameterTuningJobs"
    ] = serializeAws_json1_1ParentHyperParameterTuningJobs(
      input.ParentHyperParameterTuningJobs,
      context
    );
  }
  if (input.WarmStartType !== undefined) {
    bodyParams["WarmStartType"] = input.WarmStartType;
  }
  return bodyParams;
};

const serializeAws_json1_1HyperParameters = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1InferenceSpecification = (
  input: InferenceSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Containers !== undefined) {
    bodyParams[
      "Containers"
    ] = serializeAws_json1_1ModelPackageContainerDefinitionList(
      input.Containers,
      context
    );
  }
  if (input.SupportedContentTypes !== undefined) {
    bodyParams["SupportedContentTypes"] = serializeAws_json1_1ContentTypes(
      input.SupportedContentTypes,
      context
    );
  }
  if (input.SupportedRealtimeInferenceInstanceTypes !== undefined) {
    bodyParams[
      "SupportedRealtimeInferenceInstanceTypes"
    ] = serializeAws_json1_1RealtimeInferenceInstanceTypes(
      input.SupportedRealtimeInferenceInstanceTypes,
      context
    );
  }
  if (input.SupportedResponseMIMETypes !== undefined) {
    bodyParams[
      "SupportedResponseMIMETypes"
    ] = serializeAws_json1_1ResponseMIMETypes(
      input.SupportedResponseMIMETypes,
      context
    );
  }
  if (input.SupportedTransformInstanceTypes !== undefined) {
    bodyParams[
      "SupportedTransformInstanceTypes"
    ] = serializeAws_json1_1TransformInstanceTypes(
      input.SupportedTransformInstanceTypes,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1InputConfig = (
  input: InputConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DataInputConfig !== undefined) {
    bodyParams["DataInputConfig"] = input.DataInputConfig;
  }
  if (input.Framework !== undefined) {
    bodyParams["Framework"] = input.Framework;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1InputDataConfig = (
  input: Array<Channel>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1Channel(entry, context)
  );
};

const serializeAws_json1_1InputModes = (
  input: Array<TrainingInputMode | string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1IntegerParameterRange = (
  input: IntegerParameterRange,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxValue !== undefined) {
    bodyParams["MaxValue"] = input.MaxValue;
  }
  if (input.MinValue !== undefined) {
    bodyParams["MinValue"] = input.MinValue;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.ScalingType !== undefined) {
    bodyParams["ScalingType"] = input.ScalingType;
  }
  return bodyParams;
};

const serializeAws_json1_1IntegerParameterRangeSpecification = (
  input: IntegerParameterRangeSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxValue !== undefined) {
    bodyParams["MaxValue"] = input.MaxValue;
  }
  if (input.MinValue !== undefined) {
    bodyParams["MinValue"] = input.MinValue;
  }
  return bodyParams;
};

const serializeAws_json1_1IntegerParameterRanges = (
  input: Array<IntegerParameterRange>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1IntegerParameterRange(entry, context)
  );
};

const serializeAws_json1_1JsonContentTypes = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1JupyterServerAppSettings = (
  input: JupyterServerAppSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DefaultResourceSpec !== undefined) {
    bodyParams["DefaultResourceSpec"] = serializeAws_json1_1ResourceSpec(
      input.DefaultResourceSpec,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1KernelGatewayAppSettings = (
  input: KernelGatewayAppSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DefaultResourceSpec !== undefined) {
    bodyParams["DefaultResourceSpec"] = serializeAws_json1_1ResourceSpec(
      input.DefaultResourceSpec,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1LabelingJobAlgorithmsConfig = (
  input: LabelingJobAlgorithmsConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.InitialActiveLearningModelArn !== undefined) {
    bodyParams["InitialActiveLearningModelArn"] =
      input.InitialActiveLearningModelArn;
  }
  if (input.LabelingJobAlgorithmSpecificationArn !== undefined) {
    bodyParams["LabelingJobAlgorithmSpecificationArn"] =
      input.LabelingJobAlgorithmSpecificationArn;
  }
  if (input.LabelingJobResourceConfig !== undefined) {
    bodyParams[
      "LabelingJobResourceConfig"
    ] = serializeAws_json1_1LabelingJobResourceConfig(
      input.LabelingJobResourceConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1LabelingJobDataAttributes = (
  input: LabelingJobDataAttributes,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ContentClassifiers !== undefined) {
    bodyParams["ContentClassifiers"] = serializeAws_json1_1ContentClassifiers(
      input.ContentClassifiers,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1LabelingJobDataSource = (
  input: LabelingJobDataSource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3DataSource !== undefined) {
    bodyParams["S3DataSource"] = serializeAws_json1_1LabelingJobS3DataSource(
      input.S3DataSource,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1LabelingJobInputConfig = (
  input: LabelingJobInputConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DataAttributes !== undefined) {
    bodyParams[
      "DataAttributes"
    ] = serializeAws_json1_1LabelingJobDataAttributes(
      input.DataAttributes,
      context
    );
  }
  if (input.DataSource !== undefined) {
    bodyParams["DataSource"] = serializeAws_json1_1LabelingJobDataSource(
      input.DataSource,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1LabelingJobOutputConfig = (
  input: LabelingJobOutputConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.S3OutputPath !== undefined) {
    bodyParams["S3OutputPath"] = input.S3OutputPath;
  }
  return bodyParams;
};

const serializeAws_json1_1LabelingJobResourceConfig = (
  input: LabelingJobResourceConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  return bodyParams;
};

const serializeAws_json1_1LabelingJobS3DataSource = (
  input: LabelingJobS3DataSource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ManifestS3Uri !== undefined) {
    bodyParams["ManifestS3Uri"] = input.ManifestS3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1LabelingJobStoppingConditions = (
  input: LabelingJobStoppingConditions,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxHumanLabeledObjectCount !== undefined) {
    bodyParams["MaxHumanLabeledObjectCount"] = input.MaxHumanLabeledObjectCount;
  }
  if (input.MaxPercentageOfInputDatasetLabeled !== undefined) {
    bodyParams["MaxPercentageOfInputDatasetLabeled"] =
      input.MaxPercentageOfInputDatasetLabeled;
  }
  return bodyParams;
};

const serializeAws_json1_1ListAlgorithmsInput = (
  input: ListAlgorithmsInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1ListAppsRequest = (
  input: ListAppsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DomainIdEquals !== undefined) {
    bodyParams["DomainIdEquals"] = input.DomainIdEquals;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.UserProfileNameEquals !== undefined) {
    bodyParams["UserProfileNameEquals"] = input.UserProfileNameEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListAutoMLJobsRequest = (
  input: ListAutoMLJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListCandidatesForAutoMLJobRequest = (
  input: ListCandidatesForAutoMLJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AutoMLJobName !== undefined) {
    bodyParams["AutoMLJobName"] = input.AutoMLJobName;
  }
  if (input.CandidateNameEquals !== undefined) {
    bodyParams["CandidateNameEquals"] = input.CandidateNameEquals;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListCodeRepositoriesInput = (
  input: ListCodeRepositoriesInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1ListCompilationJobsRequest = (
  input: ListCompilationJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListDomainsRequest = (
  input: ListDomainsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListEndpointConfigsInput = (
  input: ListEndpointConfigsInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1ListEndpointsInput = (
  input: ListEndpointsInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListExperimentsRequest = (
  input: ListExperimentsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreatedAfter !== undefined) {
    bodyParams["CreatedAfter"] = Math.round(
      input.CreatedAfter.getTime() / 1000
    );
  }
  if (input.CreatedBefore !== undefined) {
    bodyParams["CreatedBefore"] = Math.round(
      input.CreatedBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1ListFlowDefinitionsRequest = (
  input: ListFlowDefinitionsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1ListHumanTaskUisRequest = (
  input: ListHumanTaskUisRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1ListHyperParameterTuningJobsRequest = (
  input: ListHyperParameterTuningJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListLabelingJobsForWorkteamRequest = (
  input: ListLabelingJobsForWorkteamRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.JobReferenceCodeContains !== undefined) {
    bodyParams["JobReferenceCodeContains"] = input.JobReferenceCodeContains;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.WorkteamArn !== undefined) {
    bodyParams["WorkteamArn"] = input.WorkteamArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ListLabelingJobsRequest = (
  input: ListLabelingJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListModelPackagesInput = (
  input: ListModelPackagesInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1ListModelsInput = (
  input: ListModelsInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1ListMonitoringExecutionsRequest = (
  input: ListMonitoringExecutionsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.MonitoringScheduleName !== undefined) {
    bodyParams["MonitoringScheduleName"] = input.MonitoringScheduleName;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ScheduledTimeAfter !== undefined) {
    bodyParams["ScheduledTimeAfter"] = Math.round(
      input.ScheduledTimeAfter.getTime() / 1000
    );
  }
  if (input.ScheduledTimeBefore !== undefined) {
    bodyParams["ScheduledTimeBefore"] = Math.round(
      input.ScheduledTimeBefore.getTime() / 1000
    );
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListMonitoringSchedulesRequest = (
  input: ListMonitoringSchedulesRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListNotebookInstanceLifecycleConfigsInput = (
  input: ListNotebookInstanceLifecycleConfigsInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1ListNotebookInstancesInput = (
  input: ListNotebookInstancesInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AdditionalCodeRepositoryEquals !== undefined) {
    bodyParams["AdditionalCodeRepositoryEquals"] =
      input.AdditionalCodeRepositoryEquals;
  }
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.DefaultCodeRepositoryContains !== undefined) {
    bodyParams["DefaultCodeRepositoryContains"] =
      input.DefaultCodeRepositoryContains;
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.NotebookInstanceLifecycleConfigNameContains !== undefined) {
    bodyParams["NotebookInstanceLifecycleConfigNameContains"] =
      input.NotebookInstanceLifecycleConfigNameContains;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListProcessingJobsRequest = (
  input: ListProcessingJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSubscribedWorkteamsRequest = (
  input: ListSubscribedWorkteamsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsInput = (
  input: ListTagsInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTrainingJobsForHyperParameterTuningJobRequest = (
  input: ListTrainingJobsForHyperParameterTuningJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HyperParameterTuningJobName !== undefined) {
    bodyParams["HyperParameterTuningJobName"] =
      input.HyperParameterTuningJobName;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTrainingJobsRequest = (
  input: ListTrainingJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTransformJobsRequest = (
  input: ListTransformJobsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreationTimeAfter !== undefined) {
    bodyParams["CreationTimeAfter"] = Math.round(
      input.CreationTimeAfter.getTime() / 1000
    );
  }
  if (input.CreationTimeBefore !== undefined) {
    bodyParams["CreationTimeBefore"] = Math.round(
      input.CreationTimeBefore.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeAfter !== undefined) {
    bodyParams["LastModifiedTimeAfter"] = Math.round(
      input.LastModifiedTimeAfter.getTime() / 1000
    );
  }
  if (input.LastModifiedTimeBefore !== undefined) {
    bodyParams["LastModifiedTimeBefore"] = Math.round(
      input.LastModifiedTimeBefore.getTime() / 1000
    );
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.StatusEquals !== undefined) {
    bodyParams["StatusEquals"] = input.StatusEquals;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTrialComponentKey256 = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ListTrialComponentsRequest = (
  input: ListTrialComponentsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreatedAfter !== undefined) {
    bodyParams["CreatedAfter"] = Math.round(
      input.CreatedAfter.getTime() / 1000
    );
  }
  if (input.CreatedBefore !== undefined) {
    bodyParams["CreatedBefore"] = Math.round(
      input.CreatedBefore.getTime() / 1000
    );
  }
  if (input.ExperimentName !== undefined) {
    bodyParams["ExperimentName"] = input.ExperimentName;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.SourceArn !== undefined) {
    bodyParams["SourceArn"] = input.SourceArn;
  }
  if (input.TrialName !== undefined) {
    bodyParams["TrialName"] = input.TrialName;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTrialsRequest = (
  input: ListTrialsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CreatedAfter !== undefined) {
    bodyParams["CreatedAfter"] = Math.round(
      input.CreatedAfter.getTime() / 1000
    );
  }
  if (input.CreatedBefore !== undefined) {
    bodyParams["CreatedBefore"] = Math.round(
      input.CreatedBefore.getTime() / 1000
    );
  }
  if (input.ExperimentName !== undefined) {
    bodyParams["ExperimentName"] = input.ExperimentName;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1ListUserProfilesRequest = (
  input: ListUserProfilesRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DomainIdEquals !== undefined) {
    bodyParams["DomainIdEquals"] = input.DomainIdEquals;
  }
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  if (input.UserProfileNameContains !== undefined) {
    bodyParams["UserProfileNameContains"] = input.UserProfileNameContains;
  }
  return bodyParams;
};

const serializeAws_json1_1ListWorkteamsRequest = (
  input: ListWorkteamsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NameContains !== undefined) {
    bodyParams["NameContains"] = input.NameContains;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1MemberDefinition = (
  input: MemberDefinition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CognitoMemberDefinition !== undefined) {
    bodyParams[
      "CognitoMemberDefinition"
    ] = serializeAws_json1_1CognitoMemberDefinition(
      input.CognitoMemberDefinition,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MemberDefinitions = (
  input: Array<MemberDefinition>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1MemberDefinition(entry, context)
  );
};

const serializeAws_json1_1MetricDefinition = (
  input: MetricDefinition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Regex !== undefined) {
    bodyParams["Regex"] = input.Regex;
  }
  return bodyParams;
};

const serializeAws_json1_1MetricDefinitionList = (
  input: Array<MetricDefinition>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1MetricDefinition(entry, context)
  );
};

const serializeAws_json1_1ModelPackageContainerDefinition = (
  input: ModelPackageContainerDefinition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ContainerHostname !== undefined) {
    bodyParams["ContainerHostname"] = input.ContainerHostname;
  }
  if (input.Image !== undefined) {
    bodyParams["Image"] = input.Image;
  }
  if (input.ImageDigest !== undefined) {
    bodyParams["ImageDigest"] = input.ImageDigest;
  }
  if (input.ModelDataUrl !== undefined) {
    bodyParams["ModelDataUrl"] = input.ModelDataUrl;
  }
  if (input.ProductId !== undefined) {
    bodyParams["ProductId"] = input.ProductId;
  }
  return bodyParams;
};

const serializeAws_json1_1ModelPackageContainerDefinitionList = (
  input: Array<ModelPackageContainerDefinition>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ModelPackageContainerDefinition(entry, context)
  );
};

const serializeAws_json1_1ModelPackageValidationProfile = (
  input: ModelPackageValidationProfile,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ProfileName !== undefined) {
    bodyParams["ProfileName"] = input.ProfileName;
  }
  if (input.TransformJobDefinition !== undefined) {
    bodyParams[
      "TransformJobDefinition"
    ] = serializeAws_json1_1TransformJobDefinition(
      input.TransformJobDefinition,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ModelPackageValidationProfiles = (
  input: Array<ModelPackageValidationProfile>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ModelPackageValidationProfile(entry, context)
  );
};

const serializeAws_json1_1ModelPackageValidationSpecification = (
  input: ModelPackageValidationSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ValidationProfiles !== undefined) {
    bodyParams[
      "ValidationProfiles"
    ] = serializeAws_json1_1ModelPackageValidationProfiles(
      input.ValidationProfiles,
      context
    );
  }
  if (input.ValidationRole !== undefined) {
    bodyParams["ValidationRole"] = input.ValidationRole;
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringAppSpecification = (
  input: MonitoringAppSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ContainerArguments !== undefined) {
    bodyParams[
      "ContainerArguments"
    ] = serializeAws_json1_1MonitoringContainerArguments(
      input.ContainerArguments,
      context
    );
  }
  if (input.ContainerEntrypoint !== undefined) {
    bodyParams["ContainerEntrypoint"] = serializeAws_json1_1ContainerEntrypoint(
      input.ContainerEntrypoint,
      context
    );
  }
  if (input.ImageUri !== undefined) {
    bodyParams["ImageUri"] = input.ImageUri;
  }
  if (input.PostAnalyticsProcessorSourceUri !== undefined) {
    bodyParams["PostAnalyticsProcessorSourceUri"] =
      input.PostAnalyticsProcessorSourceUri;
  }
  if (input.RecordPreprocessorSourceUri !== undefined) {
    bodyParams["RecordPreprocessorSourceUri"] =
      input.RecordPreprocessorSourceUri;
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringBaselineConfig = (
  input: MonitoringBaselineConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ConstraintsResource !== undefined) {
    bodyParams[
      "ConstraintsResource"
    ] = serializeAws_json1_1MonitoringConstraintsResource(
      input.ConstraintsResource,
      context
    );
  }
  if (input.StatisticsResource !== undefined) {
    bodyParams[
      "StatisticsResource"
    ] = serializeAws_json1_1MonitoringStatisticsResource(
      input.StatisticsResource,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringClusterConfig = (
  input: MonitoringClusterConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.InstanceCount !== undefined) {
    bodyParams["InstanceCount"] = input.InstanceCount;
  }
  if (input.InstanceType !== undefined) {
    bodyParams["InstanceType"] = input.InstanceType;
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VolumeSizeInGB !== undefined) {
    bodyParams["VolumeSizeInGB"] = input.VolumeSizeInGB;
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringConstraintsResource = (
  input: MonitoringConstraintsResource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringContainerArguments = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1MonitoringEnvironmentMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1MonitoringInput = (
  input: MonitoringInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointInput !== undefined) {
    bodyParams["EndpointInput"] = serializeAws_json1_1EndpointInput(
      input.EndpointInput,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringInputs = (
  input: Array<MonitoringInput>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1MonitoringInput(entry, context)
  );
};

const serializeAws_json1_1MonitoringJobDefinition = (
  input: MonitoringJobDefinition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.BaselineConfig !== undefined) {
    bodyParams["BaselineConfig"] = serializeAws_json1_1MonitoringBaselineConfig(
      input.BaselineConfig,
      context
    );
  }
  if (input.Environment !== undefined) {
    bodyParams["Environment"] = serializeAws_json1_1MonitoringEnvironmentMap(
      input.Environment,
      context
    );
  }
  if (input.MonitoringAppSpecification !== undefined) {
    bodyParams[
      "MonitoringAppSpecification"
    ] = serializeAws_json1_1MonitoringAppSpecification(
      input.MonitoringAppSpecification,
      context
    );
  }
  if (input.MonitoringInputs !== undefined) {
    bodyParams["MonitoringInputs"] = serializeAws_json1_1MonitoringInputs(
      input.MonitoringInputs,
      context
    );
  }
  if (input.MonitoringOutputConfig !== undefined) {
    bodyParams[
      "MonitoringOutputConfig"
    ] = serializeAws_json1_1MonitoringOutputConfig(
      input.MonitoringOutputConfig,
      context
    );
  }
  if (input.MonitoringResources !== undefined) {
    bodyParams["MonitoringResources"] = serializeAws_json1_1MonitoringResources(
      input.MonitoringResources,
      context
    );
  }
  if (input.NetworkConfig !== undefined) {
    bodyParams["NetworkConfig"] = serializeAws_json1_1NetworkConfig(
      input.NetworkConfig,
      context
    );
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.StoppingCondition !== undefined) {
    bodyParams[
      "StoppingCondition"
    ] = serializeAws_json1_1MonitoringStoppingCondition(
      input.StoppingCondition,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringOutput = (
  input: MonitoringOutput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3Output !== undefined) {
    bodyParams["S3Output"] = serializeAws_json1_1MonitoringS3Output(
      input.S3Output,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringOutputConfig = (
  input: MonitoringOutputConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MonitoringOutputs !== undefined) {
    bodyParams["MonitoringOutputs"] = serializeAws_json1_1MonitoringOutputs(
      input.MonitoringOutputs,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringOutputs = (
  input: Array<MonitoringOutput>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1MonitoringOutput(entry, context)
  );
};

const serializeAws_json1_1MonitoringResources = (
  input: MonitoringResources,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClusterConfig !== undefined) {
    bodyParams["ClusterConfig"] = serializeAws_json1_1MonitoringClusterConfig(
      input.ClusterConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringS3Output = (
  input: MonitoringS3Output,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LocalPath !== undefined) {
    bodyParams["LocalPath"] = input.LocalPath;
  }
  if (input.S3UploadMode !== undefined) {
    bodyParams["S3UploadMode"] = input.S3UploadMode;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringScheduleConfig = (
  input: MonitoringScheduleConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MonitoringJobDefinition !== undefined) {
    bodyParams[
      "MonitoringJobDefinition"
    ] = serializeAws_json1_1MonitoringJobDefinition(
      input.MonitoringJobDefinition,
      context
    );
  }
  if (input.ScheduleConfig !== undefined) {
    bodyParams["ScheduleConfig"] = serializeAws_json1_1ScheduleConfig(
      input.ScheduleConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringStatisticsResource = (
  input: MonitoringStatisticsResource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1MonitoringStoppingCondition = (
  input: MonitoringStoppingCondition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxRuntimeInSeconds !== undefined) {
    bodyParams["MaxRuntimeInSeconds"] = input.MaxRuntimeInSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1NestedFilters = (
  input: NestedFilters,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.NestedPropertyName !== undefined) {
    bodyParams["NestedPropertyName"] = input.NestedPropertyName;
  }
  return bodyParams;
};

const serializeAws_json1_1NestedFiltersList = (
  input: Array<NestedFilters>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1NestedFilters(entry, context)
  );
};

const serializeAws_json1_1NetworkConfig = (
  input: NetworkConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EnableNetworkIsolation !== undefined) {
    bodyParams["EnableNetworkIsolation"] = input.EnableNetworkIsolation;
  }
  if (input.VpcConfig !== undefined) {
    bodyParams["VpcConfig"] = serializeAws_json1_1VpcConfig(
      input.VpcConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1NotebookInstanceAcceleratorTypes = (
  input: Array<NotebookInstanceAcceleratorType | string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1NotebookInstanceLifecycleConfigList = (
  input: Array<NotebookInstanceLifecycleHook>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1NotebookInstanceLifecycleHook(entry, context)
  );
};

const serializeAws_json1_1NotebookInstanceLifecycleHook = (
  input: NotebookInstanceLifecycleHook,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Content !== undefined) {
    bodyParams["Content"] = input.Content;
  }
  return bodyParams;
};

const serializeAws_json1_1NotificationConfiguration = (
  input: NotificationConfiguration,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotificationTopicArn !== undefined) {
    bodyParams["NotificationTopicArn"] = input.NotificationTopicArn;
  }
  return bodyParams;
};

const serializeAws_json1_1OutputConfig = (
  input: OutputConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3OutputLocation !== undefined) {
    bodyParams["S3OutputLocation"] = input.S3OutputLocation;
  }
  if (input.TargetDevice !== undefined) {
    bodyParams["TargetDevice"] = input.TargetDevice;
  }
  return bodyParams;
};

const serializeAws_json1_1OutputDataConfig = (
  input: OutputDataConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.S3OutputPath !== undefined) {
    bodyParams["S3OutputPath"] = input.S3OutputPath;
  }
  return bodyParams;
};

const serializeAws_json1_1ParameterRange = (
  input: ParameterRange,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CategoricalParameterRangeSpecification !== undefined) {
    bodyParams[
      "CategoricalParameterRangeSpecification"
    ] = serializeAws_json1_1CategoricalParameterRangeSpecification(
      input.CategoricalParameterRangeSpecification,
      context
    );
  }
  if (input.ContinuousParameterRangeSpecification !== undefined) {
    bodyParams[
      "ContinuousParameterRangeSpecification"
    ] = serializeAws_json1_1ContinuousParameterRangeSpecification(
      input.ContinuousParameterRangeSpecification,
      context
    );
  }
  if (input.IntegerParameterRangeSpecification !== undefined) {
    bodyParams[
      "IntegerParameterRangeSpecification"
    ] = serializeAws_json1_1IntegerParameterRangeSpecification(
      input.IntegerParameterRangeSpecification,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ParameterRanges = (
  input: ParameterRanges,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CategoricalParameterRanges !== undefined) {
    bodyParams[
      "CategoricalParameterRanges"
    ] = serializeAws_json1_1CategoricalParameterRanges(
      input.CategoricalParameterRanges,
      context
    );
  }
  if (input.ContinuousParameterRanges !== undefined) {
    bodyParams[
      "ContinuousParameterRanges"
    ] = serializeAws_json1_1ContinuousParameterRanges(
      input.ContinuousParameterRanges,
      context
    );
  }
  if (input.IntegerParameterRanges !== undefined) {
    bodyParams[
      "IntegerParameterRanges"
    ] = serializeAws_json1_1IntegerParameterRanges(
      input.IntegerParameterRanges,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ParameterValues = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ParentHyperParameterTuningJob = (
  input: ParentHyperParameterTuningJob,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HyperParameterTuningJobName !== undefined) {
    bodyParams["HyperParameterTuningJobName"] =
      input.HyperParameterTuningJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1ParentHyperParameterTuningJobs = (
  input: Array<ParentHyperParameterTuningJob>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ParentHyperParameterTuningJob(entry, context)
  );
};

const serializeAws_json1_1ProcessingClusterConfig = (
  input: ProcessingClusterConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.InstanceCount !== undefined) {
    bodyParams["InstanceCount"] = input.InstanceCount;
  }
  if (input.InstanceType !== undefined) {
    bodyParams["InstanceType"] = input.InstanceType;
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VolumeSizeInGB !== undefined) {
    bodyParams["VolumeSizeInGB"] = input.VolumeSizeInGB;
  }
  return bodyParams;
};

const serializeAws_json1_1ProcessingEnvironmentMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1ProcessingInput = (
  input: ProcessingInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.InputName !== undefined) {
    bodyParams["InputName"] = input.InputName;
  }
  if (input.S3Input !== undefined) {
    bodyParams["S3Input"] = serializeAws_json1_1ProcessingS3Input(
      input.S3Input,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ProcessingInputs = (
  input: Array<ProcessingInput>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ProcessingInput(entry, context)
  );
};

const serializeAws_json1_1ProcessingOutput = (
  input: ProcessingOutput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.OutputName !== undefined) {
    bodyParams["OutputName"] = input.OutputName;
  }
  if (input.S3Output !== undefined) {
    bodyParams["S3Output"] = serializeAws_json1_1ProcessingS3Output(
      input.S3Output,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ProcessingOutputConfig = (
  input: ProcessingOutputConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.Outputs !== undefined) {
    bodyParams["Outputs"] = serializeAws_json1_1ProcessingOutputs(
      input.Outputs,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ProcessingOutputs = (
  input: Array<ProcessingOutput>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ProcessingOutput(entry, context)
  );
};

const serializeAws_json1_1ProcessingResources = (
  input: ProcessingResources,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ClusterConfig !== undefined) {
    bodyParams["ClusterConfig"] = serializeAws_json1_1ProcessingClusterConfig(
      input.ClusterConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ProcessingS3Input = (
  input: ProcessingS3Input,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LocalPath !== undefined) {
    bodyParams["LocalPath"] = input.LocalPath;
  }
  if (input.S3CompressionType !== undefined) {
    bodyParams["S3CompressionType"] = input.S3CompressionType;
  }
  if (input.S3DataDistributionType !== undefined) {
    bodyParams["S3DataDistributionType"] = input.S3DataDistributionType;
  }
  if (input.S3DataType !== undefined) {
    bodyParams["S3DataType"] = input.S3DataType;
  }
  if (input.S3InputMode !== undefined) {
    bodyParams["S3InputMode"] = input.S3InputMode;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1ProcessingS3Output = (
  input: ProcessingS3Output,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LocalPath !== undefined) {
    bodyParams["LocalPath"] = input.LocalPath;
  }
  if (input.S3UploadMode !== undefined) {
    bodyParams["S3UploadMode"] = input.S3UploadMode;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1ProcessingStoppingCondition = (
  input: ProcessingStoppingCondition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxRuntimeInSeconds !== undefined) {
    bodyParams["MaxRuntimeInSeconds"] = input.MaxRuntimeInSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1ProductionVariant = (
  input: ProductionVariant,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AcceleratorType !== undefined) {
    bodyParams["AcceleratorType"] = input.AcceleratorType;
  }
  if (input.InitialInstanceCount !== undefined) {
    bodyParams["InitialInstanceCount"] = input.InitialInstanceCount;
  }
  if (input.InitialVariantWeight !== undefined) {
    bodyParams["InitialVariantWeight"] = input.InitialVariantWeight;
  }
  if (input.InstanceType !== undefined) {
    bodyParams["InstanceType"] = input.InstanceType;
  }
  if (input.ModelName !== undefined) {
    bodyParams["ModelName"] = input.ModelName;
  }
  if (input.VariantName !== undefined) {
    bodyParams["VariantName"] = input.VariantName;
  }
  return bodyParams;
};

const serializeAws_json1_1ProductionVariantList = (
  input: Array<ProductionVariant>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ProductionVariant(entry, context)
  );
};

const serializeAws_json1_1PropertyNameQuery = (
  input: PropertyNameQuery,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.PropertyNameHint !== undefined) {
    bodyParams["PropertyNameHint"] = input.PropertyNameHint;
  }
  return bodyParams;
};

const serializeAws_json1_1PublicWorkforceTaskPrice = (
  input: PublicWorkforceTaskPrice,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AmountInUsd !== undefined) {
    bodyParams["AmountInUsd"] = serializeAws_json1_1USD(
      input.AmountInUsd,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1RealtimeInferenceInstanceTypes = (
  input: Array<ProductionVariantInstanceType | string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1RenderUiTemplateRequest = (
  input: RenderUiTemplateRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.Task !== undefined) {
    bodyParams["Task"] = serializeAws_json1_1RenderableTask(
      input.Task,
      context
    );
  }
  if (input.UiTemplate !== undefined) {
    bodyParams["UiTemplate"] = serializeAws_json1_1UiTemplate(
      input.UiTemplate,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1RenderableTask = (
  input: RenderableTask,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Input !== undefined) {
    bodyParams["Input"] = input.Input;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceConfig = (
  input: ResourceConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.InstanceCount !== undefined) {
    bodyParams["InstanceCount"] = input.InstanceCount;
  }
  if (input.InstanceType !== undefined) {
    bodyParams["InstanceType"] = input.InstanceType;
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  if (input.VolumeSizeInGB !== undefined) {
    bodyParams["VolumeSizeInGB"] = input.VolumeSizeInGB;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceLimits = (
  input: ResourceLimits,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxNumberOfTrainingJobs !== undefined) {
    bodyParams["MaxNumberOfTrainingJobs"] = input.MaxNumberOfTrainingJobs;
  }
  if (input.MaxParallelTrainingJobs !== undefined) {
    bodyParams["MaxParallelTrainingJobs"] = input.MaxParallelTrainingJobs;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceSpec = (
  input: ResourceSpec,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EnvironmentArn !== undefined) {
    bodyParams["EnvironmentArn"] = input.EnvironmentArn;
  }
  if (input.InstanceType !== undefined) {
    bodyParams["InstanceType"] = input.InstanceType;
  }
  return bodyParams;
};

const serializeAws_json1_1ResponseMIMETypes = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1RetentionPolicy = (
  input: RetentionPolicy,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HomeEfsFileSystem !== undefined) {
    bodyParams["HomeEfsFileSystem"] = input.HomeEfsFileSystem;
  }
  return bodyParams;
};

const serializeAws_json1_1RuleParameters = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1S3DataSource = (
  input: S3DataSource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AttributeNames !== undefined) {
    bodyParams["AttributeNames"] = serializeAws_json1_1AttributeNames(
      input.AttributeNames,
      context
    );
  }
  if (input.S3DataDistributionType !== undefined) {
    bodyParams["S3DataDistributionType"] = input.S3DataDistributionType;
  }
  if (input.S3DataType !== undefined) {
    bodyParams["S3DataType"] = input.S3DataType;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1ScheduleConfig = (
  input: ScheduleConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ScheduleExpression !== undefined) {
    bodyParams["ScheduleExpression"] = input.ScheduleExpression;
  }
  return bodyParams;
};

const serializeAws_json1_1SearchExpression = (
  input: SearchExpression,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.NestedFilters !== undefined) {
    bodyParams["NestedFilters"] = serializeAws_json1_1NestedFiltersList(
      input.NestedFilters,
      context
    );
  }
  if (input.Operator !== undefined) {
    bodyParams["Operator"] = input.Operator;
  }
  if (input.SubExpressions !== undefined) {
    bodyParams["SubExpressions"] = serializeAws_json1_1SearchExpressionList(
      input.SubExpressions,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SearchExpressionList = (
  input: Array<SearchExpression>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1SearchExpression(entry, context)
  );
};

const serializeAws_json1_1SearchRequest = (
  input: SearchRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxResults !== undefined) {
    bodyParams["MaxResults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Resource !== undefined) {
    bodyParams["Resource"] = input.Resource;
  }
  if (input.SearchExpression !== undefined) {
    bodyParams["SearchExpression"] = serializeAws_json1_1SearchExpression(
      input.SearchExpression,
      context
    );
  }
  if (input.SortBy !== undefined) {
    bodyParams["SortBy"] = input.SortBy;
  }
  if (input.SortOrder !== undefined) {
    bodyParams["SortOrder"] = input.SortOrder;
  }
  return bodyParams;
};

const serializeAws_json1_1SecurityGroupIds = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1SharingSettings = (
  input: SharingSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotebookOutputOption !== undefined) {
    bodyParams["NotebookOutputOption"] = input.NotebookOutputOption;
  }
  if (input.S3KmsKeyId !== undefined) {
    bodyParams["S3KmsKeyId"] = input.S3KmsKeyId;
  }
  if (input.S3OutputPath !== undefined) {
    bodyParams["S3OutputPath"] = input.S3OutputPath;
  }
  return bodyParams;
};

const serializeAws_json1_1ShuffleConfig = (
  input: ShuffleConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Seed !== undefined) {
    bodyParams["Seed"] = input.Seed;
  }
  return bodyParams;
};

const serializeAws_json1_1SourceAlgorithm = (
  input: SourceAlgorithm,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AlgorithmName !== undefined) {
    bodyParams["AlgorithmName"] = input.AlgorithmName;
  }
  if (input.ModelDataUrl !== undefined) {
    bodyParams["ModelDataUrl"] = input.ModelDataUrl;
  }
  return bodyParams;
};

const serializeAws_json1_1SourceAlgorithmList = (
  input: Array<SourceAlgorithm>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1SourceAlgorithm(entry, context)
  );
};

const serializeAws_json1_1SourceAlgorithmSpecification = (
  input: SourceAlgorithmSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.SourceAlgorithms !== undefined) {
    bodyParams["SourceAlgorithms"] = serializeAws_json1_1SourceAlgorithmList(
      input.SourceAlgorithms,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SourceIpConfig = (
  input: SourceIpConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Cidrs !== undefined) {
    bodyParams["Cidrs"] = serializeAws_json1_1Cidrs(input.Cidrs, context);
  }
  return bodyParams;
};

const serializeAws_json1_1StartMonitoringScheduleRequest = (
  input: StartMonitoringScheduleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MonitoringScheduleName !== undefined) {
    bodyParams["MonitoringScheduleName"] = input.MonitoringScheduleName;
  }
  return bodyParams;
};

const serializeAws_json1_1StartNotebookInstanceInput = (
  input: StartNotebookInstanceInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotebookInstanceName !== undefined) {
    bodyParams["NotebookInstanceName"] = input.NotebookInstanceName;
  }
  return bodyParams;
};

const serializeAws_json1_1StopAutoMLJobRequest = (
  input: StopAutoMLJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AutoMLJobName !== undefined) {
    bodyParams["AutoMLJobName"] = input.AutoMLJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1StopCompilationJobRequest = (
  input: StopCompilationJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CompilationJobName !== undefined) {
    bodyParams["CompilationJobName"] = input.CompilationJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1StopHyperParameterTuningJobRequest = (
  input: StopHyperParameterTuningJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HyperParameterTuningJobName !== undefined) {
    bodyParams["HyperParameterTuningJobName"] =
      input.HyperParameterTuningJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1StopLabelingJobRequest = (
  input: StopLabelingJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LabelingJobName !== undefined) {
    bodyParams["LabelingJobName"] = input.LabelingJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1StopMonitoringScheduleRequest = (
  input: StopMonitoringScheduleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MonitoringScheduleName !== undefined) {
    bodyParams["MonitoringScheduleName"] = input.MonitoringScheduleName;
  }
  return bodyParams;
};

const serializeAws_json1_1StopNotebookInstanceInput = (
  input: StopNotebookInstanceInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotebookInstanceName !== undefined) {
    bodyParams["NotebookInstanceName"] = input.NotebookInstanceName;
  }
  return bodyParams;
};

const serializeAws_json1_1StopProcessingJobRequest = (
  input: StopProcessingJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ProcessingJobName !== undefined) {
    bodyParams["ProcessingJobName"] = input.ProcessingJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1StopTrainingJobRequest = (
  input: StopTrainingJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TrainingJobName !== undefined) {
    bodyParams["TrainingJobName"] = input.TrainingJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1StopTransformJobRequest = (
  input: StopTransformJobRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TransformJobName !== undefined) {
    bodyParams["TransformJobName"] = input.TransformJobName;
  }
  return bodyParams;
};

const serializeAws_json1_1StoppingCondition = (
  input: StoppingCondition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxRuntimeInSeconds !== undefined) {
    bodyParams["MaxRuntimeInSeconds"] = input.MaxRuntimeInSeconds;
  }
  if (input.MaxWaitTimeInSeconds !== undefined) {
    bodyParams["MaxWaitTimeInSeconds"] = input.MaxWaitTimeInSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1Subnets = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1SuggestionQuery = (
  input: SuggestionQuery,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.PropertyNameQuery !== undefined) {
    bodyParams["PropertyNameQuery"] = serializeAws_json1_1PropertyNameQuery(
      input.PropertyNameQuery,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  let bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagKeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => serializeAws_json1_1Tag(entry, context));
};

const serializeAws_json1_1TaskKeywords = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1TensorBoardAppSettings = (
  input: TensorBoardAppSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DefaultResourceSpec !== undefined) {
    bodyParams["DefaultResourceSpec"] = serializeAws_json1_1ResourceSpec(
      input.DefaultResourceSpec,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1TensorBoardOutputConfig = (
  input: TensorBoardOutputConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LocalPath !== undefined) {
    bodyParams["LocalPath"] = input.LocalPath;
  }
  if (input.S3OutputPath !== undefined) {
    bodyParams["S3OutputPath"] = input.S3OutputPath;
  }
  return bodyParams;
};

const serializeAws_json1_1TrainingInstanceTypes = (
  input: Array<TrainingInstanceType | string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1TrainingJobDefinition = (
  input: TrainingJobDefinition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.HyperParameters !== undefined) {
    bodyParams["HyperParameters"] = serializeAws_json1_1HyperParameters(
      input.HyperParameters,
      context
    );
  }
  if (input.InputDataConfig !== undefined) {
    bodyParams["InputDataConfig"] = serializeAws_json1_1InputDataConfig(
      input.InputDataConfig,
      context
    );
  }
  if (input.OutputDataConfig !== undefined) {
    bodyParams["OutputDataConfig"] = serializeAws_json1_1OutputDataConfig(
      input.OutputDataConfig,
      context
    );
  }
  if (input.ResourceConfig !== undefined) {
    bodyParams["ResourceConfig"] = serializeAws_json1_1ResourceConfig(
      input.ResourceConfig,
      context
    );
  }
  if (input.StoppingCondition !== undefined) {
    bodyParams["StoppingCondition"] = serializeAws_json1_1StoppingCondition(
      input.StoppingCondition,
      context
    );
  }
  if (input.TrainingInputMode !== undefined) {
    bodyParams["TrainingInputMode"] = input.TrainingInputMode;
  }
  return bodyParams;
};

const serializeAws_json1_1TrainingSpecification = (
  input: TrainingSpecification,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MetricDefinitions !== undefined) {
    bodyParams["MetricDefinitions"] = serializeAws_json1_1MetricDefinitionList(
      input.MetricDefinitions,
      context
    );
  }
  if (input.SupportedHyperParameters !== undefined) {
    bodyParams[
      "SupportedHyperParameters"
    ] = serializeAws_json1_1HyperParameterSpecifications(
      input.SupportedHyperParameters,
      context
    );
  }
  if (input.SupportedTrainingInstanceTypes !== undefined) {
    bodyParams[
      "SupportedTrainingInstanceTypes"
    ] = serializeAws_json1_1TrainingInstanceTypes(
      input.SupportedTrainingInstanceTypes,
      context
    );
  }
  if (input.SupportedTuningJobObjectiveMetrics !== undefined) {
    bodyParams[
      "SupportedTuningJobObjectiveMetrics"
    ] = serializeAws_json1_1HyperParameterTuningJobObjectives(
      input.SupportedTuningJobObjectiveMetrics,
      context
    );
  }
  if (input.SupportsDistributedTraining !== undefined) {
    bodyParams["SupportsDistributedTraining"] =
      input.SupportsDistributedTraining;
  }
  if (input.TrainingChannels !== undefined) {
    bodyParams["TrainingChannels"] = serializeAws_json1_1ChannelSpecifications(
      input.TrainingChannels,
      context
    );
  }
  if (input.TrainingImage !== undefined) {
    bodyParams["TrainingImage"] = input.TrainingImage;
  }
  if (input.TrainingImageDigest !== undefined) {
    bodyParams["TrainingImageDigest"] = input.TrainingImageDigest;
  }
  return bodyParams;
};

const serializeAws_json1_1TransformDataSource = (
  input: TransformDataSource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3DataSource !== undefined) {
    bodyParams["S3DataSource"] = serializeAws_json1_1TransformS3DataSource(
      input.S3DataSource,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1TransformEnvironmentMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1TransformInput = (
  input: TransformInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CompressionType !== undefined) {
    bodyParams["CompressionType"] = input.CompressionType;
  }
  if (input.ContentType !== undefined) {
    bodyParams["ContentType"] = input.ContentType;
  }
  if (input.DataSource !== undefined) {
    bodyParams["DataSource"] = serializeAws_json1_1TransformDataSource(
      input.DataSource,
      context
    );
  }
  if (input.SplitType !== undefined) {
    bodyParams["SplitType"] = input.SplitType;
  }
  return bodyParams;
};

const serializeAws_json1_1TransformInstanceTypes = (
  input: Array<TransformInstanceType | string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1TransformJobDefinition = (
  input: TransformJobDefinition,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.BatchStrategy !== undefined) {
    bodyParams["BatchStrategy"] = input.BatchStrategy;
  }
  if (input.Environment !== undefined) {
    bodyParams["Environment"] = serializeAws_json1_1TransformEnvironmentMap(
      input.Environment,
      context
    );
  }
  if (input.MaxConcurrentTransforms !== undefined) {
    bodyParams["MaxConcurrentTransforms"] = input.MaxConcurrentTransforms;
  }
  if (input.MaxPayloadInMB !== undefined) {
    bodyParams["MaxPayloadInMB"] = input.MaxPayloadInMB;
  }
  if (input.TransformInput !== undefined) {
    bodyParams["TransformInput"] = serializeAws_json1_1TransformInput(
      input.TransformInput,
      context
    );
  }
  if (input.TransformOutput !== undefined) {
    bodyParams["TransformOutput"] = serializeAws_json1_1TransformOutput(
      input.TransformOutput,
      context
    );
  }
  if (input.TransformResources !== undefined) {
    bodyParams["TransformResources"] = serializeAws_json1_1TransformResources(
      input.TransformResources,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1TransformOutput = (
  input: TransformOutput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Accept !== undefined) {
    bodyParams["Accept"] = input.Accept;
  }
  if (input.AssembleWith !== undefined) {
    bodyParams["AssembleWith"] = input.AssembleWith;
  }
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.S3OutputPath !== undefined) {
    bodyParams["S3OutputPath"] = input.S3OutputPath;
  }
  return bodyParams;
};

const serializeAws_json1_1TransformResources = (
  input: TransformResources,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.InstanceCount !== undefined) {
    bodyParams["InstanceCount"] = input.InstanceCount;
  }
  if (input.InstanceType !== undefined) {
    bodyParams["InstanceType"] = input.InstanceType;
  }
  if (input.VolumeKmsKeyId !== undefined) {
    bodyParams["VolumeKmsKeyId"] = input.VolumeKmsKeyId;
  }
  return bodyParams;
};

const serializeAws_json1_1TransformS3DataSource = (
  input: TransformS3DataSource,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.S3DataType !== undefined) {
    bodyParams["S3DataType"] = input.S3DataType;
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1TrialComponentArtifact = (
  input: TrialComponentArtifact,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MediaType !== undefined) {
    bodyParams["MediaType"] = input.MediaType;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TrialComponentArtifacts = (
  input: { [key: string]: TrialComponentArtifact },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_json1_1TrialComponentArtifact(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_json1_1TrialComponentParameterValue = (
  input: TrialComponentParameterValue,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NumberValue !== undefined) {
    bodyParams["NumberValue"] = input.NumberValue;
  }
  if (input.StringValue !== undefined) {
    bodyParams["StringValue"] = input.StringValue;
  }
  return bodyParams;
};

const serializeAws_json1_1TrialComponentParameters = (
  input: { [key: string]: TrialComponentParameterValue },
  context: __SerdeContext
): any => {
  let mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_json1_1TrialComponentParameterValue(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_json1_1TrialComponentStatus = (
  input: TrialComponentStatus,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Message !== undefined) {
    bodyParams["Message"] = input.Message;
  }
  if (input.PrimaryStatus !== undefined) {
    bodyParams["PrimaryStatus"] = input.PrimaryStatus;
  }
  return bodyParams;
};

const serializeAws_json1_1TuningJobCompletionCriteria = (
  input: TuningJobCompletionCriteria,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.TargetObjectiveMetricValue !== undefined) {
    bodyParams["TargetObjectiveMetricValue"] = input.TargetObjectiveMetricValue;
  }
  return bodyParams;
};

const serializeAws_json1_1USD = (input: USD, context: __SerdeContext): any => {
  let bodyParams: any = {};
  if (input.Cents !== undefined) {
    bodyParams["Cents"] = input.Cents;
  }
  if (input.Dollars !== undefined) {
    bodyParams["Dollars"] = input.Dollars;
  }
  if (input.TenthFractionsOfACent !== undefined) {
    bodyParams["TenthFractionsOfACent"] = input.TenthFractionsOfACent;
  }
  return bodyParams;
};

const serializeAws_json1_1UiConfig = (
  input: UiConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.UiTemplateS3Uri !== undefined) {
    bodyParams["UiTemplateS3Uri"] = input.UiTemplateS3Uri;
  }
  return bodyParams;
};

const serializeAws_json1_1UiTemplate = (
  input: UiTemplate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Content !== undefined) {
    bodyParams["Content"] = input.Content;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateCodeRepositoryInput = (
  input: UpdateCodeRepositoryInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CodeRepositoryName !== undefined) {
    bodyParams["CodeRepositoryName"] = input.CodeRepositoryName;
  }
  if (input.GitConfig !== undefined) {
    bodyParams["GitConfig"] = serializeAws_json1_1GitConfigForUpdate(
      input.GitConfig,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateDomainRequest = (
  input: UpdateDomainRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DefaultUserSettings !== undefined) {
    bodyParams["DefaultUserSettings"] = serializeAws_json1_1UserSettings(
      input.DefaultUserSettings,
      context
    );
  }
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateEndpointInput = (
  input: UpdateEndpointInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointConfigName !== undefined) {
    bodyParams["EndpointConfigName"] = input.EndpointConfigName;
  }
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateEndpointWeightsAndCapacitiesInput = (
  input: UpdateEndpointWeightsAndCapacitiesInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DesiredWeightsAndCapacities !== undefined) {
    bodyParams[
      "DesiredWeightsAndCapacities"
    ] = serializeAws_json1_1DesiredWeightAndCapacityList(
      input.DesiredWeightsAndCapacities,
      context
    );
  }
  if (input.EndpointName !== undefined) {
    bodyParams["EndpointName"] = input.EndpointName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateExperimentRequest = (
  input: UpdateExperimentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.DisplayName !== undefined) {
    bodyParams["DisplayName"] = input.DisplayName;
  }
  if (input.ExperimentName !== undefined) {
    bodyParams["ExperimentName"] = input.ExperimentName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateMonitoringScheduleRequest = (
  input: UpdateMonitoringScheduleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MonitoringScheduleConfig !== undefined) {
    bodyParams[
      "MonitoringScheduleConfig"
    ] = serializeAws_json1_1MonitoringScheduleConfig(
      input.MonitoringScheduleConfig,
      context
    );
  }
  if (input.MonitoringScheduleName !== undefined) {
    bodyParams["MonitoringScheduleName"] = input.MonitoringScheduleName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateNotebookInstanceInput = (
  input: UpdateNotebookInstanceInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AcceleratorTypes !== undefined) {
    bodyParams[
      "AcceleratorTypes"
    ] = serializeAws_json1_1NotebookInstanceAcceleratorTypes(
      input.AcceleratorTypes,
      context
    );
  }
  if (input.AdditionalCodeRepositories !== undefined) {
    bodyParams[
      "AdditionalCodeRepositories"
    ] = serializeAws_json1_1AdditionalCodeRepositoryNamesOrUrls(
      input.AdditionalCodeRepositories,
      context
    );
  }
  if (input.DefaultCodeRepository !== undefined) {
    bodyParams["DefaultCodeRepository"] = input.DefaultCodeRepository;
  }
  if (input.DisassociateAcceleratorTypes !== undefined) {
    bodyParams["DisassociateAcceleratorTypes"] =
      input.DisassociateAcceleratorTypes;
  }
  if (input.DisassociateAdditionalCodeRepositories !== undefined) {
    bodyParams["DisassociateAdditionalCodeRepositories"] =
      input.DisassociateAdditionalCodeRepositories;
  }
  if (input.DisassociateDefaultCodeRepository !== undefined) {
    bodyParams["DisassociateDefaultCodeRepository"] =
      input.DisassociateDefaultCodeRepository;
  }
  if (input.DisassociateLifecycleConfig !== undefined) {
    bodyParams["DisassociateLifecycleConfig"] =
      input.DisassociateLifecycleConfig;
  }
  if (input.InstanceType !== undefined) {
    bodyParams["InstanceType"] = input.InstanceType;
  }
  if (input.LifecycleConfigName !== undefined) {
    bodyParams["LifecycleConfigName"] = input.LifecycleConfigName;
  }
  if (input.NotebookInstanceName !== undefined) {
    bodyParams["NotebookInstanceName"] = input.NotebookInstanceName;
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  if (input.RootAccess !== undefined) {
    bodyParams["RootAccess"] = input.RootAccess;
  }
  if (input.VolumeSizeInGB !== undefined) {
    bodyParams["VolumeSizeInGB"] = input.VolumeSizeInGB;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateNotebookInstanceLifecycleConfigInput = (
  input: UpdateNotebookInstanceLifecycleConfigInput,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NotebookInstanceLifecycleConfigName !== undefined) {
    bodyParams["NotebookInstanceLifecycleConfigName"] =
      input.NotebookInstanceLifecycleConfigName;
  }
  if (input.OnCreate !== undefined) {
    bodyParams[
      "OnCreate"
    ] = serializeAws_json1_1NotebookInstanceLifecycleConfigList(
      input.OnCreate,
      context
    );
  }
  if (input.OnStart !== undefined) {
    bodyParams[
      "OnStart"
    ] = serializeAws_json1_1NotebookInstanceLifecycleConfigList(
      input.OnStart,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateTrialComponentRequest = (
  input: UpdateTrialComponentRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DisplayName !== undefined) {
    bodyParams["DisplayName"] = input.DisplayName;
  }
  if (input.EndTime !== undefined) {
    bodyParams["EndTime"] = Math.round(input.EndTime.getTime() / 1000);
  }
  if (input.InputArtifacts !== undefined) {
    bodyParams["InputArtifacts"] = serializeAws_json1_1TrialComponentArtifacts(
      input.InputArtifacts,
      context
    );
  }
  if (input.InputArtifactsToRemove !== undefined) {
    bodyParams[
      "InputArtifactsToRemove"
    ] = serializeAws_json1_1ListTrialComponentKey256(
      input.InputArtifactsToRemove,
      context
    );
  }
  if (input.OutputArtifacts !== undefined) {
    bodyParams["OutputArtifacts"] = serializeAws_json1_1TrialComponentArtifacts(
      input.OutputArtifacts,
      context
    );
  }
  if (input.OutputArtifactsToRemove !== undefined) {
    bodyParams[
      "OutputArtifactsToRemove"
    ] = serializeAws_json1_1ListTrialComponentKey256(
      input.OutputArtifactsToRemove,
      context
    );
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_json1_1TrialComponentParameters(
      input.Parameters,
      context
    );
  }
  if (input.ParametersToRemove !== undefined) {
    bodyParams[
      "ParametersToRemove"
    ] = serializeAws_json1_1ListTrialComponentKey256(
      input.ParametersToRemove,
      context
    );
  }
  if (input.StartTime !== undefined) {
    bodyParams["StartTime"] = Math.round(input.StartTime.getTime() / 1000);
  }
  if (input.Status !== undefined) {
    bodyParams["Status"] = serializeAws_json1_1TrialComponentStatus(
      input.Status,
      context
    );
  }
  if (input.TrialComponentName !== undefined) {
    bodyParams["TrialComponentName"] = input.TrialComponentName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateTrialRequest = (
  input: UpdateTrialRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DisplayName !== undefined) {
    bodyParams["DisplayName"] = input.DisplayName;
  }
  if (input.TrialName !== undefined) {
    bodyParams["TrialName"] = input.TrialName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateUserProfileRequest = (
  input: UpdateUserProfileRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DomainId !== undefined) {
    bodyParams["DomainId"] = input.DomainId;
  }
  if (input.UserProfileName !== undefined) {
    bodyParams["UserProfileName"] = input.UserProfileName;
  }
  if (input.UserSettings !== undefined) {
    bodyParams["UserSettings"] = serializeAws_json1_1UserSettings(
      input.UserSettings,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateWorkforceRequest = (
  input: UpdateWorkforceRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.SourceIpConfig !== undefined) {
    bodyParams["SourceIpConfig"] = serializeAws_json1_1SourceIpConfig(
      input.SourceIpConfig,
      context
    );
  }
  if (input.WorkforceName !== undefined) {
    bodyParams["WorkforceName"] = input.WorkforceName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateWorkteamRequest = (
  input: UpdateWorkteamRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.MemberDefinitions !== undefined) {
    bodyParams["MemberDefinitions"] = serializeAws_json1_1MemberDefinitions(
      input.MemberDefinitions,
      context
    );
  }
  if (input.NotificationConfiguration !== undefined) {
    bodyParams[
      "NotificationConfiguration"
    ] = serializeAws_json1_1NotificationConfiguration(
      input.NotificationConfiguration,
      context
    );
  }
  if (input.WorkteamName !== undefined) {
    bodyParams["WorkteamName"] = input.WorkteamName;
  }
  return bodyParams;
};

const serializeAws_json1_1UserSettings = (
  input: UserSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ExecutionRole !== undefined) {
    bodyParams["ExecutionRole"] = input.ExecutionRole;
  }
  if (input.JupyterServerAppSettings !== undefined) {
    bodyParams[
      "JupyterServerAppSettings"
    ] = serializeAws_json1_1JupyterServerAppSettings(
      input.JupyterServerAppSettings,
      context
    );
  }
  if (input.KernelGatewayAppSettings !== undefined) {
    bodyParams[
      "KernelGatewayAppSettings"
    ] = serializeAws_json1_1KernelGatewayAppSettings(
      input.KernelGatewayAppSettings,
      context
    );
  }
  if (input.SecurityGroups !== undefined) {
    bodyParams["SecurityGroups"] = serializeAws_json1_1SecurityGroupIds(
      input.SecurityGroups,
      context
    );
  }
  if (input.SharingSettings !== undefined) {
    bodyParams["SharingSettings"] = serializeAws_json1_1SharingSettings(
      input.SharingSettings,
      context
    );
  }
  if (input.TensorBoardAppSettings !== undefined) {
    bodyParams[
      "TensorBoardAppSettings"
    ] = serializeAws_json1_1TensorBoardAppSettings(
      input.TensorBoardAppSettings,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1VpcConfig = (
  input: VpcConfig,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.SecurityGroupIds !== undefined) {
    bodyParams["SecurityGroupIds"] = serializeAws_json1_1VpcSecurityGroupIds(
      input.SecurityGroupIds,
      context
    );
  }
  if (input.Subnets !== undefined) {
    bodyParams["Subnets"] = serializeAws_json1_1Subnets(input.Subnets, context);
  }
  return bodyParams;
};

const serializeAws_json1_1VpcSecurityGroupIds = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const deserializeAws_json1_1AddTagsOutput = (
  output: any,
  context: __SerdeContext
): AddTagsOutput => {
  let contents: any = {
    __type: "AddTagsOutput",
    Tags: undefined
  };
  if (output.Tags !== undefined) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1AdditionalCodeRepositoryNamesOrUrls = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1AlgorithmSpecification = (
  output: any,
  context: __SerdeContext
): AlgorithmSpecification => {
  let contents: any = {
    __type: "AlgorithmSpecification",
    AlgorithmName: undefined,
    EnableSageMakerMetricsTimeSeries: undefined,
    MetricDefinitions: undefined,
    TrainingImage: undefined,
    TrainingInputMode: undefined
  };
  if (output.AlgorithmName !== undefined) {
    contents.AlgorithmName = output.AlgorithmName;
  }
  if (output.EnableSageMakerMetricsTimeSeries !== undefined) {
    contents.EnableSageMakerMetricsTimeSeries =
      output.EnableSageMakerMetricsTimeSeries;
  }
  if (output.MetricDefinitions !== undefined) {
    contents.MetricDefinitions = deserializeAws_json1_1MetricDefinitionList(
      output.MetricDefinitions,
      context
    );
  }
  if (output.TrainingImage !== undefined) {
    contents.TrainingImage = output.TrainingImage;
  }
  if (output.TrainingInputMode !== undefined) {
    contents.TrainingInputMode = output.TrainingInputMode;
  }
  return contents;
};

const deserializeAws_json1_1AlgorithmStatusDetails = (
  output: any,
  context: __SerdeContext
): AlgorithmStatusDetails => {
  let contents: any = {
    __type: "AlgorithmStatusDetails",
    ImageScanStatuses: undefined,
    ValidationStatuses: undefined
  };
  if (output.ImageScanStatuses !== undefined) {
    contents.ImageScanStatuses = deserializeAws_json1_1AlgorithmStatusItemList(
      output.ImageScanStatuses,
      context
    );
  }
  if (output.ValidationStatuses !== undefined) {
    contents.ValidationStatuses = deserializeAws_json1_1AlgorithmStatusItemList(
      output.ValidationStatuses,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1AlgorithmStatusItem = (
  output: any,
  context: __SerdeContext
): AlgorithmStatusItem => {
  let contents: any = {
    __type: "AlgorithmStatusItem",
    FailureReason: undefined,
    Name: undefined,
    Status: undefined
  };
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1AlgorithmStatusItemList = (
  output: any,
  context: __SerdeContext
): Array<AlgorithmStatusItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AlgorithmStatusItem(entry, context)
  );
};

const deserializeAws_json1_1AlgorithmSummary = (
  output: any,
  context: __SerdeContext
): AlgorithmSummary => {
  let contents: any = {
    __type: "AlgorithmSummary",
    AlgorithmArn: undefined,
    AlgorithmDescription: undefined,
    AlgorithmName: undefined,
    AlgorithmStatus: undefined,
    CreationTime: undefined
  };
  if (output.AlgorithmArn !== undefined) {
    contents.AlgorithmArn = output.AlgorithmArn;
  }
  if (output.AlgorithmDescription !== undefined) {
    contents.AlgorithmDescription = output.AlgorithmDescription;
  }
  if (output.AlgorithmName !== undefined) {
    contents.AlgorithmName = output.AlgorithmName;
  }
  if (output.AlgorithmStatus !== undefined) {
    contents.AlgorithmStatus = output.AlgorithmStatus;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  return contents;
};

const deserializeAws_json1_1AlgorithmSummaryList = (
  output: any,
  context: __SerdeContext
): Array<AlgorithmSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AlgorithmSummary(entry, context)
  );
};

const deserializeAws_json1_1AlgorithmValidationProfile = (
  output: any,
  context: __SerdeContext
): AlgorithmValidationProfile => {
  let contents: any = {
    __type: "AlgorithmValidationProfile",
    ProfileName: undefined,
    TrainingJobDefinition: undefined,
    TransformJobDefinition: undefined
  };
  if (output.ProfileName !== undefined) {
    contents.ProfileName = output.ProfileName;
  }
  if (output.TrainingJobDefinition !== undefined) {
    contents.TrainingJobDefinition = deserializeAws_json1_1TrainingJobDefinition(
      output.TrainingJobDefinition,
      context
    );
  }
  if (output.TransformJobDefinition !== undefined) {
    contents.TransformJobDefinition = deserializeAws_json1_1TransformJobDefinition(
      output.TransformJobDefinition,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1AlgorithmValidationProfiles = (
  output: any,
  context: __SerdeContext
): Array<AlgorithmValidationProfile> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AlgorithmValidationProfile(entry, context)
  );
};

const deserializeAws_json1_1AlgorithmValidationSpecification = (
  output: any,
  context: __SerdeContext
): AlgorithmValidationSpecification => {
  let contents: any = {
    __type: "AlgorithmValidationSpecification",
    ValidationProfiles: undefined,
    ValidationRole: undefined
  };
  if (output.ValidationProfiles !== undefined) {
    contents.ValidationProfiles = deserializeAws_json1_1AlgorithmValidationProfiles(
      output.ValidationProfiles,
      context
    );
  }
  if (output.ValidationRole !== undefined) {
    contents.ValidationRole = output.ValidationRole;
  }
  return contents;
};

const deserializeAws_json1_1AnnotationConsolidationConfig = (
  output: any,
  context: __SerdeContext
): AnnotationConsolidationConfig => {
  let contents: any = {
    __type: "AnnotationConsolidationConfig",
    AnnotationConsolidationLambdaArn: undefined
  };
  if (output.AnnotationConsolidationLambdaArn !== undefined) {
    contents.AnnotationConsolidationLambdaArn =
      output.AnnotationConsolidationLambdaArn;
  }
  return contents;
};

const deserializeAws_json1_1AppDetails = (
  output: any,
  context: __SerdeContext
): AppDetails => {
  let contents: any = {
    __type: "AppDetails",
    AppName: undefined,
    AppType: undefined,
    CreationTime: undefined,
    DomainId: undefined,
    Status: undefined,
    UserProfileName: undefined
  };
  if (output.AppName !== undefined) {
    contents.AppName = output.AppName;
  }
  if (output.AppType !== undefined) {
    contents.AppType = output.AppType;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DomainId !== undefined) {
    contents.DomainId = output.DomainId;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.UserProfileName !== undefined) {
    contents.UserProfileName = output.UserProfileName;
  }
  return contents;
};

const deserializeAws_json1_1AppList = (
  output: any,
  context: __SerdeContext
): Array<AppDetails> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AppDetails(entry, context)
  );
};

const deserializeAws_json1_1AppSpecification = (
  output: any,
  context: __SerdeContext
): AppSpecification => {
  let contents: any = {
    __type: "AppSpecification",
    ContainerArguments: undefined,
    ContainerEntrypoint: undefined,
    ImageUri: undefined
  };
  if (output.ContainerArguments !== undefined) {
    contents.ContainerArguments = deserializeAws_json1_1ContainerArguments(
      output.ContainerArguments,
      context
    );
  }
  if (output.ContainerEntrypoint !== undefined) {
    contents.ContainerEntrypoint = deserializeAws_json1_1ContainerEntrypoint(
      output.ContainerEntrypoint,
      context
    );
  }
  if (output.ImageUri !== undefined) {
    contents.ImageUri = output.ImageUri;
  }
  return contents;
};

const deserializeAws_json1_1AssociateTrialComponentResponse = (
  output: any,
  context: __SerdeContext
): AssociateTrialComponentResponse => {
  let contents: any = {
    __type: "AssociateTrialComponentResponse",
    TrialArn: undefined,
    TrialComponentArn: undefined
  };
  if (output.TrialArn !== undefined) {
    contents.TrialArn = output.TrialArn;
  }
  if (output.TrialComponentArn !== undefined) {
    contents.TrialComponentArn = output.TrialComponentArn;
  }
  return contents;
};

const deserializeAws_json1_1AttributeNames = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1AutoMLCandidate = (
  output: any,
  context: __SerdeContext
): AutoMLCandidate => {
  let contents: any = {
    __type: "AutoMLCandidate",
    CandidateName: undefined,
    CandidateStatus: undefined,
    CandidateSteps: undefined,
    CreationTime: undefined,
    EndTime: undefined,
    FailureReason: undefined,
    FinalAutoMLJobObjectiveMetric: undefined,
    InferenceContainers: undefined,
    LastModifiedTime: undefined,
    ObjectiveStatus: undefined
  };
  if (output.CandidateName !== undefined) {
    contents.CandidateName = output.CandidateName;
  }
  if (output.CandidateStatus !== undefined) {
    contents.CandidateStatus = output.CandidateStatus;
  }
  if (output.CandidateSteps !== undefined) {
    contents.CandidateSteps = deserializeAws_json1_1CandidateSteps(
      output.CandidateSteps,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.FinalAutoMLJobObjectiveMetric !== undefined) {
    contents.FinalAutoMLJobObjectiveMetric = deserializeAws_json1_1FinalAutoMLJobObjectiveMetric(
      output.FinalAutoMLJobObjectiveMetric,
      context
    );
  }
  if (output.InferenceContainers !== undefined) {
    contents.InferenceContainers = deserializeAws_json1_1AutoMLContainerDefinitions(
      output.InferenceContainers,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.ObjectiveStatus !== undefined) {
    contents.ObjectiveStatus = output.ObjectiveStatus;
  }
  return contents;
};

const deserializeAws_json1_1AutoMLCandidateStep = (
  output: any,
  context: __SerdeContext
): AutoMLCandidateStep => {
  let contents: any = {
    __type: "AutoMLCandidateStep",
    CandidateStepArn: undefined,
    CandidateStepName: undefined,
    CandidateStepType: undefined
  };
  if (output.CandidateStepArn !== undefined) {
    contents.CandidateStepArn = output.CandidateStepArn;
  }
  if (output.CandidateStepName !== undefined) {
    contents.CandidateStepName = output.CandidateStepName;
  }
  if (output.CandidateStepType !== undefined) {
    contents.CandidateStepType = output.CandidateStepType;
  }
  return contents;
};

const deserializeAws_json1_1AutoMLCandidates = (
  output: any,
  context: __SerdeContext
): Array<AutoMLCandidate> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AutoMLCandidate(entry, context)
  );
};

const deserializeAws_json1_1AutoMLChannel = (
  output: any,
  context: __SerdeContext
): AutoMLChannel => {
  let contents: any = {
    __type: "AutoMLChannel",
    CompressionType: undefined,
    DataSource: undefined,
    TargetAttributeName: undefined
  };
  if (output.CompressionType !== undefined) {
    contents.CompressionType = output.CompressionType;
  }
  if (output.DataSource !== undefined) {
    contents.DataSource = deserializeAws_json1_1AutoMLDataSource(
      output.DataSource,
      context
    );
  }
  if (output.TargetAttributeName !== undefined) {
    contents.TargetAttributeName = output.TargetAttributeName;
  }
  return contents;
};

const deserializeAws_json1_1AutoMLContainerDefinition = (
  output: any,
  context: __SerdeContext
): AutoMLContainerDefinition => {
  let contents: any = {
    __type: "AutoMLContainerDefinition",
    Environment: undefined,
    Image: undefined,
    ModelDataUrl: undefined
  };
  if (output.Environment !== undefined) {
    contents.Environment = deserializeAws_json1_1EnvironmentMap(
      output.Environment,
      context
    );
  }
  if (output.Image !== undefined) {
    contents.Image = output.Image;
  }
  if (output.ModelDataUrl !== undefined) {
    contents.ModelDataUrl = output.ModelDataUrl;
  }
  return contents;
};

const deserializeAws_json1_1AutoMLContainerDefinitions = (
  output: any,
  context: __SerdeContext
): Array<AutoMLContainerDefinition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AutoMLContainerDefinition(entry, context)
  );
};

const deserializeAws_json1_1AutoMLDataSource = (
  output: any,
  context: __SerdeContext
): AutoMLDataSource => {
  let contents: any = {
    __type: "AutoMLDataSource",
    S3DataSource: undefined
  };
  if (output.S3DataSource !== undefined) {
    contents.S3DataSource = deserializeAws_json1_1AutoMLS3DataSource(
      output.S3DataSource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1AutoMLInputDataConfig = (
  output: any,
  context: __SerdeContext
): Array<AutoMLChannel> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AutoMLChannel(entry, context)
  );
};

const deserializeAws_json1_1AutoMLJobArtifacts = (
  output: any,
  context: __SerdeContext
): AutoMLJobArtifacts => {
  let contents: any = {
    __type: "AutoMLJobArtifacts",
    CandidateDefinitionNotebookLocation: undefined,
    DataExplorationNotebookLocation: undefined
  };
  if (output.CandidateDefinitionNotebookLocation !== undefined) {
    contents.CandidateDefinitionNotebookLocation =
      output.CandidateDefinitionNotebookLocation;
  }
  if (output.DataExplorationNotebookLocation !== undefined) {
    contents.DataExplorationNotebookLocation =
      output.DataExplorationNotebookLocation;
  }
  return contents;
};

const deserializeAws_json1_1AutoMLJobCompletionCriteria = (
  output: any,
  context: __SerdeContext
): AutoMLJobCompletionCriteria => {
  let contents: any = {
    __type: "AutoMLJobCompletionCriteria",
    MaxAutoMLJobRuntimeInSeconds: undefined,
    MaxCandidates: undefined,
    MaxRuntimePerTrainingJobInSeconds: undefined
  };
  if (output.MaxAutoMLJobRuntimeInSeconds !== undefined) {
    contents.MaxAutoMLJobRuntimeInSeconds = output.MaxAutoMLJobRuntimeInSeconds;
  }
  if (output.MaxCandidates !== undefined) {
    contents.MaxCandidates = output.MaxCandidates;
  }
  if (output.MaxRuntimePerTrainingJobInSeconds !== undefined) {
    contents.MaxRuntimePerTrainingJobInSeconds =
      output.MaxRuntimePerTrainingJobInSeconds;
  }
  return contents;
};

const deserializeAws_json1_1AutoMLJobConfig = (
  output: any,
  context: __SerdeContext
): AutoMLJobConfig => {
  let contents: any = {
    __type: "AutoMLJobConfig",
    CompletionCriteria: undefined,
    SecurityConfig: undefined
  };
  if (output.CompletionCriteria !== undefined) {
    contents.CompletionCriteria = deserializeAws_json1_1AutoMLJobCompletionCriteria(
      output.CompletionCriteria,
      context
    );
  }
  if (output.SecurityConfig !== undefined) {
    contents.SecurityConfig = deserializeAws_json1_1AutoMLSecurityConfig(
      output.SecurityConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1AutoMLJobObjective = (
  output: any,
  context: __SerdeContext
): AutoMLJobObjective => {
  let contents: any = {
    __type: "AutoMLJobObjective",
    MetricName: undefined
  };
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  return contents;
};

const deserializeAws_json1_1AutoMLJobSummaries = (
  output: any,
  context: __SerdeContext
): Array<AutoMLJobSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AutoMLJobSummary(entry, context)
  );
};

const deserializeAws_json1_1AutoMLJobSummary = (
  output: any,
  context: __SerdeContext
): AutoMLJobSummary => {
  let contents: any = {
    __type: "AutoMLJobSummary",
    AutoMLJobArn: undefined,
    AutoMLJobName: undefined,
    AutoMLJobSecondaryStatus: undefined,
    AutoMLJobStatus: undefined,
    CreationTime: undefined,
    EndTime: undefined,
    FailureReason: undefined,
    LastModifiedTime: undefined
  };
  if (output.AutoMLJobArn !== undefined) {
    contents.AutoMLJobArn = output.AutoMLJobArn;
  }
  if (output.AutoMLJobName !== undefined) {
    contents.AutoMLJobName = output.AutoMLJobName;
  }
  if (output.AutoMLJobSecondaryStatus !== undefined) {
    contents.AutoMLJobSecondaryStatus = output.AutoMLJobSecondaryStatus;
  }
  if (output.AutoMLJobStatus !== undefined) {
    contents.AutoMLJobStatus = output.AutoMLJobStatus;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1AutoMLOutputDataConfig = (
  output: any,
  context: __SerdeContext
): AutoMLOutputDataConfig => {
  let contents: any = {
    __type: "AutoMLOutputDataConfig",
    KmsKeyId: undefined,
    S3OutputPath: undefined
  };
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.S3OutputPath !== undefined) {
    contents.S3OutputPath = output.S3OutputPath;
  }
  return contents;
};

const deserializeAws_json1_1AutoMLS3DataSource = (
  output: any,
  context: __SerdeContext
): AutoMLS3DataSource => {
  let contents: any = {
    __type: "AutoMLS3DataSource",
    S3DataType: undefined,
    S3Uri: undefined
  };
  if (output.S3DataType !== undefined) {
    contents.S3DataType = output.S3DataType;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1AutoMLSecurityConfig = (
  output: any,
  context: __SerdeContext
): AutoMLSecurityConfig => {
  let contents: any = {
    __type: "AutoMLSecurityConfig",
    EnableInterContainerTrafficEncryption: undefined,
    VolumeKmsKeyId: undefined,
    VpcConfig: undefined
  };
  if (output.EnableInterContainerTrafficEncryption !== undefined) {
    contents.EnableInterContainerTrafficEncryption =
      output.EnableInterContainerTrafficEncryption;
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CandidateSteps = (
  output: any,
  context: __SerdeContext
): Array<AutoMLCandidateStep> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AutoMLCandidateStep(entry, context)
  );
};

const deserializeAws_json1_1CaptureContentTypeHeader = (
  output: any,
  context: __SerdeContext
): CaptureContentTypeHeader => {
  let contents: any = {
    __type: "CaptureContentTypeHeader",
    CsvContentTypes: undefined,
    JsonContentTypes: undefined
  };
  if (output.CsvContentTypes !== undefined) {
    contents.CsvContentTypes = deserializeAws_json1_1CsvContentTypes(
      output.CsvContentTypes,
      context
    );
  }
  if (output.JsonContentTypes !== undefined) {
    contents.JsonContentTypes = deserializeAws_json1_1JsonContentTypes(
      output.JsonContentTypes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CaptureOption = (
  output: any,
  context: __SerdeContext
): CaptureOption => {
  let contents: any = {
    __type: "CaptureOption",
    CaptureMode: undefined
  };
  if (output.CaptureMode !== undefined) {
    contents.CaptureMode = output.CaptureMode;
  }
  return contents;
};

const deserializeAws_json1_1CaptureOptionList = (
  output: any,
  context: __SerdeContext
): Array<CaptureOption> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CaptureOption(entry, context)
  );
};

const deserializeAws_json1_1CategoricalParameterRange = (
  output: any,
  context: __SerdeContext
): CategoricalParameterRange => {
  let contents: any = {
    __type: "CategoricalParameterRange",
    Name: undefined,
    Values: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.Values !== undefined) {
    contents.Values = deserializeAws_json1_1ParameterValues(
      output.Values,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CategoricalParameterRangeSpecification = (
  output: any,
  context: __SerdeContext
): CategoricalParameterRangeSpecification => {
  let contents: any = {
    __type: "CategoricalParameterRangeSpecification",
    Values: undefined
  };
  if (output.Values !== undefined) {
    contents.Values = deserializeAws_json1_1ParameterValues(
      output.Values,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CategoricalParameterRanges = (
  output: any,
  context: __SerdeContext
): Array<CategoricalParameterRange> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CategoricalParameterRange(entry, context)
  );
};

const deserializeAws_json1_1Channel = (
  output: any,
  context: __SerdeContext
): Channel => {
  let contents: any = {
    __type: "Channel",
    ChannelName: undefined,
    CompressionType: undefined,
    ContentType: undefined,
    DataSource: undefined,
    InputMode: undefined,
    RecordWrapperType: undefined,
    ShuffleConfig: undefined
  };
  if (output.ChannelName !== undefined) {
    contents.ChannelName = output.ChannelName;
  }
  if (output.CompressionType !== undefined) {
    contents.CompressionType = output.CompressionType;
  }
  if (output.ContentType !== undefined) {
    contents.ContentType = output.ContentType;
  }
  if (output.DataSource !== undefined) {
    contents.DataSource = deserializeAws_json1_1DataSource(
      output.DataSource,
      context
    );
  }
  if (output.InputMode !== undefined) {
    contents.InputMode = output.InputMode;
  }
  if (output.RecordWrapperType !== undefined) {
    contents.RecordWrapperType = output.RecordWrapperType;
  }
  if (output.ShuffleConfig !== undefined) {
    contents.ShuffleConfig = deserializeAws_json1_1ShuffleConfig(
      output.ShuffleConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ChannelSpecification = (
  output: any,
  context: __SerdeContext
): ChannelSpecification => {
  let contents: any = {
    __type: "ChannelSpecification",
    Description: undefined,
    IsRequired: undefined,
    Name: undefined,
    SupportedCompressionTypes: undefined,
    SupportedContentTypes: undefined,
    SupportedInputModes: undefined
  };
  if (output.Description !== undefined) {
    contents.Description = output.Description;
  }
  if (output.IsRequired !== undefined) {
    contents.IsRequired = output.IsRequired;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.SupportedCompressionTypes !== undefined) {
    contents.SupportedCompressionTypes = deserializeAws_json1_1CompressionTypes(
      output.SupportedCompressionTypes,
      context
    );
  }
  if (output.SupportedContentTypes !== undefined) {
    contents.SupportedContentTypes = deserializeAws_json1_1ContentTypes(
      output.SupportedContentTypes,
      context
    );
  }
  if (output.SupportedInputModes !== undefined) {
    contents.SupportedInputModes = deserializeAws_json1_1InputModes(
      output.SupportedInputModes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ChannelSpecifications = (
  output: any,
  context: __SerdeContext
): Array<ChannelSpecification> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ChannelSpecification(entry, context)
  );
};

const deserializeAws_json1_1CheckpointConfig = (
  output: any,
  context: __SerdeContext
): CheckpointConfig => {
  let contents: any = {
    __type: "CheckpointConfig",
    LocalPath: undefined,
    S3Uri: undefined
  };
  if (output.LocalPath !== undefined) {
    contents.LocalPath = output.LocalPath;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1Cidrs = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1CodeRepositorySummary = (
  output: any,
  context: __SerdeContext
): CodeRepositorySummary => {
  let contents: any = {
    __type: "CodeRepositorySummary",
    CodeRepositoryArn: undefined,
    CodeRepositoryName: undefined,
    CreationTime: undefined,
    GitConfig: undefined,
    LastModifiedTime: undefined
  };
  if (output.CodeRepositoryArn !== undefined) {
    contents.CodeRepositoryArn = output.CodeRepositoryArn;
  }
  if (output.CodeRepositoryName !== undefined) {
    contents.CodeRepositoryName = output.CodeRepositoryName;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.GitConfig !== undefined) {
    contents.GitConfig = deserializeAws_json1_1GitConfig(
      output.GitConfig,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1CodeRepositorySummaryList = (
  output: any,
  context: __SerdeContext
): Array<CodeRepositorySummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CodeRepositorySummary(entry, context)
  );
};

const deserializeAws_json1_1CognitoMemberDefinition = (
  output: any,
  context: __SerdeContext
): CognitoMemberDefinition => {
  let contents: any = {
    __type: "CognitoMemberDefinition",
    ClientId: undefined,
    UserGroup: undefined,
    UserPool: undefined
  };
  if (output.ClientId !== undefined) {
    contents.ClientId = output.ClientId;
  }
  if (output.UserGroup !== undefined) {
    contents.UserGroup = output.UserGroup;
  }
  if (output.UserPool !== undefined) {
    contents.UserPool = output.UserPool;
  }
  return contents;
};

const deserializeAws_json1_1CollectionConfiguration = (
  output: any,
  context: __SerdeContext
): CollectionConfiguration => {
  let contents: any = {
    __type: "CollectionConfiguration",
    CollectionName: undefined,
    CollectionParameters: undefined
  };
  if (output.CollectionName !== undefined) {
    contents.CollectionName = output.CollectionName;
  }
  if (output.CollectionParameters !== undefined) {
    contents.CollectionParameters = deserializeAws_json1_1CollectionParameters(
      output.CollectionParameters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CollectionConfigurations = (
  output: any,
  context: __SerdeContext
): Array<CollectionConfiguration> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CollectionConfiguration(entry, context)
  );
};

const deserializeAws_json1_1CollectionParameters = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1CompilationJobSummaries = (
  output: any,
  context: __SerdeContext
): Array<CompilationJobSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CompilationJobSummary(entry, context)
  );
};

const deserializeAws_json1_1CompilationJobSummary = (
  output: any,
  context: __SerdeContext
): CompilationJobSummary => {
  let contents: any = {
    __type: "CompilationJobSummary",
    CompilationEndTime: undefined,
    CompilationJobArn: undefined,
    CompilationJobName: undefined,
    CompilationJobStatus: undefined,
    CompilationStartTime: undefined,
    CompilationTargetDevice: undefined,
    CreationTime: undefined,
    LastModifiedTime: undefined
  };
  if (output.CompilationEndTime !== undefined) {
    contents.CompilationEndTime = new Date(
      Math.round(output.CompilationEndTime * 1000)
    );
  }
  if (output.CompilationJobArn !== undefined) {
    contents.CompilationJobArn = output.CompilationJobArn;
  }
  if (output.CompilationJobName !== undefined) {
    contents.CompilationJobName = output.CompilationJobName;
  }
  if (output.CompilationJobStatus !== undefined) {
    contents.CompilationJobStatus = output.CompilationJobStatus;
  }
  if (output.CompilationStartTime !== undefined) {
    contents.CompilationStartTime = new Date(
      Math.round(output.CompilationStartTime * 1000)
    );
  }
  if (output.CompilationTargetDevice !== undefined) {
    contents.CompilationTargetDevice = output.CompilationTargetDevice;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1CompressionTypes = (
  output: any,
  context: __SerdeContext
): Array<CompressionType | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ConflictException = (
  output: any,
  context: __SerdeContext
): ConflictException => {
  let contents: any = {
    __type: "ConflictException",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ContainerArguments = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ContainerDefinition = (
  output: any,
  context: __SerdeContext
): ContainerDefinition => {
  let contents: any = {
    __type: "ContainerDefinition",
    ContainerHostname: undefined,
    Environment: undefined,
    Image: undefined,
    Mode: undefined,
    ModelDataUrl: undefined,
    ModelPackageName: undefined
  };
  if (output.ContainerHostname !== undefined) {
    contents.ContainerHostname = output.ContainerHostname;
  }
  if (output.Environment !== undefined) {
    contents.Environment = deserializeAws_json1_1EnvironmentMap(
      output.Environment,
      context
    );
  }
  if (output.Image !== undefined) {
    contents.Image = output.Image;
  }
  if (output.Mode !== undefined) {
    contents.Mode = output.Mode;
  }
  if (output.ModelDataUrl !== undefined) {
    contents.ModelDataUrl = output.ModelDataUrl;
  }
  if (output.ModelPackageName !== undefined) {
    contents.ModelPackageName = output.ModelPackageName;
  }
  return contents;
};

const deserializeAws_json1_1ContainerDefinitionList = (
  output: any,
  context: __SerdeContext
): Array<ContainerDefinition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ContainerDefinition(entry, context)
  );
};

const deserializeAws_json1_1ContainerEntrypoint = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ContentClassifiers = (
  output: any,
  context: __SerdeContext
): Array<ContentClassifier | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ContentTypes = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ContinuousParameterRange = (
  output: any,
  context: __SerdeContext
): ContinuousParameterRange => {
  let contents: any = {
    __type: "ContinuousParameterRange",
    MaxValue: undefined,
    MinValue: undefined,
    Name: undefined,
    ScalingType: undefined
  };
  if (output.MaxValue !== undefined) {
    contents.MaxValue = output.MaxValue;
  }
  if (output.MinValue !== undefined) {
    contents.MinValue = output.MinValue;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.ScalingType !== undefined) {
    contents.ScalingType = output.ScalingType;
  }
  return contents;
};

const deserializeAws_json1_1ContinuousParameterRangeSpecification = (
  output: any,
  context: __SerdeContext
): ContinuousParameterRangeSpecification => {
  let contents: any = {
    __type: "ContinuousParameterRangeSpecification",
    MaxValue: undefined,
    MinValue: undefined
  };
  if (output.MaxValue !== undefined) {
    contents.MaxValue = output.MaxValue;
  }
  if (output.MinValue !== undefined) {
    contents.MinValue = output.MinValue;
  }
  return contents;
};

const deserializeAws_json1_1ContinuousParameterRanges = (
  output: any,
  context: __SerdeContext
): Array<ContinuousParameterRange> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ContinuousParameterRange(entry, context)
  );
};

const deserializeAws_json1_1CreateAlgorithmOutput = (
  output: any,
  context: __SerdeContext
): CreateAlgorithmOutput => {
  let contents: any = {
    __type: "CreateAlgorithmOutput",
    AlgorithmArn: undefined
  };
  if (output.AlgorithmArn !== undefined) {
    contents.AlgorithmArn = output.AlgorithmArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateAppResponse = (
  output: any,
  context: __SerdeContext
): CreateAppResponse => {
  let contents: any = {
    __type: "CreateAppResponse",
    AppArn: undefined
  };
  if (output.AppArn !== undefined) {
    contents.AppArn = output.AppArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateAutoMLJobResponse = (
  output: any,
  context: __SerdeContext
): CreateAutoMLJobResponse => {
  let contents: any = {
    __type: "CreateAutoMLJobResponse",
    AutoMLJobArn: undefined
  };
  if (output.AutoMLJobArn !== undefined) {
    contents.AutoMLJobArn = output.AutoMLJobArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateCodeRepositoryOutput = (
  output: any,
  context: __SerdeContext
): CreateCodeRepositoryOutput => {
  let contents: any = {
    __type: "CreateCodeRepositoryOutput",
    CodeRepositoryArn: undefined
  };
  if (output.CodeRepositoryArn !== undefined) {
    contents.CodeRepositoryArn = output.CodeRepositoryArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateCompilationJobResponse = (
  output: any,
  context: __SerdeContext
): CreateCompilationJobResponse => {
  let contents: any = {
    __type: "CreateCompilationJobResponse",
    CompilationJobArn: undefined
  };
  if (output.CompilationJobArn !== undefined) {
    contents.CompilationJobArn = output.CompilationJobArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateDomainResponse = (
  output: any,
  context: __SerdeContext
): CreateDomainResponse => {
  let contents: any = {
    __type: "CreateDomainResponse",
    DomainArn: undefined,
    Url: undefined
  };
  if (output.DomainArn !== undefined) {
    contents.DomainArn = output.DomainArn;
  }
  if (output.Url !== undefined) {
    contents.Url = output.Url;
  }
  return contents;
};

const deserializeAws_json1_1CreateEndpointConfigOutput = (
  output: any,
  context: __SerdeContext
): CreateEndpointConfigOutput => {
  let contents: any = {
    __type: "CreateEndpointConfigOutput",
    EndpointConfigArn: undefined
  };
  if (output.EndpointConfigArn !== undefined) {
    contents.EndpointConfigArn = output.EndpointConfigArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateEndpointOutput = (
  output: any,
  context: __SerdeContext
): CreateEndpointOutput => {
  let contents: any = {
    __type: "CreateEndpointOutput",
    EndpointArn: undefined
  };
  if (output.EndpointArn !== undefined) {
    contents.EndpointArn = output.EndpointArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateExperimentResponse = (
  output: any,
  context: __SerdeContext
): CreateExperimentResponse => {
  let contents: any = {
    __type: "CreateExperimentResponse",
    ExperimentArn: undefined
  };
  if (output.ExperimentArn !== undefined) {
    contents.ExperimentArn = output.ExperimentArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateFlowDefinitionResponse = (
  output: any,
  context: __SerdeContext
): CreateFlowDefinitionResponse => {
  let contents: any = {
    __type: "CreateFlowDefinitionResponse",
    FlowDefinitionArn: undefined
  };
  if (output.FlowDefinitionArn !== undefined) {
    contents.FlowDefinitionArn = output.FlowDefinitionArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateHumanTaskUiResponse = (
  output: any,
  context: __SerdeContext
): CreateHumanTaskUiResponse => {
  let contents: any = {
    __type: "CreateHumanTaskUiResponse",
    HumanTaskUiArn: undefined
  };
  if (output.HumanTaskUiArn !== undefined) {
    contents.HumanTaskUiArn = output.HumanTaskUiArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateHyperParameterTuningJobResponse = (
  output: any,
  context: __SerdeContext
): CreateHyperParameterTuningJobResponse => {
  let contents: any = {
    __type: "CreateHyperParameterTuningJobResponse",
    HyperParameterTuningJobArn: undefined
  };
  if (output.HyperParameterTuningJobArn !== undefined) {
    contents.HyperParameterTuningJobArn = output.HyperParameterTuningJobArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateLabelingJobResponse = (
  output: any,
  context: __SerdeContext
): CreateLabelingJobResponse => {
  let contents: any = {
    __type: "CreateLabelingJobResponse",
    LabelingJobArn: undefined
  };
  if (output.LabelingJobArn !== undefined) {
    contents.LabelingJobArn = output.LabelingJobArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateModelOutput = (
  output: any,
  context: __SerdeContext
): CreateModelOutput => {
  let contents: any = {
    __type: "CreateModelOutput",
    ModelArn: undefined
  };
  if (output.ModelArn !== undefined) {
    contents.ModelArn = output.ModelArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateModelPackageOutput = (
  output: any,
  context: __SerdeContext
): CreateModelPackageOutput => {
  let contents: any = {
    __type: "CreateModelPackageOutput",
    ModelPackageArn: undefined
  };
  if (output.ModelPackageArn !== undefined) {
    contents.ModelPackageArn = output.ModelPackageArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateMonitoringScheduleResponse = (
  output: any,
  context: __SerdeContext
): CreateMonitoringScheduleResponse => {
  let contents: any = {
    __type: "CreateMonitoringScheduleResponse",
    MonitoringScheduleArn: undefined
  };
  if (output.MonitoringScheduleArn !== undefined) {
    contents.MonitoringScheduleArn = output.MonitoringScheduleArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateNotebookInstanceLifecycleConfigOutput = (
  output: any,
  context: __SerdeContext
): CreateNotebookInstanceLifecycleConfigOutput => {
  let contents: any = {
    __type: "CreateNotebookInstanceLifecycleConfigOutput",
    NotebookInstanceLifecycleConfigArn: undefined
  };
  if (output.NotebookInstanceLifecycleConfigArn !== undefined) {
    contents.NotebookInstanceLifecycleConfigArn =
      output.NotebookInstanceLifecycleConfigArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateNotebookInstanceOutput = (
  output: any,
  context: __SerdeContext
): CreateNotebookInstanceOutput => {
  let contents: any = {
    __type: "CreateNotebookInstanceOutput",
    NotebookInstanceArn: undefined
  };
  if (output.NotebookInstanceArn !== undefined) {
    contents.NotebookInstanceArn = output.NotebookInstanceArn;
  }
  return contents;
};

const deserializeAws_json1_1CreatePresignedDomainUrlResponse = (
  output: any,
  context: __SerdeContext
): CreatePresignedDomainUrlResponse => {
  let contents: any = {
    __type: "CreatePresignedDomainUrlResponse",
    AuthorizedUrl: undefined
  };
  if (output.AuthorizedUrl !== undefined) {
    contents.AuthorizedUrl = output.AuthorizedUrl;
  }
  return contents;
};

const deserializeAws_json1_1CreatePresignedNotebookInstanceUrlOutput = (
  output: any,
  context: __SerdeContext
): CreatePresignedNotebookInstanceUrlOutput => {
  let contents: any = {
    __type: "CreatePresignedNotebookInstanceUrlOutput",
    AuthorizedUrl: undefined
  };
  if (output.AuthorizedUrl !== undefined) {
    contents.AuthorizedUrl = output.AuthorizedUrl;
  }
  return contents;
};

const deserializeAws_json1_1CreateProcessingJobResponse = (
  output: any,
  context: __SerdeContext
): CreateProcessingJobResponse => {
  let contents: any = {
    __type: "CreateProcessingJobResponse",
    ProcessingJobArn: undefined
  };
  if (output.ProcessingJobArn !== undefined) {
    contents.ProcessingJobArn = output.ProcessingJobArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateTrainingJobResponse = (
  output: any,
  context: __SerdeContext
): CreateTrainingJobResponse => {
  let contents: any = {
    __type: "CreateTrainingJobResponse",
    TrainingJobArn: undefined
  };
  if (output.TrainingJobArn !== undefined) {
    contents.TrainingJobArn = output.TrainingJobArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateTransformJobResponse = (
  output: any,
  context: __SerdeContext
): CreateTransformJobResponse => {
  let contents: any = {
    __type: "CreateTransformJobResponse",
    TransformJobArn: undefined
  };
  if (output.TransformJobArn !== undefined) {
    contents.TransformJobArn = output.TransformJobArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateTrialComponentResponse = (
  output: any,
  context: __SerdeContext
): CreateTrialComponentResponse => {
  let contents: any = {
    __type: "CreateTrialComponentResponse",
    TrialComponentArn: undefined
  };
  if (output.TrialComponentArn !== undefined) {
    contents.TrialComponentArn = output.TrialComponentArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateTrialResponse = (
  output: any,
  context: __SerdeContext
): CreateTrialResponse => {
  let contents: any = {
    __type: "CreateTrialResponse",
    TrialArn: undefined
  };
  if (output.TrialArn !== undefined) {
    contents.TrialArn = output.TrialArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateUserProfileResponse = (
  output: any,
  context: __SerdeContext
): CreateUserProfileResponse => {
  let contents: any = {
    __type: "CreateUserProfileResponse",
    UserProfileArn: undefined
  };
  if (output.UserProfileArn !== undefined) {
    contents.UserProfileArn = output.UserProfileArn;
  }
  return contents;
};

const deserializeAws_json1_1CreateWorkteamResponse = (
  output: any,
  context: __SerdeContext
): CreateWorkteamResponse => {
  let contents: any = {
    __type: "CreateWorkteamResponse",
    WorkteamArn: undefined
  };
  if (output.WorkteamArn !== undefined) {
    contents.WorkteamArn = output.WorkteamArn;
  }
  return contents;
};

const deserializeAws_json1_1CsvContentTypes = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1DataCaptureConfig = (
  output: any,
  context: __SerdeContext
): DataCaptureConfig => {
  let contents: any = {
    __type: "DataCaptureConfig",
    CaptureContentTypeHeader: undefined,
    CaptureOptions: undefined,
    DestinationS3Uri: undefined,
    EnableCapture: undefined,
    InitialSamplingPercentage: undefined,
    KmsKeyId: undefined
  };
  if (output.CaptureContentTypeHeader !== undefined) {
    contents.CaptureContentTypeHeader = deserializeAws_json1_1CaptureContentTypeHeader(
      output.CaptureContentTypeHeader,
      context
    );
  }
  if (output.CaptureOptions !== undefined) {
    contents.CaptureOptions = deserializeAws_json1_1CaptureOptionList(
      output.CaptureOptions,
      context
    );
  }
  if (output.DestinationS3Uri !== undefined) {
    contents.DestinationS3Uri = output.DestinationS3Uri;
  }
  if (output.EnableCapture !== undefined) {
    contents.EnableCapture = output.EnableCapture;
  }
  if (output.InitialSamplingPercentage !== undefined) {
    contents.InitialSamplingPercentage = output.InitialSamplingPercentage;
  }
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  return contents;
};

const deserializeAws_json1_1DataCaptureConfigSummary = (
  output: any,
  context: __SerdeContext
): DataCaptureConfigSummary => {
  let contents: any = {
    __type: "DataCaptureConfigSummary",
    CaptureStatus: undefined,
    CurrentSamplingPercentage: undefined,
    DestinationS3Uri: undefined,
    EnableCapture: undefined,
    KmsKeyId: undefined
  };
  if (output.CaptureStatus !== undefined) {
    contents.CaptureStatus = output.CaptureStatus;
  }
  if (output.CurrentSamplingPercentage !== undefined) {
    contents.CurrentSamplingPercentage = output.CurrentSamplingPercentage;
  }
  if (output.DestinationS3Uri !== undefined) {
    contents.DestinationS3Uri = output.DestinationS3Uri;
  }
  if (output.EnableCapture !== undefined) {
    contents.EnableCapture = output.EnableCapture;
  }
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  return contents;
};

const deserializeAws_json1_1DataProcessing = (
  output: any,
  context: __SerdeContext
): DataProcessing => {
  let contents: any = {
    __type: "DataProcessing",
    InputFilter: undefined,
    JoinSource: undefined,
    OutputFilter: undefined
  };
  if (output.InputFilter !== undefined) {
    contents.InputFilter = output.InputFilter;
  }
  if (output.JoinSource !== undefined) {
    contents.JoinSource = output.JoinSource;
  }
  if (output.OutputFilter !== undefined) {
    contents.OutputFilter = output.OutputFilter;
  }
  return contents;
};

const deserializeAws_json1_1DataSource = (
  output: any,
  context: __SerdeContext
): DataSource => {
  let contents: any = {
    __type: "DataSource",
    FileSystemDataSource: undefined,
    S3DataSource: undefined
  };
  if (output.FileSystemDataSource !== undefined) {
    contents.FileSystemDataSource = deserializeAws_json1_1FileSystemDataSource(
      output.FileSystemDataSource,
      context
    );
  }
  if (output.S3DataSource !== undefined) {
    contents.S3DataSource = deserializeAws_json1_1S3DataSource(
      output.S3DataSource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DebugHookConfig = (
  output: any,
  context: __SerdeContext
): DebugHookConfig => {
  let contents: any = {
    __type: "DebugHookConfig",
    CollectionConfigurations: undefined,
    HookParameters: undefined,
    LocalPath: undefined,
    S3OutputPath: undefined
  };
  if (output.CollectionConfigurations !== undefined) {
    contents.CollectionConfigurations = deserializeAws_json1_1CollectionConfigurations(
      output.CollectionConfigurations,
      context
    );
  }
  if (output.HookParameters !== undefined) {
    contents.HookParameters = deserializeAws_json1_1HookParameters(
      output.HookParameters,
      context
    );
  }
  if (output.LocalPath !== undefined) {
    contents.LocalPath = output.LocalPath;
  }
  if (output.S3OutputPath !== undefined) {
    contents.S3OutputPath = output.S3OutputPath;
  }
  return contents;
};

const deserializeAws_json1_1DebugRuleConfiguration = (
  output: any,
  context: __SerdeContext
): DebugRuleConfiguration => {
  let contents: any = {
    __type: "DebugRuleConfiguration",
    InstanceType: undefined,
    LocalPath: undefined,
    RuleConfigurationName: undefined,
    RuleEvaluatorImage: undefined,
    RuleParameters: undefined,
    S3OutputPath: undefined,
    VolumeSizeInGB: undefined
  };
  if (output.InstanceType !== undefined) {
    contents.InstanceType = output.InstanceType;
  }
  if (output.LocalPath !== undefined) {
    contents.LocalPath = output.LocalPath;
  }
  if (output.RuleConfigurationName !== undefined) {
    contents.RuleConfigurationName = output.RuleConfigurationName;
  }
  if (output.RuleEvaluatorImage !== undefined) {
    contents.RuleEvaluatorImage = output.RuleEvaluatorImage;
  }
  if (output.RuleParameters !== undefined) {
    contents.RuleParameters = deserializeAws_json1_1RuleParameters(
      output.RuleParameters,
      context
    );
  }
  if (output.S3OutputPath !== undefined) {
    contents.S3OutputPath = output.S3OutputPath;
  }
  if (output.VolumeSizeInGB !== undefined) {
    contents.VolumeSizeInGB = output.VolumeSizeInGB;
  }
  return contents;
};

const deserializeAws_json1_1DebugRuleConfigurations = (
  output: any,
  context: __SerdeContext
): Array<DebugRuleConfiguration> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DebugRuleConfiguration(entry, context)
  );
};

const deserializeAws_json1_1DebugRuleEvaluationStatus = (
  output: any,
  context: __SerdeContext
): DebugRuleEvaluationStatus => {
  let contents: any = {
    __type: "DebugRuleEvaluationStatus",
    LastModifiedTime: undefined,
    RuleConfigurationName: undefined,
    RuleEvaluationJobArn: undefined,
    RuleEvaluationStatus: undefined,
    StatusDetails: undefined
  };
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.RuleConfigurationName !== undefined) {
    contents.RuleConfigurationName = output.RuleConfigurationName;
  }
  if (output.RuleEvaluationJobArn !== undefined) {
    contents.RuleEvaluationJobArn = output.RuleEvaluationJobArn;
  }
  if (output.RuleEvaluationStatus !== undefined) {
    contents.RuleEvaluationStatus = output.RuleEvaluationStatus;
  }
  if (output.StatusDetails !== undefined) {
    contents.StatusDetails = output.StatusDetails;
  }
  return contents;
};

const deserializeAws_json1_1DebugRuleEvaluationStatuses = (
  output: any,
  context: __SerdeContext
): Array<DebugRuleEvaluationStatus> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DebugRuleEvaluationStatus(entry, context)
  );
};

const deserializeAws_json1_1DeleteExperimentResponse = (
  output: any,
  context: __SerdeContext
): DeleteExperimentResponse => {
  let contents: any = {
    __type: "DeleteExperimentResponse",
    ExperimentArn: undefined
  };
  if (output.ExperimentArn !== undefined) {
    contents.ExperimentArn = output.ExperimentArn;
  }
  return contents;
};

const deserializeAws_json1_1DeleteFlowDefinitionResponse = (
  output: any,
  context: __SerdeContext
): DeleteFlowDefinitionResponse => {
  let contents: any = {
    __type: "DeleteFlowDefinitionResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteTagsOutput = (
  output: any,
  context: __SerdeContext
): DeleteTagsOutput => {
  let contents: any = {
    __type: "DeleteTagsOutput"
  };
  return contents;
};

const deserializeAws_json1_1DeleteTrialComponentResponse = (
  output: any,
  context: __SerdeContext
): DeleteTrialComponentResponse => {
  let contents: any = {
    __type: "DeleteTrialComponentResponse",
    TrialComponentArn: undefined
  };
  if (output.TrialComponentArn !== undefined) {
    contents.TrialComponentArn = output.TrialComponentArn;
  }
  return contents;
};

const deserializeAws_json1_1DeleteTrialResponse = (
  output: any,
  context: __SerdeContext
): DeleteTrialResponse => {
  let contents: any = {
    __type: "DeleteTrialResponse",
    TrialArn: undefined
  };
  if (output.TrialArn !== undefined) {
    contents.TrialArn = output.TrialArn;
  }
  return contents;
};

const deserializeAws_json1_1DeleteWorkteamResponse = (
  output: any,
  context: __SerdeContext
): DeleteWorkteamResponse => {
  let contents: any = {
    __type: "DeleteWorkteamResponse",
    Success: undefined
  };
  if (output.Success !== undefined) {
    contents.Success = output.Success;
  }
  return contents;
};

const deserializeAws_json1_1DeployedImage = (
  output: any,
  context: __SerdeContext
): DeployedImage => {
  let contents: any = {
    __type: "DeployedImage",
    ResolutionTime: undefined,
    ResolvedImage: undefined,
    SpecifiedImage: undefined
  };
  if (output.ResolutionTime !== undefined) {
    contents.ResolutionTime = new Date(
      Math.round(output.ResolutionTime * 1000)
    );
  }
  if (output.ResolvedImage !== undefined) {
    contents.ResolvedImage = output.ResolvedImage;
  }
  if (output.SpecifiedImage !== undefined) {
    contents.SpecifiedImage = output.SpecifiedImage;
  }
  return contents;
};

const deserializeAws_json1_1DeployedImages = (
  output: any,
  context: __SerdeContext
): Array<DeployedImage> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DeployedImage(entry, context)
  );
};

const deserializeAws_json1_1DescribeAlgorithmOutput = (
  output: any,
  context: __SerdeContext
): DescribeAlgorithmOutput => {
  let contents: any = {
    __type: "DescribeAlgorithmOutput",
    AlgorithmArn: undefined,
    AlgorithmDescription: undefined,
    AlgorithmName: undefined,
    AlgorithmStatus: undefined,
    AlgorithmStatusDetails: undefined,
    CertifyForMarketplace: undefined,
    CreationTime: undefined,
    InferenceSpecification: undefined,
    ProductId: undefined,
    TrainingSpecification: undefined,
    ValidationSpecification: undefined
  };
  if (output.AlgorithmArn !== undefined) {
    contents.AlgorithmArn = output.AlgorithmArn;
  }
  if (output.AlgorithmDescription !== undefined) {
    contents.AlgorithmDescription = output.AlgorithmDescription;
  }
  if (output.AlgorithmName !== undefined) {
    contents.AlgorithmName = output.AlgorithmName;
  }
  if (output.AlgorithmStatus !== undefined) {
    contents.AlgorithmStatus = output.AlgorithmStatus;
  }
  if (output.AlgorithmStatusDetails !== undefined) {
    contents.AlgorithmStatusDetails = deserializeAws_json1_1AlgorithmStatusDetails(
      output.AlgorithmStatusDetails,
      context
    );
  }
  if (output.CertifyForMarketplace !== undefined) {
    contents.CertifyForMarketplace = output.CertifyForMarketplace;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.InferenceSpecification !== undefined) {
    contents.InferenceSpecification = deserializeAws_json1_1InferenceSpecification(
      output.InferenceSpecification,
      context
    );
  }
  if (output.ProductId !== undefined) {
    contents.ProductId = output.ProductId;
  }
  if (output.TrainingSpecification !== undefined) {
    contents.TrainingSpecification = deserializeAws_json1_1TrainingSpecification(
      output.TrainingSpecification,
      context
    );
  }
  if (output.ValidationSpecification !== undefined) {
    contents.ValidationSpecification = deserializeAws_json1_1AlgorithmValidationSpecification(
      output.ValidationSpecification,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeAppResponse = (
  output: any,
  context: __SerdeContext
): DescribeAppResponse => {
  let contents: any = {
    __type: "DescribeAppResponse",
    AppArn: undefined,
    AppName: undefined,
    AppType: undefined,
    CreationTime: undefined,
    DomainId: undefined,
    FailureReason: undefined,
    LastHealthCheckTimestamp: undefined,
    LastUserActivityTimestamp: undefined,
    ResourceSpec: undefined,
    Status: undefined,
    UserProfileName: undefined
  };
  if (output.AppArn !== undefined) {
    contents.AppArn = output.AppArn;
  }
  if (output.AppName !== undefined) {
    contents.AppName = output.AppName;
  }
  if (output.AppType !== undefined) {
    contents.AppType = output.AppType;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DomainId !== undefined) {
    contents.DomainId = output.DomainId;
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.LastHealthCheckTimestamp !== undefined) {
    contents.LastHealthCheckTimestamp = new Date(
      Math.round(output.LastHealthCheckTimestamp * 1000)
    );
  }
  if (output.LastUserActivityTimestamp !== undefined) {
    contents.LastUserActivityTimestamp = new Date(
      Math.round(output.LastUserActivityTimestamp * 1000)
    );
  }
  if (output.ResourceSpec !== undefined) {
    contents.ResourceSpec = deserializeAws_json1_1ResourceSpec(
      output.ResourceSpec,
      context
    );
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.UserProfileName !== undefined) {
    contents.UserProfileName = output.UserProfileName;
  }
  return contents;
};

const deserializeAws_json1_1DescribeAutoMLJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeAutoMLJobResponse => {
  let contents: any = {
    __type: "DescribeAutoMLJobResponse",
    AutoMLJobArn: undefined,
    AutoMLJobArtifacts: undefined,
    AutoMLJobConfig: undefined,
    AutoMLJobName: undefined,
    AutoMLJobObjective: undefined,
    AutoMLJobSecondaryStatus: undefined,
    AutoMLJobStatus: undefined,
    BestCandidate: undefined,
    CreationTime: undefined,
    EndTime: undefined,
    FailureReason: undefined,
    GenerateCandidateDefinitionsOnly: undefined,
    InputDataConfig: undefined,
    LastModifiedTime: undefined,
    OutputDataConfig: undefined,
    ProblemType: undefined,
    ResolvedAttributes: undefined,
    RoleArn: undefined
  };
  if (output.AutoMLJobArn !== undefined) {
    contents.AutoMLJobArn = output.AutoMLJobArn;
  }
  if (output.AutoMLJobArtifacts !== undefined) {
    contents.AutoMLJobArtifacts = deserializeAws_json1_1AutoMLJobArtifacts(
      output.AutoMLJobArtifacts,
      context
    );
  }
  if (output.AutoMLJobConfig !== undefined) {
    contents.AutoMLJobConfig = deserializeAws_json1_1AutoMLJobConfig(
      output.AutoMLJobConfig,
      context
    );
  }
  if (output.AutoMLJobName !== undefined) {
    contents.AutoMLJobName = output.AutoMLJobName;
  }
  if (output.AutoMLJobObjective !== undefined) {
    contents.AutoMLJobObjective = deserializeAws_json1_1AutoMLJobObjective(
      output.AutoMLJobObjective,
      context
    );
  }
  if (output.AutoMLJobSecondaryStatus !== undefined) {
    contents.AutoMLJobSecondaryStatus = output.AutoMLJobSecondaryStatus;
  }
  if (output.AutoMLJobStatus !== undefined) {
    contents.AutoMLJobStatus = output.AutoMLJobStatus;
  }
  if (output.BestCandidate !== undefined) {
    contents.BestCandidate = deserializeAws_json1_1AutoMLCandidate(
      output.BestCandidate,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.GenerateCandidateDefinitionsOnly !== undefined) {
    contents.GenerateCandidateDefinitionsOnly =
      output.GenerateCandidateDefinitionsOnly;
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1AutoMLInputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1AutoMLOutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.ProblemType !== undefined) {
    contents.ProblemType = output.ProblemType;
  }
  if (output.ResolvedAttributes !== undefined) {
    contents.ResolvedAttributes = deserializeAws_json1_1ResolvedAttributes(
      output.ResolvedAttributes,
      context
    );
  }
  if (output.RoleArn !== undefined) {
    contents.RoleArn = output.RoleArn;
  }
  return contents;
};

const deserializeAws_json1_1DescribeCodeRepositoryOutput = (
  output: any,
  context: __SerdeContext
): DescribeCodeRepositoryOutput => {
  let contents: any = {
    __type: "DescribeCodeRepositoryOutput",
    CodeRepositoryArn: undefined,
    CodeRepositoryName: undefined,
    CreationTime: undefined,
    GitConfig: undefined,
    LastModifiedTime: undefined
  };
  if (output.CodeRepositoryArn !== undefined) {
    contents.CodeRepositoryArn = output.CodeRepositoryArn;
  }
  if (output.CodeRepositoryName !== undefined) {
    contents.CodeRepositoryName = output.CodeRepositoryName;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.GitConfig !== undefined) {
    contents.GitConfig = deserializeAws_json1_1GitConfig(
      output.GitConfig,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeCompilationJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeCompilationJobResponse => {
  let contents: any = {
    __type: "DescribeCompilationJobResponse",
    CompilationEndTime: undefined,
    CompilationJobArn: undefined,
    CompilationJobName: undefined,
    CompilationJobStatus: undefined,
    CompilationStartTime: undefined,
    CreationTime: undefined,
    FailureReason: undefined,
    InputConfig: undefined,
    LastModifiedTime: undefined,
    ModelArtifacts: undefined,
    OutputConfig: undefined,
    RoleArn: undefined,
    StoppingCondition: undefined
  };
  if (output.CompilationEndTime !== undefined) {
    contents.CompilationEndTime = new Date(
      Math.round(output.CompilationEndTime * 1000)
    );
  }
  if (output.CompilationJobArn !== undefined) {
    contents.CompilationJobArn = output.CompilationJobArn;
  }
  if (output.CompilationJobName !== undefined) {
    contents.CompilationJobName = output.CompilationJobName;
  }
  if (output.CompilationJobStatus !== undefined) {
    contents.CompilationJobStatus = output.CompilationJobStatus;
  }
  if (output.CompilationStartTime !== undefined) {
    contents.CompilationStartTime = new Date(
      Math.round(output.CompilationStartTime * 1000)
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.InputConfig !== undefined) {
    contents.InputConfig = deserializeAws_json1_1InputConfig(
      output.InputConfig,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.ModelArtifacts !== undefined) {
    contents.ModelArtifacts = deserializeAws_json1_1ModelArtifacts(
      output.ModelArtifacts,
      context
    );
  }
  if (output.OutputConfig !== undefined) {
    contents.OutputConfig = deserializeAws_json1_1OutputConfig(
      output.OutputConfig,
      context
    );
  }
  if (output.RoleArn !== undefined) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.StoppingCondition !== undefined) {
    contents.StoppingCondition = deserializeAws_json1_1StoppingCondition(
      output.StoppingCondition,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeDomainResponse = (
  output: any,
  context: __SerdeContext
): DescribeDomainResponse => {
  let contents: any = {
    __type: "DescribeDomainResponse",
    AuthMode: undefined,
    CreationTime: undefined,
    DefaultUserSettings: undefined,
    DomainArn: undefined,
    DomainId: undefined,
    DomainName: undefined,
    FailureReason: undefined,
    HomeEfsFileSystemId: undefined,
    HomeEfsFileSystemKmsKeyId: undefined,
    LastModifiedTime: undefined,
    SingleSignOnManagedApplicationInstanceId: undefined,
    Status: undefined,
    SubnetIds: undefined,
    Url: undefined,
    VpcId: undefined
  };
  if (output.AuthMode !== undefined) {
    contents.AuthMode = output.AuthMode;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DefaultUserSettings !== undefined) {
    contents.DefaultUserSettings = deserializeAws_json1_1UserSettings(
      output.DefaultUserSettings,
      context
    );
  }
  if (output.DomainArn !== undefined) {
    contents.DomainArn = output.DomainArn;
  }
  if (output.DomainId !== undefined) {
    contents.DomainId = output.DomainId;
  }
  if (output.DomainName !== undefined) {
    contents.DomainName = output.DomainName;
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.HomeEfsFileSystemId !== undefined) {
    contents.HomeEfsFileSystemId = output.HomeEfsFileSystemId;
  }
  if (output.HomeEfsFileSystemKmsKeyId !== undefined) {
    contents.HomeEfsFileSystemKmsKeyId = output.HomeEfsFileSystemKmsKeyId;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.SingleSignOnManagedApplicationInstanceId !== undefined) {
    contents.SingleSignOnManagedApplicationInstanceId =
      output.SingleSignOnManagedApplicationInstanceId;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.SubnetIds !== undefined) {
    contents.SubnetIds = deserializeAws_json1_1Subnets(
      output.SubnetIds,
      context
    );
  }
  if (output.Url !== undefined) {
    contents.Url = output.Url;
  }
  if (output.VpcId !== undefined) {
    contents.VpcId = output.VpcId;
  }
  return contents;
};

const deserializeAws_json1_1DescribeEndpointConfigOutput = (
  output: any,
  context: __SerdeContext
): DescribeEndpointConfigOutput => {
  let contents: any = {
    __type: "DescribeEndpointConfigOutput",
    CreationTime: undefined,
    DataCaptureConfig: undefined,
    EndpointConfigArn: undefined,
    EndpointConfigName: undefined,
    KmsKeyId: undefined,
    ProductionVariants: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DataCaptureConfig !== undefined) {
    contents.DataCaptureConfig = deserializeAws_json1_1DataCaptureConfig(
      output.DataCaptureConfig,
      context
    );
  }
  if (output.EndpointConfigArn !== undefined) {
    contents.EndpointConfigArn = output.EndpointConfigArn;
  }
  if (output.EndpointConfigName !== undefined) {
    contents.EndpointConfigName = output.EndpointConfigName;
  }
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.ProductionVariants !== undefined) {
    contents.ProductionVariants = deserializeAws_json1_1ProductionVariantList(
      output.ProductionVariants,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEndpointOutput = (
  output: any,
  context: __SerdeContext
): DescribeEndpointOutput => {
  let contents: any = {
    __type: "DescribeEndpointOutput",
    CreationTime: undefined,
    DataCaptureConfig: undefined,
    EndpointArn: undefined,
    EndpointConfigName: undefined,
    EndpointName: undefined,
    EndpointStatus: undefined,
    FailureReason: undefined,
    LastModifiedTime: undefined,
    ProductionVariants: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DataCaptureConfig !== undefined) {
    contents.DataCaptureConfig = deserializeAws_json1_1DataCaptureConfigSummary(
      output.DataCaptureConfig,
      context
    );
  }
  if (output.EndpointArn !== undefined) {
    contents.EndpointArn = output.EndpointArn;
  }
  if (output.EndpointConfigName !== undefined) {
    contents.EndpointConfigName = output.EndpointConfigName;
  }
  if (output.EndpointName !== undefined) {
    contents.EndpointName = output.EndpointName;
  }
  if (output.EndpointStatus !== undefined) {
    contents.EndpointStatus = output.EndpointStatus;
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.ProductionVariants !== undefined) {
    contents.ProductionVariants = deserializeAws_json1_1ProductionVariantSummaryList(
      output.ProductionVariants,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeExperimentResponse = (
  output: any,
  context: __SerdeContext
): DescribeExperimentResponse => {
  let contents: any = {
    __type: "DescribeExperimentResponse",
    CreatedBy: undefined,
    CreationTime: undefined,
    Description: undefined,
    DisplayName: undefined,
    ExperimentArn: undefined,
    ExperimentName: undefined,
    LastModifiedBy: undefined,
    LastModifiedTime: undefined,
    Source: undefined
  };
  if (output.CreatedBy !== undefined) {
    contents.CreatedBy = deserializeAws_json1_1UserContext(
      output.CreatedBy,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.Description !== undefined) {
    contents.Description = output.Description;
  }
  if (output.DisplayName !== undefined) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.ExperimentArn !== undefined) {
    contents.ExperimentArn = output.ExperimentArn;
  }
  if (output.ExperimentName !== undefined) {
    contents.ExperimentName = output.ExperimentName;
  }
  if (output.LastModifiedBy !== undefined) {
    contents.LastModifiedBy = deserializeAws_json1_1UserContext(
      output.LastModifiedBy,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.Source !== undefined) {
    contents.Source = deserializeAws_json1_1ExperimentSource(
      output.Source,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeFlowDefinitionResponse = (
  output: any,
  context: __SerdeContext
): DescribeFlowDefinitionResponse => {
  let contents: any = {
    __type: "DescribeFlowDefinitionResponse",
    CreationTime: undefined,
    FailureReason: undefined,
    FlowDefinitionArn: undefined,
    FlowDefinitionName: undefined,
    FlowDefinitionStatus: undefined,
    HumanLoopActivationConfig: undefined,
    HumanLoopConfig: undefined,
    OutputConfig: undefined,
    RoleArn: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.FlowDefinitionArn !== undefined) {
    contents.FlowDefinitionArn = output.FlowDefinitionArn;
  }
  if (output.FlowDefinitionName !== undefined) {
    contents.FlowDefinitionName = output.FlowDefinitionName;
  }
  if (output.FlowDefinitionStatus !== undefined) {
    contents.FlowDefinitionStatus = output.FlowDefinitionStatus;
  }
  if (output.HumanLoopActivationConfig !== undefined) {
    contents.HumanLoopActivationConfig = deserializeAws_json1_1HumanLoopActivationConfig(
      output.HumanLoopActivationConfig,
      context
    );
  }
  if (output.HumanLoopConfig !== undefined) {
    contents.HumanLoopConfig = deserializeAws_json1_1HumanLoopConfig(
      output.HumanLoopConfig,
      context
    );
  }
  if (output.OutputConfig !== undefined) {
    contents.OutputConfig = deserializeAws_json1_1FlowDefinitionOutputConfig(
      output.OutputConfig,
      context
    );
  }
  if (output.RoleArn !== undefined) {
    contents.RoleArn = output.RoleArn;
  }
  return contents;
};

const deserializeAws_json1_1DescribeHumanTaskUiResponse = (
  output: any,
  context: __SerdeContext
): DescribeHumanTaskUiResponse => {
  let contents: any = {
    __type: "DescribeHumanTaskUiResponse",
    CreationTime: undefined,
    HumanTaskUiArn: undefined,
    HumanTaskUiName: undefined,
    UiTemplate: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.HumanTaskUiArn !== undefined) {
    contents.HumanTaskUiArn = output.HumanTaskUiArn;
  }
  if (output.HumanTaskUiName !== undefined) {
    contents.HumanTaskUiName = output.HumanTaskUiName;
  }
  if (output.UiTemplate !== undefined) {
    contents.UiTemplate = deserializeAws_json1_1UiTemplateInfo(
      output.UiTemplate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeHyperParameterTuningJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeHyperParameterTuningJobResponse => {
  let contents: any = {
    __type: "DescribeHyperParameterTuningJobResponse",
    BestTrainingJob: undefined,
    CreationTime: undefined,
    FailureReason: undefined,
    HyperParameterTuningEndTime: undefined,
    HyperParameterTuningJobArn: undefined,
    HyperParameterTuningJobConfig: undefined,
    HyperParameterTuningJobName: undefined,
    HyperParameterTuningJobStatus: undefined,
    LastModifiedTime: undefined,
    ObjectiveStatusCounters: undefined,
    OverallBestTrainingJob: undefined,
    TrainingJobDefinition: undefined,
    TrainingJobDefinitions: undefined,
    TrainingJobStatusCounters: undefined,
    WarmStartConfig: undefined
  };
  if (output.BestTrainingJob !== undefined) {
    contents.BestTrainingJob = deserializeAws_json1_1HyperParameterTrainingJobSummary(
      output.BestTrainingJob,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.HyperParameterTuningEndTime !== undefined) {
    contents.HyperParameterTuningEndTime = new Date(
      Math.round(output.HyperParameterTuningEndTime * 1000)
    );
  }
  if (output.HyperParameterTuningJobArn !== undefined) {
    contents.HyperParameterTuningJobArn = output.HyperParameterTuningJobArn;
  }
  if (output.HyperParameterTuningJobConfig !== undefined) {
    contents.HyperParameterTuningJobConfig = deserializeAws_json1_1HyperParameterTuningJobConfig(
      output.HyperParameterTuningJobConfig,
      context
    );
  }
  if (output.HyperParameterTuningJobName !== undefined) {
    contents.HyperParameterTuningJobName = output.HyperParameterTuningJobName;
  }
  if (output.HyperParameterTuningJobStatus !== undefined) {
    contents.HyperParameterTuningJobStatus =
      output.HyperParameterTuningJobStatus;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.ObjectiveStatusCounters !== undefined) {
    contents.ObjectiveStatusCounters = deserializeAws_json1_1ObjectiveStatusCounters(
      output.ObjectiveStatusCounters,
      context
    );
  }
  if (output.OverallBestTrainingJob !== undefined) {
    contents.OverallBestTrainingJob = deserializeAws_json1_1HyperParameterTrainingJobSummary(
      output.OverallBestTrainingJob,
      context
    );
  }
  if (output.TrainingJobDefinition !== undefined) {
    contents.TrainingJobDefinition = deserializeAws_json1_1HyperParameterTrainingJobDefinition(
      output.TrainingJobDefinition,
      context
    );
  }
  if (output.TrainingJobDefinitions !== undefined) {
    contents.TrainingJobDefinitions = deserializeAws_json1_1HyperParameterTrainingJobDefinitions(
      output.TrainingJobDefinitions,
      context
    );
  }
  if (output.TrainingJobStatusCounters !== undefined) {
    contents.TrainingJobStatusCounters = deserializeAws_json1_1TrainingJobStatusCounters(
      output.TrainingJobStatusCounters,
      context
    );
  }
  if (output.WarmStartConfig !== undefined) {
    contents.WarmStartConfig = deserializeAws_json1_1HyperParameterTuningJobWarmStartConfig(
      output.WarmStartConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeLabelingJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeLabelingJobResponse => {
  let contents: any = {
    __type: "DescribeLabelingJobResponse",
    CreationTime: undefined,
    FailureReason: undefined,
    HumanTaskConfig: undefined,
    InputConfig: undefined,
    JobReferenceCode: undefined,
    LabelAttributeName: undefined,
    LabelCategoryConfigS3Uri: undefined,
    LabelCounters: undefined,
    LabelingJobAlgorithmsConfig: undefined,
    LabelingJobArn: undefined,
    LabelingJobName: undefined,
    LabelingJobOutput: undefined,
    LabelingJobStatus: undefined,
    LastModifiedTime: undefined,
    OutputConfig: undefined,
    RoleArn: undefined,
    StoppingConditions: undefined,
    Tags: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.HumanTaskConfig !== undefined) {
    contents.HumanTaskConfig = deserializeAws_json1_1HumanTaskConfig(
      output.HumanTaskConfig,
      context
    );
  }
  if (output.InputConfig !== undefined) {
    contents.InputConfig = deserializeAws_json1_1LabelingJobInputConfig(
      output.InputConfig,
      context
    );
  }
  if (output.JobReferenceCode !== undefined) {
    contents.JobReferenceCode = output.JobReferenceCode;
  }
  if (output.LabelAttributeName !== undefined) {
    contents.LabelAttributeName = output.LabelAttributeName;
  }
  if (output.LabelCategoryConfigS3Uri !== undefined) {
    contents.LabelCategoryConfigS3Uri = output.LabelCategoryConfigS3Uri;
  }
  if (output.LabelCounters !== undefined) {
    contents.LabelCounters = deserializeAws_json1_1LabelCounters(
      output.LabelCounters,
      context
    );
  }
  if (output.LabelingJobAlgorithmsConfig !== undefined) {
    contents.LabelingJobAlgorithmsConfig = deserializeAws_json1_1LabelingJobAlgorithmsConfig(
      output.LabelingJobAlgorithmsConfig,
      context
    );
  }
  if (output.LabelingJobArn !== undefined) {
    contents.LabelingJobArn = output.LabelingJobArn;
  }
  if (output.LabelingJobName !== undefined) {
    contents.LabelingJobName = output.LabelingJobName;
  }
  if (output.LabelingJobOutput !== undefined) {
    contents.LabelingJobOutput = deserializeAws_json1_1LabelingJobOutput(
      output.LabelingJobOutput,
      context
    );
  }
  if (output.LabelingJobStatus !== undefined) {
    contents.LabelingJobStatus = output.LabelingJobStatus;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.OutputConfig !== undefined) {
    contents.OutputConfig = deserializeAws_json1_1LabelingJobOutputConfig(
      output.OutputConfig,
      context
    );
  }
  if (output.RoleArn !== undefined) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.StoppingConditions !== undefined) {
    contents.StoppingConditions = deserializeAws_json1_1LabelingJobStoppingConditions(
      output.StoppingConditions,
      context
    );
  }
  if (output.Tags !== undefined) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1DescribeModelOutput = (
  output: any,
  context: __SerdeContext
): DescribeModelOutput => {
  let contents: any = {
    __type: "DescribeModelOutput",
    Containers: undefined,
    CreationTime: undefined,
    EnableNetworkIsolation: undefined,
    ExecutionRoleArn: undefined,
    ModelArn: undefined,
    ModelName: undefined,
    PrimaryContainer: undefined,
    VpcConfig: undefined
  };
  if (output.Containers !== undefined) {
    contents.Containers = deserializeAws_json1_1ContainerDefinitionList(
      output.Containers,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.EnableNetworkIsolation !== undefined) {
    contents.EnableNetworkIsolation = output.EnableNetworkIsolation;
  }
  if (output.ExecutionRoleArn !== undefined) {
    contents.ExecutionRoleArn = output.ExecutionRoleArn;
  }
  if (output.ModelArn !== undefined) {
    contents.ModelArn = output.ModelArn;
  }
  if (output.ModelName !== undefined) {
    contents.ModelName = output.ModelName;
  }
  if (output.PrimaryContainer !== undefined) {
    contents.PrimaryContainer = deserializeAws_json1_1ContainerDefinition(
      output.PrimaryContainer,
      context
    );
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeModelPackageOutput = (
  output: any,
  context: __SerdeContext
): DescribeModelPackageOutput => {
  let contents: any = {
    __type: "DescribeModelPackageOutput",
    CertifyForMarketplace: undefined,
    CreationTime: undefined,
    InferenceSpecification: undefined,
    ModelPackageArn: undefined,
    ModelPackageDescription: undefined,
    ModelPackageName: undefined,
    ModelPackageStatus: undefined,
    ModelPackageStatusDetails: undefined,
    SourceAlgorithmSpecification: undefined,
    ValidationSpecification: undefined
  };
  if (output.CertifyForMarketplace !== undefined) {
    contents.CertifyForMarketplace = output.CertifyForMarketplace;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.InferenceSpecification !== undefined) {
    contents.InferenceSpecification = deserializeAws_json1_1InferenceSpecification(
      output.InferenceSpecification,
      context
    );
  }
  if (output.ModelPackageArn !== undefined) {
    contents.ModelPackageArn = output.ModelPackageArn;
  }
  if (output.ModelPackageDescription !== undefined) {
    contents.ModelPackageDescription = output.ModelPackageDescription;
  }
  if (output.ModelPackageName !== undefined) {
    contents.ModelPackageName = output.ModelPackageName;
  }
  if (output.ModelPackageStatus !== undefined) {
    contents.ModelPackageStatus = output.ModelPackageStatus;
  }
  if (output.ModelPackageStatusDetails !== undefined) {
    contents.ModelPackageStatusDetails = deserializeAws_json1_1ModelPackageStatusDetails(
      output.ModelPackageStatusDetails,
      context
    );
  }
  if (output.SourceAlgorithmSpecification !== undefined) {
    contents.SourceAlgorithmSpecification = deserializeAws_json1_1SourceAlgorithmSpecification(
      output.SourceAlgorithmSpecification,
      context
    );
  }
  if (output.ValidationSpecification !== undefined) {
    contents.ValidationSpecification = deserializeAws_json1_1ModelPackageValidationSpecification(
      output.ValidationSpecification,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeMonitoringScheduleResponse = (
  output: any,
  context: __SerdeContext
): DescribeMonitoringScheduleResponse => {
  let contents: any = {
    __type: "DescribeMonitoringScheduleResponse",
    CreationTime: undefined,
    EndpointName: undefined,
    FailureReason: undefined,
    LastModifiedTime: undefined,
    LastMonitoringExecutionSummary: undefined,
    MonitoringScheduleArn: undefined,
    MonitoringScheduleConfig: undefined,
    MonitoringScheduleName: undefined,
    MonitoringScheduleStatus: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.EndpointName !== undefined) {
    contents.EndpointName = output.EndpointName;
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.LastMonitoringExecutionSummary !== undefined) {
    contents.LastMonitoringExecutionSummary = deserializeAws_json1_1MonitoringExecutionSummary(
      output.LastMonitoringExecutionSummary,
      context
    );
  }
  if (output.MonitoringScheduleArn !== undefined) {
    contents.MonitoringScheduleArn = output.MonitoringScheduleArn;
  }
  if (output.MonitoringScheduleConfig !== undefined) {
    contents.MonitoringScheduleConfig = deserializeAws_json1_1MonitoringScheduleConfig(
      output.MonitoringScheduleConfig,
      context
    );
  }
  if (output.MonitoringScheduleName !== undefined) {
    contents.MonitoringScheduleName = output.MonitoringScheduleName;
  }
  if (output.MonitoringScheduleStatus !== undefined) {
    contents.MonitoringScheduleStatus = output.MonitoringScheduleStatus;
  }
  return contents;
};

const deserializeAws_json1_1DescribeNotebookInstanceLifecycleConfigOutput = (
  output: any,
  context: __SerdeContext
): DescribeNotebookInstanceLifecycleConfigOutput => {
  let contents: any = {
    __type: "DescribeNotebookInstanceLifecycleConfigOutput",
    CreationTime: undefined,
    LastModifiedTime: undefined,
    NotebookInstanceLifecycleConfigArn: undefined,
    NotebookInstanceLifecycleConfigName: undefined,
    OnCreate: undefined,
    OnStart: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.NotebookInstanceLifecycleConfigArn !== undefined) {
    contents.NotebookInstanceLifecycleConfigArn =
      output.NotebookInstanceLifecycleConfigArn;
  }
  if (output.NotebookInstanceLifecycleConfigName !== undefined) {
    contents.NotebookInstanceLifecycleConfigName =
      output.NotebookInstanceLifecycleConfigName;
  }
  if (output.OnCreate !== undefined) {
    contents.OnCreate = deserializeAws_json1_1NotebookInstanceLifecycleConfigList(
      output.OnCreate,
      context
    );
  }
  if (output.OnStart !== undefined) {
    contents.OnStart = deserializeAws_json1_1NotebookInstanceLifecycleConfigList(
      output.OnStart,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeNotebookInstanceOutput = (
  output: any,
  context: __SerdeContext
): DescribeNotebookInstanceOutput => {
  let contents: any = {
    __type: "DescribeNotebookInstanceOutput",
    AcceleratorTypes: undefined,
    AdditionalCodeRepositories: undefined,
    CreationTime: undefined,
    DefaultCodeRepository: undefined,
    DirectInternetAccess: undefined,
    FailureReason: undefined,
    InstanceType: undefined,
    KmsKeyId: undefined,
    LastModifiedTime: undefined,
    NetworkInterfaceId: undefined,
    NotebookInstanceArn: undefined,
    NotebookInstanceLifecycleConfigName: undefined,
    NotebookInstanceName: undefined,
    NotebookInstanceStatus: undefined,
    RoleArn: undefined,
    RootAccess: undefined,
    SecurityGroups: undefined,
    SubnetId: undefined,
    Url: undefined,
    VolumeSizeInGB: undefined
  };
  if (output.AcceleratorTypes !== undefined) {
    contents.AcceleratorTypes = deserializeAws_json1_1NotebookInstanceAcceleratorTypes(
      output.AcceleratorTypes,
      context
    );
  }
  if (output.AdditionalCodeRepositories !== undefined) {
    contents.AdditionalCodeRepositories = deserializeAws_json1_1AdditionalCodeRepositoryNamesOrUrls(
      output.AdditionalCodeRepositories,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DefaultCodeRepository !== undefined) {
    contents.DefaultCodeRepository = output.DefaultCodeRepository;
  }
  if (output.DirectInternetAccess !== undefined) {
    contents.DirectInternetAccess = output.DirectInternetAccess;
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.InstanceType !== undefined) {
    contents.InstanceType = output.InstanceType;
  }
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.NetworkInterfaceId !== undefined) {
    contents.NetworkInterfaceId = output.NetworkInterfaceId;
  }
  if (output.NotebookInstanceArn !== undefined) {
    contents.NotebookInstanceArn = output.NotebookInstanceArn;
  }
  if (output.NotebookInstanceLifecycleConfigName !== undefined) {
    contents.NotebookInstanceLifecycleConfigName =
      output.NotebookInstanceLifecycleConfigName;
  }
  if (output.NotebookInstanceName !== undefined) {
    contents.NotebookInstanceName = output.NotebookInstanceName;
  }
  if (output.NotebookInstanceStatus !== undefined) {
    contents.NotebookInstanceStatus = output.NotebookInstanceStatus;
  }
  if (output.RoleArn !== undefined) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.RootAccess !== undefined) {
    contents.RootAccess = output.RootAccess;
  }
  if (output.SecurityGroups !== undefined) {
    contents.SecurityGroups = deserializeAws_json1_1SecurityGroupIds(
      output.SecurityGroups,
      context
    );
  }
  if (output.SubnetId !== undefined) {
    contents.SubnetId = output.SubnetId;
  }
  if (output.Url !== undefined) {
    contents.Url = output.Url;
  }
  if (output.VolumeSizeInGB !== undefined) {
    contents.VolumeSizeInGB = output.VolumeSizeInGB;
  }
  return contents;
};

const deserializeAws_json1_1DescribeProcessingJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeProcessingJobResponse => {
  let contents: any = {
    __type: "DescribeProcessingJobResponse",
    AppSpecification: undefined,
    AutoMLJobArn: undefined,
    CreationTime: undefined,
    Environment: undefined,
    ExitMessage: undefined,
    ExperimentConfig: undefined,
    FailureReason: undefined,
    LastModifiedTime: undefined,
    MonitoringScheduleArn: undefined,
    NetworkConfig: undefined,
    ProcessingEndTime: undefined,
    ProcessingInputs: undefined,
    ProcessingJobArn: undefined,
    ProcessingJobName: undefined,
    ProcessingJobStatus: undefined,
    ProcessingOutputConfig: undefined,
    ProcessingResources: undefined,
    ProcessingStartTime: undefined,
    RoleArn: undefined,
    StoppingCondition: undefined,
    TrainingJobArn: undefined
  };
  if (output.AppSpecification !== undefined) {
    contents.AppSpecification = deserializeAws_json1_1AppSpecification(
      output.AppSpecification,
      context
    );
  }
  if (output.AutoMLJobArn !== undefined) {
    contents.AutoMLJobArn = output.AutoMLJobArn;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.Environment !== undefined) {
    contents.Environment = deserializeAws_json1_1ProcessingEnvironmentMap(
      output.Environment,
      context
    );
  }
  if (output.ExitMessage !== undefined) {
    contents.ExitMessage = output.ExitMessage;
  }
  if (output.ExperimentConfig !== undefined) {
    contents.ExperimentConfig = deserializeAws_json1_1ExperimentConfig(
      output.ExperimentConfig,
      context
    );
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.MonitoringScheduleArn !== undefined) {
    contents.MonitoringScheduleArn = output.MonitoringScheduleArn;
  }
  if (output.NetworkConfig !== undefined) {
    contents.NetworkConfig = deserializeAws_json1_1NetworkConfig(
      output.NetworkConfig,
      context
    );
  }
  if (output.ProcessingEndTime !== undefined) {
    contents.ProcessingEndTime = new Date(
      Math.round(output.ProcessingEndTime * 1000)
    );
  }
  if (output.ProcessingInputs !== undefined) {
    contents.ProcessingInputs = deserializeAws_json1_1ProcessingInputs(
      output.ProcessingInputs,
      context
    );
  }
  if (output.ProcessingJobArn !== undefined) {
    contents.ProcessingJobArn = output.ProcessingJobArn;
  }
  if (output.ProcessingJobName !== undefined) {
    contents.ProcessingJobName = output.ProcessingJobName;
  }
  if (output.ProcessingJobStatus !== undefined) {
    contents.ProcessingJobStatus = output.ProcessingJobStatus;
  }
  if (output.ProcessingOutputConfig !== undefined) {
    contents.ProcessingOutputConfig = deserializeAws_json1_1ProcessingOutputConfig(
      output.ProcessingOutputConfig,
      context
    );
  }
  if (output.ProcessingResources !== undefined) {
    contents.ProcessingResources = deserializeAws_json1_1ProcessingResources(
      output.ProcessingResources,
      context
    );
  }
  if (output.ProcessingStartTime !== undefined) {
    contents.ProcessingStartTime = new Date(
      Math.round(output.ProcessingStartTime * 1000)
    );
  }
  if (output.RoleArn !== undefined) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.StoppingCondition !== undefined) {
    contents.StoppingCondition = deserializeAws_json1_1ProcessingStoppingCondition(
      output.StoppingCondition,
      context
    );
  }
  if (output.TrainingJobArn !== undefined) {
    contents.TrainingJobArn = output.TrainingJobArn;
  }
  return contents;
};

const deserializeAws_json1_1DescribeSubscribedWorkteamResponse = (
  output: any,
  context: __SerdeContext
): DescribeSubscribedWorkteamResponse => {
  let contents: any = {
    __type: "DescribeSubscribedWorkteamResponse",
    SubscribedWorkteam: undefined
  };
  if (output.SubscribedWorkteam !== undefined) {
    contents.SubscribedWorkteam = deserializeAws_json1_1SubscribedWorkteam(
      output.SubscribedWorkteam,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeTrainingJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeTrainingJobResponse => {
  let contents: any = {
    __type: "DescribeTrainingJobResponse",
    AlgorithmSpecification: undefined,
    AutoMLJobArn: undefined,
    BillableTimeInSeconds: undefined,
    CheckpointConfig: undefined,
    CreationTime: undefined,
    DebugHookConfig: undefined,
    DebugRuleConfigurations: undefined,
    DebugRuleEvaluationStatuses: undefined,
    EnableInterContainerTrafficEncryption: undefined,
    EnableManagedSpotTraining: undefined,
    EnableNetworkIsolation: undefined,
    ExperimentConfig: undefined,
    FailureReason: undefined,
    FinalMetricDataList: undefined,
    HyperParameters: undefined,
    InputDataConfig: undefined,
    LabelingJobArn: undefined,
    LastModifiedTime: undefined,
    ModelArtifacts: undefined,
    OutputDataConfig: undefined,
    ResourceConfig: undefined,
    RoleArn: undefined,
    SecondaryStatus: undefined,
    SecondaryStatusTransitions: undefined,
    StoppingCondition: undefined,
    TensorBoardOutputConfig: undefined,
    TrainingEndTime: undefined,
    TrainingJobArn: undefined,
    TrainingJobName: undefined,
    TrainingJobStatus: undefined,
    TrainingStartTime: undefined,
    TrainingTimeInSeconds: undefined,
    TuningJobArn: undefined,
    VpcConfig: undefined
  };
  if (output.AlgorithmSpecification !== undefined) {
    contents.AlgorithmSpecification = deserializeAws_json1_1AlgorithmSpecification(
      output.AlgorithmSpecification,
      context
    );
  }
  if (output.AutoMLJobArn !== undefined) {
    contents.AutoMLJobArn = output.AutoMLJobArn;
  }
  if (output.BillableTimeInSeconds !== undefined) {
    contents.BillableTimeInSeconds = output.BillableTimeInSeconds;
  }
  if (output.CheckpointConfig !== undefined) {
    contents.CheckpointConfig = deserializeAws_json1_1CheckpointConfig(
      output.CheckpointConfig,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DebugHookConfig !== undefined) {
    contents.DebugHookConfig = deserializeAws_json1_1DebugHookConfig(
      output.DebugHookConfig,
      context
    );
  }
  if (output.DebugRuleConfigurations !== undefined) {
    contents.DebugRuleConfigurations = deserializeAws_json1_1DebugRuleConfigurations(
      output.DebugRuleConfigurations,
      context
    );
  }
  if (output.DebugRuleEvaluationStatuses !== undefined) {
    contents.DebugRuleEvaluationStatuses = deserializeAws_json1_1DebugRuleEvaluationStatuses(
      output.DebugRuleEvaluationStatuses,
      context
    );
  }
  if (output.EnableInterContainerTrafficEncryption !== undefined) {
    contents.EnableInterContainerTrafficEncryption =
      output.EnableInterContainerTrafficEncryption;
  }
  if (output.EnableManagedSpotTraining !== undefined) {
    contents.EnableManagedSpotTraining = output.EnableManagedSpotTraining;
  }
  if (output.EnableNetworkIsolation !== undefined) {
    contents.EnableNetworkIsolation = output.EnableNetworkIsolation;
  }
  if (output.ExperimentConfig !== undefined) {
    contents.ExperimentConfig = deserializeAws_json1_1ExperimentConfig(
      output.ExperimentConfig,
      context
    );
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.FinalMetricDataList !== undefined) {
    contents.FinalMetricDataList = deserializeAws_json1_1FinalMetricDataList(
      output.FinalMetricDataList,
      context
    );
  }
  if (output.HyperParameters !== undefined) {
    contents.HyperParameters = deserializeAws_json1_1HyperParameters(
      output.HyperParameters,
      context
    );
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.LabelingJobArn !== undefined) {
    contents.LabelingJobArn = output.LabelingJobArn;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.ModelArtifacts !== undefined) {
    contents.ModelArtifacts = deserializeAws_json1_1ModelArtifacts(
      output.ModelArtifacts,
      context
    );
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.ResourceConfig !== undefined) {
    contents.ResourceConfig = deserializeAws_json1_1ResourceConfig(
      output.ResourceConfig,
      context
    );
  }
  if (output.RoleArn !== undefined) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.SecondaryStatus !== undefined) {
    contents.SecondaryStatus = output.SecondaryStatus;
  }
  if (output.SecondaryStatusTransitions !== undefined) {
    contents.SecondaryStatusTransitions = deserializeAws_json1_1SecondaryStatusTransitions(
      output.SecondaryStatusTransitions,
      context
    );
  }
  if (output.StoppingCondition !== undefined) {
    contents.StoppingCondition = deserializeAws_json1_1StoppingCondition(
      output.StoppingCondition,
      context
    );
  }
  if (output.TensorBoardOutputConfig !== undefined) {
    contents.TensorBoardOutputConfig = deserializeAws_json1_1TensorBoardOutputConfig(
      output.TensorBoardOutputConfig,
      context
    );
  }
  if (output.TrainingEndTime !== undefined) {
    contents.TrainingEndTime = new Date(
      Math.round(output.TrainingEndTime * 1000)
    );
  }
  if (output.TrainingJobArn !== undefined) {
    contents.TrainingJobArn = output.TrainingJobArn;
  }
  if (output.TrainingJobName !== undefined) {
    contents.TrainingJobName = output.TrainingJobName;
  }
  if (output.TrainingJobStatus !== undefined) {
    contents.TrainingJobStatus = output.TrainingJobStatus;
  }
  if (output.TrainingStartTime !== undefined) {
    contents.TrainingStartTime = new Date(
      Math.round(output.TrainingStartTime * 1000)
    );
  }
  if (output.TrainingTimeInSeconds !== undefined) {
    contents.TrainingTimeInSeconds = output.TrainingTimeInSeconds;
  }
  if (output.TuningJobArn !== undefined) {
    contents.TuningJobArn = output.TuningJobArn;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeTransformJobResponse = (
  output: any,
  context: __SerdeContext
): DescribeTransformJobResponse => {
  let contents: any = {
    __type: "DescribeTransformJobResponse",
    AutoMLJobArn: undefined,
    BatchStrategy: undefined,
    CreationTime: undefined,
    DataProcessing: undefined,
    Environment: undefined,
    ExperimentConfig: undefined,
    FailureReason: undefined,
    LabelingJobArn: undefined,
    MaxConcurrentTransforms: undefined,
    MaxPayloadInMB: undefined,
    ModelName: undefined,
    TransformEndTime: undefined,
    TransformInput: undefined,
    TransformJobArn: undefined,
    TransformJobName: undefined,
    TransformJobStatus: undefined,
    TransformOutput: undefined,
    TransformResources: undefined,
    TransformStartTime: undefined
  };
  if (output.AutoMLJobArn !== undefined) {
    contents.AutoMLJobArn = output.AutoMLJobArn;
  }
  if (output.BatchStrategy !== undefined) {
    contents.BatchStrategy = output.BatchStrategy;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DataProcessing !== undefined) {
    contents.DataProcessing = deserializeAws_json1_1DataProcessing(
      output.DataProcessing,
      context
    );
  }
  if (output.Environment !== undefined) {
    contents.Environment = deserializeAws_json1_1TransformEnvironmentMap(
      output.Environment,
      context
    );
  }
  if (output.ExperimentConfig !== undefined) {
    contents.ExperimentConfig = deserializeAws_json1_1ExperimentConfig(
      output.ExperimentConfig,
      context
    );
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.LabelingJobArn !== undefined) {
    contents.LabelingJobArn = output.LabelingJobArn;
  }
  if (output.MaxConcurrentTransforms !== undefined) {
    contents.MaxConcurrentTransforms = output.MaxConcurrentTransforms;
  }
  if (output.MaxPayloadInMB !== undefined) {
    contents.MaxPayloadInMB = output.MaxPayloadInMB;
  }
  if (output.ModelName !== undefined) {
    contents.ModelName = output.ModelName;
  }
  if (output.TransformEndTime !== undefined) {
    contents.TransformEndTime = new Date(
      Math.round(output.TransformEndTime * 1000)
    );
  }
  if (output.TransformInput !== undefined) {
    contents.TransformInput = deserializeAws_json1_1TransformInput(
      output.TransformInput,
      context
    );
  }
  if (output.TransformJobArn !== undefined) {
    contents.TransformJobArn = output.TransformJobArn;
  }
  if (output.TransformJobName !== undefined) {
    contents.TransformJobName = output.TransformJobName;
  }
  if (output.TransformJobStatus !== undefined) {
    contents.TransformJobStatus = output.TransformJobStatus;
  }
  if (output.TransformOutput !== undefined) {
    contents.TransformOutput = deserializeAws_json1_1TransformOutput(
      output.TransformOutput,
      context
    );
  }
  if (output.TransformResources !== undefined) {
    contents.TransformResources = deserializeAws_json1_1TransformResources(
      output.TransformResources,
      context
    );
  }
  if (output.TransformStartTime !== undefined) {
    contents.TransformStartTime = new Date(
      Math.round(output.TransformStartTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeTrialComponentResponse = (
  output: any,
  context: __SerdeContext
): DescribeTrialComponentResponse => {
  let contents: any = {
    __type: "DescribeTrialComponentResponse",
    CreatedBy: undefined,
    CreationTime: undefined,
    DisplayName: undefined,
    EndTime: undefined,
    InputArtifacts: undefined,
    LastModifiedBy: undefined,
    LastModifiedTime: undefined,
    Metrics: undefined,
    OutputArtifacts: undefined,
    Parameters: undefined,
    Source: undefined,
    StartTime: undefined,
    Status: undefined,
    TrialComponentArn: undefined,
    TrialComponentName: undefined
  };
  if (output.CreatedBy !== undefined) {
    contents.CreatedBy = deserializeAws_json1_1UserContext(
      output.CreatedBy,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DisplayName !== undefined) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.InputArtifacts !== undefined) {
    contents.InputArtifacts = deserializeAws_json1_1TrialComponentArtifacts(
      output.InputArtifacts,
      context
    );
  }
  if (output.LastModifiedBy !== undefined) {
    contents.LastModifiedBy = deserializeAws_json1_1UserContext(
      output.LastModifiedBy,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.Metrics !== undefined) {
    contents.Metrics = deserializeAws_json1_1TrialComponentMetricSummaries(
      output.Metrics,
      context
    );
  }
  if (output.OutputArtifacts !== undefined) {
    contents.OutputArtifacts = deserializeAws_json1_1TrialComponentArtifacts(
      output.OutputArtifacts,
      context
    );
  }
  if (output.Parameters !== undefined) {
    contents.Parameters = deserializeAws_json1_1TrialComponentParameters(
      output.Parameters,
      context
    );
  }
  if (output.Source !== undefined) {
    contents.Source = deserializeAws_json1_1TrialComponentSource(
      output.Source,
      context
    );
  }
  if (output.StartTime !== undefined) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined) {
    contents.Status = deserializeAws_json1_1TrialComponentStatus(
      output.Status,
      context
    );
  }
  if (output.TrialComponentArn !== undefined) {
    contents.TrialComponentArn = output.TrialComponentArn;
  }
  if (output.TrialComponentName !== undefined) {
    contents.TrialComponentName = output.TrialComponentName;
  }
  return contents;
};

const deserializeAws_json1_1DescribeTrialResponse = (
  output: any,
  context: __SerdeContext
): DescribeTrialResponse => {
  let contents: any = {
    __type: "DescribeTrialResponse",
    CreatedBy: undefined,
    CreationTime: undefined,
    DisplayName: undefined,
    ExperimentName: undefined,
    LastModifiedBy: undefined,
    LastModifiedTime: undefined,
    Source: undefined,
    TrialArn: undefined,
    TrialName: undefined
  };
  if (output.CreatedBy !== undefined) {
    contents.CreatedBy = deserializeAws_json1_1UserContext(
      output.CreatedBy,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DisplayName !== undefined) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.ExperimentName !== undefined) {
    contents.ExperimentName = output.ExperimentName;
  }
  if (output.LastModifiedBy !== undefined) {
    contents.LastModifiedBy = deserializeAws_json1_1UserContext(
      output.LastModifiedBy,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.Source !== undefined) {
    contents.Source = deserializeAws_json1_1TrialSource(output.Source, context);
  }
  if (output.TrialArn !== undefined) {
    contents.TrialArn = output.TrialArn;
  }
  if (output.TrialName !== undefined) {
    contents.TrialName = output.TrialName;
  }
  return contents;
};

const deserializeAws_json1_1DescribeUserProfileResponse = (
  output: any,
  context: __SerdeContext
): DescribeUserProfileResponse => {
  let contents: any = {
    __type: "DescribeUserProfileResponse",
    CreationTime: undefined,
    DomainId: undefined,
    FailureReason: undefined,
    HomeEfsFileSystemUid: undefined,
    LastModifiedTime: undefined,
    SingleSignOnUserIdentifier: undefined,
    SingleSignOnUserValue: undefined,
    Status: undefined,
    UserProfileArn: undefined,
    UserProfileName: undefined,
    UserSettings: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DomainId !== undefined) {
    contents.DomainId = output.DomainId;
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.HomeEfsFileSystemUid !== undefined) {
    contents.HomeEfsFileSystemUid = output.HomeEfsFileSystemUid;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.SingleSignOnUserIdentifier !== undefined) {
    contents.SingleSignOnUserIdentifier = output.SingleSignOnUserIdentifier;
  }
  if (output.SingleSignOnUserValue !== undefined) {
    contents.SingleSignOnUserValue = output.SingleSignOnUserValue;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.UserProfileArn !== undefined) {
    contents.UserProfileArn = output.UserProfileArn;
  }
  if (output.UserProfileName !== undefined) {
    contents.UserProfileName = output.UserProfileName;
  }
  if (output.UserSettings !== undefined) {
    contents.UserSettings = deserializeAws_json1_1UserSettings(
      output.UserSettings,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeWorkforceResponse = (
  output: any,
  context: __SerdeContext
): DescribeWorkforceResponse => {
  let contents: any = {
    __type: "DescribeWorkforceResponse",
    Workforce: undefined
  };
  if (output.Workforce !== undefined) {
    contents.Workforce = deserializeAws_json1_1Workforce(
      output.Workforce,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeWorkteamResponse = (
  output: any,
  context: __SerdeContext
): DescribeWorkteamResponse => {
  let contents: any = {
    __type: "DescribeWorkteamResponse",
    Workteam: undefined
  };
  if (output.Workteam !== undefined) {
    contents.Workteam = deserializeAws_json1_1Workteam(
      output.Workteam,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DisassociateTrialComponentResponse = (
  output: any,
  context: __SerdeContext
): DisassociateTrialComponentResponse => {
  let contents: any = {
    __type: "DisassociateTrialComponentResponse",
    TrialArn: undefined,
    TrialComponentArn: undefined
  };
  if (output.TrialArn !== undefined) {
    contents.TrialArn = output.TrialArn;
  }
  if (output.TrialComponentArn !== undefined) {
    contents.TrialComponentArn = output.TrialComponentArn;
  }
  return contents;
};

const deserializeAws_json1_1DomainDetails = (
  output: any,
  context: __SerdeContext
): DomainDetails => {
  let contents: any = {
    __type: "DomainDetails",
    CreationTime: undefined,
    DomainArn: undefined,
    DomainId: undefined,
    DomainName: undefined,
    LastModifiedTime: undefined,
    Status: undefined,
    Url: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DomainArn !== undefined) {
    contents.DomainArn = output.DomainArn;
  }
  if (output.DomainId !== undefined) {
    contents.DomainId = output.DomainId;
  }
  if (output.DomainName !== undefined) {
    contents.DomainName = output.DomainName;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.Url !== undefined) {
    contents.Url = output.Url;
  }
  return contents;
};

const deserializeAws_json1_1DomainList = (
  output: any,
  context: __SerdeContext
): Array<DomainDetails> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DomainDetails(entry, context)
  );
};

const deserializeAws_json1_1EndpointConfigSummary = (
  output: any,
  context: __SerdeContext
): EndpointConfigSummary => {
  let contents: any = {
    __type: "EndpointConfigSummary",
    CreationTime: undefined,
    EndpointConfigArn: undefined,
    EndpointConfigName: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.EndpointConfigArn !== undefined) {
    contents.EndpointConfigArn = output.EndpointConfigArn;
  }
  if (output.EndpointConfigName !== undefined) {
    contents.EndpointConfigName = output.EndpointConfigName;
  }
  return contents;
};

const deserializeAws_json1_1EndpointConfigSummaryList = (
  output: any,
  context: __SerdeContext
): Array<EndpointConfigSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EndpointConfigSummary(entry, context)
  );
};

const deserializeAws_json1_1EndpointInput = (
  output: any,
  context: __SerdeContext
): EndpointInput => {
  let contents: any = {
    __type: "EndpointInput",
    EndpointName: undefined,
    LocalPath: undefined,
    S3DataDistributionType: undefined,
    S3InputMode: undefined
  };
  if (output.EndpointName !== undefined) {
    contents.EndpointName = output.EndpointName;
  }
  if (output.LocalPath !== undefined) {
    contents.LocalPath = output.LocalPath;
  }
  if (output.S3DataDistributionType !== undefined) {
    contents.S3DataDistributionType = output.S3DataDistributionType;
  }
  if (output.S3InputMode !== undefined) {
    contents.S3InputMode = output.S3InputMode;
  }
  return contents;
};

const deserializeAws_json1_1EndpointSummary = (
  output: any,
  context: __SerdeContext
): EndpointSummary => {
  let contents: any = {
    __type: "EndpointSummary",
    CreationTime: undefined,
    EndpointArn: undefined,
    EndpointName: undefined,
    EndpointStatus: undefined,
    LastModifiedTime: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.EndpointArn !== undefined) {
    contents.EndpointArn = output.EndpointArn;
  }
  if (output.EndpointName !== undefined) {
    contents.EndpointName = output.EndpointName;
  }
  if (output.EndpointStatus !== undefined) {
    contents.EndpointStatus = output.EndpointStatus;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1EndpointSummaryList = (
  output: any,
  context: __SerdeContext
): Array<EndpointSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EndpointSummary(entry, context)
  );
};

const deserializeAws_json1_1EnvironmentMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1Experiment = (
  output: any,
  context: __SerdeContext
): Experiment => {
  let contents: any = {
    __type: "Experiment",
    CreatedBy: undefined,
    CreationTime: undefined,
    Description: undefined,
    DisplayName: undefined,
    ExperimentArn: undefined,
    ExperimentName: undefined,
    LastModifiedBy: undefined,
    LastModifiedTime: undefined,
    Source: undefined,
    Tags: undefined
  };
  if (output.CreatedBy !== undefined) {
    contents.CreatedBy = deserializeAws_json1_1UserContext(
      output.CreatedBy,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.Description !== undefined) {
    contents.Description = output.Description;
  }
  if (output.DisplayName !== undefined) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.ExperimentArn !== undefined) {
    contents.ExperimentArn = output.ExperimentArn;
  }
  if (output.ExperimentName !== undefined) {
    contents.ExperimentName = output.ExperimentName;
  }
  if (output.LastModifiedBy !== undefined) {
    contents.LastModifiedBy = deserializeAws_json1_1UserContext(
      output.LastModifiedBy,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.Source !== undefined) {
    contents.Source = deserializeAws_json1_1ExperimentSource(
      output.Source,
      context
    );
  }
  if (output.Tags !== undefined) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1ExperimentConfig = (
  output: any,
  context: __SerdeContext
): ExperimentConfig => {
  let contents: any = {
    __type: "ExperimentConfig",
    ExperimentName: undefined,
    TrialComponentDisplayName: undefined,
    TrialName: undefined
  };
  if (output.ExperimentName !== undefined) {
    contents.ExperimentName = output.ExperimentName;
  }
  if (output.TrialComponentDisplayName !== undefined) {
    contents.TrialComponentDisplayName = output.TrialComponentDisplayName;
  }
  if (output.TrialName !== undefined) {
    contents.TrialName = output.TrialName;
  }
  return contents;
};

const deserializeAws_json1_1ExperimentSource = (
  output: any,
  context: __SerdeContext
): ExperimentSource => {
  let contents: any = {
    __type: "ExperimentSource",
    SourceArn: undefined,
    SourceType: undefined
  };
  if (output.SourceArn !== undefined) {
    contents.SourceArn = output.SourceArn;
  }
  if (output.SourceType !== undefined) {
    contents.SourceType = output.SourceType;
  }
  return contents;
};

const deserializeAws_json1_1ExperimentSummaries = (
  output: any,
  context: __SerdeContext
): Array<ExperimentSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ExperimentSummary(entry, context)
  );
};

const deserializeAws_json1_1ExperimentSummary = (
  output: any,
  context: __SerdeContext
): ExperimentSummary => {
  let contents: any = {
    __type: "ExperimentSummary",
    CreationTime: undefined,
    DisplayName: undefined,
    ExperimentArn: undefined,
    ExperimentName: undefined,
    ExperimentSource: undefined,
    LastModifiedTime: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DisplayName !== undefined) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.ExperimentArn !== undefined) {
    contents.ExperimentArn = output.ExperimentArn;
  }
  if (output.ExperimentName !== undefined) {
    contents.ExperimentName = output.ExperimentName;
  }
  if (output.ExperimentSource !== undefined) {
    contents.ExperimentSource = deserializeAws_json1_1ExperimentSource(
      output.ExperimentSource,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1FileSystemDataSource = (
  output: any,
  context: __SerdeContext
): FileSystemDataSource => {
  let contents: any = {
    __type: "FileSystemDataSource",
    DirectoryPath: undefined,
    FileSystemAccessMode: undefined,
    FileSystemId: undefined,
    FileSystemType: undefined
  };
  if (output.DirectoryPath !== undefined) {
    contents.DirectoryPath = output.DirectoryPath;
  }
  if (output.FileSystemAccessMode !== undefined) {
    contents.FileSystemAccessMode = output.FileSystemAccessMode;
  }
  if (output.FileSystemId !== undefined) {
    contents.FileSystemId = output.FileSystemId;
  }
  if (output.FileSystemType !== undefined) {
    contents.FileSystemType = output.FileSystemType;
  }
  return contents;
};

const deserializeAws_json1_1FinalAutoMLJobObjectiveMetric = (
  output: any,
  context: __SerdeContext
): FinalAutoMLJobObjectiveMetric => {
  let contents: any = {
    __type: "FinalAutoMLJobObjectiveMetric",
    MetricName: undefined,
    Type: undefined,
    Value: undefined
  };
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1FinalHyperParameterTuningJobObjectiveMetric = (
  output: any,
  context: __SerdeContext
): FinalHyperParameterTuningJobObjectiveMetric => {
  let contents: any = {
    __type: "FinalHyperParameterTuningJobObjectiveMetric",
    MetricName: undefined,
    Type: undefined,
    Value: undefined
  };
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1FinalMetricDataList = (
  output: any,
  context: __SerdeContext
): Array<MetricData> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MetricData(entry, context)
  );
};

const deserializeAws_json1_1FlowDefinitionOutputConfig = (
  output: any,
  context: __SerdeContext
): FlowDefinitionOutputConfig => {
  let contents: any = {
    __type: "FlowDefinitionOutputConfig",
    KmsKeyId: undefined,
    S3OutputPath: undefined
  };
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.S3OutputPath !== undefined) {
    contents.S3OutputPath = output.S3OutputPath;
  }
  return contents;
};

const deserializeAws_json1_1FlowDefinitionSummaries = (
  output: any,
  context: __SerdeContext
): Array<FlowDefinitionSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1FlowDefinitionSummary(entry, context)
  );
};

const deserializeAws_json1_1FlowDefinitionSummary = (
  output: any,
  context: __SerdeContext
): FlowDefinitionSummary => {
  let contents: any = {
    __type: "FlowDefinitionSummary",
    CreationTime: undefined,
    FailureReason: undefined,
    FlowDefinitionArn: undefined,
    FlowDefinitionName: undefined,
    FlowDefinitionStatus: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.FlowDefinitionArn !== undefined) {
    contents.FlowDefinitionArn = output.FlowDefinitionArn;
  }
  if (output.FlowDefinitionName !== undefined) {
    contents.FlowDefinitionName = output.FlowDefinitionName;
  }
  if (output.FlowDefinitionStatus !== undefined) {
    contents.FlowDefinitionStatus = output.FlowDefinitionStatus;
  }
  return contents;
};

const deserializeAws_json1_1FlowDefinitionTaskKeywords = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1GetSearchSuggestionsResponse = (
  output: any,
  context: __SerdeContext
): GetSearchSuggestionsResponse => {
  let contents: any = {
    __type: "GetSearchSuggestionsResponse",
    PropertyNameSuggestions: undefined
  };
  if (output.PropertyNameSuggestions !== undefined) {
    contents.PropertyNameSuggestions = deserializeAws_json1_1PropertyNameSuggestionList(
      output.PropertyNameSuggestions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GitConfig = (
  output: any,
  context: __SerdeContext
): GitConfig => {
  let contents: any = {
    __type: "GitConfig",
    Branch: undefined,
    RepositoryUrl: undefined,
    SecretArn: undefined
  };
  if (output.Branch !== undefined) {
    contents.Branch = output.Branch;
  }
  if (output.RepositoryUrl !== undefined) {
    contents.RepositoryUrl = output.RepositoryUrl;
  }
  if (output.SecretArn !== undefined) {
    contents.SecretArn = output.SecretArn;
  }
  return contents;
};

const deserializeAws_json1_1HookParameters = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1HumanLoopActivationConditionsConfig = (
  output: any,
  context: __SerdeContext
): HumanLoopActivationConditionsConfig => {
  let contents: any = {
    __type: "HumanLoopActivationConditionsConfig",
    HumanLoopActivationConditions: undefined
  };
  if (output.HumanLoopActivationConditions !== undefined) {
    contents.HumanLoopActivationConditions =
      output.HumanLoopActivationConditions;
  }
  return contents;
};

const deserializeAws_json1_1HumanLoopActivationConfig = (
  output: any,
  context: __SerdeContext
): HumanLoopActivationConfig => {
  let contents: any = {
    __type: "HumanLoopActivationConfig",
    HumanLoopActivationConditionsConfig: undefined,
    HumanLoopRequestSource: undefined
  };
  if (output.HumanLoopActivationConditionsConfig !== undefined) {
    contents.HumanLoopActivationConditionsConfig = deserializeAws_json1_1HumanLoopActivationConditionsConfig(
      output.HumanLoopActivationConditionsConfig,
      context
    );
  }
  if (output.HumanLoopRequestSource !== undefined) {
    contents.HumanLoopRequestSource = deserializeAws_json1_1HumanLoopRequestSource(
      output.HumanLoopRequestSource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1HumanLoopConfig = (
  output: any,
  context: __SerdeContext
): HumanLoopConfig => {
  let contents: any = {
    __type: "HumanLoopConfig",
    HumanTaskUiArn: undefined,
    PublicWorkforceTaskPrice: undefined,
    TaskAvailabilityLifetimeInSeconds: undefined,
    TaskCount: undefined,
    TaskDescription: undefined,
    TaskKeywords: undefined,
    TaskTimeLimitInSeconds: undefined,
    TaskTitle: undefined,
    WorkteamArn: undefined
  };
  if (output.HumanTaskUiArn !== undefined) {
    contents.HumanTaskUiArn = output.HumanTaskUiArn;
  }
  if (output.PublicWorkforceTaskPrice !== undefined) {
    contents.PublicWorkforceTaskPrice = deserializeAws_json1_1PublicWorkforceTaskPrice(
      output.PublicWorkforceTaskPrice,
      context
    );
  }
  if (output.TaskAvailabilityLifetimeInSeconds !== undefined) {
    contents.TaskAvailabilityLifetimeInSeconds =
      output.TaskAvailabilityLifetimeInSeconds;
  }
  if (output.TaskCount !== undefined) {
    contents.TaskCount = output.TaskCount;
  }
  if (output.TaskDescription !== undefined) {
    contents.TaskDescription = output.TaskDescription;
  }
  if (output.TaskKeywords !== undefined) {
    contents.TaskKeywords = deserializeAws_json1_1FlowDefinitionTaskKeywords(
      output.TaskKeywords,
      context
    );
  }
  if (output.TaskTimeLimitInSeconds !== undefined) {
    contents.TaskTimeLimitInSeconds = output.TaskTimeLimitInSeconds;
  }
  if (output.TaskTitle !== undefined) {
    contents.TaskTitle = output.TaskTitle;
  }
  if (output.WorkteamArn !== undefined) {
    contents.WorkteamArn = output.WorkteamArn;
  }
  return contents;
};

const deserializeAws_json1_1HumanLoopRequestSource = (
  output: any,
  context: __SerdeContext
): HumanLoopRequestSource => {
  let contents: any = {
    __type: "HumanLoopRequestSource",
    AwsManagedHumanLoopRequestSource: undefined
  };
  if (output.AwsManagedHumanLoopRequestSource !== undefined) {
    contents.AwsManagedHumanLoopRequestSource =
      output.AwsManagedHumanLoopRequestSource;
  }
  return contents;
};

const deserializeAws_json1_1HumanTaskConfig = (
  output: any,
  context: __SerdeContext
): HumanTaskConfig => {
  let contents: any = {
    __type: "HumanTaskConfig",
    AnnotationConsolidationConfig: undefined,
    MaxConcurrentTaskCount: undefined,
    NumberOfHumanWorkersPerDataObject: undefined,
    PreHumanTaskLambdaArn: undefined,
    PublicWorkforceTaskPrice: undefined,
    TaskAvailabilityLifetimeInSeconds: undefined,
    TaskDescription: undefined,
    TaskKeywords: undefined,
    TaskTimeLimitInSeconds: undefined,
    TaskTitle: undefined,
    UiConfig: undefined,
    WorkteamArn: undefined
  };
  if (output.AnnotationConsolidationConfig !== undefined) {
    contents.AnnotationConsolidationConfig = deserializeAws_json1_1AnnotationConsolidationConfig(
      output.AnnotationConsolidationConfig,
      context
    );
  }
  if (output.MaxConcurrentTaskCount !== undefined) {
    contents.MaxConcurrentTaskCount = output.MaxConcurrentTaskCount;
  }
  if (output.NumberOfHumanWorkersPerDataObject !== undefined) {
    contents.NumberOfHumanWorkersPerDataObject =
      output.NumberOfHumanWorkersPerDataObject;
  }
  if (output.PreHumanTaskLambdaArn !== undefined) {
    contents.PreHumanTaskLambdaArn = output.PreHumanTaskLambdaArn;
  }
  if (output.PublicWorkforceTaskPrice !== undefined) {
    contents.PublicWorkforceTaskPrice = deserializeAws_json1_1PublicWorkforceTaskPrice(
      output.PublicWorkforceTaskPrice,
      context
    );
  }
  if (output.TaskAvailabilityLifetimeInSeconds !== undefined) {
    contents.TaskAvailabilityLifetimeInSeconds =
      output.TaskAvailabilityLifetimeInSeconds;
  }
  if (output.TaskDescription !== undefined) {
    contents.TaskDescription = output.TaskDescription;
  }
  if (output.TaskKeywords !== undefined) {
    contents.TaskKeywords = deserializeAws_json1_1TaskKeywords(
      output.TaskKeywords,
      context
    );
  }
  if (output.TaskTimeLimitInSeconds !== undefined) {
    contents.TaskTimeLimitInSeconds = output.TaskTimeLimitInSeconds;
  }
  if (output.TaskTitle !== undefined) {
    contents.TaskTitle = output.TaskTitle;
  }
  if (output.UiConfig !== undefined) {
    contents.UiConfig = deserializeAws_json1_1UiConfig(
      output.UiConfig,
      context
    );
  }
  if (output.WorkteamArn !== undefined) {
    contents.WorkteamArn = output.WorkteamArn;
  }
  return contents;
};

const deserializeAws_json1_1HumanTaskUiSummaries = (
  output: any,
  context: __SerdeContext
): Array<HumanTaskUiSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1HumanTaskUiSummary(entry, context)
  );
};

const deserializeAws_json1_1HumanTaskUiSummary = (
  output: any,
  context: __SerdeContext
): HumanTaskUiSummary => {
  let contents: any = {
    __type: "HumanTaskUiSummary",
    CreationTime: undefined,
    HumanTaskUiArn: undefined,
    HumanTaskUiName: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.HumanTaskUiArn !== undefined) {
    contents.HumanTaskUiArn = output.HumanTaskUiArn;
  }
  if (output.HumanTaskUiName !== undefined) {
    contents.HumanTaskUiName = output.HumanTaskUiName;
  }
  return contents;
};

const deserializeAws_json1_1HyperParameterAlgorithmSpecification = (
  output: any,
  context: __SerdeContext
): HyperParameterAlgorithmSpecification => {
  let contents: any = {
    __type: "HyperParameterAlgorithmSpecification",
    AlgorithmName: undefined,
    MetricDefinitions: undefined,
    TrainingImage: undefined,
    TrainingInputMode: undefined
  };
  if (output.AlgorithmName !== undefined) {
    contents.AlgorithmName = output.AlgorithmName;
  }
  if (output.MetricDefinitions !== undefined) {
    contents.MetricDefinitions = deserializeAws_json1_1MetricDefinitionList(
      output.MetricDefinitions,
      context
    );
  }
  if (output.TrainingImage !== undefined) {
    contents.TrainingImage = output.TrainingImage;
  }
  if (output.TrainingInputMode !== undefined) {
    contents.TrainingInputMode = output.TrainingInputMode;
  }
  return contents;
};

const deserializeAws_json1_1HyperParameterSpecification = (
  output: any,
  context: __SerdeContext
): HyperParameterSpecification => {
  let contents: any = {
    __type: "HyperParameterSpecification",
    DefaultValue: undefined,
    Description: undefined,
    IsRequired: undefined,
    IsTunable: undefined,
    Name: undefined,
    Range: undefined,
    Type: undefined
  };
  if (output.DefaultValue !== undefined) {
    contents.DefaultValue = output.DefaultValue;
  }
  if (output.Description !== undefined) {
    contents.Description = output.Description;
  }
  if (output.IsRequired !== undefined) {
    contents.IsRequired = output.IsRequired;
  }
  if (output.IsTunable !== undefined) {
    contents.IsTunable = output.IsTunable;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.Range !== undefined) {
    contents.Range = deserializeAws_json1_1ParameterRange(
      output.Range,
      context
    );
  }
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1HyperParameterSpecifications = (
  output: any,
  context: __SerdeContext
): Array<HyperParameterSpecification> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1HyperParameterSpecification(entry, context)
  );
};

const deserializeAws_json1_1HyperParameterTrainingJobDefinition = (
  output: any,
  context: __SerdeContext
): HyperParameterTrainingJobDefinition => {
  let contents: any = {
    __type: "HyperParameterTrainingJobDefinition",
    AlgorithmSpecification: undefined,
    CheckpointConfig: undefined,
    DefinitionName: undefined,
    EnableInterContainerTrafficEncryption: undefined,
    EnableManagedSpotTraining: undefined,
    EnableNetworkIsolation: undefined,
    HyperParameterRanges: undefined,
    InputDataConfig: undefined,
    OutputDataConfig: undefined,
    ResourceConfig: undefined,
    RoleArn: undefined,
    StaticHyperParameters: undefined,
    StoppingCondition: undefined,
    TuningObjective: undefined,
    VpcConfig: undefined
  };
  if (output.AlgorithmSpecification !== undefined) {
    contents.AlgorithmSpecification = deserializeAws_json1_1HyperParameterAlgorithmSpecification(
      output.AlgorithmSpecification,
      context
    );
  }
  if (output.CheckpointConfig !== undefined) {
    contents.CheckpointConfig = deserializeAws_json1_1CheckpointConfig(
      output.CheckpointConfig,
      context
    );
  }
  if (output.DefinitionName !== undefined) {
    contents.DefinitionName = output.DefinitionName;
  }
  if (output.EnableInterContainerTrafficEncryption !== undefined) {
    contents.EnableInterContainerTrafficEncryption =
      output.EnableInterContainerTrafficEncryption;
  }
  if (output.EnableManagedSpotTraining !== undefined) {
    contents.EnableManagedSpotTraining = output.EnableManagedSpotTraining;
  }
  if (output.EnableNetworkIsolation !== undefined) {
    contents.EnableNetworkIsolation = output.EnableNetworkIsolation;
  }
  if (output.HyperParameterRanges !== undefined) {
    contents.HyperParameterRanges = deserializeAws_json1_1ParameterRanges(
      output.HyperParameterRanges,
      context
    );
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.ResourceConfig !== undefined) {
    contents.ResourceConfig = deserializeAws_json1_1ResourceConfig(
      output.ResourceConfig,
      context
    );
  }
  if (output.RoleArn !== undefined) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.StaticHyperParameters !== undefined) {
    contents.StaticHyperParameters = deserializeAws_json1_1HyperParameters(
      output.StaticHyperParameters,
      context
    );
  }
  if (output.StoppingCondition !== undefined) {
    contents.StoppingCondition = deserializeAws_json1_1StoppingCondition(
      output.StoppingCondition,
      context
    );
  }
  if (output.TuningObjective !== undefined) {
    contents.TuningObjective = deserializeAws_json1_1HyperParameterTuningJobObjective(
      output.TuningObjective,
      context
    );
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1HyperParameterTrainingJobDefinitions = (
  output: any,
  context: __SerdeContext
): Array<HyperParameterTrainingJobDefinition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1HyperParameterTrainingJobDefinition(entry, context)
  );
};

const deserializeAws_json1_1HyperParameterTrainingJobSummaries = (
  output: any,
  context: __SerdeContext
): Array<HyperParameterTrainingJobSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1HyperParameterTrainingJobSummary(entry, context)
  );
};

const deserializeAws_json1_1HyperParameterTrainingJobSummary = (
  output: any,
  context: __SerdeContext
): HyperParameterTrainingJobSummary => {
  let contents: any = {
    __type: "HyperParameterTrainingJobSummary",
    CreationTime: undefined,
    FailureReason: undefined,
    FinalHyperParameterTuningJobObjectiveMetric: undefined,
    ObjectiveStatus: undefined,
    TrainingEndTime: undefined,
    TrainingJobArn: undefined,
    TrainingJobDefinitionName: undefined,
    TrainingJobName: undefined,
    TrainingJobStatus: undefined,
    TrainingStartTime: undefined,
    TunedHyperParameters: undefined,
    TuningJobName: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.FinalHyperParameterTuningJobObjectiveMetric !== undefined) {
    contents.FinalHyperParameterTuningJobObjectiveMetric = deserializeAws_json1_1FinalHyperParameterTuningJobObjectiveMetric(
      output.FinalHyperParameterTuningJobObjectiveMetric,
      context
    );
  }
  if (output.ObjectiveStatus !== undefined) {
    contents.ObjectiveStatus = output.ObjectiveStatus;
  }
  if (output.TrainingEndTime !== undefined) {
    contents.TrainingEndTime = new Date(
      Math.round(output.TrainingEndTime * 1000)
    );
  }
  if (output.TrainingJobArn !== undefined) {
    contents.TrainingJobArn = output.TrainingJobArn;
  }
  if (output.TrainingJobDefinitionName !== undefined) {
    contents.TrainingJobDefinitionName = output.TrainingJobDefinitionName;
  }
  if (output.TrainingJobName !== undefined) {
    contents.TrainingJobName = output.TrainingJobName;
  }
  if (output.TrainingJobStatus !== undefined) {
    contents.TrainingJobStatus = output.TrainingJobStatus;
  }
  if (output.TrainingStartTime !== undefined) {
    contents.TrainingStartTime = new Date(
      Math.round(output.TrainingStartTime * 1000)
    );
  }
  if (output.TunedHyperParameters !== undefined) {
    contents.TunedHyperParameters = deserializeAws_json1_1HyperParameters(
      output.TunedHyperParameters,
      context
    );
  }
  if (output.TuningJobName !== undefined) {
    contents.TuningJobName = output.TuningJobName;
  }
  return contents;
};

const deserializeAws_json1_1HyperParameterTuningJobConfig = (
  output: any,
  context: __SerdeContext
): HyperParameterTuningJobConfig => {
  let contents: any = {
    __type: "HyperParameterTuningJobConfig",
    HyperParameterTuningJobObjective: undefined,
    ParameterRanges: undefined,
    ResourceLimits: undefined,
    Strategy: undefined,
    TrainingJobEarlyStoppingType: undefined,
    TuningJobCompletionCriteria: undefined
  };
  if (output.HyperParameterTuningJobObjective !== undefined) {
    contents.HyperParameterTuningJobObjective = deserializeAws_json1_1HyperParameterTuningJobObjective(
      output.HyperParameterTuningJobObjective,
      context
    );
  }
  if (output.ParameterRanges !== undefined) {
    contents.ParameterRanges = deserializeAws_json1_1ParameterRanges(
      output.ParameterRanges,
      context
    );
  }
  if (output.ResourceLimits !== undefined) {
    contents.ResourceLimits = deserializeAws_json1_1ResourceLimits(
      output.ResourceLimits,
      context
    );
  }
  if (output.Strategy !== undefined) {
    contents.Strategy = output.Strategy;
  }
  if (output.TrainingJobEarlyStoppingType !== undefined) {
    contents.TrainingJobEarlyStoppingType = output.TrainingJobEarlyStoppingType;
  }
  if (output.TuningJobCompletionCriteria !== undefined) {
    contents.TuningJobCompletionCriteria = deserializeAws_json1_1TuningJobCompletionCriteria(
      output.TuningJobCompletionCriteria,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1HyperParameterTuningJobObjective = (
  output: any,
  context: __SerdeContext
): HyperParameterTuningJobObjective => {
  let contents: any = {
    __type: "HyperParameterTuningJobObjective",
    MetricName: undefined,
    Type: undefined
  };
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1HyperParameterTuningJobObjectives = (
  output: any,
  context: __SerdeContext
): Array<HyperParameterTuningJobObjective> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1HyperParameterTuningJobObjective(entry, context)
  );
};

const deserializeAws_json1_1HyperParameterTuningJobSummaries = (
  output: any,
  context: __SerdeContext
): Array<HyperParameterTuningJobSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1HyperParameterTuningJobSummary(entry, context)
  );
};

const deserializeAws_json1_1HyperParameterTuningJobSummary = (
  output: any,
  context: __SerdeContext
): HyperParameterTuningJobSummary => {
  let contents: any = {
    __type: "HyperParameterTuningJobSummary",
    CreationTime: undefined,
    HyperParameterTuningEndTime: undefined,
    HyperParameterTuningJobArn: undefined,
    HyperParameterTuningJobName: undefined,
    HyperParameterTuningJobStatus: undefined,
    LastModifiedTime: undefined,
    ObjectiveStatusCounters: undefined,
    ResourceLimits: undefined,
    Strategy: undefined,
    TrainingJobStatusCounters: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.HyperParameterTuningEndTime !== undefined) {
    contents.HyperParameterTuningEndTime = new Date(
      Math.round(output.HyperParameterTuningEndTime * 1000)
    );
  }
  if (output.HyperParameterTuningJobArn !== undefined) {
    contents.HyperParameterTuningJobArn = output.HyperParameterTuningJobArn;
  }
  if (output.HyperParameterTuningJobName !== undefined) {
    contents.HyperParameterTuningJobName = output.HyperParameterTuningJobName;
  }
  if (output.HyperParameterTuningJobStatus !== undefined) {
    contents.HyperParameterTuningJobStatus =
      output.HyperParameterTuningJobStatus;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.ObjectiveStatusCounters !== undefined) {
    contents.ObjectiveStatusCounters = deserializeAws_json1_1ObjectiveStatusCounters(
      output.ObjectiveStatusCounters,
      context
    );
  }
  if (output.ResourceLimits !== undefined) {
    contents.ResourceLimits = deserializeAws_json1_1ResourceLimits(
      output.ResourceLimits,
      context
    );
  }
  if (output.Strategy !== undefined) {
    contents.Strategy = output.Strategy;
  }
  if (output.TrainingJobStatusCounters !== undefined) {
    contents.TrainingJobStatusCounters = deserializeAws_json1_1TrainingJobStatusCounters(
      output.TrainingJobStatusCounters,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1HyperParameterTuningJobWarmStartConfig = (
  output: any,
  context: __SerdeContext
): HyperParameterTuningJobWarmStartConfig => {
  let contents: any = {
    __type: "HyperParameterTuningJobWarmStartConfig",
    ParentHyperParameterTuningJobs: undefined,
    WarmStartType: undefined
  };
  if (output.ParentHyperParameterTuningJobs !== undefined) {
    contents.ParentHyperParameterTuningJobs = deserializeAws_json1_1ParentHyperParameterTuningJobs(
      output.ParentHyperParameterTuningJobs,
      context
    );
  }
  if (output.WarmStartType !== undefined) {
    contents.WarmStartType = output.WarmStartType;
  }
  return contents;
};

const deserializeAws_json1_1HyperParameters = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1InferenceSpecification = (
  output: any,
  context: __SerdeContext
): InferenceSpecification => {
  let contents: any = {
    __type: "InferenceSpecification",
    Containers: undefined,
    SupportedContentTypes: undefined,
    SupportedRealtimeInferenceInstanceTypes: undefined,
    SupportedResponseMIMETypes: undefined,
    SupportedTransformInstanceTypes: undefined
  };
  if (output.Containers !== undefined) {
    contents.Containers = deserializeAws_json1_1ModelPackageContainerDefinitionList(
      output.Containers,
      context
    );
  }
  if (output.SupportedContentTypes !== undefined) {
    contents.SupportedContentTypes = deserializeAws_json1_1ContentTypes(
      output.SupportedContentTypes,
      context
    );
  }
  if (output.SupportedRealtimeInferenceInstanceTypes !== undefined) {
    contents.SupportedRealtimeInferenceInstanceTypes = deserializeAws_json1_1RealtimeInferenceInstanceTypes(
      output.SupportedRealtimeInferenceInstanceTypes,
      context
    );
  }
  if (output.SupportedResponseMIMETypes !== undefined) {
    contents.SupportedResponseMIMETypes = deserializeAws_json1_1ResponseMIMETypes(
      output.SupportedResponseMIMETypes,
      context
    );
  }
  if (output.SupportedTransformInstanceTypes !== undefined) {
    contents.SupportedTransformInstanceTypes = deserializeAws_json1_1TransformInstanceTypes(
      output.SupportedTransformInstanceTypes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1InputConfig = (
  output: any,
  context: __SerdeContext
): InputConfig => {
  let contents: any = {
    __type: "InputConfig",
    DataInputConfig: undefined,
    Framework: undefined,
    S3Uri: undefined
  };
  if (output.DataInputConfig !== undefined) {
    contents.DataInputConfig = output.DataInputConfig;
  }
  if (output.Framework !== undefined) {
    contents.Framework = output.Framework;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1InputDataConfig = (
  output: any,
  context: __SerdeContext
): Array<Channel> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Channel(entry, context)
  );
};

const deserializeAws_json1_1InputModes = (
  output: any,
  context: __SerdeContext
): Array<TrainingInputMode | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1IntegerParameterRange = (
  output: any,
  context: __SerdeContext
): IntegerParameterRange => {
  let contents: any = {
    __type: "IntegerParameterRange",
    MaxValue: undefined,
    MinValue: undefined,
    Name: undefined,
    ScalingType: undefined
  };
  if (output.MaxValue !== undefined) {
    contents.MaxValue = output.MaxValue;
  }
  if (output.MinValue !== undefined) {
    contents.MinValue = output.MinValue;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.ScalingType !== undefined) {
    contents.ScalingType = output.ScalingType;
  }
  return contents;
};

const deserializeAws_json1_1IntegerParameterRangeSpecification = (
  output: any,
  context: __SerdeContext
): IntegerParameterRangeSpecification => {
  let contents: any = {
    __type: "IntegerParameterRangeSpecification",
    MaxValue: undefined,
    MinValue: undefined
  };
  if (output.MaxValue !== undefined) {
    contents.MaxValue = output.MaxValue;
  }
  if (output.MinValue !== undefined) {
    contents.MinValue = output.MinValue;
  }
  return contents;
};

const deserializeAws_json1_1IntegerParameterRanges = (
  output: any,
  context: __SerdeContext
): Array<IntegerParameterRange> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1IntegerParameterRange(entry, context)
  );
};

const deserializeAws_json1_1JsonContentTypes = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1JupyterServerAppSettings = (
  output: any,
  context: __SerdeContext
): JupyterServerAppSettings => {
  let contents: any = {
    __type: "JupyterServerAppSettings",
    DefaultResourceSpec: undefined
  };
  if (output.DefaultResourceSpec !== undefined) {
    contents.DefaultResourceSpec = deserializeAws_json1_1ResourceSpec(
      output.DefaultResourceSpec,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1KernelGatewayAppSettings = (
  output: any,
  context: __SerdeContext
): KernelGatewayAppSettings => {
  let contents: any = {
    __type: "KernelGatewayAppSettings",
    DefaultResourceSpec: undefined
  };
  if (output.DefaultResourceSpec !== undefined) {
    contents.DefaultResourceSpec = deserializeAws_json1_1ResourceSpec(
      output.DefaultResourceSpec,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1LabelCounters = (
  output: any,
  context: __SerdeContext
): LabelCounters => {
  let contents: any = {
    __type: "LabelCounters",
    FailedNonRetryableError: undefined,
    HumanLabeled: undefined,
    MachineLabeled: undefined,
    TotalLabeled: undefined,
    Unlabeled: undefined
  };
  if (output.FailedNonRetryableError !== undefined) {
    contents.FailedNonRetryableError = output.FailedNonRetryableError;
  }
  if (output.HumanLabeled !== undefined) {
    contents.HumanLabeled = output.HumanLabeled;
  }
  if (output.MachineLabeled !== undefined) {
    contents.MachineLabeled = output.MachineLabeled;
  }
  if (output.TotalLabeled !== undefined) {
    contents.TotalLabeled = output.TotalLabeled;
  }
  if (output.Unlabeled !== undefined) {
    contents.Unlabeled = output.Unlabeled;
  }
  return contents;
};

const deserializeAws_json1_1LabelCountersForWorkteam = (
  output: any,
  context: __SerdeContext
): LabelCountersForWorkteam => {
  let contents: any = {
    __type: "LabelCountersForWorkteam",
    HumanLabeled: undefined,
    PendingHuman: undefined,
    Total: undefined
  };
  if (output.HumanLabeled !== undefined) {
    contents.HumanLabeled = output.HumanLabeled;
  }
  if (output.PendingHuman !== undefined) {
    contents.PendingHuman = output.PendingHuman;
  }
  if (output.Total !== undefined) {
    contents.Total = output.Total;
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobAlgorithmsConfig = (
  output: any,
  context: __SerdeContext
): LabelingJobAlgorithmsConfig => {
  let contents: any = {
    __type: "LabelingJobAlgorithmsConfig",
    InitialActiveLearningModelArn: undefined,
    LabelingJobAlgorithmSpecificationArn: undefined,
    LabelingJobResourceConfig: undefined
  };
  if (output.InitialActiveLearningModelArn !== undefined) {
    contents.InitialActiveLearningModelArn =
      output.InitialActiveLearningModelArn;
  }
  if (output.LabelingJobAlgorithmSpecificationArn !== undefined) {
    contents.LabelingJobAlgorithmSpecificationArn =
      output.LabelingJobAlgorithmSpecificationArn;
  }
  if (output.LabelingJobResourceConfig !== undefined) {
    contents.LabelingJobResourceConfig = deserializeAws_json1_1LabelingJobResourceConfig(
      output.LabelingJobResourceConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobDataAttributes = (
  output: any,
  context: __SerdeContext
): LabelingJobDataAttributes => {
  let contents: any = {
    __type: "LabelingJobDataAttributes",
    ContentClassifiers: undefined
  };
  if (output.ContentClassifiers !== undefined) {
    contents.ContentClassifiers = deserializeAws_json1_1ContentClassifiers(
      output.ContentClassifiers,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobDataSource = (
  output: any,
  context: __SerdeContext
): LabelingJobDataSource => {
  let contents: any = {
    __type: "LabelingJobDataSource",
    S3DataSource: undefined
  };
  if (output.S3DataSource !== undefined) {
    contents.S3DataSource = deserializeAws_json1_1LabelingJobS3DataSource(
      output.S3DataSource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobForWorkteamSummary = (
  output: any,
  context: __SerdeContext
): LabelingJobForWorkteamSummary => {
  let contents: any = {
    __type: "LabelingJobForWorkteamSummary",
    CreationTime: undefined,
    JobReferenceCode: undefined,
    LabelCounters: undefined,
    LabelingJobName: undefined,
    NumberOfHumanWorkersPerDataObject: undefined,
    WorkRequesterAccountId: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.JobReferenceCode !== undefined) {
    contents.JobReferenceCode = output.JobReferenceCode;
  }
  if (output.LabelCounters !== undefined) {
    contents.LabelCounters = deserializeAws_json1_1LabelCountersForWorkteam(
      output.LabelCounters,
      context
    );
  }
  if (output.LabelingJobName !== undefined) {
    contents.LabelingJobName = output.LabelingJobName;
  }
  if (output.NumberOfHumanWorkersPerDataObject !== undefined) {
    contents.NumberOfHumanWorkersPerDataObject =
      output.NumberOfHumanWorkersPerDataObject;
  }
  if (output.WorkRequesterAccountId !== undefined) {
    contents.WorkRequesterAccountId = output.WorkRequesterAccountId;
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobForWorkteamSummaryList = (
  output: any,
  context: __SerdeContext
): Array<LabelingJobForWorkteamSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1LabelingJobForWorkteamSummary(entry, context)
  );
};

const deserializeAws_json1_1LabelingJobInputConfig = (
  output: any,
  context: __SerdeContext
): LabelingJobInputConfig => {
  let contents: any = {
    __type: "LabelingJobInputConfig",
    DataAttributes: undefined,
    DataSource: undefined
  };
  if (output.DataAttributes !== undefined) {
    contents.DataAttributes = deserializeAws_json1_1LabelingJobDataAttributes(
      output.DataAttributes,
      context
    );
  }
  if (output.DataSource !== undefined) {
    contents.DataSource = deserializeAws_json1_1LabelingJobDataSource(
      output.DataSource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobOutput = (
  output: any,
  context: __SerdeContext
): LabelingJobOutput => {
  let contents: any = {
    __type: "LabelingJobOutput",
    FinalActiveLearningModelArn: undefined,
    OutputDatasetS3Uri: undefined
  };
  if (output.FinalActiveLearningModelArn !== undefined) {
    contents.FinalActiveLearningModelArn = output.FinalActiveLearningModelArn;
  }
  if (output.OutputDatasetS3Uri !== undefined) {
    contents.OutputDatasetS3Uri = output.OutputDatasetS3Uri;
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobOutputConfig = (
  output: any,
  context: __SerdeContext
): LabelingJobOutputConfig => {
  let contents: any = {
    __type: "LabelingJobOutputConfig",
    KmsKeyId: undefined,
    S3OutputPath: undefined
  };
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.S3OutputPath !== undefined) {
    contents.S3OutputPath = output.S3OutputPath;
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobResourceConfig = (
  output: any,
  context: __SerdeContext
): LabelingJobResourceConfig => {
  let contents: any = {
    __type: "LabelingJobResourceConfig",
    VolumeKmsKeyId: undefined
  };
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobS3DataSource = (
  output: any,
  context: __SerdeContext
): LabelingJobS3DataSource => {
  let contents: any = {
    __type: "LabelingJobS3DataSource",
    ManifestS3Uri: undefined
  };
  if (output.ManifestS3Uri !== undefined) {
    contents.ManifestS3Uri = output.ManifestS3Uri;
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobStoppingConditions = (
  output: any,
  context: __SerdeContext
): LabelingJobStoppingConditions => {
  let contents: any = {
    __type: "LabelingJobStoppingConditions",
    MaxHumanLabeledObjectCount: undefined,
    MaxPercentageOfInputDatasetLabeled: undefined
  };
  if (output.MaxHumanLabeledObjectCount !== undefined) {
    contents.MaxHumanLabeledObjectCount = output.MaxHumanLabeledObjectCount;
  }
  if (output.MaxPercentageOfInputDatasetLabeled !== undefined) {
    contents.MaxPercentageOfInputDatasetLabeled =
      output.MaxPercentageOfInputDatasetLabeled;
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobSummary = (
  output: any,
  context: __SerdeContext
): LabelingJobSummary => {
  let contents: any = {
    __type: "LabelingJobSummary",
    AnnotationConsolidationLambdaArn: undefined,
    CreationTime: undefined,
    FailureReason: undefined,
    InputConfig: undefined,
    LabelCounters: undefined,
    LabelingJobArn: undefined,
    LabelingJobName: undefined,
    LabelingJobOutput: undefined,
    LabelingJobStatus: undefined,
    LastModifiedTime: undefined,
    PreHumanTaskLambdaArn: undefined,
    WorkteamArn: undefined
  };
  if (output.AnnotationConsolidationLambdaArn !== undefined) {
    contents.AnnotationConsolidationLambdaArn =
      output.AnnotationConsolidationLambdaArn;
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.InputConfig !== undefined) {
    contents.InputConfig = deserializeAws_json1_1LabelingJobInputConfig(
      output.InputConfig,
      context
    );
  }
  if (output.LabelCounters !== undefined) {
    contents.LabelCounters = deserializeAws_json1_1LabelCounters(
      output.LabelCounters,
      context
    );
  }
  if (output.LabelingJobArn !== undefined) {
    contents.LabelingJobArn = output.LabelingJobArn;
  }
  if (output.LabelingJobName !== undefined) {
    contents.LabelingJobName = output.LabelingJobName;
  }
  if (output.LabelingJobOutput !== undefined) {
    contents.LabelingJobOutput = deserializeAws_json1_1LabelingJobOutput(
      output.LabelingJobOutput,
      context
    );
  }
  if (output.LabelingJobStatus !== undefined) {
    contents.LabelingJobStatus = output.LabelingJobStatus;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.PreHumanTaskLambdaArn !== undefined) {
    contents.PreHumanTaskLambdaArn = output.PreHumanTaskLambdaArn;
  }
  if (output.WorkteamArn !== undefined) {
    contents.WorkteamArn = output.WorkteamArn;
  }
  return contents;
};

const deserializeAws_json1_1LabelingJobSummaryList = (
  output: any,
  context: __SerdeContext
): Array<LabelingJobSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1LabelingJobSummary(entry, context)
  );
};

const deserializeAws_json1_1ListAlgorithmsOutput = (
  output: any,
  context: __SerdeContext
): ListAlgorithmsOutput => {
  let contents: any = {
    __type: "ListAlgorithmsOutput",
    AlgorithmSummaryList: undefined,
    NextToken: undefined
  };
  if (output.AlgorithmSummaryList !== undefined) {
    contents.AlgorithmSummaryList = deserializeAws_json1_1AlgorithmSummaryList(
      output.AlgorithmSummaryList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListAppsResponse = (
  output: any,
  context: __SerdeContext
): ListAppsResponse => {
  let contents: any = {
    __type: "ListAppsResponse",
    Apps: undefined,
    NextToken: undefined
  };
  if (output.Apps !== undefined) {
    contents.Apps = deserializeAws_json1_1AppList(output.Apps, context);
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListAutoMLJobsResponse = (
  output: any,
  context: __SerdeContext
): ListAutoMLJobsResponse => {
  let contents: any = {
    __type: "ListAutoMLJobsResponse",
    AutoMLJobSummaries: undefined,
    NextToken: undefined
  };
  if (output.AutoMLJobSummaries !== undefined) {
    contents.AutoMLJobSummaries = deserializeAws_json1_1AutoMLJobSummaries(
      output.AutoMLJobSummaries,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListCandidatesForAutoMLJobResponse = (
  output: any,
  context: __SerdeContext
): ListCandidatesForAutoMLJobResponse => {
  let contents: any = {
    __type: "ListCandidatesForAutoMLJobResponse",
    Candidates: undefined,
    NextToken: undefined
  };
  if (output.Candidates !== undefined) {
    contents.Candidates = deserializeAws_json1_1AutoMLCandidates(
      output.Candidates,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListCodeRepositoriesOutput = (
  output: any,
  context: __SerdeContext
): ListCodeRepositoriesOutput => {
  let contents: any = {
    __type: "ListCodeRepositoriesOutput",
    CodeRepositorySummaryList: undefined,
    NextToken: undefined
  };
  if (output.CodeRepositorySummaryList !== undefined) {
    contents.CodeRepositorySummaryList = deserializeAws_json1_1CodeRepositorySummaryList(
      output.CodeRepositorySummaryList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListCompilationJobsResponse = (
  output: any,
  context: __SerdeContext
): ListCompilationJobsResponse => {
  let contents: any = {
    __type: "ListCompilationJobsResponse",
    CompilationJobSummaries: undefined,
    NextToken: undefined
  };
  if (output.CompilationJobSummaries !== undefined) {
    contents.CompilationJobSummaries = deserializeAws_json1_1CompilationJobSummaries(
      output.CompilationJobSummaries,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListDomainsResponse = (
  output: any,
  context: __SerdeContext
): ListDomainsResponse => {
  let contents: any = {
    __type: "ListDomainsResponse",
    Domains: undefined,
    NextToken: undefined
  };
  if (output.Domains !== undefined) {
    contents.Domains = deserializeAws_json1_1DomainList(
      output.Domains,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListEndpointConfigsOutput = (
  output: any,
  context: __SerdeContext
): ListEndpointConfigsOutput => {
  let contents: any = {
    __type: "ListEndpointConfigsOutput",
    EndpointConfigs: undefined,
    NextToken: undefined
  };
  if (output.EndpointConfigs !== undefined) {
    contents.EndpointConfigs = deserializeAws_json1_1EndpointConfigSummaryList(
      output.EndpointConfigs,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListEndpointsOutput = (
  output: any,
  context: __SerdeContext
): ListEndpointsOutput => {
  let contents: any = {
    __type: "ListEndpointsOutput",
    Endpoints: undefined,
    NextToken: undefined
  };
  if (output.Endpoints !== undefined) {
    contents.Endpoints = deserializeAws_json1_1EndpointSummaryList(
      output.Endpoints,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListExperimentsResponse = (
  output: any,
  context: __SerdeContext
): ListExperimentsResponse => {
  let contents: any = {
    __type: "ListExperimentsResponse",
    ExperimentSummaries: undefined,
    NextToken: undefined
  };
  if (output.ExperimentSummaries !== undefined) {
    contents.ExperimentSummaries = deserializeAws_json1_1ExperimentSummaries(
      output.ExperimentSummaries,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListFlowDefinitionsResponse = (
  output: any,
  context: __SerdeContext
): ListFlowDefinitionsResponse => {
  let contents: any = {
    __type: "ListFlowDefinitionsResponse",
    FlowDefinitionSummaries: undefined,
    NextToken: undefined
  };
  if (output.FlowDefinitionSummaries !== undefined) {
    contents.FlowDefinitionSummaries = deserializeAws_json1_1FlowDefinitionSummaries(
      output.FlowDefinitionSummaries,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListHumanTaskUisResponse = (
  output: any,
  context: __SerdeContext
): ListHumanTaskUisResponse => {
  let contents: any = {
    __type: "ListHumanTaskUisResponse",
    HumanTaskUiSummaries: undefined,
    NextToken: undefined
  };
  if (output.HumanTaskUiSummaries !== undefined) {
    contents.HumanTaskUiSummaries = deserializeAws_json1_1HumanTaskUiSummaries(
      output.HumanTaskUiSummaries,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListHyperParameterTuningJobsResponse = (
  output: any,
  context: __SerdeContext
): ListHyperParameterTuningJobsResponse => {
  let contents: any = {
    __type: "ListHyperParameterTuningJobsResponse",
    HyperParameterTuningJobSummaries: undefined,
    NextToken: undefined
  };
  if (output.HyperParameterTuningJobSummaries !== undefined) {
    contents.HyperParameterTuningJobSummaries = deserializeAws_json1_1HyperParameterTuningJobSummaries(
      output.HyperParameterTuningJobSummaries,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListLabelingJobsForWorkteamResponse = (
  output: any,
  context: __SerdeContext
): ListLabelingJobsForWorkteamResponse => {
  let contents: any = {
    __type: "ListLabelingJobsForWorkteamResponse",
    LabelingJobSummaryList: undefined,
    NextToken: undefined
  };
  if (output.LabelingJobSummaryList !== undefined) {
    contents.LabelingJobSummaryList = deserializeAws_json1_1LabelingJobForWorkteamSummaryList(
      output.LabelingJobSummaryList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListLabelingJobsResponse = (
  output: any,
  context: __SerdeContext
): ListLabelingJobsResponse => {
  let contents: any = {
    __type: "ListLabelingJobsResponse",
    LabelingJobSummaryList: undefined,
    NextToken: undefined
  };
  if (output.LabelingJobSummaryList !== undefined) {
    contents.LabelingJobSummaryList = deserializeAws_json1_1LabelingJobSummaryList(
      output.LabelingJobSummaryList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListModelPackagesOutput = (
  output: any,
  context: __SerdeContext
): ListModelPackagesOutput => {
  let contents: any = {
    __type: "ListModelPackagesOutput",
    ModelPackageSummaryList: undefined,
    NextToken: undefined
  };
  if (output.ModelPackageSummaryList !== undefined) {
    contents.ModelPackageSummaryList = deserializeAws_json1_1ModelPackageSummaryList(
      output.ModelPackageSummaryList,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListModelsOutput = (
  output: any,
  context: __SerdeContext
): ListModelsOutput => {
  let contents: any = {
    __type: "ListModelsOutput",
    Models: undefined,
    NextToken: undefined
  };
  if (output.Models !== undefined) {
    contents.Models = deserializeAws_json1_1ModelSummaryList(
      output.Models,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListMonitoringExecutionsResponse = (
  output: any,
  context: __SerdeContext
): ListMonitoringExecutionsResponse => {
  let contents: any = {
    __type: "ListMonitoringExecutionsResponse",
    MonitoringExecutionSummaries: undefined,
    NextToken: undefined
  };
  if (output.MonitoringExecutionSummaries !== undefined) {
    contents.MonitoringExecutionSummaries = deserializeAws_json1_1MonitoringExecutionSummaryList(
      output.MonitoringExecutionSummaries,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListMonitoringSchedulesResponse = (
  output: any,
  context: __SerdeContext
): ListMonitoringSchedulesResponse => {
  let contents: any = {
    __type: "ListMonitoringSchedulesResponse",
    MonitoringScheduleSummaries: undefined,
    NextToken: undefined
  };
  if (output.MonitoringScheduleSummaries !== undefined) {
    contents.MonitoringScheduleSummaries = deserializeAws_json1_1MonitoringScheduleSummaryList(
      output.MonitoringScheduleSummaries,
      context
    );
  }
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListNotebookInstanceLifecycleConfigsOutput = (
  output: any,
  context: __SerdeContext
): ListNotebookInstanceLifecycleConfigsOutput => {
  let contents: any = {
    __type: "ListNotebookInstanceLifecycleConfigsOutput",
    NextToken: undefined,
    NotebookInstanceLifecycleConfigs: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.NotebookInstanceLifecycleConfigs !== undefined) {
    contents.NotebookInstanceLifecycleConfigs = deserializeAws_json1_1NotebookInstanceLifecycleConfigSummaryList(
      output.NotebookInstanceLifecycleConfigs,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListNotebookInstancesOutput = (
  output: any,
  context: __SerdeContext
): ListNotebookInstancesOutput => {
  let contents: any = {
    __type: "ListNotebookInstancesOutput",
    NextToken: undefined,
    NotebookInstances: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.NotebookInstances !== undefined) {
    contents.NotebookInstances = deserializeAws_json1_1NotebookInstanceSummaryList(
      output.NotebookInstances,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListProcessingJobsResponse = (
  output: any,
  context: __SerdeContext
): ListProcessingJobsResponse => {
  let contents: any = {
    __type: "ListProcessingJobsResponse",
    NextToken: undefined,
    ProcessingJobSummaries: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.ProcessingJobSummaries !== undefined) {
    contents.ProcessingJobSummaries = deserializeAws_json1_1ProcessingJobSummaries(
      output.ProcessingJobSummaries,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListSubscribedWorkteamsResponse = (
  output: any,
  context: __SerdeContext
): ListSubscribedWorkteamsResponse => {
  let contents: any = {
    __type: "ListSubscribedWorkteamsResponse",
    NextToken: undefined,
    SubscribedWorkteams: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.SubscribedWorkteams !== undefined) {
    contents.SubscribedWorkteams = deserializeAws_json1_1SubscribedWorkteams(
      output.SubscribedWorkteams,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTagsOutput = (
  output: any,
  context: __SerdeContext
): ListTagsOutput => {
  let contents: any = {
    __type: "ListTagsOutput",
    NextToken: undefined,
    Tags: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.Tags !== undefined) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1ListTrainingJobsForHyperParameterTuningJobResponse = (
  output: any,
  context: __SerdeContext
): ListTrainingJobsForHyperParameterTuningJobResponse => {
  let contents: any = {
    __type: "ListTrainingJobsForHyperParameterTuningJobResponse",
    NextToken: undefined,
    TrainingJobSummaries: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.TrainingJobSummaries !== undefined) {
    contents.TrainingJobSummaries = deserializeAws_json1_1HyperParameterTrainingJobSummaries(
      output.TrainingJobSummaries,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTrainingJobsResponse = (
  output: any,
  context: __SerdeContext
): ListTrainingJobsResponse => {
  let contents: any = {
    __type: "ListTrainingJobsResponse",
    NextToken: undefined,
    TrainingJobSummaries: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.TrainingJobSummaries !== undefined) {
    contents.TrainingJobSummaries = deserializeAws_json1_1TrainingJobSummaries(
      output.TrainingJobSummaries,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTransformJobsResponse = (
  output: any,
  context: __SerdeContext
): ListTransformJobsResponse => {
  let contents: any = {
    __type: "ListTransformJobsResponse",
    NextToken: undefined,
    TransformJobSummaries: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.TransformJobSummaries !== undefined) {
    contents.TransformJobSummaries = deserializeAws_json1_1TransformJobSummaries(
      output.TransformJobSummaries,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTrialComponentsResponse = (
  output: any,
  context: __SerdeContext
): ListTrialComponentsResponse => {
  let contents: any = {
    __type: "ListTrialComponentsResponse",
    NextToken: undefined,
    TrialComponentSummaries: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.TrialComponentSummaries !== undefined) {
    contents.TrialComponentSummaries = deserializeAws_json1_1TrialComponentSummaries(
      output.TrialComponentSummaries,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTrialsResponse = (
  output: any,
  context: __SerdeContext
): ListTrialsResponse => {
  let contents: any = {
    __type: "ListTrialsResponse",
    NextToken: undefined,
    TrialSummaries: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.TrialSummaries !== undefined) {
    contents.TrialSummaries = deserializeAws_json1_1TrialSummaries(
      output.TrialSummaries,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListUserProfilesResponse = (
  output: any,
  context: __SerdeContext
): ListUserProfilesResponse => {
  let contents: any = {
    __type: "ListUserProfilesResponse",
    NextToken: undefined,
    UserProfiles: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.UserProfiles !== undefined) {
    contents.UserProfiles = deserializeAws_json1_1UserProfileList(
      output.UserProfiles,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListWorkteamsResponse = (
  output: any,
  context: __SerdeContext
): ListWorkteamsResponse => {
  let contents: any = {
    __type: "ListWorkteamsResponse",
    NextToken: undefined,
    Workteams: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.Workteams !== undefined) {
    contents.Workteams = deserializeAws_json1_1Workteams(
      output.Workteams,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MemberDefinition = (
  output: any,
  context: __SerdeContext
): MemberDefinition => {
  let contents: any = {
    __type: "MemberDefinition",
    CognitoMemberDefinition: undefined
  };
  if (output.CognitoMemberDefinition !== undefined) {
    contents.CognitoMemberDefinition = deserializeAws_json1_1CognitoMemberDefinition(
      output.CognitoMemberDefinition,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MemberDefinitions = (
  output: any,
  context: __SerdeContext
): Array<MemberDefinition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MemberDefinition(entry, context)
  );
};

const deserializeAws_json1_1MetricData = (
  output: any,
  context: __SerdeContext
): MetricData => {
  let contents: any = {
    __type: "MetricData",
    MetricName: undefined,
    Timestamp: undefined,
    Value: undefined
  };
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  if (output.Timestamp !== undefined) {
    contents.Timestamp = new Date(Math.round(output.Timestamp * 1000));
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1MetricDefinition = (
  output: any,
  context: __SerdeContext
): MetricDefinition => {
  let contents: any = {
    __type: "MetricDefinition",
    Name: undefined,
    Regex: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.Regex !== undefined) {
    contents.Regex = output.Regex;
  }
  return contents;
};

const deserializeAws_json1_1MetricDefinitionList = (
  output: any,
  context: __SerdeContext
): Array<MetricDefinition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MetricDefinition(entry, context)
  );
};

const deserializeAws_json1_1ModelArtifacts = (
  output: any,
  context: __SerdeContext
): ModelArtifacts => {
  let contents: any = {
    __type: "ModelArtifacts",
    S3ModelArtifacts: undefined
  };
  if (output.S3ModelArtifacts !== undefined) {
    contents.S3ModelArtifacts = output.S3ModelArtifacts;
  }
  return contents;
};

const deserializeAws_json1_1ModelPackageContainerDefinition = (
  output: any,
  context: __SerdeContext
): ModelPackageContainerDefinition => {
  let contents: any = {
    __type: "ModelPackageContainerDefinition",
    ContainerHostname: undefined,
    Image: undefined,
    ImageDigest: undefined,
    ModelDataUrl: undefined,
    ProductId: undefined
  };
  if (output.ContainerHostname !== undefined) {
    contents.ContainerHostname = output.ContainerHostname;
  }
  if (output.Image !== undefined) {
    contents.Image = output.Image;
  }
  if (output.ImageDigest !== undefined) {
    contents.ImageDigest = output.ImageDigest;
  }
  if (output.ModelDataUrl !== undefined) {
    contents.ModelDataUrl = output.ModelDataUrl;
  }
  if (output.ProductId !== undefined) {
    contents.ProductId = output.ProductId;
  }
  return contents;
};

const deserializeAws_json1_1ModelPackageContainerDefinitionList = (
  output: any,
  context: __SerdeContext
): Array<ModelPackageContainerDefinition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ModelPackageContainerDefinition(entry, context)
  );
};

const deserializeAws_json1_1ModelPackageStatusDetails = (
  output: any,
  context: __SerdeContext
): ModelPackageStatusDetails => {
  let contents: any = {
    __type: "ModelPackageStatusDetails",
    ImageScanStatuses: undefined,
    ValidationStatuses: undefined
  };
  if (output.ImageScanStatuses !== undefined) {
    contents.ImageScanStatuses = deserializeAws_json1_1ModelPackageStatusItemList(
      output.ImageScanStatuses,
      context
    );
  }
  if (output.ValidationStatuses !== undefined) {
    contents.ValidationStatuses = deserializeAws_json1_1ModelPackageStatusItemList(
      output.ValidationStatuses,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ModelPackageStatusItem = (
  output: any,
  context: __SerdeContext
): ModelPackageStatusItem => {
  let contents: any = {
    __type: "ModelPackageStatusItem",
    FailureReason: undefined,
    Name: undefined,
    Status: undefined
  };
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1ModelPackageStatusItemList = (
  output: any,
  context: __SerdeContext
): Array<ModelPackageStatusItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ModelPackageStatusItem(entry, context)
  );
};

const deserializeAws_json1_1ModelPackageSummary = (
  output: any,
  context: __SerdeContext
): ModelPackageSummary => {
  let contents: any = {
    __type: "ModelPackageSummary",
    CreationTime: undefined,
    ModelPackageArn: undefined,
    ModelPackageDescription: undefined,
    ModelPackageName: undefined,
    ModelPackageStatus: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.ModelPackageArn !== undefined) {
    contents.ModelPackageArn = output.ModelPackageArn;
  }
  if (output.ModelPackageDescription !== undefined) {
    contents.ModelPackageDescription = output.ModelPackageDescription;
  }
  if (output.ModelPackageName !== undefined) {
    contents.ModelPackageName = output.ModelPackageName;
  }
  if (output.ModelPackageStatus !== undefined) {
    contents.ModelPackageStatus = output.ModelPackageStatus;
  }
  return contents;
};

const deserializeAws_json1_1ModelPackageSummaryList = (
  output: any,
  context: __SerdeContext
): Array<ModelPackageSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ModelPackageSummary(entry, context)
  );
};

const deserializeAws_json1_1ModelPackageValidationProfile = (
  output: any,
  context: __SerdeContext
): ModelPackageValidationProfile => {
  let contents: any = {
    __type: "ModelPackageValidationProfile",
    ProfileName: undefined,
    TransformJobDefinition: undefined
  };
  if (output.ProfileName !== undefined) {
    contents.ProfileName = output.ProfileName;
  }
  if (output.TransformJobDefinition !== undefined) {
    contents.TransformJobDefinition = deserializeAws_json1_1TransformJobDefinition(
      output.TransformJobDefinition,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ModelPackageValidationProfiles = (
  output: any,
  context: __SerdeContext
): Array<ModelPackageValidationProfile> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ModelPackageValidationProfile(entry, context)
  );
};

const deserializeAws_json1_1ModelPackageValidationSpecification = (
  output: any,
  context: __SerdeContext
): ModelPackageValidationSpecification => {
  let contents: any = {
    __type: "ModelPackageValidationSpecification",
    ValidationProfiles: undefined,
    ValidationRole: undefined
  };
  if (output.ValidationProfiles !== undefined) {
    contents.ValidationProfiles = deserializeAws_json1_1ModelPackageValidationProfiles(
      output.ValidationProfiles,
      context
    );
  }
  if (output.ValidationRole !== undefined) {
    contents.ValidationRole = output.ValidationRole;
  }
  return contents;
};

const deserializeAws_json1_1ModelSummary = (
  output: any,
  context: __SerdeContext
): ModelSummary => {
  let contents: any = {
    __type: "ModelSummary",
    CreationTime: undefined,
    ModelArn: undefined,
    ModelName: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.ModelArn !== undefined) {
    contents.ModelArn = output.ModelArn;
  }
  if (output.ModelName !== undefined) {
    contents.ModelName = output.ModelName;
  }
  return contents;
};

const deserializeAws_json1_1ModelSummaryList = (
  output: any,
  context: __SerdeContext
): Array<ModelSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ModelSummary(entry, context)
  );
};

const deserializeAws_json1_1MonitoringAppSpecification = (
  output: any,
  context: __SerdeContext
): MonitoringAppSpecification => {
  let contents: any = {
    __type: "MonitoringAppSpecification",
    ContainerArguments: undefined,
    ContainerEntrypoint: undefined,
    ImageUri: undefined,
    PostAnalyticsProcessorSourceUri: undefined,
    RecordPreprocessorSourceUri: undefined
  };
  if (output.ContainerArguments !== undefined) {
    contents.ContainerArguments = deserializeAws_json1_1MonitoringContainerArguments(
      output.ContainerArguments,
      context
    );
  }
  if (output.ContainerEntrypoint !== undefined) {
    contents.ContainerEntrypoint = deserializeAws_json1_1ContainerEntrypoint(
      output.ContainerEntrypoint,
      context
    );
  }
  if (output.ImageUri !== undefined) {
    contents.ImageUri = output.ImageUri;
  }
  if (output.PostAnalyticsProcessorSourceUri !== undefined) {
    contents.PostAnalyticsProcessorSourceUri =
      output.PostAnalyticsProcessorSourceUri;
  }
  if (output.RecordPreprocessorSourceUri !== undefined) {
    contents.RecordPreprocessorSourceUri = output.RecordPreprocessorSourceUri;
  }
  return contents;
};

const deserializeAws_json1_1MonitoringBaselineConfig = (
  output: any,
  context: __SerdeContext
): MonitoringBaselineConfig => {
  let contents: any = {
    __type: "MonitoringBaselineConfig",
    ConstraintsResource: undefined,
    StatisticsResource: undefined
  };
  if (output.ConstraintsResource !== undefined) {
    contents.ConstraintsResource = deserializeAws_json1_1MonitoringConstraintsResource(
      output.ConstraintsResource,
      context
    );
  }
  if (output.StatisticsResource !== undefined) {
    contents.StatisticsResource = deserializeAws_json1_1MonitoringStatisticsResource(
      output.StatisticsResource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MonitoringClusterConfig = (
  output: any,
  context: __SerdeContext
): MonitoringClusterConfig => {
  let contents: any = {
    __type: "MonitoringClusterConfig",
    InstanceCount: undefined,
    InstanceType: undefined,
    VolumeKmsKeyId: undefined,
    VolumeSizeInGB: undefined
  };
  if (output.InstanceCount !== undefined) {
    contents.InstanceCount = output.InstanceCount;
  }
  if (output.InstanceType !== undefined) {
    contents.InstanceType = output.InstanceType;
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VolumeSizeInGB !== undefined) {
    contents.VolumeSizeInGB = output.VolumeSizeInGB;
  }
  return contents;
};

const deserializeAws_json1_1MonitoringConstraintsResource = (
  output: any,
  context: __SerdeContext
): MonitoringConstraintsResource => {
  let contents: any = {
    __type: "MonitoringConstraintsResource",
    S3Uri: undefined
  };
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1MonitoringContainerArguments = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1MonitoringEnvironmentMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1MonitoringExecutionSummary = (
  output: any,
  context: __SerdeContext
): MonitoringExecutionSummary => {
  let contents: any = {
    __type: "MonitoringExecutionSummary",
    CreationTime: undefined,
    EndpointName: undefined,
    FailureReason: undefined,
    LastModifiedTime: undefined,
    MonitoringExecutionStatus: undefined,
    MonitoringScheduleName: undefined,
    ProcessingJobArn: undefined,
    ScheduledTime: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.EndpointName !== undefined) {
    contents.EndpointName = output.EndpointName;
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.MonitoringExecutionStatus !== undefined) {
    contents.MonitoringExecutionStatus = output.MonitoringExecutionStatus;
  }
  if (output.MonitoringScheduleName !== undefined) {
    contents.MonitoringScheduleName = output.MonitoringScheduleName;
  }
  if (output.ProcessingJobArn !== undefined) {
    contents.ProcessingJobArn = output.ProcessingJobArn;
  }
  if (output.ScheduledTime !== undefined) {
    contents.ScheduledTime = new Date(Math.round(output.ScheduledTime * 1000));
  }
  return contents;
};

const deserializeAws_json1_1MonitoringExecutionSummaryList = (
  output: any,
  context: __SerdeContext
): Array<MonitoringExecutionSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MonitoringExecutionSummary(entry, context)
  );
};

const deserializeAws_json1_1MonitoringInput = (
  output: any,
  context: __SerdeContext
): MonitoringInput => {
  let contents: any = {
    __type: "MonitoringInput",
    EndpointInput: undefined
  };
  if (output.EndpointInput !== undefined) {
    contents.EndpointInput = deserializeAws_json1_1EndpointInput(
      output.EndpointInput,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MonitoringInputs = (
  output: any,
  context: __SerdeContext
): Array<MonitoringInput> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MonitoringInput(entry, context)
  );
};

const deserializeAws_json1_1MonitoringJobDefinition = (
  output: any,
  context: __SerdeContext
): MonitoringJobDefinition => {
  let contents: any = {
    __type: "MonitoringJobDefinition",
    BaselineConfig: undefined,
    Environment: undefined,
    MonitoringAppSpecification: undefined,
    MonitoringInputs: undefined,
    MonitoringOutputConfig: undefined,
    MonitoringResources: undefined,
    NetworkConfig: undefined,
    RoleArn: undefined,
    StoppingCondition: undefined
  };
  if (output.BaselineConfig !== undefined) {
    contents.BaselineConfig = deserializeAws_json1_1MonitoringBaselineConfig(
      output.BaselineConfig,
      context
    );
  }
  if (output.Environment !== undefined) {
    contents.Environment = deserializeAws_json1_1MonitoringEnvironmentMap(
      output.Environment,
      context
    );
  }
  if (output.MonitoringAppSpecification !== undefined) {
    contents.MonitoringAppSpecification = deserializeAws_json1_1MonitoringAppSpecification(
      output.MonitoringAppSpecification,
      context
    );
  }
  if (output.MonitoringInputs !== undefined) {
    contents.MonitoringInputs = deserializeAws_json1_1MonitoringInputs(
      output.MonitoringInputs,
      context
    );
  }
  if (output.MonitoringOutputConfig !== undefined) {
    contents.MonitoringOutputConfig = deserializeAws_json1_1MonitoringOutputConfig(
      output.MonitoringOutputConfig,
      context
    );
  }
  if (output.MonitoringResources !== undefined) {
    contents.MonitoringResources = deserializeAws_json1_1MonitoringResources(
      output.MonitoringResources,
      context
    );
  }
  if (output.NetworkConfig !== undefined) {
    contents.NetworkConfig = deserializeAws_json1_1NetworkConfig(
      output.NetworkConfig,
      context
    );
  }
  if (output.RoleArn !== undefined) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.StoppingCondition !== undefined) {
    contents.StoppingCondition = deserializeAws_json1_1MonitoringStoppingCondition(
      output.StoppingCondition,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MonitoringOutput = (
  output: any,
  context: __SerdeContext
): MonitoringOutput => {
  let contents: any = {
    __type: "MonitoringOutput",
    S3Output: undefined
  };
  if (output.S3Output !== undefined) {
    contents.S3Output = deserializeAws_json1_1MonitoringS3Output(
      output.S3Output,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MonitoringOutputConfig = (
  output: any,
  context: __SerdeContext
): MonitoringOutputConfig => {
  let contents: any = {
    __type: "MonitoringOutputConfig",
    KmsKeyId: undefined,
    MonitoringOutputs: undefined
  };
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.MonitoringOutputs !== undefined) {
    contents.MonitoringOutputs = deserializeAws_json1_1MonitoringOutputs(
      output.MonitoringOutputs,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MonitoringOutputs = (
  output: any,
  context: __SerdeContext
): Array<MonitoringOutput> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MonitoringOutput(entry, context)
  );
};

const deserializeAws_json1_1MonitoringResources = (
  output: any,
  context: __SerdeContext
): MonitoringResources => {
  let contents: any = {
    __type: "MonitoringResources",
    ClusterConfig: undefined
  };
  if (output.ClusterConfig !== undefined) {
    contents.ClusterConfig = deserializeAws_json1_1MonitoringClusterConfig(
      output.ClusterConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MonitoringS3Output = (
  output: any,
  context: __SerdeContext
): MonitoringS3Output => {
  let contents: any = {
    __type: "MonitoringS3Output",
    LocalPath: undefined,
    S3UploadMode: undefined,
    S3Uri: undefined
  };
  if (output.LocalPath !== undefined) {
    contents.LocalPath = output.LocalPath;
  }
  if (output.S3UploadMode !== undefined) {
    contents.S3UploadMode = output.S3UploadMode;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1MonitoringScheduleConfig = (
  output: any,
  context: __SerdeContext
): MonitoringScheduleConfig => {
  let contents: any = {
    __type: "MonitoringScheduleConfig",
    MonitoringJobDefinition: undefined,
    ScheduleConfig: undefined
  };
  if (output.MonitoringJobDefinition !== undefined) {
    contents.MonitoringJobDefinition = deserializeAws_json1_1MonitoringJobDefinition(
      output.MonitoringJobDefinition,
      context
    );
  }
  if (output.ScheduleConfig !== undefined) {
    contents.ScheduleConfig = deserializeAws_json1_1ScheduleConfig(
      output.ScheduleConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MonitoringScheduleSummary = (
  output: any,
  context: __SerdeContext
): MonitoringScheduleSummary => {
  let contents: any = {
    __type: "MonitoringScheduleSummary",
    CreationTime: undefined,
    EndpointName: undefined,
    LastModifiedTime: undefined,
    MonitoringScheduleArn: undefined,
    MonitoringScheduleName: undefined,
    MonitoringScheduleStatus: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.EndpointName !== undefined) {
    contents.EndpointName = output.EndpointName;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.MonitoringScheduleArn !== undefined) {
    contents.MonitoringScheduleArn = output.MonitoringScheduleArn;
  }
  if (output.MonitoringScheduleName !== undefined) {
    contents.MonitoringScheduleName = output.MonitoringScheduleName;
  }
  if (output.MonitoringScheduleStatus !== undefined) {
    contents.MonitoringScheduleStatus = output.MonitoringScheduleStatus;
  }
  return contents;
};

const deserializeAws_json1_1MonitoringScheduleSummaryList = (
  output: any,
  context: __SerdeContext
): Array<MonitoringScheduleSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MonitoringScheduleSummary(entry, context)
  );
};

const deserializeAws_json1_1MonitoringStatisticsResource = (
  output: any,
  context: __SerdeContext
): MonitoringStatisticsResource => {
  let contents: any = {
    __type: "MonitoringStatisticsResource",
    S3Uri: undefined
  };
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1MonitoringStoppingCondition = (
  output: any,
  context: __SerdeContext
): MonitoringStoppingCondition => {
  let contents: any = {
    __type: "MonitoringStoppingCondition",
    MaxRuntimeInSeconds: undefined
  };
  if (output.MaxRuntimeInSeconds !== undefined) {
    contents.MaxRuntimeInSeconds = output.MaxRuntimeInSeconds;
  }
  return contents;
};

const deserializeAws_json1_1NetworkConfig = (
  output: any,
  context: __SerdeContext
): NetworkConfig => {
  let contents: any = {
    __type: "NetworkConfig",
    EnableNetworkIsolation: undefined,
    VpcConfig: undefined
  };
  if (output.EnableNetworkIsolation !== undefined) {
    contents.EnableNetworkIsolation = output.EnableNetworkIsolation;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1NotebookInstanceAcceleratorTypes = (
  output: any,
  context: __SerdeContext
): Array<NotebookInstanceAcceleratorType | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1NotebookInstanceLifecycleConfigList = (
  output: any,
  context: __SerdeContext
): Array<NotebookInstanceLifecycleHook> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1NotebookInstanceLifecycleHook(entry, context)
  );
};

const deserializeAws_json1_1NotebookInstanceLifecycleConfigSummary = (
  output: any,
  context: __SerdeContext
): NotebookInstanceLifecycleConfigSummary => {
  let contents: any = {
    __type: "NotebookInstanceLifecycleConfigSummary",
    CreationTime: undefined,
    LastModifiedTime: undefined,
    NotebookInstanceLifecycleConfigArn: undefined,
    NotebookInstanceLifecycleConfigName: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.NotebookInstanceLifecycleConfigArn !== undefined) {
    contents.NotebookInstanceLifecycleConfigArn =
      output.NotebookInstanceLifecycleConfigArn;
  }
  if (output.NotebookInstanceLifecycleConfigName !== undefined) {
    contents.NotebookInstanceLifecycleConfigName =
      output.NotebookInstanceLifecycleConfigName;
  }
  return contents;
};

const deserializeAws_json1_1NotebookInstanceLifecycleConfigSummaryList = (
  output: any,
  context: __SerdeContext
): Array<NotebookInstanceLifecycleConfigSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1NotebookInstanceLifecycleConfigSummary(entry, context)
  );
};

const deserializeAws_json1_1NotebookInstanceLifecycleHook = (
  output: any,
  context: __SerdeContext
): NotebookInstanceLifecycleHook => {
  let contents: any = {
    __type: "NotebookInstanceLifecycleHook",
    Content: undefined
  };
  if (output.Content !== undefined) {
    contents.Content = output.Content;
  }
  return contents;
};

const deserializeAws_json1_1NotebookInstanceSummary = (
  output: any,
  context: __SerdeContext
): NotebookInstanceSummary => {
  let contents: any = {
    __type: "NotebookInstanceSummary",
    AdditionalCodeRepositories: undefined,
    CreationTime: undefined,
    DefaultCodeRepository: undefined,
    InstanceType: undefined,
    LastModifiedTime: undefined,
    NotebookInstanceArn: undefined,
    NotebookInstanceLifecycleConfigName: undefined,
    NotebookInstanceName: undefined,
    NotebookInstanceStatus: undefined,
    Url: undefined
  };
  if (output.AdditionalCodeRepositories !== undefined) {
    contents.AdditionalCodeRepositories = deserializeAws_json1_1AdditionalCodeRepositoryNamesOrUrls(
      output.AdditionalCodeRepositories,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DefaultCodeRepository !== undefined) {
    contents.DefaultCodeRepository = output.DefaultCodeRepository;
  }
  if (output.InstanceType !== undefined) {
    contents.InstanceType = output.InstanceType;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.NotebookInstanceArn !== undefined) {
    contents.NotebookInstanceArn = output.NotebookInstanceArn;
  }
  if (output.NotebookInstanceLifecycleConfigName !== undefined) {
    contents.NotebookInstanceLifecycleConfigName =
      output.NotebookInstanceLifecycleConfigName;
  }
  if (output.NotebookInstanceName !== undefined) {
    contents.NotebookInstanceName = output.NotebookInstanceName;
  }
  if (output.NotebookInstanceStatus !== undefined) {
    contents.NotebookInstanceStatus = output.NotebookInstanceStatus;
  }
  if (output.Url !== undefined) {
    contents.Url = output.Url;
  }
  return contents;
};

const deserializeAws_json1_1NotebookInstanceSummaryList = (
  output: any,
  context: __SerdeContext
): Array<NotebookInstanceSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1NotebookInstanceSummary(entry, context)
  );
};

const deserializeAws_json1_1NotificationConfiguration = (
  output: any,
  context: __SerdeContext
): NotificationConfiguration => {
  let contents: any = {
    __type: "NotificationConfiguration",
    NotificationTopicArn: undefined
  };
  if (output.NotificationTopicArn !== undefined) {
    contents.NotificationTopicArn = output.NotificationTopicArn;
  }
  return contents;
};

const deserializeAws_json1_1ObjectiveStatusCounters = (
  output: any,
  context: __SerdeContext
): ObjectiveStatusCounters => {
  let contents: any = {
    __type: "ObjectiveStatusCounters",
    Failed: undefined,
    Pending: undefined,
    Succeeded: undefined
  };
  if (output.Failed !== undefined) {
    contents.Failed = output.Failed;
  }
  if (output.Pending !== undefined) {
    contents.Pending = output.Pending;
  }
  if (output.Succeeded !== undefined) {
    contents.Succeeded = output.Succeeded;
  }
  return contents;
};

const deserializeAws_json1_1OutputConfig = (
  output: any,
  context: __SerdeContext
): OutputConfig => {
  let contents: any = {
    __type: "OutputConfig",
    S3OutputLocation: undefined,
    TargetDevice: undefined
  };
  if (output.S3OutputLocation !== undefined) {
    contents.S3OutputLocation = output.S3OutputLocation;
  }
  if (output.TargetDevice !== undefined) {
    contents.TargetDevice = output.TargetDevice;
  }
  return contents;
};

const deserializeAws_json1_1OutputDataConfig = (
  output: any,
  context: __SerdeContext
): OutputDataConfig => {
  let contents: any = {
    __type: "OutputDataConfig",
    KmsKeyId: undefined,
    S3OutputPath: undefined
  };
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.S3OutputPath !== undefined) {
    contents.S3OutputPath = output.S3OutputPath;
  }
  return contents;
};

const deserializeAws_json1_1ParameterRange = (
  output: any,
  context: __SerdeContext
): ParameterRange => {
  let contents: any = {
    __type: "ParameterRange",
    CategoricalParameterRangeSpecification: undefined,
    ContinuousParameterRangeSpecification: undefined,
    IntegerParameterRangeSpecification: undefined
  };
  if (output.CategoricalParameterRangeSpecification !== undefined) {
    contents.CategoricalParameterRangeSpecification = deserializeAws_json1_1CategoricalParameterRangeSpecification(
      output.CategoricalParameterRangeSpecification,
      context
    );
  }
  if (output.ContinuousParameterRangeSpecification !== undefined) {
    contents.ContinuousParameterRangeSpecification = deserializeAws_json1_1ContinuousParameterRangeSpecification(
      output.ContinuousParameterRangeSpecification,
      context
    );
  }
  if (output.IntegerParameterRangeSpecification !== undefined) {
    contents.IntegerParameterRangeSpecification = deserializeAws_json1_1IntegerParameterRangeSpecification(
      output.IntegerParameterRangeSpecification,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ParameterRanges = (
  output: any,
  context: __SerdeContext
): ParameterRanges => {
  let contents: any = {
    __type: "ParameterRanges",
    CategoricalParameterRanges: undefined,
    ContinuousParameterRanges: undefined,
    IntegerParameterRanges: undefined
  };
  if (output.CategoricalParameterRanges !== undefined) {
    contents.CategoricalParameterRanges = deserializeAws_json1_1CategoricalParameterRanges(
      output.CategoricalParameterRanges,
      context
    );
  }
  if (output.ContinuousParameterRanges !== undefined) {
    contents.ContinuousParameterRanges = deserializeAws_json1_1ContinuousParameterRanges(
      output.ContinuousParameterRanges,
      context
    );
  }
  if (output.IntegerParameterRanges !== undefined) {
    contents.IntegerParameterRanges = deserializeAws_json1_1IntegerParameterRanges(
      output.IntegerParameterRanges,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ParameterValues = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Parent = (
  output: any,
  context: __SerdeContext
): Parent => {
  let contents: any = {
    __type: "Parent",
    ExperimentName: undefined,
    TrialName: undefined
  };
  if (output.ExperimentName !== undefined) {
    contents.ExperimentName = output.ExperimentName;
  }
  if (output.TrialName !== undefined) {
    contents.TrialName = output.TrialName;
  }
  return contents;
};

const deserializeAws_json1_1ParentHyperParameterTuningJob = (
  output: any,
  context: __SerdeContext
): ParentHyperParameterTuningJob => {
  let contents: any = {
    __type: "ParentHyperParameterTuningJob",
    HyperParameterTuningJobName: undefined
  };
  if (output.HyperParameterTuningJobName !== undefined) {
    contents.HyperParameterTuningJobName = output.HyperParameterTuningJobName;
  }
  return contents;
};

const deserializeAws_json1_1ParentHyperParameterTuningJobs = (
  output: any,
  context: __SerdeContext
): Array<ParentHyperParameterTuningJob> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ParentHyperParameterTuningJob(entry, context)
  );
};

const deserializeAws_json1_1Parents = (
  output: any,
  context: __SerdeContext
): Array<Parent> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Parent(entry, context)
  );
};

const deserializeAws_json1_1ProcessingClusterConfig = (
  output: any,
  context: __SerdeContext
): ProcessingClusterConfig => {
  let contents: any = {
    __type: "ProcessingClusterConfig",
    InstanceCount: undefined,
    InstanceType: undefined,
    VolumeKmsKeyId: undefined,
    VolumeSizeInGB: undefined
  };
  if (output.InstanceCount !== undefined) {
    contents.InstanceCount = output.InstanceCount;
  }
  if (output.InstanceType !== undefined) {
    contents.InstanceType = output.InstanceType;
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VolumeSizeInGB !== undefined) {
    contents.VolumeSizeInGB = output.VolumeSizeInGB;
  }
  return contents;
};

const deserializeAws_json1_1ProcessingEnvironmentMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1ProcessingInput = (
  output: any,
  context: __SerdeContext
): ProcessingInput => {
  let contents: any = {
    __type: "ProcessingInput",
    InputName: undefined,
    S3Input: undefined
  };
  if (output.InputName !== undefined) {
    contents.InputName = output.InputName;
  }
  if (output.S3Input !== undefined) {
    contents.S3Input = deserializeAws_json1_1ProcessingS3Input(
      output.S3Input,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ProcessingInputs = (
  output: any,
  context: __SerdeContext
): Array<ProcessingInput> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ProcessingInput(entry, context)
  );
};

const deserializeAws_json1_1ProcessingJobSummaries = (
  output: any,
  context: __SerdeContext
): Array<ProcessingJobSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ProcessingJobSummary(entry, context)
  );
};

const deserializeAws_json1_1ProcessingJobSummary = (
  output: any,
  context: __SerdeContext
): ProcessingJobSummary => {
  let contents: any = {
    __type: "ProcessingJobSummary",
    CreationTime: undefined,
    ExitMessage: undefined,
    FailureReason: undefined,
    LastModifiedTime: undefined,
    ProcessingEndTime: undefined,
    ProcessingJobArn: undefined,
    ProcessingJobName: undefined,
    ProcessingJobStatus: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.ExitMessage !== undefined) {
    contents.ExitMessage = output.ExitMessage;
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.ProcessingEndTime !== undefined) {
    contents.ProcessingEndTime = new Date(
      Math.round(output.ProcessingEndTime * 1000)
    );
  }
  if (output.ProcessingJobArn !== undefined) {
    contents.ProcessingJobArn = output.ProcessingJobArn;
  }
  if (output.ProcessingJobName !== undefined) {
    contents.ProcessingJobName = output.ProcessingJobName;
  }
  if (output.ProcessingJobStatus !== undefined) {
    contents.ProcessingJobStatus = output.ProcessingJobStatus;
  }
  return contents;
};

const deserializeAws_json1_1ProcessingOutput = (
  output: any,
  context: __SerdeContext
): ProcessingOutput => {
  let contents: any = {
    __type: "ProcessingOutput",
    OutputName: undefined,
    S3Output: undefined
  };
  if (output.OutputName !== undefined) {
    contents.OutputName = output.OutputName;
  }
  if (output.S3Output !== undefined) {
    contents.S3Output = deserializeAws_json1_1ProcessingS3Output(
      output.S3Output,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ProcessingOutputConfig = (
  output: any,
  context: __SerdeContext
): ProcessingOutputConfig => {
  let contents: any = {
    __type: "ProcessingOutputConfig",
    KmsKeyId: undefined,
    Outputs: undefined
  };
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.Outputs !== undefined) {
    contents.Outputs = deserializeAws_json1_1ProcessingOutputs(
      output.Outputs,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ProcessingOutputs = (
  output: any,
  context: __SerdeContext
): Array<ProcessingOutput> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ProcessingOutput(entry, context)
  );
};

const deserializeAws_json1_1ProcessingResources = (
  output: any,
  context: __SerdeContext
): ProcessingResources => {
  let contents: any = {
    __type: "ProcessingResources",
    ClusterConfig: undefined
  };
  if (output.ClusterConfig !== undefined) {
    contents.ClusterConfig = deserializeAws_json1_1ProcessingClusterConfig(
      output.ClusterConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ProcessingS3Input = (
  output: any,
  context: __SerdeContext
): ProcessingS3Input => {
  let contents: any = {
    __type: "ProcessingS3Input",
    LocalPath: undefined,
    S3CompressionType: undefined,
    S3DataDistributionType: undefined,
    S3DataType: undefined,
    S3InputMode: undefined,
    S3Uri: undefined
  };
  if (output.LocalPath !== undefined) {
    contents.LocalPath = output.LocalPath;
  }
  if (output.S3CompressionType !== undefined) {
    contents.S3CompressionType = output.S3CompressionType;
  }
  if (output.S3DataDistributionType !== undefined) {
    contents.S3DataDistributionType = output.S3DataDistributionType;
  }
  if (output.S3DataType !== undefined) {
    contents.S3DataType = output.S3DataType;
  }
  if (output.S3InputMode !== undefined) {
    contents.S3InputMode = output.S3InputMode;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1ProcessingS3Output = (
  output: any,
  context: __SerdeContext
): ProcessingS3Output => {
  let contents: any = {
    __type: "ProcessingS3Output",
    LocalPath: undefined,
    S3UploadMode: undefined,
    S3Uri: undefined
  };
  if (output.LocalPath !== undefined) {
    contents.LocalPath = output.LocalPath;
  }
  if (output.S3UploadMode !== undefined) {
    contents.S3UploadMode = output.S3UploadMode;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1ProcessingStoppingCondition = (
  output: any,
  context: __SerdeContext
): ProcessingStoppingCondition => {
  let contents: any = {
    __type: "ProcessingStoppingCondition",
    MaxRuntimeInSeconds: undefined
  };
  if (output.MaxRuntimeInSeconds !== undefined) {
    contents.MaxRuntimeInSeconds = output.MaxRuntimeInSeconds;
  }
  return contents;
};

const deserializeAws_json1_1ProductListings = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ProductionVariant = (
  output: any,
  context: __SerdeContext
): ProductionVariant => {
  let contents: any = {
    __type: "ProductionVariant",
    AcceleratorType: undefined,
    InitialInstanceCount: undefined,
    InitialVariantWeight: undefined,
    InstanceType: undefined,
    ModelName: undefined,
    VariantName: undefined
  };
  if (output.AcceleratorType !== undefined) {
    contents.AcceleratorType = output.AcceleratorType;
  }
  if (output.InitialInstanceCount !== undefined) {
    contents.InitialInstanceCount = output.InitialInstanceCount;
  }
  if (output.InitialVariantWeight !== undefined) {
    contents.InitialVariantWeight = output.InitialVariantWeight;
  }
  if (output.InstanceType !== undefined) {
    contents.InstanceType = output.InstanceType;
  }
  if (output.ModelName !== undefined) {
    contents.ModelName = output.ModelName;
  }
  if (output.VariantName !== undefined) {
    contents.VariantName = output.VariantName;
  }
  return contents;
};

const deserializeAws_json1_1ProductionVariantList = (
  output: any,
  context: __SerdeContext
): Array<ProductionVariant> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ProductionVariant(entry, context)
  );
};

const deserializeAws_json1_1ProductionVariantSummary = (
  output: any,
  context: __SerdeContext
): ProductionVariantSummary => {
  let contents: any = {
    __type: "ProductionVariantSummary",
    CurrentInstanceCount: undefined,
    CurrentWeight: undefined,
    DeployedImages: undefined,
    DesiredInstanceCount: undefined,
    DesiredWeight: undefined,
    VariantName: undefined
  };
  if (output.CurrentInstanceCount !== undefined) {
    contents.CurrentInstanceCount = output.CurrentInstanceCount;
  }
  if (output.CurrentWeight !== undefined) {
    contents.CurrentWeight = output.CurrentWeight;
  }
  if (output.DeployedImages !== undefined) {
    contents.DeployedImages = deserializeAws_json1_1DeployedImages(
      output.DeployedImages,
      context
    );
  }
  if (output.DesiredInstanceCount !== undefined) {
    contents.DesiredInstanceCount = output.DesiredInstanceCount;
  }
  if (output.DesiredWeight !== undefined) {
    contents.DesiredWeight = output.DesiredWeight;
  }
  if (output.VariantName !== undefined) {
    contents.VariantName = output.VariantName;
  }
  return contents;
};

const deserializeAws_json1_1ProductionVariantSummaryList = (
  output: any,
  context: __SerdeContext
): Array<ProductionVariantSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ProductionVariantSummary(entry, context)
  );
};

const deserializeAws_json1_1PropertyNameSuggestion = (
  output: any,
  context: __SerdeContext
): PropertyNameSuggestion => {
  let contents: any = {
    __type: "PropertyNameSuggestion",
    PropertyName: undefined
  };
  if (output.PropertyName !== undefined) {
    contents.PropertyName = output.PropertyName;
  }
  return contents;
};

const deserializeAws_json1_1PropertyNameSuggestionList = (
  output: any,
  context: __SerdeContext
): Array<PropertyNameSuggestion> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PropertyNameSuggestion(entry, context)
  );
};

const deserializeAws_json1_1PublicWorkforceTaskPrice = (
  output: any,
  context: __SerdeContext
): PublicWorkforceTaskPrice => {
  let contents: any = {
    __type: "PublicWorkforceTaskPrice",
    AmountInUsd: undefined
  };
  if (output.AmountInUsd !== undefined) {
    contents.AmountInUsd = deserializeAws_json1_1USD(
      output.AmountInUsd,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1RealtimeInferenceInstanceTypes = (
  output: any,
  context: __SerdeContext
): Array<ProductionVariantInstanceType | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1RenderUiTemplateResponse = (
  output: any,
  context: __SerdeContext
): RenderUiTemplateResponse => {
  let contents: any = {
    __type: "RenderUiTemplateResponse",
    Errors: undefined,
    RenderedContent: undefined
  };
  if (output.Errors !== undefined) {
    contents.Errors = deserializeAws_json1_1RenderingErrorList(
      output.Errors,
      context
    );
  }
  if (output.RenderedContent !== undefined) {
    contents.RenderedContent = output.RenderedContent;
  }
  return contents;
};

const deserializeAws_json1_1RenderingError = (
  output: any,
  context: __SerdeContext
): RenderingError => {
  let contents: any = {
    __type: "RenderingError",
    Code: undefined,
    Message: undefined
  };
  if (output.Code !== undefined) {
    contents.Code = output.Code;
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1RenderingErrorList = (
  output: any,
  context: __SerdeContext
): Array<RenderingError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RenderingError(entry, context)
  );
};

const deserializeAws_json1_1ResolvedAttributes = (
  output: any,
  context: __SerdeContext
): ResolvedAttributes => {
  let contents: any = {
    __type: "ResolvedAttributes",
    AutoMLJobObjective: undefined,
    CompletionCriteria: undefined,
    ProblemType: undefined
  };
  if (output.AutoMLJobObjective !== undefined) {
    contents.AutoMLJobObjective = deserializeAws_json1_1AutoMLJobObjective(
      output.AutoMLJobObjective,
      context
    );
  }
  if (output.CompletionCriteria !== undefined) {
    contents.CompletionCriteria = deserializeAws_json1_1AutoMLJobCompletionCriteria(
      output.CompletionCriteria,
      context
    );
  }
  if (output.ProblemType !== undefined) {
    contents.ProblemType = output.ProblemType;
  }
  return contents;
};

const deserializeAws_json1_1ResourceConfig = (
  output: any,
  context: __SerdeContext
): ResourceConfig => {
  let contents: any = {
    __type: "ResourceConfig",
    InstanceCount: undefined,
    InstanceType: undefined,
    VolumeKmsKeyId: undefined,
    VolumeSizeInGB: undefined
  };
  if (output.InstanceCount !== undefined) {
    contents.InstanceCount = output.InstanceCount;
  }
  if (output.InstanceType !== undefined) {
    contents.InstanceType = output.InstanceType;
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  if (output.VolumeSizeInGB !== undefined) {
    contents.VolumeSizeInGB = output.VolumeSizeInGB;
  }
  return contents;
};

const deserializeAws_json1_1ResourceInUse = (
  output: any,
  context: __SerdeContext
): ResourceInUse => {
  let contents: any = {
    __type: "ResourceInUse",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceLimitExceeded = (
  output: any,
  context: __SerdeContext
): ResourceLimitExceeded => {
  let contents: any = {
    __type: "ResourceLimitExceeded",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceLimits = (
  output: any,
  context: __SerdeContext
): ResourceLimits => {
  let contents: any = {
    __type: "ResourceLimits",
    MaxNumberOfTrainingJobs: undefined,
    MaxParallelTrainingJobs: undefined
  };
  if (output.MaxNumberOfTrainingJobs !== undefined) {
    contents.MaxNumberOfTrainingJobs = output.MaxNumberOfTrainingJobs;
  }
  if (output.MaxParallelTrainingJobs !== undefined) {
    contents.MaxParallelTrainingJobs = output.MaxParallelTrainingJobs;
  }
  return contents;
};

const deserializeAws_json1_1ResourceNotFound = (
  output: any,
  context: __SerdeContext
): ResourceNotFound => {
  let contents: any = {
    __type: "ResourceNotFound",
    Message: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceSpec = (
  output: any,
  context: __SerdeContext
): ResourceSpec => {
  let contents: any = {
    __type: "ResourceSpec",
    EnvironmentArn: undefined,
    InstanceType: undefined
  };
  if (output.EnvironmentArn !== undefined) {
    contents.EnvironmentArn = output.EnvironmentArn;
  }
  if (output.InstanceType !== undefined) {
    contents.InstanceType = output.InstanceType;
  }
  return contents;
};

const deserializeAws_json1_1ResponseMIMETypes = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1RuleParameters = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1S3DataSource = (
  output: any,
  context: __SerdeContext
): S3DataSource => {
  let contents: any = {
    __type: "S3DataSource",
    AttributeNames: undefined,
    S3DataDistributionType: undefined,
    S3DataType: undefined,
    S3Uri: undefined
  };
  if (output.AttributeNames !== undefined) {
    contents.AttributeNames = deserializeAws_json1_1AttributeNames(
      output.AttributeNames,
      context
    );
  }
  if (output.S3DataDistributionType !== undefined) {
    contents.S3DataDistributionType = output.S3DataDistributionType;
  }
  if (output.S3DataType !== undefined) {
    contents.S3DataType = output.S3DataType;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1ScheduleConfig = (
  output: any,
  context: __SerdeContext
): ScheduleConfig => {
  let contents: any = {
    __type: "ScheduleConfig",
    ScheduleExpression: undefined
  };
  if (output.ScheduleExpression !== undefined) {
    contents.ScheduleExpression = output.ScheduleExpression;
  }
  return contents;
};

const deserializeAws_json1_1SearchRecord = (
  output: any,
  context: __SerdeContext
): SearchRecord => {
  let contents: any = {
    __type: "SearchRecord",
    Experiment: undefined,
    TrainingJob: undefined,
    Trial: undefined,
    TrialComponent: undefined
  };
  if (output.Experiment !== undefined) {
    contents.Experiment = deserializeAws_json1_1Experiment(
      output.Experiment,
      context
    );
  }
  if (output.TrainingJob !== undefined) {
    contents.TrainingJob = deserializeAws_json1_1TrainingJob(
      output.TrainingJob,
      context
    );
  }
  if (output.Trial !== undefined) {
    contents.Trial = deserializeAws_json1_1Trial(output.Trial, context);
  }
  if (output.TrialComponent !== undefined) {
    contents.TrialComponent = deserializeAws_json1_1TrialComponent(
      output.TrialComponent,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1SearchResponse = (
  output: any,
  context: __SerdeContext
): SearchResponse => {
  let contents: any = {
    __type: "SearchResponse",
    NextToken: undefined,
    Results: undefined
  };
  if (output.NextToken !== undefined) {
    contents.NextToken = output.NextToken;
  }
  if (output.Results !== undefined) {
    contents.Results = deserializeAws_json1_1SearchResultsList(
      output.Results,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1SearchResultsList = (
  output: any,
  context: __SerdeContext
): Array<SearchRecord> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SearchRecord(entry, context)
  );
};

const deserializeAws_json1_1SecondaryStatusTransition = (
  output: any,
  context: __SerdeContext
): SecondaryStatusTransition => {
  let contents: any = {
    __type: "SecondaryStatusTransition",
    EndTime: undefined,
    StartTime: undefined,
    Status: undefined,
    StatusMessage: undefined
  };
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.StartTime !== undefined) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.StatusMessage !== undefined) {
    contents.StatusMessage = output.StatusMessage;
  }
  return contents;
};

const deserializeAws_json1_1SecondaryStatusTransitions = (
  output: any,
  context: __SerdeContext
): Array<SecondaryStatusTransition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SecondaryStatusTransition(entry, context)
  );
};

const deserializeAws_json1_1SecurityGroupIds = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SharingSettings = (
  output: any,
  context: __SerdeContext
): SharingSettings => {
  let contents: any = {
    __type: "SharingSettings",
    NotebookOutputOption: undefined,
    S3KmsKeyId: undefined,
    S3OutputPath: undefined
  };
  if (output.NotebookOutputOption !== undefined) {
    contents.NotebookOutputOption = output.NotebookOutputOption;
  }
  if (output.S3KmsKeyId !== undefined) {
    contents.S3KmsKeyId = output.S3KmsKeyId;
  }
  if (output.S3OutputPath !== undefined) {
    contents.S3OutputPath = output.S3OutputPath;
  }
  return contents;
};

const deserializeAws_json1_1ShuffleConfig = (
  output: any,
  context: __SerdeContext
): ShuffleConfig => {
  let contents: any = {
    __type: "ShuffleConfig",
    Seed: undefined
  };
  if (output.Seed !== undefined) {
    contents.Seed = output.Seed;
  }
  return contents;
};

const deserializeAws_json1_1SourceAlgorithm = (
  output: any,
  context: __SerdeContext
): SourceAlgorithm => {
  let contents: any = {
    __type: "SourceAlgorithm",
    AlgorithmName: undefined,
    ModelDataUrl: undefined
  };
  if (output.AlgorithmName !== undefined) {
    contents.AlgorithmName = output.AlgorithmName;
  }
  if (output.ModelDataUrl !== undefined) {
    contents.ModelDataUrl = output.ModelDataUrl;
  }
  return contents;
};

const deserializeAws_json1_1SourceAlgorithmList = (
  output: any,
  context: __SerdeContext
): Array<SourceAlgorithm> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SourceAlgorithm(entry, context)
  );
};

const deserializeAws_json1_1SourceAlgorithmSpecification = (
  output: any,
  context: __SerdeContext
): SourceAlgorithmSpecification => {
  let contents: any = {
    __type: "SourceAlgorithmSpecification",
    SourceAlgorithms: undefined
  };
  if (output.SourceAlgorithms !== undefined) {
    contents.SourceAlgorithms = deserializeAws_json1_1SourceAlgorithmList(
      output.SourceAlgorithms,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1SourceIpConfig = (
  output: any,
  context: __SerdeContext
): SourceIpConfig => {
  let contents: any = {
    __type: "SourceIpConfig",
    Cidrs: undefined
  };
  if (output.Cidrs !== undefined) {
    contents.Cidrs = deserializeAws_json1_1Cidrs(output.Cidrs, context);
  }
  return contents;
};

const deserializeAws_json1_1StoppingCondition = (
  output: any,
  context: __SerdeContext
): StoppingCondition => {
  let contents: any = {
    __type: "StoppingCondition",
    MaxRuntimeInSeconds: undefined,
    MaxWaitTimeInSeconds: undefined
  };
  if (output.MaxRuntimeInSeconds !== undefined) {
    contents.MaxRuntimeInSeconds = output.MaxRuntimeInSeconds;
  }
  if (output.MaxWaitTimeInSeconds !== undefined) {
    contents.MaxWaitTimeInSeconds = output.MaxWaitTimeInSeconds;
  }
  return contents;
};

const deserializeAws_json1_1Subnets = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SubscribedWorkteam = (
  output: any,
  context: __SerdeContext
): SubscribedWorkteam => {
  let contents: any = {
    __type: "SubscribedWorkteam",
    ListingId: undefined,
    MarketplaceDescription: undefined,
    MarketplaceTitle: undefined,
    SellerName: undefined,
    WorkteamArn: undefined
  };
  if (output.ListingId !== undefined) {
    contents.ListingId = output.ListingId;
  }
  if (output.MarketplaceDescription !== undefined) {
    contents.MarketplaceDescription = output.MarketplaceDescription;
  }
  if (output.MarketplaceTitle !== undefined) {
    contents.MarketplaceTitle = output.MarketplaceTitle;
  }
  if (output.SellerName !== undefined) {
    contents.SellerName = output.SellerName;
  }
  if (output.WorkteamArn !== undefined) {
    contents.WorkteamArn = output.WorkteamArn;
  }
  return contents;
};

const deserializeAws_json1_1SubscribedWorkteams = (
  output: any,
  context: __SerdeContext
): Array<SubscribedWorkteam> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SubscribedWorkteam(entry, context)
  );
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1TaskKeywords = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1TensorBoardAppSettings = (
  output: any,
  context: __SerdeContext
): TensorBoardAppSettings => {
  let contents: any = {
    __type: "TensorBoardAppSettings",
    DefaultResourceSpec: undefined
  };
  if (output.DefaultResourceSpec !== undefined) {
    contents.DefaultResourceSpec = deserializeAws_json1_1ResourceSpec(
      output.DefaultResourceSpec,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TensorBoardOutputConfig = (
  output: any,
  context: __SerdeContext
): TensorBoardOutputConfig => {
  let contents: any = {
    __type: "TensorBoardOutputConfig",
    LocalPath: undefined,
    S3OutputPath: undefined
  };
  if (output.LocalPath !== undefined) {
    contents.LocalPath = output.LocalPath;
  }
  if (output.S3OutputPath !== undefined) {
    contents.S3OutputPath = output.S3OutputPath;
  }
  return contents;
};

const deserializeAws_json1_1TrainingInstanceTypes = (
  output: any,
  context: __SerdeContext
): Array<TrainingInstanceType | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1TrainingJob = (
  output: any,
  context: __SerdeContext
): TrainingJob => {
  let contents: any = {
    __type: "TrainingJob",
    AlgorithmSpecification: undefined,
    AutoMLJobArn: undefined,
    BillableTimeInSeconds: undefined,
    CheckpointConfig: undefined,
    CreationTime: undefined,
    DebugHookConfig: undefined,
    DebugRuleConfigurations: undefined,
    DebugRuleEvaluationStatuses: undefined,
    EnableInterContainerTrafficEncryption: undefined,
    EnableManagedSpotTraining: undefined,
    EnableNetworkIsolation: undefined,
    ExperimentConfig: undefined,
    FailureReason: undefined,
    FinalMetricDataList: undefined,
    HyperParameters: undefined,
    InputDataConfig: undefined,
    LabelingJobArn: undefined,
    LastModifiedTime: undefined,
    ModelArtifacts: undefined,
    OutputDataConfig: undefined,
    ResourceConfig: undefined,
    RoleArn: undefined,
    SecondaryStatus: undefined,
    SecondaryStatusTransitions: undefined,
    StoppingCondition: undefined,
    Tags: undefined,
    TensorBoardOutputConfig: undefined,
    TrainingEndTime: undefined,
    TrainingJobArn: undefined,
    TrainingJobName: undefined,
    TrainingJobStatus: undefined,
    TrainingStartTime: undefined,
    TrainingTimeInSeconds: undefined,
    TuningJobArn: undefined,
    VpcConfig: undefined
  };
  if (output.AlgorithmSpecification !== undefined) {
    contents.AlgorithmSpecification = deserializeAws_json1_1AlgorithmSpecification(
      output.AlgorithmSpecification,
      context
    );
  }
  if (output.AutoMLJobArn !== undefined) {
    contents.AutoMLJobArn = output.AutoMLJobArn;
  }
  if (output.BillableTimeInSeconds !== undefined) {
    contents.BillableTimeInSeconds = output.BillableTimeInSeconds;
  }
  if (output.CheckpointConfig !== undefined) {
    contents.CheckpointConfig = deserializeAws_json1_1CheckpointConfig(
      output.CheckpointConfig,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DebugHookConfig !== undefined) {
    contents.DebugHookConfig = deserializeAws_json1_1DebugHookConfig(
      output.DebugHookConfig,
      context
    );
  }
  if (output.DebugRuleConfigurations !== undefined) {
    contents.DebugRuleConfigurations = deserializeAws_json1_1DebugRuleConfigurations(
      output.DebugRuleConfigurations,
      context
    );
  }
  if (output.DebugRuleEvaluationStatuses !== undefined) {
    contents.DebugRuleEvaluationStatuses = deserializeAws_json1_1DebugRuleEvaluationStatuses(
      output.DebugRuleEvaluationStatuses,
      context
    );
  }
  if (output.EnableInterContainerTrafficEncryption !== undefined) {
    contents.EnableInterContainerTrafficEncryption =
      output.EnableInterContainerTrafficEncryption;
  }
  if (output.EnableManagedSpotTraining !== undefined) {
    contents.EnableManagedSpotTraining = output.EnableManagedSpotTraining;
  }
  if (output.EnableNetworkIsolation !== undefined) {
    contents.EnableNetworkIsolation = output.EnableNetworkIsolation;
  }
  if (output.ExperimentConfig !== undefined) {
    contents.ExperimentConfig = deserializeAws_json1_1ExperimentConfig(
      output.ExperimentConfig,
      context
    );
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.FinalMetricDataList !== undefined) {
    contents.FinalMetricDataList = deserializeAws_json1_1FinalMetricDataList(
      output.FinalMetricDataList,
      context
    );
  }
  if (output.HyperParameters !== undefined) {
    contents.HyperParameters = deserializeAws_json1_1HyperParameters(
      output.HyperParameters,
      context
    );
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.LabelingJobArn !== undefined) {
    contents.LabelingJobArn = output.LabelingJobArn;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.ModelArtifacts !== undefined) {
    contents.ModelArtifacts = deserializeAws_json1_1ModelArtifacts(
      output.ModelArtifacts,
      context
    );
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.ResourceConfig !== undefined) {
    contents.ResourceConfig = deserializeAws_json1_1ResourceConfig(
      output.ResourceConfig,
      context
    );
  }
  if (output.RoleArn !== undefined) {
    contents.RoleArn = output.RoleArn;
  }
  if (output.SecondaryStatus !== undefined) {
    contents.SecondaryStatus = output.SecondaryStatus;
  }
  if (output.SecondaryStatusTransitions !== undefined) {
    contents.SecondaryStatusTransitions = deserializeAws_json1_1SecondaryStatusTransitions(
      output.SecondaryStatusTransitions,
      context
    );
  }
  if (output.StoppingCondition !== undefined) {
    contents.StoppingCondition = deserializeAws_json1_1StoppingCondition(
      output.StoppingCondition,
      context
    );
  }
  if (output.Tags !== undefined) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  if (output.TensorBoardOutputConfig !== undefined) {
    contents.TensorBoardOutputConfig = deserializeAws_json1_1TensorBoardOutputConfig(
      output.TensorBoardOutputConfig,
      context
    );
  }
  if (output.TrainingEndTime !== undefined) {
    contents.TrainingEndTime = new Date(
      Math.round(output.TrainingEndTime * 1000)
    );
  }
  if (output.TrainingJobArn !== undefined) {
    contents.TrainingJobArn = output.TrainingJobArn;
  }
  if (output.TrainingJobName !== undefined) {
    contents.TrainingJobName = output.TrainingJobName;
  }
  if (output.TrainingJobStatus !== undefined) {
    contents.TrainingJobStatus = output.TrainingJobStatus;
  }
  if (output.TrainingStartTime !== undefined) {
    contents.TrainingStartTime = new Date(
      Math.round(output.TrainingStartTime * 1000)
    );
  }
  if (output.TrainingTimeInSeconds !== undefined) {
    contents.TrainingTimeInSeconds = output.TrainingTimeInSeconds;
  }
  if (output.TuningJobArn !== undefined) {
    contents.TuningJobArn = output.TuningJobArn;
  }
  if (output.VpcConfig !== undefined) {
    contents.VpcConfig = deserializeAws_json1_1VpcConfig(
      output.VpcConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TrainingJobDefinition = (
  output: any,
  context: __SerdeContext
): TrainingJobDefinition => {
  let contents: any = {
    __type: "TrainingJobDefinition",
    HyperParameters: undefined,
    InputDataConfig: undefined,
    OutputDataConfig: undefined,
    ResourceConfig: undefined,
    StoppingCondition: undefined,
    TrainingInputMode: undefined
  };
  if (output.HyperParameters !== undefined) {
    contents.HyperParameters = deserializeAws_json1_1HyperParameters(
      output.HyperParameters,
      context
    );
  }
  if (output.InputDataConfig !== undefined) {
    contents.InputDataConfig = deserializeAws_json1_1InputDataConfig(
      output.InputDataConfig,
      context
    );
  }
  if (output.OutputDataConfig !== undefined) {
    contents.OutputDataConfig = deserializeAws_json1_1OutputDataConfig(
      output.OutputDataConfig,
      context
    );
  }
  if (output.ResourceConfig !== undefined) {
    contents.ResourceConfig = deserializeAws_json1_1ResourceConfig(
      output.ResourceConfig,
      context
    );
  }
  if (output.StoppingCondition !== undefined) {
    contents.StoppingCondition = deserializeAws_json1_1StoppingCondition(
      output.StoppingCondition,
      context
    );
  }
  if (output.TrainingInputMode !== undefined) {
    contents.TrainingInputMode = output.TrainingInputMode;
  }
  return contents;
};

const deserializeAws_json1_1TrainingJobStatusCounters = (
  output: any,
  context: __SerdeContext
): TrainingJobStatusCounters => {
  let contents: any = {
    __type: "TrainingJobStatusCounters",
    Completed: undefined,
    InProgress: undefined,
    NonRetryableError: undefined,
    RetryableError: undefined,
    Stopped: undefined
  };
  if (output.Completed !== undefined) {
    contents.Completed = output.Completed;
  }
  if (output.InProgress !== undefined) {
    contents.InProgress = output.InProgress;
  }
  if (output.NonRetryableError !== undefined) {
    contents.NonRetryableError = output.NonRetryableError;
  }
  if (output.RetryableError !== undefined) {
    contents.RetryableError = output.RetryableError;
  }
  if (output.Stopped !== undefined) {
    contents.Stopped = output.Stopped;
  }
  return contents;
};

const deserializeAws_json1_1TrainingJobSummaries = (
  output: any,
  context: __SerdeContext
): Array<TrainingJobSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TrainingJobSummary(entry, context)
  );
};

const deserializeAws_json1_1TrainingJobSummary = (
  output: any,
  context: __SerdeContext
): TrainingJobSummary => {
  let contents: any = {
    __type: "TrainingJobSummary",
    CreationTime: undefined,
    LastModifiedTime: undefined,
    TrainingEndTime: undefined,
    TrainingJobArn: undefined,
    TrainingJobName: undefined,
    TrainingJobStatus: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.TrainingEndTime !== undefined) {
    contents.TrainingEndTime = new Date(
      Math.round(output.TrainingEndTime * 1000)
    );
  }
  if (output.TrainingJobArn !== undefined) {
    contents.TrainingJobArn = output.TrainingJobArn;
  }
  if (output.TrainingJobName !== undefined) {
    contents.TrainingJobName = output.TrainingJobName;
  }
  if (output.TrainingJobStatus !== undefined) {
    contents.TrainingJobStatus = output.TrainingJobStatus;
  }
  return contents;
};

const deserializeAws_json1_1TrainingSpecification = (
  output: any,
  context: __SerdeContext
): TrainingSpecification => {
  let contents: any = {
    __type: "TrainingSpecification",
    MetricDefinitions: undefined,
    SupportedHyperParameters: undefined,
    SupportedTrainingInstanceTypes: undefined,
    SupportedTuningJobObjectiveMetrics: undefined,
    SupportsDistributedTraining: undefined,
    TrainingChannels: undefined,
    TrainingImage: undefined,
    TrainingImageDigest: undefined
  };
  if (output.MetricDefinitions !== undefined) {
    contents.MetricDefinitions = deserializeAws_json1_1MetricDefinitionList(
      output.MetricDefinitions,
      context
    );
  }
  if (output.SupportedHyperParameters !== undefined) {
    contents.SupportedHyperParameters = deserializeAws_json1_1HyperParameterSpecifications(
      output.SupportedHyperParameters,
      context
    );
  }
  if (output.SupportedTrainingInstanceTypes !== undefined) {
    contents.SupportedTrainingInstanceTypes = deserializeAws_json1_1TrainingInstanceTypes(
      output.SupportedTrainingInstanceTypes,
      context
    );
  }
  if (output.SupportedTuningJobObjectiveMetrics !== undefined) {
    contents.SupportedTuningJobObjectiveMetrics = deserializeAws_json1_1HyperParameterTuningJobObjectives(
      output.SupportedTuningJobObjectiveMetrics,
      context
    );
  }
  if (output.SupportsDistributedTraining !== undefined) {
    contents.SupportsDistributedTraining = output.SupportsDistributedTraining;
  }
  if (output.TrainingChannels !== undefined) {
    contents.TrainingChannels = deserializeAws_json1_1ChannelSpecifications(
      output.TrainingChannels,
      context
    );
  }
  if (output.TrainingImage !== undefined) {
    contents.TrainingImage = output.TrainingImage;
  }
  if (output.TrainingImageDigest !== undefined) {
    contents.TrainingImageDigest = output.TrainingImageDigest;
  }
  return contents;
};

const deserializeAws_json1_1TransformDataSource = (
  output: any,
  context: __SerdeContext
): TransformDataSource => {
  let contents: any = {
    __type: "TransformDataSource",
    S3DataSource: undefined
  };
  if (output.S3DataSource !== undefined) {
    contents.S3DataSource = deserializeAws_json1_1TransformS3DataSource(
      output.S3DataSource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TransformEnvironmentMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1TransformInput = (
  output: any,
  context: __SerdeContext
): TransformInput => {
  let contents: any = {
    __type: "TransformInput",
    CompressionType: undefined,
    ContentType: undefined,
    DataSource: undefined,
    SplitType: undefined
  };
  if (output.CompressionType !== undefined) {
    contents.CompressionType = output.CompressionType;
  }
  if (output.ContentType !== undefined) {
    contents.ContentType = output.ContentType;
  }
  if (output.DataSource !== undefined) {
    contents.DataSource = deserializeAws_json1_1TransformDataSource(
      output.DataSource,
      context
    );
  }
  if (output.SplitType !== undefined) {
    contents.SplitType = output.SplitType;
  }
  return contents;
};

const deserializeAws_json1_1TransformInstanceTypes = (
  output: any,
  context: __SerdeContext
): Array<TransformInstanceType | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1TransformJobDefinition = (
  output: any,
  context: __SerdeContext
): TransformJobDefinition => {
  let contents: any = {
    __type: "TransformJobDefinition",
    BatchStrategy: undefined,
    Environment: undefined,
    MaxConcurrentTransforms: undefined,
    MaxPayloadInMB: undefined,
    TransformInput: undefined,
    TransformOutput: undefined,
    TransformResources: undefined
  };
  if (output.BatchStrategy !== undefined) {
    contents.BatchStrategy = output.BatchStrategy;
  }
  if (output.Environment !== undefined) {
    contents.Environment = deserializeAws_json1_1TransformEnvironmentMap(
      output.Environment,
      context
    );
  }
  if (output.MaxConcurrentTransforms !== undefined) {
    contents.MaxConcurrentTransforms = output.MaxConcurrentTransforms;
  }
  if (output.MaxPayloadInMB !== undefined) {
    contents.MaxPayloadInMB = output.MaxPayloadInMB;
  }
  if (output.TransformInput !== undefined) {
    contents.TransformInput = deserializeAws_json1_1TransformInput(
      output.TransformInput,
      context
    );
  }
  if (output.TransformOutput !== undefined) {
    contents.TransformOutput = deserializeAws_json1_1TransformOutput(
      output.TransformOutput,
      context
    );
  }
  if (output.TransformResources !== undefined) {
    contents.TransformResources = deserializeAws_json1_1TransformResources(
      output.TransformResources,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TransformJobSummaries = (
  output: any,
  context: __SerdeContext
): Array<TransformJobSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TransformJobSummary(entry, context)
  );
};

const deserializeAws_json1_1TransformJobSummary = (
  output: any,
  context: __SerdeContext
): TransformJobSummary => {
  let contents: any = {
    __type: "TransformJobSummary",
    CreationTime: undefined,
    FailureReason: undefined,
    LastModifiedTime: undefined,
    TransformEndTime: undefined,
    TransformJobArn: undefined,
    TransformJobName: undefined,
    TransformJobStatus: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.FailureReason !== undefined) {
    contents.FailureReason = output.FailureReason;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.TransformEndTime !== undefined) {
    contents.TransformEndTime = new Date(
      Math.round(output.TransformEndTime * 1000)
    );
  }
  if (output.TransformJobArn !== undefined) {
    contents.TransformJobArn = output.TransformJobArn;
  }
  if (output.TransformJobName !== undefined) {
    contents.TransformJobName = output.TransformJobName;
  }
  if (output.TransformJobStatus !== undefined) {
    contents.TransformJobStatus = output.TransformJobStatus;
  }
  return contents;
};

const deserializeAws_json1_1TransformOutput = (
  output: any,
  context: __SerdeContext
): TransformOutput => {
  let contents: any = {
    __type: "TransformOutput",
    Accept: undefined,
    AssembleWith: undefined,
    KmsKeyId: undefined,
    S3OutputPath: undefined
  };
  if (output.Accept !== undefined) {
    contents.Accept = output.Accept;
  }
  if (output.AssembleWith !== undefined) {
    contents.AssembleWith = output.AssembleWith;
  }
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.S3OutputPath !== undefined) {
    contents.S3OutputPath = output.S3OutputPath;
  }
  return contents;
};

const deserializeAws_json1_1TransformResources = (
  output: any,
  context: __SerdeContext
): TransformResources => {
  let contents: any = {
    __type: "TransformResources",
    InstanceCount: undefined,
    InstanceType: undefined,
    VolumeKmsKeyId: undefined
  };
  if (output.InstanceCount !== undefined) {
    contents.InstanceCount = output.InstanceCount;
  }
  if (output.InstanceType !== undefined) {
    contents.InstanceType = output.InstanceType;
  }
  if (output.VolumeKmsKeyId !== undefined) {
    contents.VolumeKmsKeyId = output.VolumeKmsKeyId;
  }
  return contents;
};

const deserializeAws_json1_1TransformS3DataSource = (
  output: any,
  context: __SerdeContext
): TransformS3DataSource => {
  let contents: any = {
    __type: "TransformS3DataSource",
    S3DataType: undefined,
    S3Uri: undefined
  };
  if (output.S3DataType !== undefined) {
    contents.S3DataType = output.S3DataType;
  }
  if (output.S3Uri !== undefined) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_json1_1Trial = (
  output: any,
  context: __SerdeContext
): Trial => {
  let contents: any = {
    __type: "Trial",
    CreatedBy: undefined,
    CreationTime: undefined,
    DisplayName: undefined,
    ExperimentName: undefined,
    LastModifiedBy: undefined,
    LastModifiedTime: undefined,
    Source: undefined,
    Tags: undefined,
    TrialArn: undefined,
    TrialComponentSummaries: undefined,
    TrialName: undefined
  };
  if (output.CreatedBy !== undefined) {
    contents.CreatedBy = deserializeAws_json1_1UserContext(
      output.CreatedBy,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DisplayName !== undefined) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.ExperimentName !== undefined) {
    contents.ExperimentName = output.ExperimentName;
  }
  if (output.LastModifiedBy !== undefined) {
    contents.LastModifiedBy = deserializeAws_json1_1UserContext(
      output.LastModifiedBy,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.Source !== undefined) {
    contents.Source = deserializeAws_json1_1TrialSource(output.Source, context);
  }
  if (output.Tags !== undefined) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  if (output.TrialArn !== undefined) {
    contents.TrialArn = output.TrialArn;
  }
  if (output.TrialComponentSummaries !== undefined) {
    contents.TrialComponentSummaries = deserializeAws_json1_1TrialComponentSimpleSummaries(
      output.TrialComponentSummaries,
      context
    );
  }
  if (output.TrialName !== undefined) {
    contents.TrialName = output.TrialName;
  }
  return contents;
};

const deserializeAws_json1_1TrialComponent = (
  output: any,
  context: __SerdeContext
): TrialComponent => {
  let contents: any = {
    __type: "TrialComponent",
    CreatedBy: undefined,
    CreationTime: undefined,
    DisplayName: undefined,
    EndTime: undefined,
    InputArtifacts: undefined,
    LastModifiedBy: undefined,
    LastModifiedTime: undefined,
    Metrics: undefined,
    OutputArtifacts: undefined,
    Parameters: undefined,
    Parents: undefined,
    Source: undefined,
    SourceDetail: undefined,
    StartTime: undefined,
    Status: undefined,
    Tags: undefined,
    TrialComponentArn: undefined,
    TrialComponentName: undefined
  };
  if (output.CreatedBy !== undefined) {
    contents.CreatedBy = deserializeAws_json1_1UserContext(
      output.CreatedBy,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DisplayName !== undefined) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.InputArtifacts !== undefined) {
    contents.InputArtifacts = deserializeAws_json1_1TrialComponentArtifacts(
      output.InputArtifacts,
      context
    );
  }
  if (output.LastModifiedBy !== undefined) {
    contents.LastModifiedBy = deserializeAws_json1_1UserContext(
      output.LastModifiedBy,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.Metrics !== undefined) {
    contents.Metrics = deserializeAws_json1_1TrialComponentMetricSummaries(
      output.Metrics,
      context
    );
  }
  if (output.OutputArtifacts !== undefined) {
    contents.OutputArtifacts = deserializeAws_json1_1TrialComponentArtifacts(
      output.OutputArtifacts,
      context
    );
  }
  if (output.Parameters !== undefined) {
    contents.Parameters = deserializeAws_json1_1TrialComponentParameters(
      output.Parameters,
      context
    );
  }
  if (output.Parents !== undefined) {
    contents.Parents = deserializeAws_json1_1Parents(output.Parents, context);
  }
  if (output.Source !== undefined) {
    contents.Source = deserializeAws_json1_1TrialComponentSource(
      output.Source,
      context
    );
  }
  if (output.SourceDetail !== undefined) {
    contents.SourceDetail = deserializeAws_json1_1TrialComponentSourceDetail(
      output.SourceDetail,
      context
    );
  }
  if (output.StartTime !== undefined) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined) {
    contents.Status = deserializeAws_json1_1TrialComponentStatus(
      output.Status,
      context
    );
  }
  if (output.Tags !== undefined) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  if (output.TrialComponentArn !== undefined) {
    contents.TrialComponentArn = output.TrialComponentArn;
  }
  if (output.TrialComponentName !== undefined) {
    contents.TrialComponentName = output.TrialComponentName;
  }
  return contents;
};

const deserializeAws_json1_1TrialComponentArtifact = (
  output: any,
  context: __SerdeContext
): TrialComponentArtifact => {
  let contents: any = {
    __type: "TrialComponentArtifact",
    MediaType: undefined,
    Value: undefined
  };
  if (output.MediaType !== undefined) {
    contents.MediaType = output.MediaType;
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TrialComponentArtifacts = (
  output: any,
  context: __SerdeContext
): { [key: string]: TrialComponentArtifact } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_json1_1TrialComponentArtifact(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_json1_1TrialComponentMetricSummaries = (
  output: any,
  context: __SerdeContext
): Array<TrialComponentMetricSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TrialComponentMetricSummary(entry, context)
  );
};

const deserializeAws_json1_1TrialComponentMetricSummary = (
  output: any,
  context: __SerdeContext
): TrialComponentMetricSummary => {
  let contents: any = {
    __type: "TrialComponentMetricSummary",
    Avg: undefined,
    Count: undefined,
    Last: undefined,
    Max: undefined,
    MetricName: undefined,
    Min: undefined,
    SourceArn: undefined,
    StdDev: undefined,
    TimeStamp: undefined
  };
  if (output.Avg !== undefined) {
    contents.Avg = output.Avg;
  }
  if (output.Count !== undefined) {
    contents.Count = output.Count;
  }
  if (output.Last !== undefined) {
    contents.Last = output.Last;
  }
  if (output.Max !== undefined) {
    contents.Max = output.Max;
  }
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  if (output.Min !== undefined) {
    contents.Min = output.Min;
  }
  if (output.SourceArn !== undefined) {
    contents.SourceArn = output.SourceArn;
  }
  if (output.StdDev !== undefined) {
    contents.StdDev = output.StdDev;
  }
  if (output.TimeStamp !== undefined) {
    contents.TimeStamp = new Date(Math.round(output.TimeStamp * 1000));
  }
  return contents;
};

const deserializeAws_json1_1TrialComponentParameterValue = (
  output: any,
  context: __SerdeContext
): TrialComponentParameterValue => {
  let contents: any = {
    __type: "TrialComponentParameterValue",
    NumberValue: undefined,
    StringValue: undefined
  };
  if (output.NumberValue !== undefined) {
    contents.NumberValue = output.NumberValue;
  }
  if (output.StringValue !== undefined) {
    contents.StringValue = output.StringValue;
  }
  return contents;
};

const deserializeAws_json1_1TrialComponentParameters = (
  output: any,
  context: __SerdeContext
): { [key: string]: TrialComponentParameterValue } => {
  let mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_json1_1TrialComponentParameterValue(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_json1_1TrialComponentSimpleSummaries = (
  output: any,
  context: __SerdeContext
): Array<TrialComponentSimpleSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TrialComponentSimpleSummary(entry, context)
  );
};

const deserializeAws_json1_1TrialComponentSimpleSummary = (
  output: any,
  context: __SerdeContext
): TrialComponentSimpleSummary => {
  let contents: any = {
    __type: "TrialComponentSimpleSummary",
    CreatedBy: undefined,
    CreationTime: undefined,
    TrialComponentArn: undefined,
    TrialComponentName: undefined,
    TrialComponentSource: undefined
  };
  if (output.CreatedBy !== undefined) {
    contents.CreatedBy = deserializeAws_json1_1UserContext(
      output.CreatedBy,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.TrialComponentArn !== undefined) {
    contents.TrialComponentArn = output.TrialComponentArn;
  }
  if (output.TrialComponentName !== undefined) {
    contents.TrialComponentName = output.TrialComponentName;
  }
  if (output.TrialComponentSource !== undefined) {
    contents.TrialComponentSource = deserializeAws_json1_1TrialComponentSource(
      output.TrialComponentSource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TrialComponentSource = (
  output: any,
  context: __SerdeContext
): TrialComponentSource => {
  let contents: any = {
    __type: "TrialComponentSource",
    SourceArn: undefined,
    SourceType: undefined
  };
  if (output.SourceArn !== undefined) {
    contents.SourceArn = output.SourceArn;
  }
  if (output.SourceType !== undefined) {
    contents.SourceType = output.SourceType;
  }
  return contents;
};

const deserializeAws_json1_1TrialComponentSourceDetail = (
  output: any,
  context: __SerdeContext
): TrialComponentSourceDetail => {
  let contents: any = {
    __type: "TrialComponentSourceDetail",
    SourceArn: undefined,
    TrainingJob: undefined
  };
  if (output.SourceArn !== undefined) {
    contents.SourceArn = output.SourceArn;
  }
  if (output.TrainingJob !== undefined) {
    contents.TrainingJob = deserializeAws_json1_1TrainingJob(
      output.TrainingJob,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TrialComponentStatus = (
  output: any,
  context: __SerdeContext
): TrialComponentStatus => {
  let contents: any = {
    __type: "TrialComponentStatus",
    Message: undefined,
    PrimaryStatus: undefined
  };
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.PrimaryStatus !== undefined) {
    contents.PrimaryStatus = output.PrimaryStatus;
  }
  return contents;
};

const deserializeAws_json1_1TrialComponentSummaries = (
  output: any,
  context: __SerdeContext
): Array<TrialComponentSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TrialComponentSummary(entry, context)
  );
};

const deserializeAws_json1_1TrialComponentSummary = (
  output: any,
  context: __SerdeContext
): TrialComponentSummary => {
  let contents: any = {
    __type: "TrialComponentSummary",
    CreatedBy: undefined,
    CreationTime: undefined,
    DisplayName: undefined,
    EndTime: undefined,
    LastModifiedBy: undefined,
    LastModifiedTime: undefined,
    StartTime: undefined,
    Status: undefined,
    TrialComponentArn: undefined,
    TrialComponentName: undefined,
    TrialComponentSource: undefined
  };
  if (output.CreatedBy !== undefined) {
    contents.CreatedBy = deserializeAws_json1_1UserContext(
      output.CreatedBy,
      context
    );
  }
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DisplayName !== undefined) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.LastModifiedBy !== undefined) {
    contents.LastModifiedBy = deserializeAws_json1_1UserContext(
      output.LastModifiedBy,
      context
    );
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.StartTime !== undefined) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined) {
    contents.Status = deserializeAws_json1_1TrialComponentStatus(
      output.Status,
      context
    );
  }
  if (output.TrialComponentArn !== undefined) {
    contents.TrialComponentArn = output.TrialComponentArn;
  }
  if (output.TrialComponentName !== undefined) {
    contents.TrialComponentName = output.TrialComponentName;
  }
  if (output.TrialComponentSource !== undefined) {
    contents.TrialComponentSource = deserializeAws_json1_1TrialComponentSource(
      output.TrialComponentSource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TrialSource = (
  output: any,
  context: __SerdeContext
): TrialSource => {
  let contents: any = {
    __type: "TrialSource",
    SourceArn: undefined,
    SourceType: undefined
  };
  if (output.SourceArn !== undefined) {
    contents.SourceArn = output.SourceArn;
  }
  if (output.SourceType !== undefined) {
    contents.SourceType = output.SourceType;
  }
  return contents;
};

const deserializeAws_json1_1TrialSummaries = (
  output: any,
  context: __SerdeContext
): Array<TrialSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TrialSummary(entry, context)
  );
};

const deserializeAws_json1_1TrialSummary = (
  output: any,
  context: __SerdeContext
): TrialSummary => {
  let contents: any = {
    __type: "TrialSummary",
    CreationTime: undefined,
    DisplayName: undefined,
    LastModifiedTime: undefined,
    TrialArn: undefined,
    TrialName: undefined,
    TrialSource: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DisplayName !== undefined) {
    contents.DisplayName = output.DisplayName;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.TrialArn !== undefined) {
    contents.TrialArn = output.TrialArn;
  }
  if (output.TrialName !== undefined) {
    contents.TrialName = output.TrialName;
  }
  if (output.TrialSource !== undefined) {
    contents.TrialSource = deserializeAws_json1_1TrialSource(
      output.TrialSource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1TuningJobCompletionCriteria = (
  output: any,
  context: __SerdeContext
): TuningJobCompletionCriteria => {
  let contents: any = {
    __type: "TuningJobCompletionCriteria",
    TargetObjectiveMetricValue: undefined
  };
  if (output.TargetObjectiveMetricValue !== undefined) {
    contents.TargetObjectiveMetricValue = output.TargetObjectiveMetricValue;
  }
  return contents;
};

const deserializeAws_json1_1USD = (
  output: any,
  context: __SerdeContext
): USD => {
  let contents: any = {
    __type: "USD",
    Cents: undefined,
    Dollars: undefined,
    TenthFractionsOfACent: undefined
  };
  if (output.Cents !== undefined) {
    contents.Cents = output.Cents;
  }
  if (output.Dollars !== undefined) {
    contents.Dollars = output.Dollars;
  }
  if (output.TenthFractionsOfACent !== undefined) {
    contents.TenthFractionsOfACent = output.TenthFractionsOfACent;
  }
  return contents;
};

const deserializeAws_json1_1UiConfig = (
  output: any,
  context: __SerdeContext
): UiConfig => {
  let contents: any = {
    __type: "UiConfig",
    UiTemplateS3Uri: undefined
  };
  if (output.UiTemplateS3Uri !== undefined) {
    contents.UiTemplateS3Uri = output.UiTemplateS3Uri;
  }
  return contents;
};

const deserializeAws_json1_1UiTemplateInfo = (
  output: any,
  context: __SerdeContext
): UiTemplateInfo => {
  let contents: any = {
    __type: "UiTemplateInfo",
    ContentSha256: undefined,
    Url: undefined
  };
  if (output.ContentSha256 !== undefined) {
    contents.ContentSha256 = output.ContentSha256;
  }
  if (output.Url !== undefined) {
    contents.Url = output.Url;
  }
  return contents;
};

const deserializeAws_json1_1UpdateCodeRepositoryOutput = (
  output: any,
  context: __SerdeContext
): UpdateCodeRepositoryOutput => {
  let contents: any = {
    __type: "UpdateCodeRepositoryOutput",
    CodeRepositoryArn: undefined
  };
  if (output.CodeRepositoryArn !== undefined) {
    contents.CodeRepositoryArn = output.CodeRepositoryArn;
  }
  return contents;
};

const deserializeAws_json1_1UpdateDomainResponse = (
  output: any,
  context: __SerdeContext
): UpdateDomainResponse => {
  let contents: any = {
    __type: "UpdateDomainResponse",
    DomainArn: undefined
  };
  if (output.DomainArn !== undefined) {
    contents.DomainArn = output.DomainArn;
  }
  return contents;
};

const deserializeAws_json1_1UpdateEndpointOutput = (
  output: any,
  context: __SerdeContext
): UpdateEndpointOutput => {
  let contents: any = {
    __type: "UpdateEndpointOutput",
    EndpointArn: undefined
  };
  if (output.EndpointArn !== undefined) {
    contents.EndpointArn = output.EndpointArn;
  }
  return contents;
};

const deserializeAws_json1_1UpdateEndpointWeightsAndCapacitiesOutput = (
  output: any,
  context: __SerdeContext
): UpdateEndpointWeightsAndCapacitiesOutput => {
  let contents: any = {
    __type: "UpdateEndpointWeightsAndCapacitiesOutput",
    EndpointArn: undefined
  };
  if (output.EndpointArn !== undefined) {
    contents.EndpointArn = output.EndpointArn;
  }
  return contents;
};

const deserializeAws_json1_1UpdateExperimentResponse = (
  output: any,
  context: __SerdeContext
): UpdateExperimentResponse => {
  let contents: any = {
    __type: "UpdateExperimentResponse",
    ExperimentArn: undefined
  };
  if (output.ExperimentArn !== undefined) {
    contents.ExperimentArn = output.ExperimentArn;
  }
  return contents;
};

const deserializeAws_json1_1UpdateMonitoringScheduleResponse = (
  output: any,
  context: __SerdeContext
): UpdateMonitoringScheduleResponse => {
  let contents: any = {
    __type: "UpdateMonitoringScheduleResponse",
    MonitoringScheduleArn: undefined
  };
  if (output.MonitoringScheduleArn !== undefined) {
    contents.MonitoringScheduleArn = output.MonitoringScheduleArn;
  }
  return contents;
};

const deserializeAws_json1_1UpdateNotebookInstanceLifecycleConfigOutput = (
  output: any,
  context: __SerdeContext
): UpdateNotebookInstanceLifecycleConfigOutput => {
  let contents: any = {
    __type: "UpdateNotebookInstanceLifecycleConfigOutput"
  };
  return contents;
};

const deserializeAws_json1_1UpdateNotebookInstanceOutput = (
  output: any,
  context: __SerdeContext
): UpdateNotebookInstanceOutput => {
  let contents: any = {
    __type: "UpdateNotebookInstanceOutput"
  };
  return contents;
};

const deserializeAws_json1_1UpdateTrialComponentResponse = (
  output: any,
  context: __SerdeContext
): UpdateTrialComponentResponse => {
  let contents: any = {
    __type: "UpdateTrialComponentResponse",
    TrialComponentArn: undefined
  };
  if (output.TrialComponentArn !== undefined) {
    contents.TrialComponentArn = output.TrialComponentArn;
  }
  return contents;
};

const deserializeAws_json1_1UpdateTrialResponse = (
  output: any,
  context: __SerdeContext
): UpdateTrialResponse => {
  let contents: any = {
    __type: "UpdateTrialResponse",
    TrialArn: undefined
  };
  if (output.TrialArn !== undefined) {
    contents.TrialArn = output.TrialArn;
  }
  return contents;
};

const deserializeAws_json1_1UpdateUserProfileResponse = (
  output: any,
  context: __SerdeContext
): UpdateUserProfileResponse => {
  let contents: any = {
    __type: "UpdateUserProfileResponse",
    UserProfileArn: undefined
  };
  if (output.UserProfileArn !== undefined) {
    contents.UserProfileArn = output.UserProfileArn;
  }
  return contents;
};

const deserializeAws_json1_1UpdateWorkforceResponse = (
  output: any,
  context: __SerdeContext
): UpdateWorkforceResponse => {
  let contents: any = {
    __type: "UpdateWorkforceResponse",
    Workforce: undefined
  };
  if (output.Workforce !== undefined) {
    contents.Workforce = deserializeAws_json1_1Workforce(
      output.Workforce,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateWorkteamResponse = (
  output: any,
  context: __SerdeContext
): UpdateWorkteamResponse => {
  let contents: any = {
    __type: "UpdateWorkteamResponse",
    Workteam: undefined
  };
  if (output.Workteam !== undefined) {
    contents.Workteam = deserializeAws_json1_1Workteam(
      output.Workteam,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UserContext = (
  output: any,
  context: __SerdeContext
): UserContext => {
  let contents: any = {
    __type: "UserContext",
    DomainId: undefined,
    UserProfileArn: undefined,
    UserProfileName: undefined
  };
  if (output.DomainId !== undefined) {
    contents.DomainId = output.DomainId;
  }
  if (output.UserProfileArn !== undefined) {
    contents.UserProfileArn = output.UserProfileArn;
  }
  if (output.UserProfileName !== undefined) {
    contents.UserProfileName = output.UserProfileName;
  }
  return contents;
};

const deserializeAws_json1_1UserProfileDetails = (
  output: any,
  context: __SerdeContext
): UserProfileDetails => {
  let contents: any = {
    __type: "UserProfileDetails",
    CreationTime: undefined,
    DomainId: undefined,
    LastModifiedTime: undefined,
    Status: undefined,
    UserProfileName: undefined
  };
  if (output.CreationTime !== undefined) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DomainId !== undefined) {
    contents.DomainId = output.DomainId;
  }
  if (output.LastModifiedTime !== undefined) {
    contents.LastModifiedTime = new Date(
      Math.round(output.LastModifiedTime * 1000)
    );
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.UserProfileName !== undefined) {
    contents.UserProfileName = output.UserProfileName;
  }
  return contents;
};

const deserializeAws_json1_1UserProfileList = (
  output: any,
  context: __SerdeContext
): Array<UserProfileDetails> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1UserProfileDetails(entry, context)
  );
};

const deserializeAws_json1_1UserSettings = (
  output: any,
  context: __SerdeContext
): UserSettings => {
  let contents: any = {
    __type: "UserSettings",
    ExecutionRole: undefined,
    JupyterServerAppSettings: undefined,
    KernelGatewayAppSettings: undefined,
    SecurityGroups: undefined,
    SharingSettings: undefined,
    TensorBoardAppSettings: undefined
  };
  if (output.ExecutionRole !== undefined) {
    contents.ExecutionRole = output.ExecutionRole;
  }
  if (output.JupyterServerAppSettings !== undefined) {
    contents.JupyterServerAppSettings = deserializeAws_json1_1JupyterServerAppSettings(
      output.JupyterServerAppSettings,
      context
    );
  }
  if (output.KernelGatewayAppSettings !== undefined) {
    contents.KernelGatewayAppSettings = deserializeAws_json1_1KernelGatewayAppSettings(
      output.KernelGatewayAppSettings,
      context
    );
  }
  if (output.SecurityGroups !== undefined) {
    contents.SecurityGroups = deserializeAws_json1_1SecurityGroupIds(
      output.SecurityGroups,
      context
    );
  }
  if (output.SharingSettings !== undefined) {
    contents.SharingSettings = deserializeAws_json1_1SharingSettings(
      output.SharingSettings,
      context
    );
  }
  if (output.TensorBoardAppSettings !== undefined) {
    contents.TensorBoardAppSettings = deserializeAws_json1_1TensorBoardAppSettings(
      output.TensorBoardAppSettings,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1VpcConfig = (
  output: any,
  context: __SerdeContext
): VpcConfig => {
  let contents: any = {
    __type: "VpcConfig",
    SecurityGroupIds: undefined,
    Subnets: undefined
  };
  if (output.SecurityGroupIds !== undefined) {
    contents.SecurityGroupIds = deserializeAws_json1_1VpcSecurityGroupIds(
      output.SecurityGroupIds,
      context
    );
  }
  if (output.Subnets !== undefined) {
    contents.Subnets = deserializeAws_json1_1Subnets(output.Subnets, context);
  }
  return contents;
};

const deserializeAws_json1_1VpcSecurityGroupIds = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Workforce = (
  output: any,
  context: __SerdeContext
): Workforce => {
  let contents: any = {
    __type: "Workforce",
    LastUpdatedDate: undefined,
    SourceIpConfig: undefined,
    WorkforceArn: undefined,
    WorkforceName: undefined
  };
  if (output.LastUpdatedDate !== undefined) {
    contents.LastUpdatedDate = new Date(
      Math.round(output.LastUpdatedDate * 1000)
    );
  }
  if (output.SourceIpConfig !== undefined) {
    contents.SourceIpConfig = deserializeAws_json1_1SourceIpConfig(
      output.SourceIpConfig,
      context
    );
  }
  if (output.WorkforceArn !== undefined) {
    contents.WorkforceArn = output.WorkforceArn;
  }
  if (output.WorkforceName !== undefined) {
    contents.WorkforceName = output.WorkforceName;
  }
  return contents;
};

const deserializeAws_json1_1Workteam = (
  output: any,
  context: __SerdeContext
): Workteam => {
  let contents: any = {
    __type: "Workteam",
    CreateDate: undefined,
    Description: undefined,
    LastUpdatedDate: undefined,
    MemberDefinitions: undefined,
    NotificationConfiguration: undefined,
    ProductListingIds: undefined,
    SubDomain: undefined,
    WorkteamArn: undefined,
    WorkteamName: undefined
  };
  if (output.CreateDate !== undefined) {
    contents.CreateDate = new Date(Math.round(output.CreateDate * 1000));
  }
  if (output.Description !== undefined) {
    contents.Description = output.Description;
  }
  if (output.LastUpdatedDate !== undefined) {
    contents.LastUpdatedDate = new Date(
      Math.round(output.LastUpdatedDate * 1000)
    );
  }
  if (output.MemberDefinitions !== undefined) {
    contents.MemberDefinitions = deserializeAws_json1_1MemberDefinitions(
      output.MemberDefinitions,
      context
    );
  }
  if (output.NotificationConfiguration !== undefined) {
    contents.NotificationConfiguration = deserializeAws_json1_1NotificationConfiguration(
      output.NotificationConfiguration,
      context
    );
  }
  if (output.ProductListingIds !== undefined) {
    contents.ProductListingIds = deserializeAws_json1_1ProductListings(
      output.ProductListingIds,
      context
    );
  }
  if (output.SubDomain !== undefined) {
    contents.SubDomain = output.SubDomain;
  }
  if (output.WorkteamArn !== undefined) {
    contents.WorkteamArn = output.WorkteamArn;
  }
  if (output.WorkteamName !== undefined) {
    contents.WorkteamName = output.WorkteamName;
  }
  return contents;
};

const deserializeAws_json1_1Workteams = (
  output: any,
  context: __SerdeContext
): Array<Workteam> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Workteam(entry, context)
  );
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
