import {
  CreateByteMatchSetCommandInput,
  CreateByteMatchSetCommandOutput
} from "../commands/CreateByteMatchSetCommand";
import {
  CreateGeoMatchSetCommandInput,
  CreateGeoMatchSetCommandOutput
} from "../commands/CreateGeoMatchSetCommand";
import {
  CreateIPSetCommandInput,
  CreateIPSetCommandOutput
} from "../commands/CreateIPSetCommand";
import {
  CreateRateBasedRuleCommandInput,
  CreateRateBasedRuleCommandOutput
} from "../commands/CreateRateBasedRuleCommand";
import {
  CreateRegexMatchSetCommandInput,
  CreateRegexMatchSetCommandOutput
} from "../commands/CreateRegexMatchSetCommand";
import {
  CreateRegexPatternSetCommandInput,
  CreateRegexPatternSetCommandOutput
} from "../commands/CreateRegexPatternSetCommand";
import {
  CreateRuleCommandInput,
  CreateRuleCommandOutput
} from "../commands/CreateRuleCommand";
import {
  CreateRuleGroupCommandInput,
  CreateRuleGroupCommandOutput
} from "../commands/CreateRuleGroupCommand";
import {
  CreateSizeConstraintSetCommandInput,
  CreateSizeConstraintSetCommandOutput
} from "../commands/CreateSizeConstraintSetCommand";
import {
  CreateSqlInjectionMatchSetCommandInput,
  CreateSqlInjectionMatchSetCommandOutput
} from "../commands/CreateSqlInjectionMatchSetCommand";
import {
  CreateWebACLCommandInput,
  CreateWebACLCommandOutput
} from "../commands/CreateWebACLCommand";
import {
  CreateXssMatchSetCommandInput,
  CreateXssMatchSetCommandOutput
} from "../commands/CreateXssMatchSetCommand";
import {
  DeleteByteMatchSetCommandInput,
  DeleteByteMatchSetCommandOutput
} from "../commands/DeleteByteMatchSetCommand";
import {
  DeleteGeoMatchSetCommandInput,
  DeleteGeoMatchSetCommandOutput
} from "../commands/DeleteGeoMatchSetCommand";
import {
  DeleteIPSetCommandInput,
  DeleteIPSetCommandOutput
} from "../commands/DeleteIPSetCommand";
import {
  DeleteLoggingConfigurationCommandInput,
  DeleteLoggingConfigurationCommandOutput
} from "../commands/DeleteLoggingConfigurationCommand";
import {
  DeletePermissionPolicyCommandInput,
  DeletePermissionPolicyCommandOutput
} from "../commands/DeletePermissionPolicyCommand";
import {
  DeleteRateBasedRuleCommandInput,
  DeleteRateBasedRuleCommandOutput
} from "../commands/DeleteRateBasedRuleCommand";
import {
  DeleteRegexMatchSetCommandInput,
  DeleteRegexMatchSetCommandOutput
} from "../commands/DeleteRegexMatchSetCommand";
import {
  DeleteRegexPatternSetCommandInput,
  DeleteRegexPatternSetCommandOutput
} from "../commands/DeleteRegexPatternSetCommand";
import {
  DeleteRuleCommandInput,
  DeleteRuleCommandOutput
} from "../commands/DeleteRuleCommand";
import {
  DeleteRuleGroupCommandInput,
  DeleteRuleGroupCommandOutput
} from "../commands/DeleteRuleGroupCommand";
import {
  DeleteSizeConstraintSetCommandInput,
  DeleteSizeConstraintSetCommandOutput
} from "../commands/DeleteSizeConstraintSetCommand";
import {
  DeleteSqlInjectionMatchSetCommandInput,
  DeleteSqlInjectionMatchSetCommandOutput
} from "../commands/DeleteSqlInjectionMatchSetCommand";
import {
  DeleteWebACLCommandInput,
  DeleteWebACLCommandOutput
} from "../commands/DeleteWebACLCommand";
import {
  DeleteXssMatchSetCommandInput,
  DeleteXssMatchSetCommandOutput
} from "../commands/DeleteXssMatchSetCommand";
import {
  GetByteMatchSetCommandInput,
  GetByteMatchSetCommandOutput
} from "../commands/GetByteMatchSetCommand";
import {
  GetChangeTokenCommandInput,
  GetChangeTokenCommandOutput
} from "../commands/GetChangeTokenCommand";
import {
  GetChangeTokenStatusCommandInput,
  GetChangeTokenStatusCommandOutput
} from "../commands/GetChangeTokenStatusCommand";
import {
  GetGeoMatchSetCommandInput,
  GetGeoMatchSetCommandOutput
} from "../commands/GetGeoMatchSetCommand";
import {
  GetIPSetCommandInput,
  GetIPSetCommandOutput
} from "../commands/GetIPSetCommand";
import {
  GetLoggingConfigurationCommandInput,
  GetLoggingConfigurationCommandOutput
} from "../commands/GetLoggingConfigurationCommand";
import {
  GetPermissionPolicyCommandInput,
  GetPermissionPolicyCommandOutput
} from "../commands/GetPermissionPolicyCommand";
import {
  GetRateBasedRuleCommandInput,
  GetRateBasedRuleCommandOutput
} from "../commands/GetRateBasedRuleCommand";
import {
  GetRateBasedRuleManagedKeysCommandInput,
  GetRateBasedRuleManagedKeysCommandOutput
} from "../commands/GetRateBasedRuleManagedKeysCommand";
import {
  GetRegexMatchSetCommandInput,
  GetRegexMatchSetCommandOutput
} from "../commands/GetRegexMatchSetCommand";
import {
  GetRegexPatternSetCommandInput,
  GetRegexPatternSetCommandOutput
} from "../commands/GetRegexPatternSetCommand";
import {
  GetRuleCommandInput,
  GetRuleCommandOutput
} from "../commands/GetRuleCommand";
import {
  GetRuleGroupCommandInput,
  GetRuleGroupCommandOutput
} from "../commands/GetRuleGroupCommand";
import {
  GetSampledRequestsCommandInput,
  GetSampledRequestsCommandOutput
} from "../commands/GetSampledRequestsCommand";
import {
  GetSizeConstraintSetCommandInput,
  GetSizeConstraintSetCommandOutput
} from "../commands/GetSizeConstraintSetCommand";
import {
  GetSqlInjectionMatchSetCommandInput,
  GetSqlInjectionMatchSetCommandOutput
} from "../commands/GetSqlInjectionMatchSetCommand";
import {
  GetWebACLCommandInput,
  GetWebACLCommandOutput
} from "../commands/GetWebACLCommand";
import {
  GetXssMatchSetCommandInput,
  GetXssMatchSetCommandOutput
} from "../commands/GetXssMatchSetCommand";
import {
  ListActivatedRulesInRuleGroupCommandInput,
  ListActivatedRulesInRuleGroupCommandOutput
} from "../commands/ListActivatedRulesInRuleGroupCommand";
import {
  ListByteMatchSetsCommandInput,
  ListByteMatchSetsCommandOutput
} from "../commands/ListByteMatchSetsCommand";
import {
  ListGeoMatchSetsCommandInput,
  ListGeoMatchSetsCommandOutput
} from "../commands/ListGeoMatchSetsCommand";
import {
  ListIPSetsCommandInput,
  ListIPSetsCommandOutput
} from "../commands/ListIPSetsCommand";
import {
  ListLoggingConfigurationsCommandInput,
  ListLoggingConfigurationsCommandOutput
} from "../commands/ListLoggingConfigurationsCommand";
import {
  ListRateBasedRulesCommandInput,
  ListRateBasedRulesCommandOutput
} from "../commands/ListRateBasedRulesCommand";
import {
  ListRegexMatchSetsCommandInput,
  ListRegexMatchSetsCommandOutput
} from "../commands/ListRegexMatchSetsCommand";
import {
  ListRegexPatternSetsCommandInput,
  ListRegexPatternSetsCommandOutput
} from "../commands/ListRegexPatternSetsCommand";
import {
  ListRuleGroupsCommandInput,
  ListRuleGroupsCommandOutput
} from "../commands/ListRuleGroupsCommand";
import {
  ListRulesCommandInput,
  ListRulesCommandOutput
} from "../commands/ListRulesCommand";
import {
  ListSizeConstraintSetsCommandInput,
  ListSizeConstraintSetsCommandOutput
} from "../commands/ListSizeConstraintSetsCommand";
import {
  ListSqlInjectionMatchSetsCommandInput,
  ListSqlInjectionMatchSetsCommandOutput
} from "../commands/ListSqlInjectionMatchSetsCommand";
import {
  ListSubscribedRuleGroupsCommandInput,
  ListSubscribedRuleGroupsCommandOutput
} from "../commands/ListSubscribedRuleGroupsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ListWebACLsCommandInput,
  ListWebACLsCommandOutput
} from "../commands/ListWebACLsCommand";
import {
  ListXssMatchSetsCommandInput,
  ListXssMatchSetsCommandOutput
} from "../commands/ListXssMatchSetsCommand";
import {
  PutLoggingConfigurationCommandInput,
  PutLoggingConfigurationCommandOutput
} from "../commands/PutLoggingConfigurationCommand";
import {
  PutPermissionPolicyCommandInput,
  PutPermissionPolicyCommandOutput
} from "../commands/PutPermissionPolicyCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateByteMatchSetCommandInput,
  UpdateByteMatchSetCommandOutput
} from "../commands/UpdateByteMatchSetCommand";
import {
  UpdateGeoMatchSetCommandInput,
  UpdateGeoMatchSetCommandOutput
} from "../commands/UpdateGeoMatchSetCommand";
import {
  UpdateIPSetCommandInput,
  UpdateIPSetCommandOutput
} from "../commands/UpdateIPSetCommand";
import {
  UpdateRateBasedRuleCommandInput,
  UpdateRateBasedRuleCommandOutput
} from "../commands/UpdateRateBasedRuleCommand";
import {
  UpdateRegexMatchSetCommandInput,
  UpdateRegexMatchSetCommandOutput
} from "../commands/UpdateRegexMatchSetCommand";
import {
  UpdateRegexPatternSetCommandInput,
  UpdateRegexPatternSetCommandOutput
} from "../commands/UpdateRegexPatternSetCommand";
import {
  UpdateRuleCommandInput,
  UpdateRuleCommandOutput
} from "../commands/UpdateRuleCommand";
import {
  UpdateRuleGroupCommandInput,
  UpdateRuleGroupCommandOutput
} from "../commands/UpdateRuleGroupCommand";
import {
  UpdateSizeConstraintSetCommandInput,
  UpdateSizeConstraintSetCommandOutput
} from "../commands/UpdateSizeConstraintSetCommand";
import {
  UpdateSqlInjectionMatchSetCommandInput,
  UpdateSqlInjectionMatchSetCommandOutput
} from "../commands/UpdateSqlInjectionMatchSetCommand";
import {
  UpdateWebACLCommandInput,
  UpdateWebACLCommandOutput
} from "../commands/UpdateWebACLCommand";
import {
  UpdateXssMatchSetCommandInput,
  UpdateXssMatchSetCommandOutput
} from "../commands/UpdateXssMatchSetCommand";
import {
  ActivatedRule,
  ByteMatchSet,
  ByteMatchSetSummary,
  ByteMatchSetUpdate,
  ByteMatchTuple,
  CreateByteMatchSetRequest,
  CreateByteMatchSetResponse,
  CreateGeoMatchSetRequest,
  CreateGeoMatchSetResponse,
  CreateIPSetRequest,
  CreateIPSetResponse,
  CreateRateBasedRuleRequest,
  CreateRateBasedRuleResponse,
  CreateRegexMatchSetRequest,
  CreateRegexMatchSetResponse,
  CreateRegexPatternSetRequest,
  CreateRegexPatternSetResponse,
  CreateRuleGroupRequest,
  CreateRuleGroupResponse,
  CreateRuleRequest,
  CreateRuleResponse,
  CreateSizeConstraintSetRequest,
  CreateSizeConstraintSetResponse,
  CreateSqlInjectionMatchSetRequest,
  CreateSqlInjectionMatchSetResponse,
  CreateWebACLRequest,
  CreateWebACLResponse,
  CreateXssMatchSetRequest,
  CreateXssMatchSetResponse,
  DeleteByteMatchSetRequest,
  DeleteByteMatchSetResponse,
  DeleteGeoMatchSetRequest,
  DeleteGeoMatchSetResponse,
  DeleteIPSetRequest,
  DeleteIPSetResponse,
  DeleteLoggingConfigurationRequest,
  DeleteLoggingConfigurationResponse,
  DeletePermissionPolicyRequest,
  DeletePermissionPolicyResponse,
  DeleteRateBasedRuleRequest,
  DeleteRateBasedRuleResponse,
  DeleteRegexMatchSetRequest,
  DeleteRegexMatchSetResponse,
  DeleteRegexPatternSetRequest,
  DeleteRegexPatternSetResponse,
  DeleteRuleGroupRequest,
  DeleteRuleGroupResponse,
  DeleteRuleRequest,
  DeleteRuleResponse,
  DeleteSizeConstraintSetRequest,
  DeleteSizeConstraintSetResponse,
  DeleteSqlInjectionMatchSetRequest,
  DeleteSqlInjectionMatchSetResponse,
  DeleteWebACLRequest,
  DeleteWebACLResponse,
  DeleteXssMatchSetRequest,
  DeleteXssMatchSetResponse,
  ExcludedRule,
  FieldToMatch,
  GeoMatchConstraint,
  GeoMatchSet,
  GeoMatchSetSummary,
  GeoMatchSetUpdate,
  GetByteMatchSetRequest,
  GetByteMatchSetResponse,
  GetChangeTokenRequest,
  GetChangeTokenResponse,
  GetChangeTokenStatusRequest,
  GetChangeTokenStatusResponse,
  GetGeoMatchSetRequest,
  GetGeoMatchSetResponse,
  GetIPSetRequest,
  GetIPSetResponse,
  GetLoggingConfigurationRequest,
  GetLoggingConfigurationResponse,
  GetPermissionPolicyRequest,
  GetPermissionPolicyResponse,
  GetRateBasedRuleManagedKeysRequest,
  GetRateBasedRuleManagedKeysResponse,
  GetRateBasedRuleRequest,
  GetRateBasedRuleResponse,
  GetRegexMatchSetRequest,
  GetRegexMatchSetResponse,
  GetRegexPatternSetRequest,
  GetRegexPatternSetResponse,
  GetRuleGroupRequest,
  GetRuleGroupResponse,
  GetRuleRequest,
  GetRuleResponse,
  GetSampledRequestsRequest,
  GetSampledRequestsResponse,
  GetSizeConstraintSetRequest,
  GetSizeConstraintSetResponse,
  GetSqlInjectionMatchSetRequest,
  GetSqlInjectionMatchSetResponse,
  GetWebACLRequest,
  GetWebACLResponse,
  GetXssMatchSetRequest,
  GetXssMatchSetResponse,
  HTTPHeader,
  HTTPRequest,
  IPSet,
  IPSetDescriptor,
  IPSetSummary,
  IPSetUpdate,
  ListActivatedRulesInRuleGroupRequest,
  ListActivatedRulesInRuleGroupResponse,
  ListByteMatchSetsRequest,
  ListByteMatchSetsResponse,
  ListGeoMatchSetsRequest,
  ListGeoMatchSetsResponse,
  ListIPSetsRequest,
  ListIPSetsResponse,
  ListLoggingConfigurationsRequest,
  ListLoggingConfigurationsResponse,
  ListRateBasedRulesRequest,
  ListRateBasedRulesResponse,
  ListRegexMatchSetsRequest,
  ListRegexMatchSetsResponse,
  ListRegexPatternSetsRequest,
  ListRegexPatternSetsResponse,
  ListRuleGroupsRequest,
  ListRuleGroupsResponse,
  ListRulesRequest,
  ListRulesResponse,
  ListSizeConstraintSetsRequest,
  ListSizeConstraintSetsResponse,
  ListSqlInjectionMatchSetsRequest,
  ListSqlInjectionMatchSetsResponse,
  ListSubscribedRuleGroupsRequest,
  ListSubscribedRuleGroupsResponse,
  ListTagsForResourceRequest,
  ListTagsForResourceResponse,
  ListWebACLsRequest,
  ListWebACLsResponse,
  ListXssMatchSetsRequest,
  ListXssMatchSetsResponse,
  LoggingConfiguration,
  Predicate,
  PutLoggingConfigurationRequest,
  PutLoggingConfigurationResponse,
  PutPermissionPolicyRequest,
  PutPermissionPolicyResponse,
  RateBasedRule,
  RegexMatchSet,
  RegexMatchSetSummary,
  RegexMatchSetUpdate,
  RegexMatchTuple,
  RegexPatternSet,
  RegexPatternSetSummary,
  RegexPatternSetUpdate,
  Rule,
  RuleGroup,
  RuleGroupSummary,
  RuleGroupUpdate,
  RuleSummary,
  RuleUpdate,
  SampledHTTPRequest,
  SizeConstraint,
  SizeConstraintSet,
  SizeConstraintSetSummary,
  SizeConstraintSetUpdate,
  SqlInjectionMatchSet,
  SqlInjectionMatchSetSummary,
  SqlInjectionMatchSetUpdate,
  SqlInjectionMatchTuple,
  SubscribedRuleGroupSummary,
  Tag,
  TagInfoForResource,
  TagResourceRequest,
  TagResourceResponse,
  TimeWindow,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateByteMatchSetRequest,
  UpdateByteMatchSetResponse,
  UpdateGeoMatchSetRequest,
  UpdateGeoMatchSetResponse,
  UpdateIPSetRequest,
  UpdateIPSetResponse,
  UpdateRateBasedRuleRequest,
  UpdateRateBasedRuleResponse,
  UpdateRegexMatchSetRequest,
  UpdateRegexMatchSetResponse,
  UpdateRegexPatternSetRequest,
  UpdateRegexPatternSetResponse,
  UpdateRuleGroupRequest,
  UpdateRuleGroupResponse,
  UpdateRuleRequest,
  UpdateRuleResponse,
  UpdateSizeConstraintSetRequest,
  UpdateSizeConstraintSetResponse,
  UpdateSqlInjectionMatchSetRequest,
  UpdateSqlInjectionMatchSetResponse,
  UpdateWebACLRequest,
  UpdateWebACLResponse,
  UpdateXssMatchSetRequest,
  UpdateXssMatchSetResponse,
  WAFBadRequestException,
  WAFDisallowedNameException,
  WAFInternalErrorException,
  WAFInvalidAccountException,
  WAFInvalidOperationException,
  WAFInvalidParameterException,
  WAFInvalidPermissionPolicyException,
  WAFInvalidRegexPatternException,
  WAFLimitsExceededException,
  WAFNonEmptyEntityException,
  WAFNonexistentContainerException,
  WAFNonexistentItemException,
  WAFReferencedItemException,
  WAFServiceLinkedRoleErrorException,
  WAFStaleDataException,
  WAFSubscriptionNotFoundException,
  WAFTagOperationException,
  WAFTagOperationInternalErrorException,
  WafAction,
  WafOverrideAction,
  WebACL,
  WebACLSummary,
  WebACLUpdate,
  XssMatchSet,
  XssMatchSetSummary,
  XssMatchSetUpdate,
  XssMatchTuple
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_json1_1CreateByteMatchSetCommand(
  input: CreateByteMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateByteMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateByteMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateGeoMatchSetCommand(
  input: CreateGeoMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateGeoMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateGeoMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateIPSetCommand(
  input: CreateIPSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateIPSet";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1CreateIPSetRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateRateBasedRuleCommand(
  input: CreateRateBasedRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateRateBasedRule";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateRateBasedRuleRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateRegexMatchSetCommand(
  input: CreateRegexMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateRegexMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateRegexMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateRegexPatternSetCommand(
  input: CreateRegexPatternSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateRegexPatternSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateRegexPatternSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateRuleCommand(
  input: CreateRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateRule";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1CreateRuleRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateRuleGroupCommand(
  input: CreateRuleGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateRuleGroup";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateRuleGroupRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateSizeConstraintSetCommand(
  input: CreateSizeConstraintSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateSizeConstraintSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateSizeConstraintSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateSqlInjectionMatchSetCommand(
  input: CreateSqlInjectionMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateSqlInjectionMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateSqlInjectionMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateWebACLCommand(
  input: CreateWebACLCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateWebACL";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateWebACLRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateXssMatchSetCommand(
  input: CreateXssMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.CreateXssMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1CreateXssMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteByteMatchSetCommand(
  input: DeleteByteMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteByteMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteByteMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteGeoMatchSetCommand(
  input: DeleteGeoMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteGeoMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteGeoMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteIPSetCommand(
  input: DeleteIPSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteIPSet";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1DeleteIPSetRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteLoggingConfigurationCommand(
  input: DeleteLoggingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteLoggingConfiguration";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteLoggingConfigurationRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeletePermissionPolicyCommand(
  input: DeletePermissionPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeletePermissionPolicy";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeletePermissionPolicyRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteRateBasedRuleCommand(
  input: DeleteRateBasedRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteRateBasedRule";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteRateBasedRuleRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteRegexMatchSetCommand(
  input: DeleteRegexMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteRegexMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteRegexMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteRegexPatternSetCommand(
  input: DeleteRegexPatternSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteRegexPatternSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteRegexPatternSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteRuleCommand(
  input: DeleteRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteRule";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1DeleteRuleRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteRuleGroupCommand(
  input: DeleteRuleGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteRuleGroup";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteRuleGroupRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteSizeConstraintSetCommand(
  input: DeleteSizeConstraintSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteSizeConstraintSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteSizeConstraintSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteSqlInjectionMatchSetCommand(
  input: DeleteSqlInjectionMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteSqlInjectionMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteSqlInjectionMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteWebACLCommand(
  input: DeleteWebACLCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteWebACL";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteWebACLRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteXssMatchSetCommand(
  input: DeleteXssMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.DeleteXssMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1DeleteXssMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetByteMatchSetCommand(
  input: GetByteMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetByteMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetByteMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetChangeTokenCommand(
  input: GetChangeTokenCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetChangeToken";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetChangeTokenRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetChangeTokenStatusCommand(
  input: GetChangeTokenStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetChangeTokenStatus";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetChangeTokenStatusRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetGeoMatchSetCommand(
  input: GetGeoMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetGeoMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetGeoMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetIPSetCommand(
  input: GetIPSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetIPSet";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1GetIPSetRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetLoggingConfigurationCommand(
  input: GetLoggingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetLoggingConfiguration";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetLoggingConfigurationRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetPermissionPolicyCommand(
  input: GetPermissionPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetPermissionPolicy";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetPermissionPolicyRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetRateBasedRuleCommand(
  input: GetRateBasedRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetRateBasedRule";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetRateBasedRuleRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetRateBasedRuleManagedKeysCommand(
  input: GetRateBasedRuleManagedKeysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetRateBasedRuleManagedKeys";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetRateBasedRuleManagedKeysRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetRegexMatchSetCommand(
  input: GetRegexMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetRegexMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetRegexMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetRegexPatternSetCommand(
  input: GetRegexPatternSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetRegexPatternSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetRegexPatternSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetRuleCommand(
  input: GetRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetRule";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1GetRuleRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetRuleGroupCommand(
  input: GetRuleGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetRuleGroup";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetRuleGroupRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetSampledRequestsCommand(
  input: GetSampledRequestsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetSampledRequests";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetSampledRequestsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetSizeConstraintSetCommand(
  input: GetSizeConstraintSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetSizeConstraintSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetSizeConstraintSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetSqlInjectionMatchSetCommand(
  input: GetSqlInjectionMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetSqlInjectionMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetSqlInjectionMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetWebACLCommand(
  input: GetWebACLCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetWebACL";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1GetWebACLRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1GetXssMatchSetCommand(
  input: GetXssMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.GetXssMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1GetXssMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListActivatedRulesInRuleGroupCommand(
  input: ListActivatedRulesInRuleGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListActivatedRulesInRuleGroup";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListActivatedRulesInRuleGroupRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListByteMatchSetsCommand(
  input: ListByteMatchSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListByteMatchSets";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListByteMatchSetsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListGeoMatchSetsCommand(
  input: ListGeoMatchSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListGeoMatchSets";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListGeoMatchSetsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListIPSetsCommand(
  input: ListIPSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListIPSets";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1ListIPSetsRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListLoggingConfigurationsCommand(
  input: ListLoggingConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListLoggingConfigurations";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListLoggingConfigurationsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListRateBasedRulesCommand(
  input: ListRateBasedRulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListRateBasedRules";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListRateBasedRulesRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListRegexMatchSetsCommand(
  input: ListRegexMatchSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListRegexMatchSets";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListRegexMatchSetsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListRegexPatternSetsCommand(
  input: ListRegexPatternSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListRegexPatternSets";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListRegexPatternSetsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListRuleGroupsCommand(
  input: ListRuleGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListRuleGroups";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListRuleGroupsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListRulesCommand(
  input: ListRulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListRules";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1ListRulesRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListSizeConstraintSetsCommand(
  input: ListSizeConstraintSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListSizeConstraintSets";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListSizeConstraintSetsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListSqlInjectionMatchSetsCommand(
  input: ListSqlInjectionMatchSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListSqlInjectionMatchSets";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListSqlInjectionMatchSetsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListSubscribedRuleGroupsCommand(
  input: ListSubscribedRuleGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListSubscribedRuleGroups";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListSubscribedRuleGroupsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListTagsForResource";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListTagsForResourceRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListWebACLsCommand(
  input: ListWebACLsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListWebACLs";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1ListWebACLsRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListXssMatchSetsCommand(
  input: ListXssMatchSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.ListXssMatchSets";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1ListXssMatchSetsRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1PutLoggingConfigurationCommand(
  input: PutLoggingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.PutLoggingConfiguration";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1PutLoggingConfigurationRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1PutPermissionPolicyCommand(
  input: PutPermissionPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.PutPermissionPolicy";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1PutPermissionPolicyRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.TagResource";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UntagResource";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UntagResourceRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateByteMatchSetCommand(
  input: UpdateByteMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateByteMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateByteMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateGeoMatchSetCommand(
  input: UpdateGeoMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateGeoMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateGeoMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateIPSetCommand(
  input: UpdateIPSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateIPSet";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1UpdateIPSetRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateRateBasedRuleCommand(
  input: UpdateRateBasedRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateRateBasedRule";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateRateBasedRuleRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateRegexMatchSetCommand(
  input: UpdateRegexMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateRegexMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateRegexMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateRegexPatternSetCommand(
  input: UpdateRegexPatternSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateRegexPatternSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateRegexPatternSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateRuleCommand(
  input: UpdateRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateRule";
  let body: any = {};
  body = JSON.stringify(serializeAws_json1_1UpdateRuleRequest(input, context));
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateRuleGroupCommand(
  input: UpdateRuleGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateRuleGroup";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateRuleGroupRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateSizeConstraintSetCommand(
  input: UpdateSizeConstraintSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateSizeConstraintSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateSizeConstraintSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateSqlInjectionMatchSetCommand(
  input: UpdateSqlInjectionMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateSqlInjectionMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateSqlInjectionMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateWebACLCommand(
  input: UpdateWebACLCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateWebACL";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateWebACLRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1UpdateXssMatchSetCommand(
  input: UpdateXssMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AWSWAF_20150824.UpdateXssMatchSet";
  let body: any = {};
  body = JSON.stringify(
    serializeAws_json1_1UpdateXssMatchSetRequest(input, context)
  );
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/",
    headers: headers,
    body: body
  });
}

export async function deserializeAws_json1_1CreateByteMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateByteMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateByteMatchSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateByteMatchSetResponse(data, context);
  const response: CreateByteMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateByteMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateByteMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateByteMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateGeoMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGeoMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateGeoMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateGeoMatchSetResponse(data, context);
  const response: CreateGeoMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGeoMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateGeoMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGeoMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateIPSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateIPSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateIPSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateIPSetResponse(data, context);
  const response: CreateIPSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateIPSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateIPSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateIPSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateRateBasedRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRateBasedRuleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRateBasedRuleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRateBasedRuleResponse(data, context);
  const response: CreateRateBasedRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRateBasedRuleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateRateBasedRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRateBasedRuleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFBadRequestException":
      response = await deserializeAws_json1_1WAFBadRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateRegexMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRegexMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRegexMatchSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRegexMatchSetResponse(data, context);
  const response: CreateRegexMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRegexMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateRegexMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRegexMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateRegexPatternSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRegexPatternSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRegexPatternSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRegexPatternSetResponse(data, context);
  const response: CreateRegexPatternSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRegexPatternSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateRegexPatternSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRegexPatternSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRuleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRuleResponse(data, context);
  const response: CreateRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRuleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRuleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFBadRequestException":
      response = await deserializeAws_json1_1WAFBadRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateRuleGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRuleGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRuleGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRuleGroupResponse(data, context);
  const response: CreateRuleGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRuleGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateRuleGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRuleGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFBadRequestException":
      response = await deserializeAws_json1_1WAFBadRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateSizeConstraintSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSizeConstraintSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateSizeConstraintSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateSizeConstraintSetResponse(
    data,
    context
  );
  const response: CreateSizeConstraintSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSizeConstraintSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateSizeConstraintSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSizeConstraintSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateSqlInjectionMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSqlInjectionMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateSqlInjectionMatchSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateSqlInjectionMatchSetResponse(
    data,
    context
  );
  const response: CreateSqlInjectionMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSqlInjectionMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateSqlInjectionMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSqlInjectionMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateWebACLCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWebACLCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateWebACLCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateWebACLResponse(data, context);
  const response: CreateWebACLCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateWebACLResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateWebACLCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWebACLCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFBadRequestException":
      response = await deserializeAws_json1_1WAFBadRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateXssMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateXssMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateXssMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateXssMatchSetResponse(data, context);
  const response: CreateXssMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateXssMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateXssMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateXssMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteByteMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteByteMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteByteMatchSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteByteMatchSetResponse(data, context);
  const response: DeleteByteMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteByteMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteByteMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteByteMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteGeoMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGeoMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteGeoMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteGeoMatchSetResponse(data, context);
  const response: DeleteGeoMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteGeoMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteGeoMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGeoMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteIPSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIPSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteIPSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteIPSetResponse(data, context);
  const response: DeleteIPSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteIPSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteIPSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIPSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteLoggingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLoggingConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteLoggingConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteLoggingConfigurationResponse(
    data,
    context
  );
  const response: DeleteLoggingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteLoggingConfigurationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteLoggingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLoggingConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeletePermissionPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePermissionPolicyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeletePermissionPolicyCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeletePermissionPolicyResponse(
    data,
    context
  );
  const response: DeletePermissionPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeletePermissionPolicyResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeletePermissionPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePermissionPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteRateBasedRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRateBasedRuleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRateBasedRuleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRateBasedRuleResponse(data, context);
  const response: DeleteRateBasedRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRateBasedRuleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteRateBasedRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRateBasedRuleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteRegexMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegexMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRegexMatchSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRegexMatchSetResponse(data, context);
  const response: DeleteRegexMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRegexMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteRegexMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegexMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteRegexPatternSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegexPatternSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRegexPatternSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRegexPatternSetResponse(data, context);
  const response: DeleteRegexPatternSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRegexPatternSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteRegexPatternSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegexPatternSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRuleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRuleResponse(data, context);
  const response: DeleteRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRuleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRuleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteRuleGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRuleGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRuleGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRuleGroupResponse(data, context);
  const response: DeleteRuleGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRuleGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteRuleGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRuleGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteSizeConstraintSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSizeConstraintSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteSizeConstraintSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteSizeConstraintSetResponse(
    data,
    context
  );
  const response: DeleteSizeConstraintSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSizeConstraintSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteSizeConstraintSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSizeConstraintSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteSqlInjectionMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSqlInjectionMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteSqlInjectionMatchSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteSqlInjectionMatchSetResponse(
    data,
    context
  );
  const response: DeleteSqlInjectionMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSqlInjectionMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteSqlInjectionMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSqlInjectionMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteWebACLCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWebACLCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteWebACLCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteWebACLResponse(data, context);
  const response: DeleteWebACLCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteWebACLResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteWebACLCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWebACLCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteXssMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteXssMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteXssMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteXssMatchSetResponse(data, context);
  const response: DeleteXssMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteXssMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteXssMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteXssMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonEmptyEntityException":
      response = await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetByteMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetByteMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetByteMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetByteMatchSetResponse(data, context);
  const response: GetByteMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetByteMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetByteMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetByteMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetChangeTokenCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeTokenCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetChangeTokenCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetChangeTokenResponse(data, context);
  const response: GetChangeTokenCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetChangeTokenResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetChangeTokenCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeTokenCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetChangeTokenStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeTokenStatusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetChangeTokenStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetChangeTokenStatusResponse(data, context);
  const response: GetChangeTokenStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetChangeTokenStatusResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetChangeTokenStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeTokenStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetGeoMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGeoMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetGeoMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetGeoMatchSetResponse(data, context);
  const response: GetGeoMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGeoMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetGeoMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGeoMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetIPSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIPSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetIPSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetIPSetResponse(data, context);
  const response: GetIPSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetIPSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetIPSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIPSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetLoggingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggingConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetLoggingConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetLoggingConfigurationResponse(
    data,
    context
  );
  const response: GetLoggingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetLoggingConfigurationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetLoggingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggingConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetPermissionPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPermissionPolicyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPermissionPolicyCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPermissionPolicyResponse(data, context);
  const response: GetPermissionPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPermissionPolicyResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetPermissionPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPermissionPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetRateBasedRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRateBasedRuleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRateBasedRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRateBasedRuleResponse(data, context);
  const response: GetRateBasedRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRateBasedRuleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetRateBasedRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRateBasedRuleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetRateBasedRuleManagedKeysCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRateBasedRuleManagedKeysCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRateBasedRuleManagedKeysCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRateBasedRuleManagedKeysResponse(
    data,
    context
  );
  const response: GetRateBasedRuleManagedKeysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRateBasedRuleManagedKeysResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetRateBasedRuleManagedKeysCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRateBasedRuleManagedKeysCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetRegexMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegexMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRegexMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRegexMatchSetResponse(data, context);
  const response: GetRegexMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRegexMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetRegexMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegexMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetRegexPatternSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegexPatternSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRegexPatternSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRegexPatternSetResponse(data, context);
  const response: GetRegexPatternSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRegexPatternSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetRegexPatternSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegexPatternSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRuleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRuleResponse(data, context);
  const response: GetRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRuleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRuleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetRuleGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRuleGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRuleGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRuleGroupResponse(data, context);
  const response: GetRuleGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRuleGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetRuleGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRuleGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetSampledRequestsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSampledRequestsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSampledRequestsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSampledRequestsResponse(data, context);
  const response: GetSampledRequestsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSampledRequestsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetSampledRequestsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSampledRequestsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetSizeConstraintSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSizeConstraintSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSizeConstraintSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSizeConstraintSetResponse(data, context);
  const response: GetSizeConstraintSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSizeConstraintSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetSizeConstraintSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSizeConstraintSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetSqlInjectionMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSqlInjectionMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSqlInjectionMatchSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSqlInjectionMatchSetResponse(
    data,
    context
  );
  const response: GetSqlInjectionMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSqlInjectionMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetSqlInjectionMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSqlInjectionMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetWebACLCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWebACLCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetWebACLCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetWebACLResponse(data, context);
  const response: GetWebACLCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetWebACLResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetWebACLCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWebACLCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetXssMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetXssMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetXssMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetXssMatchSetResponse(data, context);
  const response: GetXssMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetXssMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetXssMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetXssMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListActivatedRulesInRuleGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListActivatedRulesInRuleGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListActivatedRulesInRuleGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListActivatedRulesInRuleGroupResponse(
    data,
    context
  );
  const response: ListActivatedRulesInRuleGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListActivatedRulesInRuleGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListActivatedRulesInRuleGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListActivatedRulesInRuleGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListByteMatchSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListByteMatchSetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListByteMatchSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListByteMatchSetsResponse(data, context);
  const response: ListByteMatchSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListByteMatchSetsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListByteMatchSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListByteMatchSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListGeoMatchSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGeoMatchSetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListGeoMatchSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListGeoMatchSetsResponse(data, context);
  const response: ListGeoMatchSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGeoMatchSetsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListGeoMatchSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGeoMatchSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListIPSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIPSetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListIPSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListIPSetsResponse(data, context);
  const response: ListIPSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListIPSetsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListIPSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIPSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListLoggingConfigurationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLoggingConfigurationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListLoggingConfigurationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListLoggingConfigurationsResponse(
    data,
    context
  );
  const response: ListLoggingConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListLoggingConfigurationsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListLoggingConfigurationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLoggingConfigurationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListRateBasedRulesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRateBasedRulesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRateBasedRulesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRateBasedRulesResponse(data, context);
  const response: ListRateBasedRulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRateBasedRulesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListRateBasedRulesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRateBasedRulesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListRegexMatchSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRegexMatchSetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRegexMatchSetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRegexMatchSetsResponse(data, context);
  const response: ListRegexMatchSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRegexMatchSetsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListRegexMatchSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRegexMatchSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListRegexPatternSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRegexPatternSetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRegexPatternSetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRegexPatternSetsResponse(data, context);
  const response: ListRegexPatternSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRegexPatternSetsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListRegexPatternSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRegexPatternSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListRuleGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRuleGroupsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRuleGroupsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRuleGroupsResponse(data, context);
  const response: ListRuleGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRuleGroupsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListRuleGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRuleGroupsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListRulesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRulesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRulesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRulesResponse(data, context);
  const response: ListRulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRulesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListRulesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRulesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListSizeConstraintSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSizeConstraintSetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSizeConstraintSetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSizeConstraintSetsResponse(
    data,
    context
  );
  const response: ListSizeConstraintSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSizeConstraintSetsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSizeConstraintSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSizeConstraintSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListSqlInjectionMatchSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSqlInjectionMatchSetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSqlInjectionMatchSetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSqlInjectionMatchSetsResponse(
    data,
    context
  );
  const response: ListSqlInjectionMatchSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSqlInjectionMatchSetsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSqlInjectionMatchSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSqlInjectionMatchSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListSubscribedRuleGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSubscribedRuleGroupsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSubscribedRuleGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSubscribedRuleGroupsResponse(
    data,
    context
  );
  const response: ListSubscribedRuleGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSubscribedRuleGroupsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListSubscribedRuleGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSubscribedRuleGroupsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceResponse(data, context);
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFBadRequestException":
      response = await deserializeAws_json1_1WAFBadRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListWebACLsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWebACLsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListWebACLsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListWebACLsResponse(data, context);
  const response: ListWebACLsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListWebACLsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListWebACLsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWebACLsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListXssMatchSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListXssMatchSetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListXssMatchSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListXssMatchSetsResponse(data, context);
  const response: ListXssMatchSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListXssMatchSetsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListXssMatchSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListXssMatchSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutLoggingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutLoggingConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutLoggingConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutLoggingConfigurationResponse(
    data,
    context
  );
  const response: PutLoggingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutLoggingConfigurationResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutLoggingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutLoggingConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFServiceLinkedRoleErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFServiceLinkedRoleErrorException":
      response = await deserializeAws_json1_1WAFServiceLinkedRoleErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutPermissionPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutPermissionPolicyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutPermissionPolicyCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutPermissionPolicyResponse(data, context);
  const response: PutPermissionPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutPermissionPolicyResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutPermissionPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutPermissionPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidPermissionPolicyException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidPermissionPolicyException":
      response = await deserializeAws_json1_1WAFInvalidPermissionPolicyExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TagResourceResponse(data, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFBadRequestException":
      response = await deserializeAws_json1_1WAFBadRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UntagResourceResponse(data, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFBadRequestException":
      response = await deserializeAws_json1_1WAFBadRequestExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationException":
      response = await deserializeAws_json1_1WAFTagOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFTagOperationInternalErrorException":
      response = await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateByteMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateByteMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateByteMatchSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateByteMatchSetResponse(data, context);
  const response: UpdateByteMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateByteMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateByteMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateByteMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateGeoMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGeoMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateGeoMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateGeoMatchSetResponse(data, context);
  const response: UpdateGeoMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateGeoMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateGeoMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGeoMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateIPSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIPSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateIPSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateIPSetResponse(data, context);
  const response: UpdateIPSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateIPSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateIPSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIPSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateRateBasedRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRateBasedRuleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRateBasedRuleCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRateBasedRuleResponse(data, context);
  const response: UpdateRateBasedRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRateBasedRuleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateRateBasedRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRateBasedRuleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateRegexMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRegexMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRegexMatchSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRegexMatchSetResponse(data, context);
  const response: UpdateRegexMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRegexMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateRegexMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRegexMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFDisallowedNameException":
      response = await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateRegexPatternSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRegexPatternSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRegexPatternSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRegexPatternSetResponse(data, context);
  const response: UpdateRegexPatternSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRegexPatternSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateRegexPatternSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRegexPatternSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidRegexPatternException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidRegexPatternException":
      response = await deserializeAws_json1_1WAFInvalidRegexPatternExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRuleCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRuleResponse(data, context);
  const response: UpdateRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRuleResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRuleCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateRuleGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRuleGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRuleGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRuleGroupResponse(data, context);
  const response: UpdateRuleGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRuleGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateRuleGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRuleGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateSizeConstraintSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSizeConstraintSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateSizeConstraintSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateSizeConstraintSetResponse(
    data,
    context
  );
  const response: UpdateSizeConstraintSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSizeConstraintSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateSizeConstraintSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSizeConstraintSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateSqlInjectionMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSqlInjectionMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateSqlInjectionMatchSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateSqlInjectionMatchSetResponse(
    data,
    context
  );
  const response: UpdateSqlInjectionMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSqlInjectionMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateSqlInjectionMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSqlInjectionMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateWebACLCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWebACLCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateWebACLCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateWebACLResponse(data, context);
  const response: UpdateWebACLCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateWebACLResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateWebACLCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWebACLCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFReferencedItemException":
      response = await deserializeAws_json1_1WAFReferencedItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFSubscriptionNotFoundException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFSubscriptionNotFoundException":
      response = await deserializeAws_json1_1WAFSubscriptionNotFoundExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateXssMatchSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateXssMatchSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateXssMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateXssMatchSetResponse(data, context);
  const response: UpdateXssMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateXssMatchSetResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateXssMatchSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateXssMatchSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInternalErrorException":
      response = await deserializeAws_json1_1WAFInternalErrorExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidAccountException":
      response = await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidOperationException":
      response = await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFInvalidParameterException":
      response = await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFLimitsExceededException":
      response = await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentContainerException":
      response = await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFNonexistentItemException":
      response = await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.gokucustomerapiservice.v20150409#WAFStaleDataException":
      response = await deserializeAws_json1_1WAFStaleDataExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = errorCode || "UnknownError";
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1WAFBadRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFBadRequestException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFBadRequestException(
    body,
    context
  );
  const contents: WAFBadRequestException = {
    name: "WAFBadRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFDisallowedNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFDisallowedNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFDisallowedNameException(
    body,
    context
  );
  const contents: WAFDisallowedNameException = {
    name: "WAFDisallowedNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFInternalErrorExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInternalErrorException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInternalErrorException(
    body,
    context
  );
  const contents: WAFInternalErrorException = {
    name: "WAFInternalErrorException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidAccountExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInvalidAccountException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInvalidAccountException(
    body,
    context
  );
  const contents: WAFInvalidAccountException = {
    name: "WAFInvalidAccountException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidOperationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInvalidOperationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInvalidOperationException(
    body,
    context
  );
  const contents: WAFInvalidOperationException = {
    name: "WAFInvalidOperationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidParameterExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInvalidParameterException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInvalidParameterException(
    body,
    context
  );
  const contents: WAFInvalidParameterException = {
    name: "WAFInvalidParameterException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidPermissionPolicyExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInvalidPermissionPolicyException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInvalidPermissionPolicyException(
    body,
    context
  );
  const contents: WAFInvalidPermissionPolicyException = {
    name: "WAFInvalidPermissionPolicyException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidRegexPatternExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInvalidRegexPatternException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInvalidRegexPatternException(
    body,
    context
  );
  const contents: WAFInvalidRegexPatternException = {
    name: "WAFInvalidRegexPatternException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFLimitsExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFLimitsExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFLimitsExceededException(
    body,
    context
  );
  const contents: WAFLimitsExceededException = {
    name: "WAFLimitsExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFNonEmptyEntityException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFNonEmptyEntityException(
    body,
    context
  );
  const contents: WAFNonEmptyEntityException = {
    name: "WAFNonEmptyEntityException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFNonexistentContainerExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFNonexistentContainerException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFNonexistentContainerException(
    body,
    context
  );
  const contents: WAFNonexistentContainerException = {
    name: "WAFNonexistentContainerException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFNonexistentItemExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFNonexistentItemException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFNonexistentItemException(
    body,
    context
  );
  const contents: WAFNonexistentItemException = {
    name: "WAFNonexistentItemException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFReferencedItemExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFReferencedItemException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFReferencedItemException(
    body,
    context
  );
  const contents: WAFReferencedItemException = {
    name: "WAFReferencedItemException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFServiceLinkedRoleErrorExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFServiceLinkedRoleErrorException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFServiceLinkedRoleErrorException(
    body,
    context
  );
  const contents: WAFServiceLinkedRoleErrorException = {
    name: "WAFServiceLinkedRoleErrorException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFStaleDataExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFStaleDataException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFStaleDataException(
    body,
    context
  );
  const contents: WAFStaleDataException = {
    name: "WAFStaleDataException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFSubscriptionNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFSubscriptionNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFSubscriptionNotFoundException(
    body,
    context
  );
  const contents: WAFSubscriptionNotFoundException = {
    name: "WAFSubscriptionNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFTagOperationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFTagOperationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFTagOperationException(
    body,
    context
  );
  const contents: WAFTagOperationException = {
    name: "WAFTagOperationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFTagOperationInternalErrorException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFTagOperationInternalErrorException(
    body,
    context
  );
  const contents: WAFTagOperationInternalErrorException = {
    name: "WAFTagOperationInternalErrorException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1ActivatedRule = (
  input: ActivatedRule,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = serializeAws_json1_1WafAction(input.Action, context);
  }
  if (input.ExcludedRules !== undefined) {
    bodyParams["ExcludedRules"] = serializeAws_json1_1ExcludedRules(
      input.ExcludedRules,
      context
    );
  }
  if (input.OverrideAction !== undefined) {
    bodyParams["OverrideAction"] = serializeAws_json1_1WafOverrideAction(
      input.OverrideAction,
      context
    );
  }
  if (input.Priority !== undefined) {
    bodyParams["Priority"] = input.Priority;
  }
  if (input.RuleId !== undefined) {
    bodyParams["RuleId"] = input.RuleId;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1ByteMatchSetUpdate = (
  input: ByteMatchSetUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.ByteMatchTuple !== undefined) {
    bodyParams["ByteMatchTuple"] = serializeAws_json1_1ByteMatchTuple(
      input.ByteMatchTuple,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ByteMatchSetUpdates = (
  input: Array<ByteMatchSetUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ByteMatchSetUpdate(entry, context)
  );
};

const serializeAws_json1_1ByteMatchTuple = (
  input: ByteMatchTuple,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.FieldToMatch !== undefined) {
    bodyParams["FieldToMatch"] = serializeAws_json1_1FieldToMatch(
      input.FieldToMatch,
      context
    );
  }
  if (input.PositionalConstraint !== undefined) {
    bodyParams["PositionalConstraint"] = input.PositionalConstraint;
  }
  if (input.TargetString !== undefined) {
    bodyParams["TargetString"] = context.base64Encoder(input.TargetString);
  }
  if (input.TextTransformation !== undefined) {
    bodyParams["TextTransformation"] = input.TextTransformation;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateByteMatchSetRequest = (
  input: CreateByteMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateGeoMatchSetRequest = (
  input: CreateGeoMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateIPSetRequest = (
  input: CreateIPSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateRateBasedRuleRequest = (
  input: CreateRateBasedRuleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.MetricName !== undefined) {
    bodyParams["MetricName"] = input.MetricName;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RateKey !== undefined) {
    bodyParams["RateKey"] = input.RateKey;
  }
  if (input.RateLimit !== undefined) {
    bodyParams["RateLimit"] = input.RateLimit;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateRegexMatchSetRequest = (
  input: CreateRegexMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateRegexPatternSetRequest = (
  input: CreateRegexPatternSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateRuleGroupRequest = (
  input: CreateRuleGroupRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.MetricName !== undefined) {
    bodyParams["MetricName"] = input.MetricName;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateRuleRequest = (
  input: CreateRuleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.MetricName !== undefined) {
    bodyParams["MetricName"] = input.MetricName;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateSizeConstraintSetRequest = (
  input: CreateSizeConstraintSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateSqlInjectionMatchSetRequest = (
  input: CreateSqlInjectionMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateWebACLRequest = (
  input: CreateWebACLRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.DefaultAction !== undefined) {
    bodyParams["DefaultAction"] = serializeAws_json1_1WafAction(
      input.DefaultAction,
      context
    );
  }
  if (input.MetricName !== undefined) {
    bodyParams["MetricName"] = input.MetricName;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateXssMatchSetRequest = (
  input: CreateXssMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteByteMatchSetRequest = (
  input: DeleteByteMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ByteMatchSetId !== undefined) {
    bodyParams["ByteMatchSetId"] = input.ByteMatchSetId;
  }
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteGeoMatchSetRequest = (
  input: DeleteGeoMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.GeoMatchSetId !== undefined) {
    bodyParams["GeoMatchSetId"] = input.GeoMatchSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteIPSetRequest = (
  input: DeleteIPSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.IPSetId !== undefined) {
    bodyParams["IPSetId"] = input.IPSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteLoggingConfigurationRequest = (
  input: DeleteLoggingConfigurationRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeletePermissionPolicyRequest = (
  input: DeletePermissionPolicyRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteRateBasedRuleRequest = (
  input: DeleteRateBasedRuleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.RuleId !== undefined) {
    bodyParams["RuleId"] = input.RuleId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteRegexMatchSetRequest = (
  input: DeleteRegexMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.RegexMatchSetId !== undefined) {
    bodyParams["RegexMatchSetId"] = input.RegexMatchSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteRegexPatternSetRequest = (
  input: DeleteRegexPatternSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.RegexPatternSetId !== undefined) {
    bodyParams["RegexPatternSetId"] = input.RegexPatternSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteRuleGroupRequest = (
  input: DeleteRuleGroupRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.RuleGroupId !== undefined) {
    bodyParams["RuleGroupId"] = input.RuleGroupId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteRuleRequest = (
  input: DeleteRuleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.RuleId !== undefined) {
    bodyParams["RuleId"] = input.RuleId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteSizeConstraintSetRequest = (
  input: DeleteSizeConstraintSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.SizeConstraintSetId !== undefined) {
    bodyParams["SizeConstraintSetId"] = input.SizeConstraintSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteSqlInjectionMatchSetRequest = (
  input: DeleteSqlInjectionMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.SqlInjectionMatchSetId !== undefined) {
    bodyParams["SqlInjectionMatchSetId"] = input.SqlInjectionMatchSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteWebACLRequest = (
  input: DeleteWebACLRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.WebACLId !== undefined) {
    bodyParams["WebACLId"] = input.WebACLId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteXssMatchSetRequest = (
  input: DeleteXssMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.XssMatchSetId !== undefined) {
    bodyParams["XssMatchSetId"] = input.XssMatchSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1ExcludedRule = (
  input: ExcludedRule,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.RuleId !== undefined) {
    bodyParams["RuleId"] = input.RuleId;
  }
  return bodyParams;
};

const serializeAws_json1_1ExcludedRules = (
  input: Array<ExcludedRule>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1ExcludedRule(entry, context)
  );
};

const serializeAws_json1_1FieldToMatch = (
  input: FieldToMatch,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Data !== undefined) {
    bodyParams["Data"] = input.Data;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1GeoMatchConstraint = (
  input: GeoMatchConstraint,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1GeoMatchSetUpdate = (
  input: GeoMatchSetUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.GeoMatchConstraint !== undefined) {
    bodyParams["GeoMatchConstraint"] = serializeAws_json1_1GeoMatchConstraint(
      input.GeoMatchConstraint,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1GeoMatchSetUpdates = (
  input: Array<GeoMatchSetUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1GeoMatchSetUpdate(entry, context)
  );
};

const serializeAws_json1_1GetByteMatchSetRequest = (
  input: GetByteMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ByteMatchSetId !== undefined) {
    bodyParams["ByteMatchSetId"] = input.ByteMatchSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetChangeTokenRequest = (
  input: GetChangeTokenRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  return bodyParams;
};

const serializeAws_json1_1GetChangeTokenStatusRequest = (
  input: GetChangeTokenStatusRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  return bodyParams;
};

const serializeAws_json1_1GetGeoMatchSetRequest = (
  input: GetGeoMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.GeoMatchSetId !== undefined) {
    bodyParams["GeoMatchSetId"] = input.GeoMatchSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetIPSetRequest = (
  input: GetIPSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.IPSetId !== undefined) {
    bodyParams["IPSetId"] = input.IPSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetLoggingConfigurationRequest = (
  input: GetLoggingConfigurationRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetPermissionPolicyRequest = (
  input: GetPermissionPolicyRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GetRateBasedRuleManagedKeysRequest = (
  input: GetRateBasedRuleManagedKeysRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  if (input.RuleId !== undefined) {
    bodyParams["RuleId"] = input.RuleId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetRateBasedRuleRequest = (
  input: GetRateBasedRuleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.RuleId !== undefined) {
    bodyParams["RuleId"] = input.RuleId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetRegexMatchSetRequest = (
  input: GetRegexMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.RegexMatchSetId !== undefined) {
    bodyParams["RegexMatchSetId"] = input.RegexMatchSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetRegexPatternSetRequest = (
  input: GetRegexPatternSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.RegexPatternSetId !== undefined) {
    bodyParams["RegexPatternSetId"] = input.RegexPatternSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetRuleGroupRequest = (
  input: GetRuleGroupRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.RuleGroupId !== undefined) {
    bodyParams["RuleGroupId"] = input.RuleGroupId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetRuleRequest = (
  input: GetRuleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.RuleId !== undefined) {
    bodyParams["RuleId"] = input.RuleId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetSampledRequestsRequest = (
  input: GetSampledRequestsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MaxItems !== undefined) {
    bodyParams["MaxItems"] = input.MaxItems;
  }
  if (input.RuleId !== undefined) {
    bodyParams["RuleId"] = input.RuleId;
  }
  if (input.TimeWindow !== undefined) {
    bodyParams["TimeWindow"] = serializeAws_json1_1TimeWindow(
      input.TimeWindow,
      context
    );
  }
  if (input.WebAclId !== undefined) {
    bodyParams["WebAclId"] = input.WebAclId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetSizeConstraintSetRequest = (
  input: GetSizeConstraintSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.SizeConstraintSetId !== undefined) {
    bodyParams["SizeConstraintSetId"] = input.SizeConstraintSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetSqlInjectionMatchSetRequest = (
  input: GetSqlInjectionMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.SqlInjectionMatchSetId !== undefined) {
    bodyParams["SqlInjectionMatchSetId"] = input.SqlInjectionMatchSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetWebACLRequest = (
  input: GetWebACLRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.WebACLId !== undefined) {
    bodyParams["WebACLId"] = input.WebACLId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetXssMatchSetRequest = (
  input: GetXssMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.XssMatchSetId !== undefined) {
    bodyParams["XssMatchSetId"] = input.XssMatchSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1IPSetDescriptor = (
  input: IPSetDescriptor,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1IPSetUpdate = (
  input: IPSetUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.IPSetDescriptor !== undefined) {
    bodyParams["IPSetDescriptor"] = serializeAws_json1_1IPSetDescriptor(
      input.IPSetDescriptor,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1IPSetUpdates = (
  input: Array<IPSetUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1IPSetUpdate(entry, context)
  );
};

const serializeAws_json1_1ListActivatedRulesInRuleGroupRequest = (
  input: ListActivatedRulesInRuleGroupRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  if (input.RuleGroupId !== undefined) {
    bodyParams["RuleGroupId"] = input.RuleGroupId;
  }
  return bodyParams;
};

const serializeAws_json1_1ListByteMatchSetsRequest = (
  input: ListByteMatchSetsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListGeoMatchSetsRequest = (
  input: ListGeoMatchSetsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListIPSetsRequest = (
  input: ListIPSetsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListLoggingConfigurationsRequest = (
  input: ListLoggingConfigurationsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListRateBasedRulesRequest = (
  input: ListRateBasedRulesRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListRegexMatchSetsRequest = (
  input: ListRegexMatchSetsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListRegexPatternSetsRequest = (
  input: ListRegexPatternSetsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListRuleGroupsRequest = (
  input: ListRuleGroupsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListRulesRequest = (
  input: ListRulesRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSizeConstraintSetsRequest = (
  input: ListSizeConstraintSetsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSqlInjectionMatchSetsRequest = (
  input: ListSqlInjectionMatchSetsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListSubscribedRuleGroupsRequest = (
  input: ListSubscribedRuleGroupsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsForResourceRequest = (
  input: ListTagsForResourceRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  if (input.ResourceARN !== undefined) {
    bodyParams["ResourceARN"] = input.ResourceARN;
  }
  return bodyParams;
};

const serializeAws_json1_1ListWebACLsRequest = (
  input: ListWebACLsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1ListXssMatchSetsRequest = (
  input: ListXssMatchSetsRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextMarker !== undefined) {
    bodyParams["NextMarker"] = input.NextMarker;
  }
  return bodyParams;
};

const serializeAws_json1_1LogDestinationConfigs = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1LoggingConfiguration = (
  input: LoggingConfiguration,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LogDestinationConfigs !== undefined) {
    bodyParams[
      "LogDestinationConfigs"
    ] = serializeAws_json1_1LogDestinationConfigs(
      input.LogDestinationConfigs,
      context
    );
  }
  if (input.RedactedFields !== undefined) {
    bodyParams["RedactedFields"] = serializeAws_json1_1RedactedFields(
      input.RedactedFields,
      context
    );
  }
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1Predicate = (
  input: Predicate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.DataId !== undefined) {
    bodyParams["DataId"] = input.DataId;
  }
  if (input.Negated !== undefined) {
    bodyParams["Negated"] = input.Negated;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1PutLoggingConfigurationRequest = (
  input: PutLoggingConfigurationRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.LoggingConfiguration !== undefined) {
    bodyParams[
      "LoggingConfiguration"
    ] = serializeAws_json1_1LoggingConfiguration(
      input.LoggingConfiguration,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1PutPermissionPolicyRequest = (
  input: PutPermissionPolicyRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Policy !== undefined) {
    bodyParams["Policy"] = input.Policy;
  }
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1RedactedFields = (
  input: Array<FieldToMatch>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1FieldToMatch(entry, context)
  );
};

const serializeAws_json1_1RegexMatchSetUpdate = (
  input: RegexMatchSetUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.RegexMatchTuple !== undefined) {
    bodyParams["RegexMatchTuple"] = serializeAws_json1_1RegexMatchTuple(
      input.RegexMatchTuple,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1RegexMatchSetUpdates = (
  input: Array<RegexMatchSetUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1RegexMatchSetUpdate(entry, context)
  );
};

const serializeAws_json1_1RegexMatchTuple = (
  input: RegexMatchTuple,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.FieldToMatch !== undefined) {
    bodyParams["FieldToMatch"] = serializeAws_json1_1FieldToMatch(
      input.FieldToMatch,
      context
    );
  }
  if (input.RegexPatternSetId !== undefined) {
    bodyParams["RegexPatternSetId"] = input.RegexPatternSetId;
  }
  if (input.TextTransformation !== undefined) {
    bodyParams["TextTransformation"] = input.TextTransformation;
  }
  return bodyParams;
};

const serializeAws_json1_1RegexPatternSetUpdate = (
  input: RegexPatternSetUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.RegexPatternString !== undefined) {
    bodyParams["RegexPatternString"] = input.RegexPatternString;
  }
  return bodyParams;
};

const serializeAws_json1_1RegexPatternSetUpdates = (
  input: Array<RegexPatternSetUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1RegexPatternSetUpdate(entry, context)
  );
};

const serializeAws_json1_1RuleGroupUpdate = (
  input: RuleGroupUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.ActivatedRule !== undefined) {
    bodyParams["ActivatedRule"] = serializeAws_json1_1ActivatedRule(
      input.ActivatedRule,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1RuleGroupUpdates = (
  input: Array<RuleGroupUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1RuleGroupUpdate(entry, context)
  );
};

const serializeAws_json1_1RuleUpdate = (
  input: RuleUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.Predicate !== undefined) {
    bodyParams["Predicate"] = serializeAws_json1_1Predicate(
      input.Predicate,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1RuleUpdates = (
  input: Array<RuleUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1RuleUpdate(entry, context)
  );
};

const serializeAws_json1_1SizeConstraint = (
  input: SizeConstraint,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ComparisonOperator !== undefined) {
    bodyParams["ComparisonOperator"] = input.ComparisonOperator;
  }
  if (input.FieldToMatch !== undefined) {
    bodyParams["FieldToMatch"] = serializeAws_json1_1FieldToMatch(
      input.FieldToMatch,
      context
    );
  }
  if (input.Size !== undefined) {
    bodyParams["Size"] = input.Size;
  }
  if (input.TextTransformation !== undefined) {
    bodyParams["TextTransformation"] = input.TextTransformation;
  }
  return bodyParams;
};

const serializeAws_json1_1SizeConstraintSetUpdate = (
  input: SizeConstraintSetUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.SizeConstraint !== undefined) {
    bodyParams["SizeConstraint"] = serializeAws_json1_1SizeConstraint(
      input.SizeConstraint,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SizeConstraintSetUpdates = (
  input: Array<SizeConstraintSetUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1SizeConstraintSetUpdate(entry, context)
  );
};

const serializeAws_json1_1SqlInjectionMatchSetUpdate = (
  input: SqlInjectionMatchSetUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.SqlInjectionMatchTuple !== undefined) {
    bodyParams[
      "SqlInjectionMatchTuple"
    ] = serializeAws_json1_1SqlInjectionMatchTuple(
      input.SqlInjectionMatchTuple,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1SqlInjectionMatchSetUpdates = (
  input: Array<SqlInjectionMatchSetUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1SqlInjectionMatchSetUpdate(entry, context)
  );
};

const serializeAws_json1_1SqlInjectionMatchTuple = (
  input: SqlInjectionMatchTuple,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.FieldToMatch !== undefined) {
    bodyParams["FieldToMatch"] = serializeAws_json1_1FieldToMatch(
      input.FieldToMatch,
      context
    );
  }
  if (input.TextTransformation !== undefined) {
    bodyParams["TextTransformation"] = input.TextTransformation;
  }
  return bodyParams;
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  let bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagKeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => serializeAws_json1_1Tag(entry, context));
};

const serializeAws_json1_1TagResourceRequest = (
  input: TagResourceRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceARN !== undefined) {
    bodyParams["ResourceARN"] = input.ResourceARN;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1TimeWindow = (
  input: TimeWindow,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndTime !== undefined) {
    bodyParams["EndTime"] = Math.round(input.EndTime.getTime() / 1000);
  }
  if (input.StartTime !== undefined) {
    bodyParams["StartTime"] = Math.round(input.StartTime.getTime() / 1000);
  }
  return bodyParams;
};

const serializeAws_json1_1UntagResourceRequest = (
  input: UntagResourceRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceARN !== undefined) {
    bodyParams["ResourceARN"] = input.ResourceARN;
  }
  if (input.TagKeys !== undefined) {
    bodyParams["TagKeys"] = serializeAws_json1_1TagKeyList(
      input.TagKeys,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateByteMatchSetRequest = (
  input: UpdateByteMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ByteMatchSetId !== undefined) {
    bodyParams["ByteMatchSetId"] = input.ByteMatchSetId;
  }
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1ByteMatchSetUpdates(
      input.Updates,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateGeoMatchSetRequest = (
  input: UpdateGeoMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.GeoMatchSetId !== undefined) {
    bodyParams["GeoMatchSetId"] = input.GeoMatchSetId;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1GeoMatchSetUpdates(
      input.Updates,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateIPSetRequest = (
  input: UpdateIPSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.IPSetId !== undefined) {
    bodyParams["IPSetId"] = input.IPSetId;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1IPSetUpdates(
      input.Updates,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRateBasedRuleRequest = (
  input: UpdateRateBasedRuleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.RateLimit !== undefined) {
    bodyParams["RateLimit"] = input.RateLimit;
  }
  if (input.RuleId !== undefined) {
    bodyParams["RuleId"] = input.RuleId;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1RuleUpdates(
      input.Updates,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRegexMatchSetRequest = (
  input: UpdateRegexMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.RegexMatchSetId !== undefined) {
    bodyParams["RegexMatchSetId"] = input.RegexMatchSetId;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1RegexMatchSetUpdates(
      input.Updates,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRegexPatternSetRequest = (
  input: UpdateRegexPatternSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.RegexPatternSetId !== undefined) {
    bodyParams["RegexPatternSetId"] = input.RegexPatternSetId;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1RegexPatternSetUpdates(
      input.Updates,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRuleGroupRequest = (
  input: UpdateRuleGroupRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.RuleGroupId !== undefined) {
    bodyParams["RuleGroupId"] = input.RuleGroupId;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1RuleGroupUpdates(
      input.Updates,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRuleRequest = (
  input: UpdateRuleRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.RuleId !== undefined) {
    bodyParams["RuleId"] = input.RuleId;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1RuleUpdates(
      input.Updates,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateSizeConstraintSetRequest = (
  input: UpdateSizeConstraintSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.SizeConstraintSetId !== undefined) {
    bodyParams["SizeConstraintSetId"] = input.SizeConstraintSetId;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1SizeConstraintSetUpdates(
      input.Updates,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateSqlInjectionMatchSetRequest = (
  input: UpdateSqlInjectionMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.SqlInjectionMatchSetId !== undefined) {
    bodyParams["SqlInjectionMatchSetId"] = input.SqlInjectionMatchSetId;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1SqlInjectionMatchSetUpdates(
      input.Updates,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateWebACLRequest = (
  input: UpdateWebACLRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.DefaultAction !== undefined) {
    bodyParams["DefaultAction"] = serializeAws_json1_1WafAction(
      input.DefaultAction,
      context
    );
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1WebACLUpdates(
      input.Updates,
      context
    );
  }
  if (input.WebACLId !== undefined) {
    bodyParams["WebACLId"] = input.WebACLId;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateXssMatchSetRequest = (
  input: UpdateXssMatchSetRequest,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ChangeToken !== undefined) {
    bodyParams["ChangeToken"] = input.ChangeToken;
  }
  if (input.Updates !== undefined) {
    bodyParams["Updates"] = serializeAws_json1_1XssMatchSetUpdates(
      input.Updates,
      context
    );
  }
  if (input.XssMatchSetId !== undefined) {
    bodyParams["XssMatchSetId"] = input.XssMatchSetId;
  }
  return bodyParams;
};

const serializeAws_json1_1WafAction = (
  input: WafAction,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1WafOverrideAction = (
  input: WafOverrideAction,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1WebACLUpdate = (
  input: WebACLUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.ActivatedRule !== undefined) {
    bodyParams["ActivatedRule"] = serializeAws_json1_1ActivatedRule(
      input.ActivatedRule,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1WebACLUpdates = (
  input: Array<WebACLUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1WebACLUpdate(entry, context)
  );
};

const serializeAws_json1_1XssMatchSetUpdate = (
  input: XssMatchSetUpdate,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Action !== undefined) {
    bodyParams["Action"] = input.Action;
  }
  if (input.XssMatchTuple !== undefined) {
    bodyParams["XssMatchTuple"] = serializeAws_json1_1XssMatchTuple(
      input.XssMatchTuple,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1XssMatchSetUpdates = (
  input: Array<XssMatchSetUpdate>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1XssMatchSetUpdate(entry, context)
  );
};

const serializeAws_json1_1XssMatchTuple = (
  input: XssMatchTuple,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.FieldToMatch !== undefined) {
    bodyParams["FieldToMatch"] = serializeAws_json1_1FieldToMatch(
      input.FieldToMatch,
      context
    );
  }
  if (input.TextTransformation !== undefined) {
    bodyParams["TextTransformation"] = input.TextTransformation;
  }
  return bodyParams;
};

const deserializeAws_json1_1ActivatedRule = (
  output: any,
  context: __SerdeContext
): ActivatedRule => {
  let contents: any = {
    __type: "ActivatedRule",
    Action: undefined,
    ExcludedRules: undefined,
    OverrideAction: undefined,
    Priority: undefined,
    RuleId: undefined,
    Type: undefined
  };
  if (output.Action !== undefined) {
    contents.Action = deserializeAws_json1_1WafAction(output.Action, context);
  }
  if (output.ExcludedRules !== undefined) {
    contents.ExcludedRules = deserializeAws_json1_1ExcludedRules(
      output.ExcludedRules,
      context
    );
  }
  if (output.OverrideAction !== undefined) {
    contents.OverrideAction = deserializeAws_json1_1WafOverrideAction(
      output.OverrideAction,
      context
    );
  }
  if (output.Priority !== undefined) {
    contents.Priority = output.Priority;
  }
  if (output.RuleId !== undefined) {
    contents.RuleId = output.RuleId;
  }
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1ActivatedRules = (
  output: any,
  context: __SerdeContext
): Array<ActivatedRule> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ActivatedRule(entry, context)
  );
};

const deserializeAws_json1_1ByteMatchSet = (
  output: any,
  context: __SerdeContext
): ByteMatchSet => {
  let contents: any = {
    __type: "ByteMatchSet",
    ByteMatchSetId: undefined,
    ByteMatchTuples: undefined,
    Name: undefined
  };
  if (output.ByteMatchSetId !== undefined) {
    contents.ByteMatchSetId = output.ByteMatchSetId;
  }
  if (output.ByteMatchTuples !== undefined) {
    contents.ByteMatchTuples = deserializeAws_json1_1ByteMatchTuples(
      output.ByteMatchTuples,
      context
    );
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1ByteMatchSetSummaries = (
  output: any,
  context: __SerdeContext
): Array<ByteMatchSetSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ByteMatchSetSummary(entry, context)
  );
};

const deserializeAws_json1_1ByteMatchSetSummary = (
  output: any,
  context: __SerdeContext
): ByteMatchSetSummary => {
  let contents: any = {
    __type: "ByteMatchSetSummary",
    ByteMatchSetId: undefined,
    Name: undefined
  };
  if (output.ByteMatchSetId !== undefined) {
    contents.ByteMatchSetId = output.ByteMatchSetId;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1ByteMatchTuple = (
  output: any,
  context: __SerdeContext
): ByteMatchTuple => {
  let contents: any = {
    __type: "ByteMatchTuple",
    FieldToMatch: undefined,
    PositionalConstraint: undefined,
    TargetString: undefined,
    TextTransformation: undefined
  };
  if (output.FieldToMatch !== undefined) {
    contents.FieldToMatch = deserializeAws_json1_1FieldToMatch(
      output.FieldToMatch,
      context
    );
  }
  if (output.PositionalConstraint !== undefined) {
    contents.PositionalConstraint = output.PositionalConstraint;
  }
  if (output.TargetString !== undefined) {
    contents.TargetString = context.base64Decoder(output.TargetString);
  }
  if (output.TextTransformation !== undefined) {
    contents.TextTransformation = output.TextTransformation;
  }
  return contents;
};

const deserializeAws_json1_1ByteMatchTuples = (
  output: any,
  context: __SerdeContext
): Array<ByteMatchTuple> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ByteMatchTuple(entry, context)
  );
};

const deserializeAws_json1_1CreateByteMatchSetResponse = (
  output: any,
  context: __SerdeContext
): CreateByteMatchSetResponse => {
  let contents: any = {
    __type: "CreateByteMatchSetResponse",
    ByteMatchSet: undefined,
    ChangeToken: undefined
  };
  if (output.ByteMatchSet !== undefined) {
    contents.ByteMatchSet = deserializeAws_json1_1ByteMatchSet(
      output.ByteMatchSet,
      context
    );
  }
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1CreateGeoMatchSetResponse = (
  output: any,
  context: __SerdeContext
): CreateGeoMatchSetResponse => {
  let contents: any = {
    __type: "CreateGeoMatchSetResponse",
    ChangeToken: undefined,
    GeoMatchSet: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.GeoMatchSet !== undefined) {
    contents.GeoMatchSet = deserializeAws_json1_1GeoMatchSet(
      output.GeoMatchSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateIPSetResponse = (
  output: any,
  context: __SerdeContext
): CreateIPSetResponse => {
  let contents: any = {
    __type: "CreateIPSetResponse",
    ChangeToken: undefined,
    IPSet: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.IPSet !== undefined) {
    contents.IPSet = deserializeAws_json1_1IPSet(output.IPSet, context);
  }
  return contents;
};

const deserializeAws_json1_1CreateRateBasedRuleResponse = (
  output: any,
  context: __SerdeContext
): CreateRateBasedRuleResponse => {
  let contents: any = {
    __type: "CreateRateBasedRuleResponse",
    ChangeToken: undefined,
    Rule: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.Rule !== undefined) {
    contents.Rule = deserializeAws_json1_1RateBasedRule(output.Rule, context);
  }
  return contents;
};

const deserializeAws_json1_1CreateRegexMatchSetResponse = (
  output: any,
  context: __SerdeContext
): CreateRegexMatchSetResponse => {
  let contents: any = {
    __type: "CreateRegexMatchSetResponse",
    ChangeToken: undefined,
    RegexMatchSet: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.RegexMatchSet !== undefined) {
    contents.RegexMatchSet = deserializeAws_json1_1RegexMatchSet(
      output.RegexMatchSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateRegexPatternSetResponse = (
  output: any,
  context: __SerdeContext
): CreateRegexPatternSetResponse => {
  let contents: any = {
    __type: "CreateRegexPatternSetResponse",
    ChangeToken: undefined,
    RegexPatternSet: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.RegexPatternSet !== undefined) {
    contents.RegexPatternSet = deserializeAws_json1_1RegexPatternSet(
      output.RegexPatternSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateRuleGroupResponse = (
  output: any,
  context: __SerdeContext
): CreateRuleGroupResponse => {
  let contents: any = {
    __type: "CreateRuleGroupResponse",
    ChangeToken: undefined,
    RuleGroup: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.RuleGroup !== undefined) {
    contents.RuleGroup = deserializeAws_json1_1RuleGroup(
      output.RuleGroup,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateRuleResponse = (
  output: any,
  context: __SerdeContext
): CreateRuleResponse => {
  let contents: any = {
    __type: "CreateRuleResponse",
    ChangeToken: undefined,
    Rule: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.Rule !== undefined) {
    contents.Rule = deserializeAws_json1_1Rule(output.Rule, context);
  }
  return contents;
};

const deserializeAws_json1_1CreateSizeConstraintSetResponse = (
  output: any,
  context: __SerdeContext
): CreateSizeConstraintSetResponse => {
  let contents: any = {
    __type: "CreateSizeConstraintSetResponse",
    ChangeToken: undefined,
    SizeConstraintSet: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.SizeConstraintSet !== undefined) {
    contents.SizeConstraintSet = deserializeAws_json1_1SizeConstraintSet(
      output.SizeConstraintSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateSqlInjectionMatchSetResponse = (
  output: any,
  context: __SerdeContext
): CreateSqlInjectionMatchSetResponse => {
  let contents: any = {
    __type: "CreateSqlInjectionMatchSetResponse",
    ChangeToken: undefined,
    SqlInjectionMatchSet: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.SqlInjectionMatchSet !== undefined) {
    contents.SqlInjectionMatchSet = deserializeAws_json1_1SqlInjectionMatchSet(
      output.SqlInjectionMatchSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateWebACLResponse = (
  output: any,
  context: __SerdeContext
): CreateWebACLResponse => {
  let contents: any = {
    __type: "CreateWebACLResponse",
    ChangeToken: undefined,
    WebACL: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.WebACL !== undefined) {
    contents.WebACL = deserializeAws_json1_1WebACL(output.WebACL, context);
  }
  return contents;
};

const deserializeAws_json1_1CreateXssMatchSetResponse = (
  output: any,
  context: __SerdeContext
): CreateXssMatchSetResponse => {
  let contents: any = {
    __type: "CreateXssMatchSetResponse",
    ChangeToken: undefined,
    XssMatchSet: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  if (output.XssMatchSet !== undefined) {
    contents.XssMatchSet = deserializeAws_json1_1XssMatchSet(
      output.XssMatchSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteByteMatchSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteByteMatchSetResponse => {
  let contents: any = {
    __type: "DeleteByteMatchSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteGeoMatchSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteGeoMatchSetResponse => {
  let contents: any = {
    __type: "DeleteGeoMatchSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteIPSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteIPSetResponse => {
  let contents: any = {
    __type: "DeleteIPSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteLoggingConfigurationResponse = (
  output: any,
  context: __SerdeContext
): DeleteLoggingConfigurationResponse => {
  let contents: any = {
    __type: "DeleteLoggingConfigurationResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeletePermissionPolicyResponse = (
  output: any,
  context: __SerdeContext
): DeletePermissionPolicyResponse => {
  let contents: any = {
    __type: "DeletePermissionPolicyResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteRateBasedRuleResponse = (
  output: any,
  context: __SerdeContext
): DeleteRateBasedRuleResponse => {
  let contents: any = {
    __type: "DeleteRateBasedRuleResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteRegexMatchSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteRegexMatchSetResponse => {
  let contents: any = {
    __type: "DeleteRegexMatchSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteRegexPatternSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteRegexPatternSetResponse => {
  let contents: any = {
    __type: "DeleteRegexPatternSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteRuleGroupResponse = (
  output: any,
  context: __SerdeContext
): DeleteRuleGroupResponse => {
  let contents: any = {
    __type: "DeleteRuleGroupResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteRuleResponse = (
  output: any,
  context: __SerdeContext
): DeleteRuleResponse => {
  let contents: any = {
    __type: "DeleteRuleResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteSizeConstraintSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteSizeConstraintSetResponse => {
  let contents: any = {
    __type: "DeleteSizeConstraintSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteSqlInjectionMatchSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteSqlInjectionMatchSetResponse => {
  let contents: any = {
    __type: "DeleteSqlInjectionMatchSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteWebACLResponse = (
  output: any,
  context: __SerdeContext
): DeleteWebACLResponse => {
  let contents: any = {
    __type: "DeleteWebACLResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1DeleteXssMatchSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteXssMatchSetResponse => {
  let contents: any = {
    __type: "DeleteXssMatchSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1ExcludedRule = (
  output: any,
  context: __SerdeContext
): ExcludedRule => {
  let contents: any = {
    __type: "ExcludedRule",
    RuleId: undefined
  };
  if (output.RuleId !== undefined) {
    contents.RuleId = output.RuleId;
  }
  return contents;
};

const deserializeAws_json1_1ExcludedRules = (
  output: any,
  context: __SerdeContext
): Array<ExcludedRule> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ExcludedRule(entry, context)
  );
};

const deserializeAws_json1_1FieldToMatch = (
  output: any,
  context: __SerdeContext
): FieldToMatch => {
  let contents: any = {
    __type: "FieldToMatch",
    Data: undefined,
    Type: undefined
  };
  if (output.Data !== undefined) {
    contents.Data = output.Data;
  }
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1GeoMatchConstraint = (
  output: any,
  context: __SerdeContext
): GeoMatchConstraint => {
  let contents: any = {
    __type: "GeoMatchConstraint",
    Type: undefined,
    Value: undefined
  };
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1GeoMatchConstraints = (
  output: any,
  context: __SerdeContext
): Array<GeoMatchConstraint> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1GeoMatchConstraint(entry, context)
  );
};

const deserializeAws_json1_1GeoMatchSet = (
  output: any,
  context: __SerdeContext
): GeoMatchSet => {
  let contents: any = {
    __type: "GeoMatchSet",
    GeoMatchConstraints: undefined,
    GeoMatchSetId: undefined,
    Name: undefined
  };
  if (output.GeoMatchConstraints !== undefined) {
    contents.GeoMatchConstraints = deserializeAws_json1_1GeoMatchConstraints(
      output.GeoMatchConstraints,
      context
    );
  }
  if (output.GeoMatchSetId !== undefined) {
    contents.GeoMatchSetId = output.GeoMatchSetId;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1GeoMatchSetSummaries = (
  output: any,
  context: __SerdeContext
): Array<GeoMatchSetSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1GeoMatchSetSummary(entry, context)
  );
};

const deserializeAws_json1_1GeoMatchSetSummary = (
  output: any,
  context: __SerdeContext
): GeoMatchSetSummary => {
  let contents: any = {
    __type: "GeoMatchSetSummary",
    GeoMatchSetId: undefined,
    Name: undefined
  };
  if (output.GeoMatchSetId !== undefined) {
    contents.GeoMatchSetId = output.GeoMatchSetId;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1GetByteMatchSetResponse = (
  output: any,
  context: __SerdeContext
): GetByteMatchSetResponse => {
  let contents: any = {
    __type: "GetByteMatchSetResponse",
    ByteMatchSet: undefined
  };
  if (output.ByteMatchSet !== undefined) {
    contents.ByteMatchSet = deserializeAws_json1_1ByteMatchSet(
      output.ByteMatchSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetChangeTokenResponse = (
  output: any,
  context: __SerdeContext
): GetChangeTokenResponse => {
  let contents: any = {
    __type: "GetChangeTokenResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1GetChangeTokenStatusResponse = (
  output: any,
  context: __SerdeContext
): GetChangeTokenStatusResponse => {
  let contents: any = {
    __type: "GetChangeTokenStatusResponse",
    ChangeTokenStatus: undefined
  };
  if (output.ChangeTokenStatus !== undefined) {
    contents.ChangeTokenStatus = output.ChangeTokenStatus;
  }
  return contents;
};

const deserializeAws_json1_1GetGeoMatchSetResponse = (
  output: any,
  context: __SerdeContext
): GetGeoMatchSetResponse => {
  let contents: any = {
    __type: "GetGeoMatchSetResponse",
    GeoMatchSet: undefined
  };
  if (output.GeoMatchSet !== undefined) {
    contents.GeoMatchSet = deserializeAws_json1_1GeoMatchSet(
      output.GeoMatchSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetIPSetResponse = (
  output: any,
  context: __SerdeContext
): GetIPSetResponse => {
  let contents: any = {
    __type: "GetIPSetResponse",
    IPSet: undefined
  };
  if (output.IPSet !== undefined) {
    contents.IPSet = deserializeAws_json1_1IPSet(output.IPSet, context);
  }
  return contents;
};

const deserializeAws_json1_1GetLoggingConfigurationResponse = (
  output: any,
  context: __SerdeContext
): GetLoggingConfigurationResponse => {
  let contents: any = {
    __type: "GetLoggingConfigurationResponse",
    LoggingConfiguration: undefined
  };
  if (output.LoggingConfiguration !== undefined) {
    contents.LoggingConfiguration = deserializeAws_json1_1LoggingConfiguration(
      output.LoggingConfiguration,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetPermissionPolicyResponse = (
  output: any,
  context: __SerdeContext
): GetPermissionPolicyResponse => {
  let contents: any = {
    __type: "GetPermissionPolicyResponse",
    Policy: undefined
  };
  if (output.Policy !== undefined) {
    contents.Policy = output.Policy;
  }
  return contents;
};

const deserializeAws_json1_1GetRateBasedRuleManagedKeysResponse = (
  output: any,
  context: __SerdeContext
): GetRateBasedRuleManagedKeysResponse => {
  let contents: any = {
    __type: "GetRateBasedRuleManagedKeysResponse",
    ManagedKeys: undefined,
    NextMarker: undefined
  };
  if (output.ManagedKeys !== undefined) {
    contents.ManagedKeys = deserializeAws_json1_1ManagedKeys(
      output.ManagedKeys,
      context
    );
  }
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  return contents;
};

const deserializeAws_json1_1GetRateBasedRuleResponse = (
  output: any,
  context: __SerdeContext
): GetRateBasedRuleResponse => {
  let contents: any = {
    __type: "GetRateBasedRuleResponse",
    Rule: undefined
  };
  if (output.Rule !== undefined) {
    contents.Rule = deserializeAws_json1_1RateBasedRule(output.Rule, context);
  }
  return contents;
};

const deserializeAws_json1_1GetRegexMatchSetResponse = (
  output: any,
  context: __SerdeContext
): GetRegexMatchSetResponse => {
  let contents: any = {
    __type: "GetRegexMatchSetResponse",
    RegexMatchSet: undefined
  };
  if (output.RegexMatchSet !== undefined) {
    contents.RegexMatchSet = deserializeAws_json1_1RegexMatchSet(
      output.RegexMatchSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetRegexPatternSetResponse = (
  output: any,
  context: __SerdeContext
): GetRegexPatternSetResponse => {
  let contents: any = {
    __type: "GetRegexPatternSetResponse",
    RegexPatternSet: undefined
  };
  if (output.RegexPatternSet !== undefined) {
    contents.RegexPatternSet = deserializeAws_json1_1RegexPatternSet(
      output.RegexPatternSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetRuleGroupResponse = (
  output: any,
  context: __SerdeContext
): GetRuleGroupResponse => {
  let contents: any = {
    __type: "GetRuleGroupResponse",
    RuleGroup: undefined
  };
  if (output.RuleGroup !== undefined) {
    contents.RuleGroup = deserializeAws_json1_1RuleGroup(
      output.RuleGroup,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetRuleResponse = (
  output: any,
  context: __SerdeContext
): GetRuleResponse => {
  let contents: any = {
    __type: "GetRuleResponse",
    Rule: undefined
  };
  if (output.Rule !== undefined) {
    contents.Rule = deserializeAws_json1_1Rule(output.Rule, context);
  }
  return contents;
};

const deserializeAws_json1_1GetSampledRequestsResponse = (
  output: any,
  context: __SerdeContext
): GetSampledRequestsResponse => {
  let contents: any = {
    __type: "GetSampledRequestsResponse",
    PopulationSize: undefined,
    SampledRequests: undefined,
    TimeWindow: undefined
  };
  if (output.PopulationSize !== undefined) {
    contents.PopulationSize = output.PopulationSize;
  }
  if (output.SampledRequests !== undefined) {
    contents.SampledRequests = deserializeAws_json1_1SampledHTTPRequests(
      output.SampledRequests,
      context
    );
  }
  if (output.TimeWindow !== undefined) {
    contents.TimeWindow = deserializeAws_json1_1TimeWindow(
      output.TimeWindow,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetSizeConstraintSetResponse = (
  output: any,
  context: __SerdeContext
): GetSizeConstraintSetResponse => {
  let contents: any = {
    __type: "GetSizeConstraintSetResponse",
    SizeConstraintSet: undefined
  };
  if (output.SizeConstraintSet !== undefined) {
    contents.SizeConstraintSet = deserializeAws_json1_1SizeConstraintSet(
      output.SizeConstraintSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetSqlInjectionMatchSetResponse = (
  output: any,
  context: __SerdeContext
): GetSqlInjectionMatchSetResponse => {
  let contents: any = {
    __type: "GetSqlInjectionMatchSetResponse",
    SqlInjectionMatchSet: undefined
  };
  if (output.SqlInjectionMatchSet !== undefined) {
    contents.SqlInjectionMatchSet = deserializeAws_json1_1SqlInjectionMatchSet(
      output.SqlInjectionMatchSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1GetWebACLResponse = (
  output: any,
  context: __SerdeContext
): GetWebACLResponse => {
  let contents: any = {
    __type: "GetWebACLResponse",
    WebACL: undefined
  };
  if (output.WebACL !== undefined) {
    contents.WebACL = deserializeAws_json1_1WebACL(output.WebACL, context);
  }
  return contents;
};

const deserializeAws_json1_1GetXssMatchSetResponse = (
  output: any,
  context: __SerdeContext
): GetXssMatchSetResponse => {
  let contents: any = {
    __type: "GetXssMatchSetResponse",
    XssMatchSet: undefined
  };
  if (output.XssMatchSet !== undefined) {
    contents.XssMatchSet = deserializeAws_json1_1XssMatchSet(
      output.XssMatchSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1HTTPHeader = (
  output: any,
  context: __SerdeContext
): HTTPHeader => {
  let contents: any = {
    __type: "HTTPHeader",
    Name: undefined,
    Value: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1HTTPHeaders = (
  output: any,
  context: __SerdeContext
): Array<HTTPHeader> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1HTTPHeader(entry, context)
  );
};

const deserializeAws_json1_1HTTPRequest = (
  output: any,
  context: __SerdeContext
): HTTPRequest => {
  let contents: any = {
    __type: "HTTPRequest",
    ClientIP: undefined,
    Country: undefined,
    HTTPVersion: undefined,
    Headers: undefined,
    Method: undefined,
    URI: undefined
  };
  if (output.ClientIP !== undefined) {
    contents.ClientIP = output.ClientIP;
  }
  if (output.Country !== undefined) {
    contents.Country = output.Country;
  }
  if (output.HTTPVersion !== undefined) {
    contents.HTTPVersion = output.HTTPVersion;
  }
  if (output.Headers !== undefined) {
    contents.Headers = deserializeAws_json1_1HTTPHeaders(
      output.Headers,
      context
    );
  }
  if (output.Method !== undefined) {
    contents.Method = output.Method;
  }
  if (output.URI !== undefined) {
    contents.URI = output.URI;
  }
  return contents;
};

const deserializeAws_json1_1IPSet = (
  output: any,
  context: __SerdeContext
): IPSet => {
  let contents: any = {
    __type: "IPSet",
    IPSetDescriptors: undefined,
    IPSetId: undefined,
    Name: undefined
  };
  if (output.IPSetDescriptors !== undefined) {
    contents.IPSetDescriptors = deserializeAws_json1_1IPSetDescriptors(
      output.IPSetDescriptors,
      context
    );
  }
  if (output.IPSetId !== undefined) {
    contents.IPSetId = output.IPSetId;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1IPSetDescriptor = (
  output: any,
  context: __SerdeContext
): IPSetDescriptor => {
  let contents: any = {
    __type: "IPSetDescriptor",
    Type: undefined,
    Value: undefined
  };
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1IPSetDescriptors = (
  output: any,
  context: __SerdeContext
): Array<IPSetDescriptor> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1IPSetDescriptor(entry, context)
  );
};

const deserializeAws_json1_1IPSetSummaries = (
  output: any,
  context: __SerdeContext
): Array<IPSetSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1IPSetSummary(entry, context)
  );
};

const deserializeAws_json1_1IPSetSummary = (
  output: any,
  context: __SerdeContext
): IPSetSummary => {
  let contents: any = {
    __type: "IPSetSummary",
    IPSetId: undefined,
    Name: undefined
  };
  if (output.IPSetId !== undefined) {
    contents.IPSetId = output.IPSetId;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1ListActivatedRulesInRuleGroupResponse = (
  output: any,
  context: __SerdeContext
): ListActivatedRulesInRuleGroupResponse => {
  let contents: any = {
    __type: "ListActivatedRulesInRuleGroupResponse",
    ActivatedRules: undefined,
    NextMarker: undefined
  };
  if (output.ActivatedRules !== undefined) {
    contents.ActivatedRules = deserializeAws_json1_1ActivatedRules(
      output.ActivatedRules,
      context
    );
  }
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  return contents;
};

const deserializeAws_json1_1ListByteMatchSetsResponse = (
  output: any,
  context: __SerdeContext
): ListByteMatchSetsResponse => {
  let contents: any = {
    __type: "ListByteMatchSetsResponse",
    ByteMatchSets: undefined,
    NextMarker: undefined
  };
  if (output.ByteMatchSets !== undefined) {
    contents.ByteMatchSets = deserializeAws_json1_1ByteMatchSetSummaries(
      output.ByteMatchSets,
      context
    );
  }
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  return contents;
};

const deserializeAws_json1_1ListGeoMatchSetsResponse = (
  output: any,
  context: __SerdeContext
): ListGeoMatchSetsResponse => {
  let contents: any = {
    __type: "ListGeoMatchSetsResponse",
    GeoMatchSets: undefined,
    NextMarker: undefined
  };
  if (output.GeoMatchSets !== undefined) {
    contents.GeoMatchSets = deserializeAws_json1_1GeoMatchSetSummaries(
      output.GeoMatchSets,
      context
    );
  }
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  return contents;
};

const deserializeAws_json1_1ListIPSetsResponse = (
  output: any,
  context: __SerdeContext
): ListIPSetsResponse => {
  let contents: any = {
    __type: "ListIPSetsResponse",
    IPSets: undefined,
    NextMarker: undefined
  };
  if (output.IPSets !== undefined) {
    contents.IPSets = deserializeAws_json1_1IPSetSummaries(
      output.IPSets,
      context
    );
  }
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  return contents;
};

const deserializeAws_json1_1ListLoggingConfigurationsResponse = (
  output: any,
  context: __SerdeContext
): ListLoggingConfigurationsResponse => {
  let contents: any = {
    __type: "ListLoggingConfigurationsResponse",
    LoggingConfigurations: undefined,
    NextMarker: undefined
  };
  if (output.LoggingConfigurations !== undefined) {
    contents.LoggingConfigurations = deserializeAws_json1_1LoggingConfigurations(
      output.LoggingConfigurations,
      context
    );
  }
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  return contents;
};

const deserializeAws_json1_1ListRateBasedRulesResponse = (
  output: any,
  context: __SerdeContext
): ListRateBasedRulesResponse => {
  let contents: any = {
    __type: "ListRateBasedRulesResponse",
    NextMarker: undefined,
    Rules: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.Rules !== undefined) {
    contents.Rules = deserializeAws_json1_1RuleSummaries(output.Rules, context);
  }
  return contents;
};

const deserializeAws_json1_1ListRegexMatchSetsResponse = (
  output: any,
  context: __SerdeContext
): ListRegexMatchSetsResponse => {
  let contents: any = {
    __type: "ListRegexMatchSetsResponse",
    NextMarker: undefined,
    RegexMatchSets: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.RegexMatchSets !== undefined) {
    contents.RegexMatchSets = deserializeAws_json1_1RegexMatchSetSummaries(
      output.RegexMatchSets,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListRegexPatternSetsResponse = (
  output: any,
  context: __SerdeContext
): ListRegexPatternSetsResponse => {
  let contents: any = {
    __type: "ListRegexPatternSetsResponse",
    NextMarker: undefined,
    RegexPatternSets: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.RegexPatternSets !== undefined) {
    contents.RegexPatternSets = deserializeAws_json1_1RegexPatternSetSummaries(
      output.RegexPatternSets,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListRuleGroupsResponse = (
  output: any,
  context: __SerdeContext
): ListRuleGroupsResponse => {
  let contents: any = {
    __type: "ListRuleGroupsResponse",
    NextMarker: undefined,
    RuleGroups: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.RuleGroups !== undefined) {
    contents.RuleGroups = deserializeAws_json1_1RuleGroupSummaries(
      output.RuleGroups,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListRulesResponse = (
  output: any,
  context: __SerdeContext
): ListRulesResponse => {
  let contents: any = {
    __type: "ListRulesResponse",
    NextMarker: undefined,
    Rules: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.Rules !== undefined) {
    contents.Rules = deserializeAws_json1_1RuleSummaries(output.Rules, context);
  }
  return contents;
};

const deserializeAws_json1_1ListSizeConstraintSetsResponse = (
  output: any,
  context: __SerdeContext
): ListSizeConstraintSetsResponse => {
  let contents: any = {
    __type: "ListSizeConstraintSetsResponse",
    NextMarker: undefined,
    SizeConstraintSets: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.SizeConstraintSets !== undefined) {
    contents.SizeConstraintSets = deserializeAws_json1_1SizeConstraintSetSummaries(
      output.SizeConstraintSets,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListSqlInjectionMatchSetsResponse = (
  output: any,
  context: __SerdeContext
): ListSqlInjectionMatchSetsResponse => {
  let contents: any = {
    __type: "ListSqlInjectionMatchSetsResponse",
    NextMarker: undefined,
    SqlInjectionMatchSets: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.SqlInjectionMatchSets !== undefined) {
    contents.SqlInjectionMatchSets = deserializeAws_json1_1SqlInjectionMatchSetSummaries(
      output.SqlInjectionMatchSets,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListSubscribedRuleGroupsResponse = (
  output: any,
  context: __SerdeContext
): ListSubscribedRuleGroupsResponse => {
  let contents: any = {
    __type: "ListSubscribedRuleGroupsResponse",
    NextMarker: undefined,
    RuleGroups: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.RuleGroups !== undefined) {
    contents.RuleGroups = deserializeAws_json1_1SubscribedRuleGroupSummaries(
      output.RuleGroups,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTagsForResourceResponse = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceResponse => {
  let contents: any = {
    __type: "ListTagsForResourceResponse",
    NextMarker: undefined,
    TagInfoForResource: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.TagInfoForResource !== undefined) {
    contents.TagInfoForResource = deserializeAws_json1_1TagInfoForResource(
      output.TagInfoForResource,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListWebACLsResponse = (
  output: any,
  context: __SerdeContext
): ListWebACLsResponse => {
  let contents: any = {
    __type: "ListWebACLsResponse",
    NextMarker: undefined,
    WebACLs: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.WebACLs !== undefined) {
    contents.WebACLs = deserializeAws_json1_1WebACLSummaries(
      output.WebACLs,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListXssMatchSetsResponse = (
  output: any,
  context: __SerdeContext
): ListXssMatchSetsResponse => {
  let contents: any = {
    __type: "ListXssMatchSetsResponse",
    NextMarker: undefined,
    XssMatchSets: undefined
  };
  if (output.NextMarker !== undefined) {
    contents.NextMarker = output.NextMarker;
  }
  if (output.XssMatchSets !== undefined) {
    contents.XssMatchSets = deserializeAws_json1_1XssMatchSetSummaries(
      output.XssMatchSets,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1LogDestinationConfigs = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1LoggingConfiguration = (
  output: any,
  context: __SerdeContext
): LoggingConfiguration => {
  let contents: any = {
    __type: "LoggingConfiguration",
    LogDestinationConfigs: undefined,
    RedactedFields: undefined,
    ResourceArn: undefined
  };
  if (output.LogDestinationConfigs !== undefined) {
    contents.LogDestinationConfigs = deserializeAws_json1_1LogDestinationConfigs(
      output.LogDestinationConfigs,
      context
    );
  }
  if (output.RedactedFields !== undefined) {
    contents.RedactedFields = deserializeAws_json1_1RedactedFields(
      output.RedactedFields,
      context
    );
  }
  if (output.ResourceArn !== undefined) {
    contents.ResourceArn = output.ResourceArn;
  }
  return contents;
};

const deserializeAws_json1_1LoggingConfigurations = (
  output: any,
  context: __SerdeContext
): Array<LoggingConfiguration> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1LoggingConfiguration(entry, context)
  );
};

const deserializeAws_json1_1ManagedKeys = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Predicate = (
  output: any,
  context: __SerdeContext
): Predicate => {
  let contents: any = {
    __type: "Predicate",
    DataId: undefined,
    Negated: undefined,
    Type: undefined
  };
  if (output.DataId !== undefined) {
    contents.DataId = output.DataId;
  }
  if (output.Negated !== undefined) {
    contents.Negated = output.Negated;
  }
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1Predicates = (
  output: any,
  context: __SerdeContext
): Array<Predicate> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Predicate(entry, context)
  );
};

const deserializeAws_json1_1PutLoggingConfigurationResponse = (
  output: any,
  context: __SerdeContext
): PutLoggingConfigurationResponse => {
  let contents: any = {
    __type: "PutLoggingConfigurationResponse",
    LoggingConfiguration: undefined
  };
  if (output.LoggingConfiguration !== undefined) {
    contents.LoggingConfiguration = deserializeAws_json1_1LoggingConfiguration(
      output.LoggingConfiguration,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1PutPermissionPolicyResponse = (
  output: any,
  context: __SerdeContext
): PutPermissionPolicyResponse => {
  let contents: any = {
    __type: "PutPermissionPolicyResponse"
  };
  return contents;
};

const deserializeAws_json1_1RateBasedRule = (
  output: any,
  context: __SerdeContext
): RateBasedRule => {
  let contents: any = {
    __type: "RateBasedRule",
    MatchPredicates: undefined,
    MetricName: undefined,
    Name: undefined,
    RateKey: undefined,
    RateLimit: undefined,
    RuleId: undefined
  };
  if (output.MatchPredicates !== undefined) {
    contents.MatchPredicates = deserializeAws_json1_1Predicates(
      output.MatchPredicates,
      context
    );
  }
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.RateKey !== undefined) {
    contents.RateKey = output.RateKey;
  }
  if (output.RateLimit !== undefined) {
    contents.RateLimit = output.RateLimit;
  }
  if (output.RuleId !== undefined) {
    contents.RuleId = output.RuleId;
  }
  return contents;
};

const deserializeAws_json1_1RedactedFields = (
  output: any,
  context: __SerdeContext
): Array<FieldToMatch> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1FieldToMatch(entry, context)
  );
};

const deserializeAws_json1_1RegexMatchSet = (
  output: any,
  context: __SerdeContext
): RegexMatchSet => {
  let contents: any = {
    __type: "RegexMatchSet",
    Name: undefined,
    RegexMatchSetId: undefined,
    RegexMatchTuples: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.RegexMatchSetId !== undefined) {
    contents.RegexMatchSetId = output.RegexMatchSetId;
  }
  if (output.RegexMatchTuples !== undefined) {
    contents.RegexMatchTuples = deserializeAws_json1_1RegexMatchTuples(
      output.RegexMatchTuples,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1RegexMatchSetSummaries = (
  output: any,
  context: __SerdeContext
): Array<RegexMatchSetSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RegexMatchSetSummary(entry, context)
  );
};

const deserializeAws_json1_1RegexMatchSetSummary = (
  output: any,
  context: __SerdeContext
): RegexMatchSetSummary => {
  let contents: any = {
    __type: "RegexMatchSetSummary",
    Name: undefined,
    RegexMatchSetId: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.RegexMatchSetId !== undefined) {
    contents.RegexMatchSetId = output.RegexMatchSetId;
  }
  return contents;
};

const deserializeAws_json1_1RegexMatchTuple = (
  output: any,
  context: __SerdeContext
): RegexMatchTuple => {
  let contents: any = {
    __type: "RegexMatchTuple",
    FieldToMatch: undefined,
    RegexPatternSetId: undefined,
    TextTransformation: undefined
  };
  if (output.FieldToMatch !== undefined) {
    contents.FieldToMatch = deserializeAws_json1_1FieldToMatch(
      output.FieldToMatch,
      context
    );
  }
  if (output.RegexPatternSetId !== undefined) {
    contents.RegexPatternSetId = output.RegexPatternSetId;
  }
  if (output.TextTransformation !== undefined) {
    contents.TextTransformation = output.TextTransformation;
  }
  return contents;
};

const deserializeAws_json1_1RegexMatchTuples = (
  output: any,
  context: __SerdeContext
): Array<RegexMatchTuple> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RegexMatchTuple(entry, context)
  );
};

const deserializeAws_json1_1RegexPatternSet = (
  output: any,
  context: __SerdeContext
): RegexPatternSet => {
  let contents: any = {
    __type: "RegexPatternSet",
    Name: undefined,
    RegexPatternSetId: undefined,
    RegexPatternStrings: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.RegexPatternSetId !== undefined) {
    contents.RegexPatternSetId = output.RegexPatternSetId;
  }
  if (output.RegexPatternStrings !== undefined) {
    contents.RegexPatternStrings = deserializeAws_json1_1RegexPatternStrings(
      output.RegexPatternStrings,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1RegexPatternSetSummaries = (
  output: any,
  context: __SerdeContext
): Array<RegexPatternSetSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RegexPatternSetSummary(entry, context)
  );
};

const deserializeAws_json1_1RegexPatternSetSummary = (
  output: any,
  context: __SerdeContext
): RegexPatternSetSummary => {
  let contents: any = {
    __type: "RegexPatternSetSummary",
    Name: undefined,
    RegexPatternSetId: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.RegexPatternSetId !== undefined) {
    contents.RegexPatternSetId = output.RegexPatternSetId;
  }
  return contents;
};

const deserializeAws_json1_1RegexPatternStrings = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Rule = (
  output: any,
  context: __SerdeContext
): Rule => {
  let contents: any = {
    __type: "Rule",
    MetricName: undefined,
    Name: undefined,
    Predicates: undefined,
    RuleId: undefined
  };
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.Predicates !== undefined) {
    contents.Predicates = deserializeAws_json1_1Predicates(
      output.Predicates,
      context
    );
  }
  if (output.RuleId !== undefined) {
    contents.RuleId = output.RuleId;
  }
  return contents;
};

const deserializeAws_json1_1RuleGroup = (
  output: any,
  context: __SerdeContext
): RuleGroup => {
  let contents: any = {
    __type: "RuleGroup",
    MetricName: undefined,
    Name: undefined,
    RuleGroupId: undefined
  };
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.RuleGroupId !== undefined) {
    contents.RuleGroupId = output.RuleGroupId;
  }
  return contents;
};

const deserializeAws_json1_1RuleGroupSummaries = (
  output: any,
  context: __SerdeContext
): Array<RuleGroupSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RuleGroupSummary(entry, context)
  );
};

const deserializeAws_json1_1RuleGroupSummary = (
  output: any,
  context: __SerdeContext
): RuleGroupSummary => {
  let contents: any = {
    __type: "RuleGroupSummary",
    Name: undefined,
    RuleGroupId: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.RuleGroupId !== undefined) {
    contents.RuleGroupId = output.RuleGroupId;
  }
  return contents;
};

const deserializeAws_json1_1RuleSummaries = (
  output: any,
  context: __SerdeContext
): Array<RuleSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RuleSummary(entry, context)
  );
};

const deserializeAws_json1_1RuleSummary = (
  output: any,
  context: __SerdeContext
): RuleSummary => {
  let contents: any = {
    __type: "RuleSummary",
    Name: undefined,
    RuleId: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.RuleId !== undefined) {
    contents.RuleId = output.RuleId;
  }
  return contents;
};

const deserializeAws_json1_1SampledHTTPRequest = (
  output: any,
  context: __SerdeContext
): SampledHTTPRequest => {
  let contents: any = {
    __type: "SampledHTTPRequest",
    Action: undefined,
    Request: undefined,
    RuleWithinRuleGroup: undefined,
    Timestamp: undefined,
    Weight: undefined
  };
  if (output.Action !== undefined) {
    contents.Action = output.Action;
  }
  if (output.Request !== undefined) {
    contents.Request = deserializeAws_json1_1HTTPRequest(
      output.Request,
      context
    );
  }
  if (output.RuleWithinRuleGroup !== undefined) {
    contents.RuleWithinRuleGroup = output.RuleWithinRuleGroup;
  }
  if (output.Timestamp !== undefined) {
    contents.Timestamp = new Date(Math.round(output.Timestamp * 1000));
  }
  if (output.Weight !== undefined) {
    contents.Weight = output.Weight;
  }
  return contents;
};

const deserializeAws_json1_1SampledHTTPRequests = (
  output: any,
  context: __SerdeContext
): Array<SampledHTTPRequest> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SampledHTTPRequest(entry, context)
  );
};

const deserializeAws_json1_1SizeConstraint = (
  output: any,
  context: __SerdeContext
): SizeConstraint => {
  let contents: any = {
    __type: "SizeConstraint",
    ComparisonOperator: undefined,
    FieldToMatch: undefined,
    Size: undefined,
    TextTransformation: undefined
  };
  if (output.ComparisonOperator !== undefined) {
    contents.ComparisonOperator = output.ComparisonOperator;
  }
  if (output.FieldToMatch !== undefined) {
    contents.FieldToMatch = deserializeAws_json1_1FieldToMatch(
      output.FieldToMatch,
      context
    );
  }
  if (output.Size !== undefined) {
    contents.Size = output.Size;
  }
  if (output.TextTransformation !== undefined) {
    contents.TextTransformation = output.TextTransformation;
  }
  return contents;
};

const deserializeAws_json1_1SizeConstraintSet = (
  output: any,
  context: __SerdeContext
): SizeConstraintSet => {
  let contents: any = {
    __type: "SizeConstraintSet",
    Name: undefined,
    SizeConstraintSetId: undefined,
    SizeConstraints: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.SizeConstraintSetId !== undefined) {
    contents.SizeConstraintSetId = output.SizeConstraintSetId;
  }
  if (output.SizeConstraints !== undefined) {
    contents.SizeConstraints = deserializeAws_json1_1SizeConstraints(
      output.SizeConstraints,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1SizeConstraintSetSummaries = (
  output: any,
  context: __SerdeContext
): Array<SizeConstraintSetSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SizeConstraintSetSummary(entry, context)
  );
};

const deserializeAws_json1_1SizeConstraintSetSummary = (
  output: any,
  context: __SerdeContext
): SizeConstraintSetSummary => {
  let contents: any = {
    __type: "SizeConstraintSetSummary",
    Name: undefined,
    SizeConstraintSetId: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.SizeConstraintSetId !== undefined) {
    contents.SizeConstraintSetId = output.SizeConstraintSetId;
  }
  return contents;
};

const deserializeAws_json1_1SizeConstraints = (
  output: any,
  context: __SerdeContext
): Array<SizeConstraint> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SizeConstraint(entry, context)
  );
};

const deserializeAws_json1_1SqlInjectionMatchSet = (
  output: any,
  context: __SerdeContext
): SqlInjectionMatchSet => {
  let contents: any = {
    __type: "SqlInjectionMatchSet",
    Name: undefined,
    SqlInjectionMatchSetId: undefined,
    SqlInjectionMatchTuples: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.SqlInjectionMatchSetId !== undefined) {
    contents.SqlInjectionMatchSetId = output.SqlInjectionMatchSetId;
  }
  if (output.SqlInjectionMatchTuples !== undefined) {
    contents.SqlInjectionMatchTuples = deserializeAws_json1_1SqlInjectionMatchTuples(
      output.SqlInjectionMatchTuples,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1SqlInjectionMatchSetSummaries = (
  output: any,
  context: __SerdeContext
): Array<SqlInjectionMatchSetSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SqlInjectionMatchSetSummary(entry, context)
  );
};

const deserializeAws_json1_1SqlInjectionMatchSetSummary = (
  output: any,
  context: __SerdeContext
): SqlInjectionMatchSetSummary => {
  let contents: any = {
    __type: "SqlInjectionMatchSetSummary",
    Name: undefined,
    SqlInjectionMatchSetId: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.SqlInjectionMatchSetId !== undefined) {
    contents.SqlInjectionMatchSetId = output.SqlInjectionMatchSetId;
  }
  return contents;
};

const deserializeAws_json1_1SqlInjectionMatchTuple = (
  output: any,
  context: __SerdeContext
): SqlInjectionMatchTuple => {
  let contents: any = {
    __type: "SqlInjectionMatchTuple",
    FieldToMatch: undefined,
    TextTransformation: undefined
  };
  if (output.FieldToMatch !== undefined) {
    contents.FieldToMatch = deserializeAws_json1_1FieldToMatch(
      output.FieldToMatch,
      context
    );
  }
  if (output.TextTransformation !== undefined) {
    contents.TextTransformation = output.TextTransformation;
  }
  return contents;
};

const deserializeAws_json1_1SqlInjectionMatchTuples = (
  output: any,
  context: __SerdeContext
): Array<SqlInjectionMatchTuple> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SqlInjectionMatchTuple(entry, context)
  );
};

const deserializeAws_json1_1SubscribedRuleGroupSummaries = (
  output: any,
  context: __SerdeContext
): Array<SubscribedRuleGroupSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SubscribedRuleGroupSummary(entry, context)
  );
};

const deserializeAws_json1_1SubscribedRuleGroupSummary = (
  output: any,
  context: __SerdeContext
): SubscribedRuleGroupSummary => {
  let contents: any = {
    __type: "SubscribedRuleGroupSummary",
    MetricName: undefined,
    Name: undefined,
    RuleGroupId: undefined
  };
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.RuleGroupId !== undefined) {
    contents.RuleGroupId = output.RuleGroupId;
  }
  return contents;
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TagInfoForResource = (
  output: any,
  context: __SerdeContext
): TagInfoForResource => {
  let contents: any = {
    __type: "TagInfoForResource",
    ResourceARN: undefined,
    TagList: undefined
  };
  if (output.ResourceARN !== undefined) {
    contents.ResourceARN = output.ResourceARN;
  }
  if (output.TagList !== undefined) {
    contents.TagList = deserializeAws_json1_1TagList(output.TagList, context);
  }
  return contents;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1TagResourceResponse = (
  output: any,
  context: __SerdeContext
): TagResourceResponse => {
  let contents: any = {
    __type: "TagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1TimeWindow = (
  output: any,
  context: __SerdeContext
): TimeWindow => {
  let contents: any = {
    __type: "TimeWindow",
    EndTime: undefined,
    StartTime: undefined
  };
  if (output.EndTime !== undefined) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.StartTime !== undefined) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  return contents;
};

const deserializeAws_json1_1UntagResourceResponse = (
  output: any,
  context: __SerdeContext
): UntagResourceResponse => {
  let contents: any = {
    __type: "UntagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateByteMatchSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateByteMatchSetResponse => {
  let contents: any = {
    __type: "UpdateByteMatchSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateGeoMatchSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateGeoMatchSetResponse => {
  let contents: any = {
    __type: "UpdateGeoMatchSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateIPSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateIPSetResponse => {
  let contents: any = {
    __type: "UpdateIPSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateRateBasedRuleResponse = (
  output: any,
  context: __SerdeContext
): UpdateRateBasedRuleResponse => {
  let contents: any = {
    __type: "UpdateRateBasedRuleResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateRegexMatchSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateRegexMatchSetResponse => {
  let contents: any = {
    __type: "UpdateRegexMatchSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateRegexPatternSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateRegexPatternSetResponse => {
  let contents: any = {
    __type: "UpdateRegexPatternSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateRuleGroupResponse = (
  output: any,
  context: __SerdeContext
): UpdateRuleGroupResponse => {
  let contents: any = {
    __type: "UpdateRuleGroupResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateRuleResponse = (
  output: any,
  context: __SerdeContext
): UpdateRuleResponse => {
  let contents: any = {
    __type: "UpdateRuleResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateSizeConstraintSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateSizeConstraintSetResponse => {
  let contents: any = {
    __type: "UpdateSizeConstraintSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateSqlInjectionMatchSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateSqlInjectionMatchSetResponse => {
  let contents: any = {
    __type: "UpdateSqlInjectionMatchSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateWebACLResponse = (
  output: any,
  context: __SerdeContext
): UpdateWebACLResponse => {
  let contents: any = {
    __type: "UpdateWebACLResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1UpdateXssMatchSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateXssMatchSetResponse => {
  let contents: any = {
    __type: "UpdateXssMatchSetResponse",
    ChangeToken: undefined
  };
  if (output.ChangeToken !== undefined) {
    contents.ChangeToken = output.ChangeToken;
  }
  return contents;
};

const deserializeAws_json1_1WAFBadRequestException = (
  output: any,
  context: __SerdeContext
): WAFBadRequestException => {
  let contents: any = {
    __type: "WAFBadRequestException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFDisallowedNameException = (
  output: any,
  context: __SerdeContext
): WAFDisallowedNameException => {
  let contents: any = {
    __type: "WAFDisallowedNameException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFInternalErrorException = (
  output: any,
  context: __SerdeContext
): WAFInternalErrorException => {
  let contents: any = {
    __type: "WAFInternalErrorException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFInvalidAccountException = (
  output: any,
  context: __SerdeContext
): WAFInvalidAccountException => {
  let contents: any = {
    __type: "WAFInvalidAccountException"
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidOperationException = (
  output: any,
  context: __SerdeContext
): WAFInvalidOperationException => {
  let contents: any = {
    __type: "WAFInvalidOperationException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFInvalidParameterException = (
  output: any,
  context: __SerdeContext
): WAFInvalidParameterException => {
  let contents: any = {
    __type: "WAFInvalidParameterException",
    field: undefined,
    parameter: undefined,
    reason: undefined
  };
  if (output.field !== undefined) {
    contents.field = output.field;
  }
  if (output.parameter !== undefined) {
    contents.parameter = output.parameter;
  }
  if (output.reason !== undefined) {
    contents.reason = output.reason;
  }
  return contents;
};

const deserializeAws_json1_1WAFInvalidPermissionPolicyException = (
  output: any,
  context: __SerdeContext
): WAFInvalidPermissionPolicyException => {
  let contents: any = {
    __type: "WAFInvalidPermissionPolicyException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFInvalidRegexPatternException = (
  output: any,
  context: __SerdeContext
): WAFInvalidRegexPatternException => {
  let contents: any = {
    __type: "WAFInvalidRegexPatternException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFLimitsExceededException = (
  output: any,
  context: __SerdeContext
): WAFLimitsExceededException => {
  let contents: any = {
    __type: "WAFLimitsExceededException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFNonEmptyEntityException = (
  output: any,
  context: __SerdeContext
): WAFNonEmptyEntityException => {
  let contents: any = {
    __type: "WAFNonEmptyEntityException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFNonexistentContainerException = (
  output: any,
  context: __SerdeContext
): WAFNonexistentContainerException => {
  let contents: any = {
    __type: "WAFNonexistentContainerException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFNonexistentItemException = (
  output: any,
  context: __SerdeContext
): WAFNonexistentItemException => {
  let contents: any = {
    __type: "WAFNonexistentItemException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFReferencedItemException = (
  output: any,
  context: __SerdeContext
): WAFReferencedItemException => {
  let contents: any = {
    __type: "WAFReferencedItemException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFServiceLinkedRoleErrorException = (
  output: any,
  context: __SerdeContext
): WAFServiceLinkedRoleErrorException => {
  let contents: any = {
    __type: "WAFServiceLinkedRoleErrorException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFStaleDataException = (
  output: any,
  context: __SerdeContext
): WAFStaleDataException => {
  let contents: any = {
    __type: "WAFStaleDataException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFSubscriptionNotFoundException = (
  output: any,
  context: __SerdeContext
): WAFSubscriptionNotFoundException => {
  let contents: any = {
    __type: "WAFSubscriptionNotFoundException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFTagOperationException = (
  output: any,
  context: __SerdeContext
): WAFTagOperationException => {
  let contents: any = {
    __type: "WAFTagOperationException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WAFTagOperationInternalErrorException = (
  output: any,
  context: __SerdeContext
): WAFTagOperationInternalErrorException => {
  let contents: any = {
    __type: "WAFTagOperationInternalErrorException",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1WafAction = (
  output: any,
  context: __SerdeContext
): WafAction => {
  let contents: any = {
    __type: "WafAction",
    Type: undefined
  };
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1WafOverrideAction = (
  output: any,
  context: __SerdeContext
): WafOverrideAction => {
  let contents: any = {
    __type: "WafOverrideAction",
    Type: undefined
  };
  if (output.Type !== undefined) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1WebACL = (
  output: any,
  context: __SerdeContext
): WebACL => {
  let contents: any = {
    __type: "WebACL",
    DefaultAction: undefined,
    MetricName: undefined,
    Name: undefined,
    Rules: undefined,
    WebACLArn: undefined,
    WebACLId: undefined
  };
  if (output.DefaultAction !== undefined) {
    contents.DefaultAction = deserializeAws_json1_1WafAction(
      output.DefaultAction,
      context
    );
  }
  if (output.MetricName !== undefined) {
    contents.MetricName = output.MetricName;
  }
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.Rules !== undefined) {
    contents.Rules = deserializeAws_json1_1ActivatedRules(
      output.Rules,
      context
    );
  }
  if (output.WebACLArn !== undefined) {
    contents.WebACLArn = output.WebACLArn;
  }
  if (output.WebACLId !== undefined) {
    contents.WebACLId = output.WebACLId;
  }
  return contents;
};

const deserializeAws_json1_1WebACLSummaries = (
  output: any,
  context: __SerdeContext
): Array<WebACLSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1WebACLSummary(entry, context)
  );
};

const deserializeAws_json1_1WebACLSummary = (
  output: any,
  context: __SerdeContext
): WebACLSummary => {
  let contents: any = {
    __type: "WebACLSummary",
    Name: undefined,
    WebACLId: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.WebACLId !== undefined) {
    contents.WebACLId = output.WebACLId;
  }
  return contents;
};

const deserializeAws_json1_1XssMatchSet = (
  output: any,
  context: __SerdeContext
): XssMatchSet => {
  let contents: any = {
    __type: "XssMatchSet",
    Name: undefined,
    XssMatchSetId: undefined,
    XssMatchTuples: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.XssMatchSetId !== undefined) {
    contents.XssMatchSetId = output.XssMatchSetId;
  }
  if (output.XssMatchTuples !== undefined) {
    contents.XssMatchTuples = deserializeAws_json1_1XssMatchTuples(
      output.XssMatchTuples,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1XssMatchSetSummaries = (
  output: any,
  context: __SerdeContext
): Array<XssMatchSetSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1XssMatchSetSummary(entry, context)
  );
};

const deserializeAws_json1_1XssMatchSetSummary = (
  output: any,
  context: __SerdeContext
): XssMatchSetSummary => {
  let contents: any = {
    __type: "XssMatchSetSummary",
    Name: undefined,
    XssMatchSetId: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  if (output.XssMatchSetId !== undefined) {
    contents.XssMatchSetId = output.XssMatchSetId;
  }
  return contents;
};

const deserializeAws_json1_1XssMatchTuple = (
  output: any,
  context: __SerdeContext
): XssMatchTuple => {
  let contents: any = {
    __type: "XssMatchTuple",
    FieldToMatch: undefined,
    TextTransformation: undefined
  };
  if (output.FieldToMatch !== undefined) {
    contents.FieldToMatch = deserializeAws_json1_1FieldToMatch(
      output.FieldToMatch,
      context
    );
  }
  if (output.TextTransformation !== undefined) {
    contents.TextTransformation = output.TextTransformation;
  }
  return contents;
};

const deserializeAws_json1_1XssMatchTuples = (
  output: any,
  context: __SerdeContext
): Array<XssMatchTuple> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1XssMatchTuple(entry, context)
  );
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
