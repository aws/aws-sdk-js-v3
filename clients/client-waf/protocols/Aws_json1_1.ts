import { CreateByteMatchSetCommandInput, CreateByteMatchSetCommandOutput } from "../commands/CreateByteMatchSetCommand";
import { CreateGeoMatchSetCommandInput, CreateGeoMatchSetCommandOutput } from "../commands/CreateGeoMatchSetCommand";
import { CreateIPSetCommandInput, CreateIPSetCommandOutput } from "../commands/CreateIPSetCommand";
import {
  CreateRateBasedRuleCommandInput,
  CreateRateBasedRuleCommandOutput,
} from "../commands/CreateRateBasedRuleCommand";
import {
  CreateRegexMatchSetCommandInput,
  CreateRegexMatchSetCommandOutput,
} from "../commands/CreateRegexMatchSetCommand";
import {
  CreateRegexPatternSetCommandInput,
  CreateRegexPatternSetCommandOutput,
} from "../commands/CreateRegexPatternSetCommand";
import { CreateRuleCommandInput, CreateRuleCommandOutput } from "../commands/CreateRuleCommand";
import { CreateRuleGroupCommandInput, CreateRuleGroupCommandOutput } from "../commands/CreateRuleGroupCommand";
import {
  CreateSizeConstraintSetCommandInput,
  CreateSizeConstraintSetCommandOutput,
} from "../commands/CreateSizeConstraintSetCommand";
import {
  CreateSqlInjectionMatchSetCommandInput,
  CreateSqlInjectionMatchSetCommandOutput,
} from "../commands/CreateSqlInjectionMatchSetCommand";
import { CreateWebACLCommandInput, CreateWebACLCommandOutput } from "../commands/CreateWebACLCommand";
import { CreateXssMatchSetCommandInput, CreateXssMatchSetCommandOutput } from "../commands/CreateXssMatchSetCommand";
import { DeleteByteMatchSetCommandInput, DeleteByteMatchSetCommandOutput } from "../commands/DeleteByteMatchSetCommand";
import { DeleteGeoMatchSetCommandInput, DeleteGeoMatchSetCommandOutput } from "../commands/DeleteGeoMatchSetCommand";
import { DeleteIPSetCommandInput, DeleteIPSetCommandOutput } from "../commands/DeleteIPSetCommand";
import {
  DeleteLoggingConfigurationCommandInput,
  DeleteLoggingConfigurationCommandOutput,
} from "../commands/DeleteLoggingConfigurationCommand";
import {
  DeletePermissionPolicyCommandInput,
  DeletePermissionPolicyCommandOutput,
} from "../commands/DeletePermissionPolicyCommand";
import {
  DeleteRateBasedRuleCommandInput,
  DeleteRateBasedRuleCommandOutput,
} from "../commands/DeleteRateBasedRuleCommand";
import {
  DeleteRegexMatchSetCommandInput,
  DeleteRegexMatchSetCommandOutput,
} from "../commands/DeleteRegexMatchSetCommand";
import {
  DeleteRegexPatternSetCommandInput,
  DeleteRegexPatternSetCommandOutput,
} from "../commands/DeleteRegexPatternSetCommand";
import { DeleteRuleCommandInput, DeleteRuleCommandOutput } from "../commands/DeleteRuleCommand";
import { DeleteRuleGroupCommandInput, DeleteRuleGroupCommandOutput } from "../commands/DeleteRuleGroupCommand";
import {
  DeleteSizeConstraintSetCommandInput,
  DeleteSizeConstraintSetCommandOutput,
} from "../commands/DeleteSizeConstraintSetCommand";
import {
  DeleteSqlInjectionMatchSetCommandInput,
  DeleteSqlInjectionMatchSetCommandOutput,
} from "../commands/DeleteSqlInjectionMatchSetCommand";
import { DeleteWebACLCommandInput, DeleteWebACLCommandOutput } from "../commands/DeleteWebACLCommand";
import { DeleteXssMatchSetCommandInput, DeleteXssMatchSetCommandOutput } from "../commands/DeleteXssMatchSetCommand";
import { GetByteMatchSetCommandInput, GetByteMatchSetCommandOutput } from "../commands/GetByteMatchSetCommand";
import { GetChangeTokenCommandInput, GetChangeTokenCommandOutput } from "../commands/GetChangeTokenCommand";
import {
  GetChangeTokenStatusCommandInput,
  GetChangeTokenStatusCommandOutput,
} from "../commands/GetChangeTokenStatusCommand";
import { GetGeoMatchSetCommandInput, GetGeoMatchSetCommandOutput } from "../commands/GetGeoMatchSetCommand";
import { GetIPSetCommandInput, GetIPSetCommandOutput } from "../commands/GetIPSetCommand";
import {
  GetLoggingConfigurationCommandInput,
  GetLoggingConfigurationCommandOutput,
} from "../commands/GetLoggingConfigurationCommand";
import {
  GetPermissionPolicyCommandInput,
  GetPermissionPolicyCommandOutput,
} from "../commands/GetPermissionPolicyCommand";
import { GetRateBasedRuleCommandInput, GetRateBasedRuleCommandOutput } from "../commands/GetRateBasedRuleCommand";
import {
  GetRateBasedRuleManagedKeysCommandInput,
  GetRateBasedRuleManagedKeysCommandOutput,
} from "../commands/GetRateBasedRuleManagedKeysCommand";
import { GetRegexMatchSetCommandInput, GetRegexMatchSetCommandOutput } from "../commands/GetRegexMatchSetCommand";
import { GetRegexPatternSetCommandInput, GetRegexPatternSetCommandOutput } from "../commands/GetRegexPatternSetCommand";
import { GetRuleCommandInput, GetRuleCommandOutput } from "../commands/GetRuleCommand";
import { GetRuleGroupCommandInput, GetRuleGroupCommandOutput } from "../commands/GetRuleGroupCommand";
import { GetSampledRequestsCommandInput, GetSampledRequestsCommandOutput } from "../commands/GetSampledRequestsCommand";
import {
  GetSizeConstraintSetCommandInput,
  GetSizeConstraintSetCommandOutput,
} from "../commands/GetSizeConstraintSetCommand";
import {
  GetSqlInjectionMatchSetCommandInput,
  GetSqlInjectionMatchSetCommandOutput,
} from "../commands/GetSqlInjectionMatchSetCommand";
import { GetWebACLCommandInput, GetWebACLCommandOutput } from "../commands/GetWebACLCommand";
import { GetXssMatchSetCommandInput, GetXssMatchSetCommandOutput } from "../commands/GetXssMatchSetCommand";
import {
  ListActivatedRulesInRuleGroupCommandInput,
  ListActivatedRulesInRuleGroupCommandOutput,
} from "../commands/ListActivatedRulesInRuleGroupCommand";
import { ListByteMatchSetsCommandInput, ListByteMatchSetsCommandOutput } from "../commands/ListByteMatchSetsCommand";
import { ListGeoMatchSetsCommandInput, ListGeoMatchSetsCommandOutput } from "../commands/ListGeoMatchSetsCommand";
import { ListIPSetsCommandInput, ListIPSetsCommandOutput } from "../commands/ListIPSetsCommand";
import {
  ListLoggingConfigurationsCommandInput,
  ListLoggingConfigurationsCommandOutput,
} from "../commands/ListLoggingConfigurationsCommand";
import { ListRateBasedRulesCommandInput, ListRateBasedRulesCommandOutput } from "../commands/ListRateBasedRulesCommand";
import { ListRegexMatchSetsCommandInput, ListRegexMatchSetsCommandOutput } from "../commands/ListRegexMatchSetsCommand";
import {
  ListRegexPatternSetsCommandInput,
  ListRegexPatternSetsCommandOutput,
} from "../commands/ListRegexPatternSetsCommand";
import { ListRuleGroupsCommandInput, ListRuleGroupsCommandOutput } from "../commands/ListRuleGroupsCommand";
import { ListRulesCommandInput, ListRulesCommandOutput } from "../commands/ListRulesCommand";
import {
  ListSizeConstraintSetsCommandInput,
  ListSizeConstraintSetsCommandOutput,
} from "../commands/ListSizeConstraintSetsCommand";
import {
  ListSqlInjectionMatchSetsCommandInput,
  ListSqlInjectionMatchSetsCommandOutput,
} from "../commands/ListSqlInjectionMatchSetsCommand";
import {
  ListSubscribedRuleGroupsCommandInput,
  ListSubscribedRuleGroupsCommandOutput,
} from "../commands/ListSubscribedRuleGroupsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput,
} from "../commands/ListTagsForResourceCommand";
import { ListWebACLsCommandInput, ListWebACLsCommandOutput } from "../commands/ListWebACLsCommand";
import { ListXssMatchSetsCommandInput, ListXssMatchSetsCommandOutput } from "../commands/ListXssMatchSetsCommand";
import {
  PutLoggingConfigurationCommandInput,
  PutLoggingConfigurationCommandOutput,
} from "../commands/PutLoggingConfigurationCommand";
import {
  PutPermissionPolicyCommandInput,
  PutPermissionPolicyCommandOutput,
} from "../commands/PutPermissionPolicyCommand";
import { TagResourceCommandInput, TagResourceCommandOutput } from "../commands/TagResourceCommand";
import { UntagResourceCommandInput, UntagResourceCommandOutput } from "../commands/UntagResourceCommand";
import { UpdateByteMatchSetCommandInput, UpdateByteMatchSetCommandOutput } from "../commands/UpdateByteMatchSetCommand";
import { UpdateGeoMatchSetCommandInput, UpdateGeoMatchSetCommandOutput } from "../commands/UpdateGeoMatchSetCommand";
import { UpdateIPSetCommandInput, UpdateIPSetCommandOutput } from "../commands/UpdateIPSetCommand";
import {
  UpdateRateBasedRuleCommandInput,
  UpdateRateBasedRuleCommandOutput,
} from "../commands/UpdateRateBasedRuleCommand";
import {
  UpdateRegexMatchSetCommandInput,
  UpdateRegexMatchSetCommandOutput,
} from "../commands/UpdateRegexMatchSetCommand";
import {
  UpdateRegexPatternSetCommandInput,
  UpdateRegexPatternSetCommandOutput,
} from "../commands/UpdateRegexPatternSetCommand";
import { UpdateRuleCommandInput, UpdateRuleCommandOutput } from "../commands/UpdateRuleCommand";
import { UpdateRuleGroupCommandInput, UpdateRuleGroupCommandOutput } from "../commands/UpdateRuleGroupCommand";
import {
  UpdateSizeConstraintSetCommandInput,
  UpdateSizeConstraintSetCommandOutput,
} from "../commands/UpdateSizeConstraintSetCommand";
import {
  UpdateSqlInjectionMatchSetCommandInput,
  UpdateSqlInjectionMatchSetCommandOutput,
} from "../commands/UpdateSqlInjectionMatchSetCommand";
import { UpdateWebACLCommandInput, UpdateWebACLCommandOutput } from "../commands/UpdateWebACLCommand";
import { UpdateXssMatchSetCommandInput, UpdateXssMatchSetCommandOutput } from "../commands/UpdateXssMatchSetCommand";
import {
  ActivatedRule,
  ByteMatchSet,
  ByteMatchSetSummary,
  ByteMatchSetUpdate,
  ByteMatchTuple,
  CreateByteMatchSetRequest,
  CreateByteMatchSetResponse,
  CreateGeoMatchSetRequest,
  CreateGeoMatchSetResponse,
  CreateIPSetRequest,
  CreateIPSetResponse,
  CreateRateBasedRuleRequest,
  CreateRateBasedRuleResponse,
  CreateRegexMatchSetRequest,
  CreateRegexMatchSetResponse,
  CreateRegexPatternSetRequest,
  CreateRegexPatternSetResponse,
  CreateRuleGroupRequest,
  CreateRuleGroupResponse,
  CreateRuleRequest,
  CreateRuleResponse,
  CreateSizeConstraintSetRequest,
  CreateSizeConstraintSetResponse,
  CreateSqlInjectionMatchSetRequest,
  CreateSqlInjectionMatchSetResponse,
  CreateWebACLRequest,
  CreateWebACLResponse,
  CreateXssMatchSetRequest,
  CreateXssMatchSetResponse,
  DeleteByteMatchSetRequest,
  DeleteByteMatchSetResponse,
  DeleteGeoMatchSetRequest,
  DeleteGeoMatchSetResponse,
  DeleteIPSetRequest,
  DeleteIPSetResponse,
  DeleteLoggingConfigurationRequest,
  DeleteLoggingConfigurationResponse,
  DeletePermissionPolicyRequest,
  DeletePermissionPolicyResponse,
  DeleteRateBasedRuleRequest,
  DeleteRateBasedRuleResponse,
  DeleteRegexMatchSetRequest,
  DeleteRegexMatchSetResponse,
  DeleteRegexPatternSetRequest,
  DeleteRegexPatternSetResponse,
  DeleteRuleGroupRequest,
  DeleteRuleGroupResponse,
  DeleteRuleRequest,
  DeleteRuleResponse,
  DeleteSizeConstraintSetRequest,
  DeleteSizeConstraintSetResponse,
  DeleteSqlInjectionMatchSetRequest,
  DeleteSqlInjectionMatchSetResponse,
  DeleteWebACLRequest,
  DeleteWebACLResponse,
  DeleteXssMatchSetRequest,
  DeleteXssMatchSetResponse,
  ExcludedRule,
  FieldToMatch,
  GeoMatchConstraint,
  GeoMatchSet,
  GeoMatchSetSummary,
  GeoMatchSetUpdate,
  GetByteMatchSetRequest,
  GetByteMatchSetResponse,
  GetChangeTokenRequest,
  GetChangeTokenResponse,
  GetChangeTokenStatusRequest,
  GetChangeTokenStatusResponse,
  GetGeoMatchSetRequest,
  GetGeoMatchSetResponse,
  GetIPSetRequest,
  GetIPSetResponse,
  GetLoggingConfigurationRequest,
  GetLoggingConfigurationResponse,
  GetPermissionPolicyRequest,
  GetPermissionPolicyResponse,
  GetRateBasedRuleManagedKeysRequest,
  GetRateBasedRuleManagedKeysResponse,
  GetRateBasedRuleRequest,
  GetRateBasedRuleResponse,
  GetRegexMatchSetRequest,
  GetRegexMatchSetResponse,
  GetRegexPatternSetRequest,
  GetRegexPatternSetResponse,
  GetRuleGroupRequest,
  GetRuleGroupResponse,
  GetRuleRequest,
  GetRuleResponse,
  GetSampledRequestsRequest,
  GetSampledRequestsResponse,
  GetSizeConstraintSetRequest,
  GetSizeConstraintSetResponse,
  GetSqlInjectionMatchSetRequest,
  GetSqlInjectionMatchSetResponse,
  GetWebACLRequest,
  GetWebACLResponse,
  GetXssMatchSetRequest,
  GetXssMatchSetResponse,
  HTTPHeader,
  HTTPRequest,
  IPSet,
  IPSetDescriptor,
  IPSetSummary,
  IPSetUpdate,
  ListActivatedRulesInRuleGroupRequest,
  ListActivatedRulesInRuleGroupResponse,
  ListByteMatchSetsRequest,
  ListByteMatchSetsResponse,
  ListGeoMatchSetsRequest,
  ListGeoMatchSetsResponse,
  ListIPSetsRequest,
  ListIPSetsResponse,
  ListLoggingConfigurationsRequest,
  ListLoggingConfigurationsResponse,
  ListRateBasedRulesRequest,
  ListRateBasedRulesResponse,
  ListRegexMatchSetsRequest,
  ListRegexMatchSetsResponse,
  ListRegexPatternSetsRequest,
  ListRegexPatternSetsResponse,
  ListRuleGroupsRequest,
  ListRuleGroupsResponse,
  ListRulesRequest,
  ListRulesResponse,
  ListSizeConstraintSetsRequest,
  ListSizeConstraintSetsResponse,
  ListSqlInjectionMatchSetsRequest,
  ListSqlInjectionMatchSetsResponse,
  ListSubscribedRuleGroupsRequest,
  ListSubscribedRuleGroupsResponse,
  ListTagsForResourceRequest,
  ListTagsForResourceResponse,
  ListWebACLsRequest,
  ListWebACLsResponse,
  ListXssMatchSetsRequest,
  ListXssMatchSetsResponse,
  LoggingConfiguration,
  Predicate,
  PutLoggingConfigurationRequest,
  PutLoggingConfigurationResponse,
  PutPermissionPolicyRequest,
  PutPermissionPolicyResponse,
  RateBasedRule,
  RegexMatchSet,
  RegexMatchSetSummary,
  RegexMatchSetUpdate,
  RegexMatchTuple,
  RegexPatternSet,
  RegexPatternSetSummary,
  RegexPatternSetUpdate,
  Rule,
  RuleGroup,
  RuleGroupSummary,
  RuleGroupUpdate,
  RuleSummary,
  RuleUpdate,
  SampledHTTPRequest,
  SizeConstraint,
  SizeConstraintSet,
  SizeConstraintSetSummary,
  SizeConstraintSetUpdate,
  SqlInjectionMatchSet,
  SqlInjectionMatchSetSummary,
  SqlInjectionMatchSetUpdate,
  SqlInjectionMatchTuple,
  SubscribedRuleGroupSummary,
  Tag,
  TagInfoForResource,
  TagResourceRequest,
  TagResourceResponse,
  TimeWindow,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateByteMatchSetRequest,
  UpdateByteMatchSetResponse,
  UpdateGeoMatchSetRequest,
  UpdateGeoMatchSetResponse,
  UpdateIPSetRequest,
  UpdateIPSetResponse,
  UpdateRateBasedRuleRequest,
  UpdateRateBasedRuleResponse,
  UpdateRegexMatchSetRequest,
  UpdateRegexMatchSetResponse,
  UpdateRegexPatternSetRequest,
  UpdateRegexPatternSetResponse,
  UpdateRuleGroupRequest,
  UpdateRuleGroupResponse,
  UpdateRuleRequest,
  UpdateRuleResponse,
  UpdateSizeConstraintSetRequest,
  UpdateSizeConstraintSetResponse,
  UpdateSqlInjectionMatchSetRequest,
  UpdateSqlInjectionMatchSetResponse,
  UpdateWebACLRequest,
  UpdateWebACLResponse,
  UpdateXssMatchSetRequest,
  UpdateXssMatchSetResponse,
  WAFBadRequestException,
  WAFDisallowedNameException,
  WAFInternalErrorException,
  WAFInvalidAccountException,
  WAFInvalidOperationException,
  WAFInvalidParameterException,
  WAFInvalidPermissionPolicyException,
  WAFInvalidRegexPatternException,
  WAFLimitsExceededException,
  WAFNonEmptyEntityException,
  WAFNonexistentContainerException,
  WAFNonexistentItemException,
  WAFReferencedItemException,
  WAFServiceLinkedRoleErrorException,
  WAFStaleDataException,
  WAFSubscriptionNotFoundException,
  WAFTagOperationException,
  WAFTagOperationInternalErrorException,
  WafAction,
  WafOverrideAction,
  WebACL,
  WebACLSummary,
  WebACLUpdate,
  XssMatchSet,
  XssMatchSetSummary,
  XssMatchSetUpdate,
  XssMatchTuple,
} from "../models/index";
import { HttpRequest as __HttpRequest, HttpResponse as __HttpResponse } from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext,
} from "@aws-sdk/types";

export const serializeAws_json1_1CreateByteMatchSetCommand = async (
  input: CreateByteMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateByteMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateByteMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateGeoMatchSetCommand = async (
  input: CreateGeoMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateGeoMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateGeoMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateIPSetCommand = async (
  input: CreateIPSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateIPSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateIPSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateRateBasedRuleCommand = async (
  input: CreateRateBasedRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateRateBasedRule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateRateBasedRuleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateRegexMatchSetCommand = async (
  input: CreateRegexMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateRegexMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateRegexMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateRegexPatternSetCommand = async (
  input: CreateRegexPatternSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateRegexPatternSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateRegexPatternSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateRuleCommand = async (
  input: CreateRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateRule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateRuleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateRuleGroupCommand = async (
  input: CreateRuleGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateRuleGroup",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateRuleGroupRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateSizeConstraintSetCommand = async (
  input: CreateSizeConstraintSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateSizeConstraintSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateSizeConstraintSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateSqlInjectionMatchSetCommand = async (
  input: CreateSqlInjectionMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateSqlInjectionMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateSqlInjectionMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateWebACLCommand = async (
  input: CreateWebACLCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateWebACL",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateWebACLRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateXssMatchSetCommand = async (
  input: CreateXssMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.CreateXssMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateXssMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteByteMatchSetCommand = async (
  input: DeleteByteMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteByteMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteByteMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteGeoMatchSetCommand = async (
  input: DeleteGeoMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteGeoMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteGeoMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteIPSetCommand = async (
  input: DeleteIPSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteIPSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteIPSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteLoggingConfigurationCommand = async (
  input: DeleteLoggingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteLoggingConfiguration",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteLoggingConfigurationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeletePermissionPolicyCommand = async (
  input: DeletePermissionPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeletePermissionPolicy",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeletePermissionPolicyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteRateBasedRuleCommand = async (
  input: DeleteRateBasedRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteRateBasedRule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteRateBasedRuleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteRegexMatchSetCommand = async (
  input: DeleteRegexMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteRegexMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteRegexMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteRegexPatternSetCommand = async (
  input: DeleteRegexPatternSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteRegexPatternSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteRegexPatternSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteRuleCommand = async (
  input: DeleteRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteRule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteRuleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteRuleGroupCommand = async (
  input: DeleteRuleGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteRuleGroup",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteRuleGroupRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteSizeConstraintSetCommand = async (
  input: DeleteSizeConstraintSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteSizeConstraintSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteSizeConstraintSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteSqlInjectionMatchSetCommand = async (
  input: DeleteSqlInjectionMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteSqlInjectionMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteSqlInjectionMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteWebACLCommand = async (
  input: DeleteWebACLCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteWebACL",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteWebACLRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteXssMatchSetCommand = async (
  input: DeleteXssMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.DeleteXssMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteXssMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetByteMatchSetCommand = async (
  input: GetByteMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetByteMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetByteMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetChangeTokenCommand = async (
  input: GetChangeTokenCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetChangeToken",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetChangeTokenRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetChangeTokenStatusCommand = async (
  input: GetChangeTokenStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetChangeTokenStatus",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetChangeTokenStatusRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetGeoMatchSetCommand = async (
  input: GetGeoMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetGeoMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetGeoMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetIPSetCommand = async (
  input: GetIPSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetIPSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetIPSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetLoggingConfigurationCommand = async (
  input: GetLoggingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetLoggingConfiguration",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetLoggingConfigurationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetPermissionPolicyCommand = async (
  input: GetPermissionPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetPermissionPolicy",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetPermissionPolicyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetRateBasedRuleCommand = async (
  input: GetRateBasedRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetRateBasedRule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetRateBasedRuleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetRateBasedRuleManagedKeysCommand = async (
  input: GetRateBasedRuleManagedKeysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetRateBasedRuleManagedKeys",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetRateBasedRuleManagedKeysRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetRegexMatchSetCommand = async (
  input: GetRegexMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetRegexMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetRegexMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetRegexPatternSetCommand = async (
  input: GetRegexPatternSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetRegexPatternSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetRegexPatternSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetRuleCommand = async (
  input: GetRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetRule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetRuleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetRuleGroupCommand = async (
  input: GetRuleGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetRuleGroup",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetRuleGroupRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetSampledRequestsCommand = async (
  input: GetSampledRequestsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetSampledRequests",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetSampledRequestsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetSizeConstraintSetCommand = async (
  input: GetSizeConstraintSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetSizeConstraintSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetSizeConstraintSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetSqlInjectionMatchSetCommand = async (
  input: GetSqlInjectionMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetSqlInjectionMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetSqlInjectionMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetWebACLCommand = async (
  input: GetWebACLCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetWebACL",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetWebACLRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetXssMatchSetCommand = async (
  input: GetXssMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.GetXssMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GetXssMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListActivatedRulesInRuleGroupCommand = async (
  input: ListActivatedRulesInRuleGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListActivatedRulesInRuleGroup",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListActivatedRulesInRuleGroupRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListByteMatchSetsCommand = async (
  input: ListByteMatchSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListByteMatchSets",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListByteMatchSetsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListGeoMatchSetsCommand = async (
  input: ListGeoMatchSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListGeoMatchSets",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListGeoMatchSetsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListIPSetsCommand = async (
  input: ListIPSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListIPSets",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListIPSetsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListLoggingConfigurationsCommand = async (
  input: ListLoggingConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListLoggingConfigurations",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListLoggingConfigurationsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListRateBasedRulesCommand = async (
  input: ListRateBasedRulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListRateBasedRules",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListRateBasedRulesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListRegexMatchSetsCommand = async (
  input: ListRegexMatchSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListRegexMatchSets",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListRegexMatchSetsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListRegexPatternSetsCommand = async (
  input: ListRegexPatternSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListRegexPatternSets",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListRegexPatternSetsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListRuleGroupsCommand = async (
  input: ListRuleGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListRuleGroups",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListRuleGroupsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListRulesCommand = async (
  input: ListRulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListRules",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListRulesRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListSizeConstraintSetsCommand = async (
  input: ListSizeConstraintSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListSizeConstraintSets",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListSizeConstraintSetsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListSqlInjectionMatchSetsCommand = async (
  input: ListSqlInjectionMatchSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListSqlInjectionMatchSets",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListSqlInjectionMatchSetsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListSubscribedRuleGroupsCommand = async (
  input: ListSubscribedRuleGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListSubscribedRuleGroups",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListSubscribedRuleGroupsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListTagsForResourceCommand = async (
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListTagsForResource",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListTagsForResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListWebACLsCommand = async (
  input: ListWebACLsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListWebACLs",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListWebACLsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListXssMatchSetsCommand = async (
  input: ListXssMatchSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.ListXssMatchSets",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListXssMatchSetsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1PutLoggingConfigurationCommand = async (
  input: PutLoggingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.PutLoggingConfiguration",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1PutLoggingConfigurationRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1PutPermissionPolicyCommand = async (
  input: PutPermissionPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.PutPermissionPolicy",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1PutPermissionPolicyRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1TagResourceCommand = async (
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.TagResource",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UntagResourceCommand = async (
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UntagResource",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UntagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateByteMatchSetCommand = async (
  input: UpdateByteMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateByteMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateByteMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateGeoMatchSetCommand = async (
  input: UpdateGeoMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateGeoMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateGeoMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateIPSetCommand = async (
  input: UpdateIPSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateIPSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateIPSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateRateBasedRuleCommand = async (
  input: UpdateRateBasedRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateRateBasedRule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateRateBasedRuleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateRegexMatchSetCommand = async (
  input: UpdateRegexMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateRegexMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateRegexMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateRegexPatternSetCommand = async (
  input: UpdateRegexPatternSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateRegexPatternSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateRegexPatternSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateRuleCommand = async (
  input: UpdateRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateRule",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateRuleRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateRuleGroupCommand = async (
  input: UpdateRuleGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateRuleGroup",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateRuleGroupRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateSizeConstraintSetCommand = async (
  input: UpdateSizeConstraintSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateSizeConstraintSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateSizeConstraintSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateSqlInjectionMatchSetCommand = async (
  input: UpdateSqlInjectionMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateSqlInjectionMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateSqlInjectionMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateWebACLCommand = async (
  input: UpdateWebACLCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateWebACL",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateWebACLRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateXssMatchSetCommand = async (
  input: UpdateXssMatchSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AWSWAF_20150824.UpdateXssMatchSet",
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateXssMatchSetRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const deserializeAws_json1_1CreateByteMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateByteMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateByteMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateByteMatchSetResponse(data, context);
  const response: CreateByteMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateByteMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateByteMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateByteMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateGeoMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGeoMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateGeoMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateGeoMatchSetResponse(data, context);
  const response: CreateGeoMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGeoMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateGeoMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGeoMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateIPSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateIPSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateIPSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateIPSetResponse(data, context);
  const response: CreateIPSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateIPSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateIPSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateIPSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateRateBasedRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRateBasedRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRateBasedRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRateBasedRuleResponse(data, context);
  const response: CreateRateBasedRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRateBasedRuleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateRateBasedRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRateBasedRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.waf#WAFBadRequestException":
      response = {
        ...(await deserializeAws_json1_1WAFBadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateRegexMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRegexMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRegexMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRegexMatchSetResponse(data, context);
  const response: CreateRegexMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRegexMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateRegexMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRegexMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateRegexPatternSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRegexPatternSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRegexPatternSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRegexPatternSetResponse(data, context);
  const response: CreateRegexPatternSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRegexPatternSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateRegexPatternSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRegexPatternSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRuleResponse(data, context);
  const response: CreateRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRuleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.waf#WAFBadRequestException":
      response = {
        ...(await deserializeAws_json1_1WAFBadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateRuleGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRuleGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateRuleGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateRuleGroupResponse(data, context);
  const response: CreateRuleGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRuleGroupResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateRuleGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRuleGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.waf#WAFBadRequestException":
      response = {
        ...(await deserializeAws_json1_1WAFBadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateSizeConstraintSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSizeConstraintSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateSizeConstraintSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateSizeConstraintSetResponse(data, context);
  const response: CreateSizeConstraintSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSizeConstraintSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateSizeConstraintSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSizeConstraintSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateSqlInjectionMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSqlInjectionMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateSqlInjectionMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateSqlInjectionMatchSetResponse(data, context);
  const response: CreateSqlInjectionMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSqlInjectionMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateSqlInjectionMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSqlInjectionMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateWebACLCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWebACLCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateWebACLCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateWebACLResponse(data, context);
  const response: CreateWebACLCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateWebACLResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateWebACLCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateWebACLCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.waf#WAFBadRequestException":
      response = {
        ...(await deserializeAws_json1_1WAFBadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateXssMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateXssMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateXssMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateXssMatchSetResponse(data, context);
  const response: CreateXssMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateXssMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateXssMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateXssMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteByteMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteByteMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteByteMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteByteMatchSetResponse(data, context);
  const response: DeleteByteMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteByteMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteByteMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteByteMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteGeoMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGeoMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteGeoMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteGeoMatchSetResponse(data, context);
  const response: DeleteGeoMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteGeoMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteGeoMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGeoMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteIPSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIPSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteIPSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteIPSetResponse(data, context);
  const response: DeleteIPSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteIPSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteIPSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIPSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteLoggingConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLoggingConfigurationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteLoggingConfigurationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteLoggingConfigurationResponse(data, context);
  const response: DeleteLoggingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteLoggingConfigurationResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteLoggingConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLoggingConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeletePermissionPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePermissionPolicyCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeletePermissionPolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeletePermissionPolicyResponse(data, context);
  const response: DeletePermissionPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeletePermissionPolicyResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeletePermissionPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePermissionPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteRateBasedRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRateBasedRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRateBasedRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRateBasedRuleResponse(data, context);
  const response: DeleteRateBasedRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRateBasedRuleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteRateBasedRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRateBasedRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteRegexMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegexMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRegexMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRegexMatchSetResponse(data, context);
  const response: DeleteRegexMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRegexMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteRegexMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegexMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteRegexPatternSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegexPatternSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRegexPatternSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRegexPatternSetResponse(data, context);
  const response: DeleteRegexPatternSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRegexPatternSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteRegexPatternSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegexPatternSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRuleResponse(data, context);
  const response: DeleteRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRuleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteRuleGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRuleGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteRuleGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteRuleGroupResponse(data, context);
  const response: DeleteRuleGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRuleGroupResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteRuleGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRuleGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteSizeConstraintSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSizeConstraintSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteSizeConstraintSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteSizeConstraintSetResponse(data, context);
  const response: DeleteSizeConstraintSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSizeConstraintSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteSizeConstraintSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSizeConstraintSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteSqlInjectionMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSqlInjectionMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteSqlInjectionMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteSqlInjectionMatchSetResponse(data, context);
  const response: DeleteSqlInjectionMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSqlInjectionMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteSqlInjectionMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSqlInjectionMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteWebACLCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWebACLCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteWebACLCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteWebACLResponse(data, context);
  const response: DeleteWebACLCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteWebACLResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteWebACLCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteWebACLCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteXssMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteXssMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteXssMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteXssMatchSetResponse(data, context);
  const response: DeleteXssMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteXssMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteXssMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteXssMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonEmptyEntityException":
    case "com.amazonaws.waf#WAFNonEmptyEntityException":
      response = {
        ...(await deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetByteMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetByteMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetByteMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetByteMatchSetResponse(data, context);
  const response: GetByteMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetByteMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetByteMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetByteMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetChangeTokenCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeTokenCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetChangeTokenCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetChangeTokenResponse(data, context);
  const response: GetChangeTokenCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetChangeTokenResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetChangeTokenCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeTokenCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetChangeTokenStatusCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeTokenStatusCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetChangeTokenStatusCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetChangeTokenStatusResponse(data, context);
  const response: GetChangeTokenStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetChangeTokenStatusResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetChangeTokenStatusCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeTokenStatusCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetGeoMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGeoMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetGeoMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetGeoMatchSetResponse(data, context);
  const response: GetGeoMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGeoMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetGeoMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGeoMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetIPSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIPSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetIPSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetIPSetResponse(data, context);
  const response: GetIPSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetIPSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetIPSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIPSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetLoggingConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggingConfigurationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetLoggingConfigurationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetLoggingConfigurationResponse(data, context);
  const response: GetLoggingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetLoggingConfigurationResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetLoggingConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggingConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetPermissionPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPermissionPolicyCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetPermissionPolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetPermissionPolicyResponse(data, context);
  const response: GetPermissionPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPermissionPolicyResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetPermissionPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPermissionPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetRateBasedRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRateBasedRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRateBasedRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRateBasedRuleResponse(data, context);
  const response: GetRateBasedRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRateBasedRuleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetRateBasedRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRateBasedRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetRateBasedRuleManagedKeysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRateBasedRuleManagedKeysCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRateBasedRuleManagedKeysCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRateBasedRuleManagedKeysResponse(data, context);
  const response: GetRateBasedRuleManagedKeysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRateBasedRuleManagedKeysResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetRateBasedRuleManagedKeysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRateBasedRuleManagedKeysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetRegexMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegexMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRegexMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRegexMatchSetResponse(data, context);
  const response: GetRegexMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRegexMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetRegexMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegexMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetRegexPatternSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegexPatternSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRegexPatternSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRegexPatternSetResponse(data, context);
  const response: GetRegexPatternSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRegexPatternSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetRegexPatternSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegexPatternSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRuleResponse(data, context);
  const response: GetRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRuleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetRuleGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRuleGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetRuleGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetRuleGroupResponse(data, context);
  const response: GetRuleGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRuleGroupResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetRuleGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRuleGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetSampledRequestsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSampledRequestsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSampledRequestsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSampledRequestsResponse(data, context);
  const response: GetSampledRequestsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSampledRequestsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetSampledRequestsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSampledRequestsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetSizeConstraintSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSizeConstraintSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSizeConstraintSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSizeConstraintSetResponse(data, context);
  const response: GetSizeConstraintSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSizeConstraintSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetSizeConstraintSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSizeConstraintSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetSqlInjectionMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSqlInjectionMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetSqlInjectionMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetSqlInjectionMatchSetResponse(data, context);
  const response: GetSqlInjectionMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSqlInjectionMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetSqlInjectionMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSqlInjectionMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetWebACLCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWebACLCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetWebACLCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetWebACLResponse(data, context);
  const response: GetWebACLCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetWebACLResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetWebACLCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetWebACLCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetXssMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetXssMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetXssMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetXssMatchSetResponse(data, context);
  const response: GetXssMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetXssMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetXssMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetXssMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListActivatedRulesInRuleGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListActivatedRulesInRuleGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListActivatedRulesInRuleGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListActivatedRulesInRuleGroupResponse(data, context);
  const response: ListActivatedRulesInRuleGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListActivatedRulesInRuleGroupResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListActivatedRulesInRuleGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListActivatedRulesInRuleGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListByteMatchSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListByteMatchSetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListByteMatchSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListByteMatchSetsResponse(data, context);
  const response: ListByteMatchSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListByteMatchSetsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListByteMatchSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListByteMatchSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListGeoMatchSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGeoMatchSetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListGeoMatchSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListGeoMatchSetsResponse(data, context);
  const response: ListGeoMatchSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGeoMatchSetsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListGeoMatchSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGeoMatchSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListIPSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIPSetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListIPSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListIPSetsResponse(data, context);
  const response: ListIPSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListIPSetsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListIPSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIPSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListLoggingConfigurationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLoggingConfigurationsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListLoggingConfigurationsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListLoggingConfigurationsResponse(data, context);
  const response: ListLoggingConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListLoggingConfigurationsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListLoggingConfigurationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLoggingConfigurationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListRateBasedRulesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRateBasedRulesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRateBasedRulesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRateBasedRulesResponse(data, context);
  const response: ListRateBasedRulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRateBasedRulesResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListRateBasedRulesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRateBasedRulesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListRegexMatchSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRegexMatchSetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRegexMatchSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRegexMatchSetsResponse(data, context);
  const response: ListRegexMatchSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRegexMatchSetsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListRegexMatchSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRegexMatchSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListRegexPatternSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRegexPatternSetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRegexPatternSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRegexPatternSetsResponse(data, context);
  const response: ListRegexPatternSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRegexPatternSetsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListRegexPatternSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRegexPatternSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListRuleGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRuleGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRuleGroupsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRuleGroupsResponse(data, context);
  const response: ListRuleGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRuleGroupsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListRuleGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRuleGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListRulesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRulesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListRulesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListRulesResponse(data, context);
  const response: ListRulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRulesResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListRulesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRulesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListSizeConstraintSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSizeConstraintSetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSizeConstraintSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSizeConstraintSetsResponse(data, context);
  const response: ListSizeConstraintSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSizeConstraintSetsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListSizeConstraintSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSizeConstraintSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListSqlInjectionMatchSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSqlInjectionMatchSetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSqlInjectionMatchSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSqlInjectionMatchSetsResponse(data, context);
  const response: ListSqlInjectionMatchSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSqlInjectionMatchSetsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListSqlInjectionMatchSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSqlInjectionMatchSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListSubscribedRuleGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSubscribedRuleGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListSubscribedRuleGroupsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListSubscribedRuleGroupsResponse(data, context);
  const response: ListSubscribedRuleGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSubscribedRuleGroupsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListSubscribedRuleGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSubscribedRuleGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListTagsForResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceResponse(data, context);
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListTagsForResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.waf#WAFBadRequestException":
      response = {
        ...(await deserializeAws_json1_1WAFBadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListWebACLsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWebACLsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListWebACLsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListWebACLsResponse(data, context);
  const response: ListWebACLsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListWebACLsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListWebACLsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListWebACLsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListXssMatchSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListXssMatchSetsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListXssMatchSetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListXssMatchSetsResponse(data, context);
  const response: ListXssMatchSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListXssMatchSetsResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListXssMatchSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListXssMatchSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1PutLoggingConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutLoggingConfigurationCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutLoggingConfigurationCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutLoggingConfigurationResponse(data, context);
  const response: PutLoggingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutLoggingConfigurationResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1PutLoggingConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutLoggingConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFServiceLinkedRoleErrorException":
    case "com.amazonaws.waf#WAFServiceLinkedRoleErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFServiceLinkedRoleErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1PutPermissionPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutPermissionPolicyCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutPermissionPolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutPermissionPolicyResponse(data, context);
  const response: PutPermissionPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutPermissionPolicyResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1PutPermissionPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutPermissionPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidPermissionPolicyException":
    case "com.amazonaws.waf#WAFInvalidPermissionPolicyException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidPermissionPolicyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1TagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TagResourceResponse(data, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1TagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.waf#WAFBadRequestException":
      response = {
        ...(await deserializeAws_json1_1WAFBadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UntagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UntagResourceResponse(data, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UntagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFBadRequestException":
    case "com.amazonaws.waf#WAFBadRequestException":
      response = {
        ...(await deserializeAws_json1_1WAFBadRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationException":
    case "com.amazonaws.waf#WAFTagOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFTagOperationInternalErrorException":
    case "com.amazonaws.waf#WAFTagOperationInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateByteMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateByteMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateByteMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateByteMatchSetResponse(data, context);
  const response: UpdateByteMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateByteMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateByteMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateByteMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateGeoMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGeoMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateGeoMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateGeoMatchSetResponse(data, context);
  const response: UpdateGeoMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateGeoMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateGeoMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGeoMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateIPSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIPSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateIPSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateIPSetResponse(data, context);
  const response: UpdateIPSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateIPSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateIPSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIPSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateRateBasedRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRateBasedRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRateBasedRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRateBasedRuleResponse(data, context);
  const response: UpdateRateBasedRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRateBasedRuleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateRateBasedRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRateBasedRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateRegexMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRegexMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRegexMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRegexMatchSetResponse(data, context);
  const response: UpdateRegexMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRegexMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateRegexMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRegexMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFDisallowedNameException":
    case "com.amazonaws.waf#WAFDisallowedNameException":
      response = {
        ...(await deserializeAws_json1_1WAFDisallowedNameExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateRegexPatternSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRegexPatternSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRegexPatternSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRegexPatternSetResponse(data, context);
  const response: UpdateRegexPatternSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRegexPatternSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateRegexPatternSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRegexPatternSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidRegexPatternException":
    case "com.amazonaws.waf#WAFInvalidRegexPatternException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidRegexPatternExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRuleCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRuleCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRuleResponse(data, context);
  const response: UpdateRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRuleResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateRuleGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRuleGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRuleGroupCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRuleGroupResponse(data, context);
  const response: UpdateRuleGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRuleGroupResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateRuleGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRuleGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateSizeConstraintSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSizeConstraintSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateSizeConstraintSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateSizeConstraintSetResponse(data, context);
  const response: UpdateSizeConstraintSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSizeConstraintSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateSizeConstraintSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSizeConstraintSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateSqlInjectionMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSqlInjectionMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateSqlInjectionMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateSqlInjectionMatchSetResponse(data, context);
  const response: UpdateSqlInjectionMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSqlInjectionMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateSqlInjectionMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSqlInjectionMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateWebACLCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWebACLCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateWebACLCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateWebACLResponse(data, context);
  const response: UpdateWebACLCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateWebACLResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateWebACLCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateWebACLCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFReferencedItemException":
    case "com.amazonaws.waf#WAFReferencedItemException":
      response = {
        ...(await deserializeAws_json1_1WAFReferencedItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFSubscriptionNotFoundException":
    case "com.amazonaws.waf#WAFSubscriptionNotFoundException":
      response = {
        ...(await deserializeAws_json1_1WAFSubscriptionNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateXssMatchSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateXssMatchSetCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateXssMatchSetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateXssMatchSetResponse(data, context);
  const response: UpdateXssMatchSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateXssMatchSetResponse",
    ...contents,
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateXssMatchSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateXssMatchSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode = errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "WAFInternalErrorException":
    case "com.amazonaws.waf#WAFInternalErrorException":
      response = {
        ...(await deserializeAws_json1_1WAFInternalErrorExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidAccountException":
    case "com.amazonaws.waf#WAFInvalidAccountException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidAccountExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidOperationException":
    case "com.amazonaws.waf#WAFInvalidOperationException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidOperationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFInvalidParameterException":
    case "com.amazonaws.waf#WAFInvalidParameterException":
      response = {
        ...(await deserializeAws_json1_1WAFInvalidParameterExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFLimitsExceededException":
    case "com.amazonaws.waf#WAFLimitsExceededException":
      response = {
        ...(await deserializeAws_json1_1WAFLimitsExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentContainerException":
    case "com.amazonaws.waf#WAFNonexistentContainerException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentContainerExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFNonexistentItemException":
    case "com.amazonaws.waf#WAFNonexistentItemException":
      response = {
        ...(await deserializeAws_json1_1WAFNonexistentItemExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "WAFStaleDataException":
    case "com.amazonaws.waf#WAFStaleDataException":
      response = {
        ...(await deserializeAws_json1_1WAFStaleDataExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_json1_1WAFBadRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFBadRequestException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFBadRequestException(body, context);
  const contents: WAFBadRequestException = {
    name: "WAFBadRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFDisallowedNameExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFDisallowedNameException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFDisallowedNameException(body, context);
  const contents: WAFDisallowedNameException = {
    name: "WAFDisallowedNameException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFInternalErrorExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInternalErrorException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInternalErrorException(body, context);
  const contents: WAFInternalErrorException = {
    name: "WAFInternalErrorException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidAccountExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInvalidAccountException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInvalidAccountException(body, context);
  const contents: WAFInvalidAccountException = {
    name: "WAFInvalidAccountException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidOperationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInvalidOperationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInvalidOperationException(body, context);
  const contents: WAFInvalidOperationException = {
    name: "WAFInvalidOperationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidParameterExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInvalidParameterException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInvalidParameterException(body, context);
  const contents: WAFInvalidParameterException = {
    name: "WAFInvalidParameterException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidPermissionPolicyExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInvalidPermissionPolicyException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInvalidPermissionPolicyException(body, context);
  const contents: WAFInvalidPermissionPolicyException = {
    name: "WAFInvalidPermissionPolicyException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFInvalidRegexPatternExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFInvalidRegexPatternException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFInvalidRegexPatternException(body, context);
  const contents: WAFInvalidRegexPatternException = {
    name: "WAFInvalidRegexPatternException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFLimitsExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFLimitsExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFLimitsExceededException(body, context);
  const contents: WAFLimitsExceededException = {
    name: "WAFLimitsExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFNonEmptyEntityExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFNonEmptyEntityException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFNonEmptyEntityException(body, context);
  const contents: WAFNonEmptyEntityException = {
    name: "WAFNonEmptyEntityException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFNonexistentContainerExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFNonexistentContainerException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFNonexistentContainerException(body, context);
  const contents: WAFNonexistentContainerException = {
    name: "WAFNonexistentContainerException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFNonexistentItemExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFNonexistentItemException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFNonexistentItemException(body, context);
  const contents: WAFNonexistentItemException = {
    name: "WAFNonexistentItemException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFReferencedItemExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFReferencedItemException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFReferencedItemException(body, context);
  const contents: WAFReferencedItemException = {
    name: "WAFReferencedItemException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFServiceLinkedRoleErrorExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFServiceLinkedRoleErrorException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFServiceLinkedRoleErrorException(body, context);
  const contents: WAFServiceLinkedRoleErrorException = {
    name: "WAFServiceLinkedRoleErrorException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFStaleDataExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFStaleDataException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFStaleDataException(body, context);
  const contents: WAFStaleDataException = {
    name: "WAFStaleDataException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFSubscriptionNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFSubscriptionNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFSubscriptionNotFoundException(body, context);
  const contents: WAFSubscriptionNotFoundException = {
    name: "WAFSubscriptionNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFTagOperationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFTagOperationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFTagOperationException(body, context);
  const contents: WAFTagOperationException = {
    name: "WAFTagOperationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const deserializeAws_json1_1WAFTagOperationInternalErrorExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<WAFTagOperationInternalErrorException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1WAFTagOperationInternalErrorException(body, context);
  const contents: WAFTagOperationInternalErrorException = {
    name: "WAFTagOperationInternalErrorException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized,
  };
  return contents;
};

const serializeAws_json1_1ActivatedRule = (input: ActivatedRule, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: serializeAws_json1_1WafAction(input.Action, context) }),
    ...(input.ExcludedRules !== undefined && {
      ExcludedRules: serializeAws_json1_1ExcludedRules(input.ExcludedRules, context),
    }),
    ...(input.OverrideAction !== undefined && {
      OverrideAction: serializeAws_json1_1WafOverrideAction(input.OverrideAction, context),
    }),
    ...(input.Priority !== undefined && { Priority: input.Priority }),
    ...(input.RuleId !== undefined && { RuleId: input.RuleId }),
    ...(input.Type !== undefined && { Type: input.Type }),
  };
};

const serializeAws_json1_1ByteMatchSetUpdate = (input: ByteMatchSetUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.ByteMatchTuple !== undefined && {
      ByteMatchTuple: serializeAws_json1_1ByteMatchTuple(input.ByteMatchTuple, context),
    }),
  };
};

const serializeAws_json1_1ByteMatchSetUpdates = (input: ByteMatchSetUpdate[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1ByteMatchSetUpdate(entry, context));
};

const serializeAws_json1_1ByteMatchTuple = (input: ByteMatchTuple, context: __SerdeContext): any => {
  return {
    ...(input.FieldToMatch !== undefined && {
      FieldToMatch: serializeAws_json1_1FieldToMatch(input.FieldToMatch, context),
    }),
    ...(input.PositionalConstraint !== undefined && { PositionalConstraint: input.PositionalConstraint }),
    ...(input.TargetString !== undefined && { TargetString: context.base64Encoder(input.TargetString) }),
    ...(input.TextTransformation !== undefined && { TextTransformation: input.TextTransformation }),
  };
};

const serializeAws_json1_1CreateByteMatchSetRequest = (
  input: CreateByteMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1CreateGeoMatchSetRequest = (
  input: CreateGeoMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1CreateIPSetRequest = (input: CreateIPSetRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1CreateRateBasedRuleRequest = (
  input: CreateRateBasedRuleRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.MetricName !== undefined && { MetricName: input.MetricName }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.RateKey !== undefined && { RateKey: input.RateKey }),
    ...(input.RateLimit !== undefined && { RateLimit: input.RateLimit }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
  };
};

const serializeAws_json1_1CreateRegexMatchSetRequest = (
  input: CreateRegexMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1CreateRegexPatternSetRequest = (
  input: CreateRegexPatternSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1CreateRuleGroupRequest = (input: CreateRuleGroupRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.MetricName !== undefined && { MetricName: input.MetricName }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
  };
};

const serializeAws_json1_1CreateRuleRequest = (input: CreateRuleRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.MetricName !== undefined && { MetricName: input.MetricName }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
  };
};

const serializeAws_json1_1CreateSizeConstraintSetRequest = (
  input: CreateSizeConstraintSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1CreateSqlInjectionMatchSetRequest = (
  input: CreateSqlInjectionMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1CreateWebACLRequest = (input: CreateWebACLRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.DefaultAction !== undefined && {
      DefaultAction: serializeAws_json1_1WafAction(input.DefaultAction, context),
    }),
    ...(input.MetricName !== undefined && { MetricName: input.MetricName }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
  };
};

const serializeAws_json1_1CreateXssMatchSetRequest = (
  input: CreateXssMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.Name !== undefined && { Name: input.Name }),
  };
};

const serializeAws_json1_1DeleteByteMatchSetRequest = (
  input: DeleteByteMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ByteMatchSetId !== undefined && { ByteMatchSetId: input.ByteMatchSetId }),
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
  };
};

const serializeAws_json1_1DeleteGeoMatchSetRequest = (
  input: DeleteGeoMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.GeoMatchSetId !== undefined && { GeoMatchSetId: input.GeoMatchSetId }),
  };
};

const serializeAws_json1_1DeleteIPSetRequest = (input: DeleteIPSetRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.IPSetId !== undefined && { IPSetId: input.IPSetId }),
  };
};

const serializeAws_json1_1DeleteLoggingConfigurationRequest = (
  input: DeleteLoggingConfigurationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
  };
};

const serializeAws_json1_1DeletePermissionPolicyRequest = (
  input: DeletePermissionPolicyRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
  };
};

const serializeAws_json1_1DeleteRateBasedRuleRequest = (
  input: DeleteRateBasedRuleRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.RuleId !== undefined && { RuleId: input.RuleId }),
  };
};

const serializeAws_json1_1DeleteRegexMatchSetRequest = (
  input: DeleteRegexMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.RegexMatchSetId !== undefined && { RegexMatchSetId: input.RegexMatchSetId }),
  };
};

const serializeAws_json1_1DeleteRegexPatternSetRequest = (
  input: DeleteRegexPatternSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.RegexPatternSetId !== undefined && { RegexPatternSetId: input.RegexPatternSetId }),
  };
};

const serializeAws_json1_1DeleteRuleGroupRequest = (input: DeleteRuleGroupRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.RuleGroupId !== undefined && { RuleGroupId: input.RuleGroupId }),
  };
};

const serializeAws_json1_1DeleteRuleRequest = (input: DeleteRuleRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.RuleId !== undefined && { RuleId: input.RuleId }),
  };
};

const serializeAws_json1_1DeleteSizeConstraintSetRequest = (
  input: DeleteSizeConstraintSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.SizeConstraintSetId !== undefined && { SizeConstraintSetId: input.SizeConstraintSetId }),
  };
};

const serializeAws_json1_1DeleteSqlInjectionMatchSetRequest = (
  input: DeleteSqlInjectionMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.SqlInjectionMatchSetId !== undefined && { SqlInjectionMatchSetId: input.SqlInjectionMatchSetId }),
  };
};

const serializeAws_json1_1DeleteWebACLRequest = (input: DeleteWebACLRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.WebACLId !== undefined && { WebACLId: input.WebACLId }),
  };
};

const serializeAws_json1_1DeleteXssMatchSetRequest = (
  input: DeleteXssMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.XssMatchSetId !== undefined && { XssMatchSetId: input.XssMatchSetId }),
  };
};

const serializeAws_json1_1ExcludedRule = (input: ExcludedRule, context: __SerdeContext): any => {
  return {
    ...(input.RuleId !== undefined && { RuleId: input.RuleId }),
  };
};

const serializeAws_json1_1ExcludedRules = (input: ExcludedRule[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1ExcludedRule(entry, context));
};

const serializeAws_json1_1FieldToMatch = (input: FieldToMatch, context: __SerdeContext): any => {
  return {
    ...(input.Data !== undefined && { Data: input.Data }),
    ...(input.Type !== undefined && { Type: input.Type }),
  };
};

const serializeAws_json1_1GeoMatchConstraint = (input: GeoMatchConstraint, context: __SerdeContext): any => {
  return {
    ...(input.Type !== undefined && { Type: input.Type }),
    ...(input.Value !== undefined && { Value: input.Value }),
  };
};

const serializeAws_json1_1GeoMatchSetUpdate = (input: GeoMatchSetUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.GeoMatchConstraint !== undefined && {
      GeoMatchConstraint: serializeAws_json1_1GeoMatchConstraint(input.GeoMatchConstraint, context),
    }),
  };
};

const serializeAws_json1_1GeoMatchSetUpdates = (input: GeoMatchSetUpdate[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1GeoMatchSetUpdate(entry, context));
};

const serializeAws_json1_1GetByteMatchSetRequest = (input: GetByteMatchSetRequest, context: __SerdeContext): any => {
  return {
    ...(input.ByteMatchSetId !== undefined && { ByteMatchSetId: input.ByteMatchSetId }),
  };
};

const serializeAws_json1_1GetChangeTokenRequest = (input: GetChangeTokenRequest, context: __SerdeContext): any => {
  return {};
};

const serializeAws_json1_1GetChangeTokenStatusRequest = (
  input: GetChangeTokenStatusRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
  };
};

const serializeAws_json1_1GetGeoMatchSetRequest = (input: GetGeoMatchSetRequest, context: __SerdeContext): any => {
  return {
    ...(input.GeoMatchSetId !== undefined && { GeoMatchSetId: input.GeoMatchSetId }),
  };
};

const serializeAws_json1_1GetIPSetRequest = (input: GetIPSetRequest, context: __SerdeContext): any => {
  return {
    ...(input.IPSetId !== undefined && { IPSetId: input.IPSetId }),
  };
};

const serializeAws_json1_1GetLoggingConfigurationRequest = (
  input: GetLoggingConfigurationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
  };
};

const serializeAws_json1_1GetPermissionPolicyRequest = (
  input: GetPermissionPolicyRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
  };
};

const serializeAws_json1_1GetRateBasedRuleManagedKeysRequest = (
  input: GetRateBasedRuleManagedKeysRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
    ...(input.RuleId !== undefined && { RuleId: input.RuleId }),
  };
};

const serializeAws_json1_1GetRateBasedRuleRequest = (input: GetRateBasedRuleRequest, context: __SerdeContext): any => {
  return {
    ...(input.RuleId !== undefined && { RuleId: input.RuleId }),
  };
};

const serializeAws_json1_1GetRegexMatchSetRequest = (input: GetRegexMatchSetRequest, context: __SerdeContext): any => {
  return {
    ...(input.RegexMatchSetId !== undefined && { RegexMatchSetId: input.RegexMatchSetId }),
  };
};

const serializeAws_json1_1GetRegexPatternSetRequest = (
  input: GetRegexPatternSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.RegexPatternSetId !== undefined && { RegexPatternSetId: input.RegexPatternSetId }),
  };
};

const serializeAws_json1_1GetRuleGroupRequest = (input: GetRuleGroupRequest, context: __SerdeContext): any => {
  return {
    ...(input.RuleGroupId !== undefined && { RuleGroupId: input.RuleGroupId }),
  };
};

const serializeAws_json1_1GetRuleRequest = (input: GetRuleRequest, context: __SerdeContext): any => {
  return {
    ...(input.RuleId !== undefined && { RuleId: input.RuleId }),
  };
};

const serializeAws_json1_1GetSampledRequestsRequest = (
  input: GetSampledRequestsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.MaxItems !== undefined && { MaxItems: input.MaxItems }),
    ...(input.RuleId !== undefined && { RuleId: input.RuleId }),
    ...(input.TimeWindow !== undefined && { TimeWindow: serializeAws_json1_1TimeWindow(input.TimeWindow, context) }),
    ...(input.WebAclId !== undefined && { WebAclId: input.WebAclId }),
  };
};

const serializeAws_json1_1GetSizeConstraintSetRequest = (
  input: GetSizeConstraintSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.SizeConstraintSetId !== undefined && { SizeConstraintSetId: input.SizeConstraintSetId }),
  };
};

const serializeAws_json1_1GetSqlInjectionMatchSetRequest = (
  input: GetSqlInjectionMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.SqlInjectionMatchSetId !== undefined && { SqlInjectionMatchSetId: input.SqlInjectionMatchSetId }),
  };
};

const serializeAws_json1_1GetWebACLRequest = (input: GetWebACLRequest, context: __SerdeContext): any => {
  return {
    ...(input.WebACLId !== undefined && { WebACLId: input.WebACLId }),
  };
};

const serializeAws_json1_1GetXssMatchSetRequest = (input: GetXssMatchSetRequest, context: __SerdeContext): any => {
  return {
    ...(input.XssMatchSetId !== undefined && { XssMatchSetId: input.XssMatchSetId }),
  };
};

const serializeAws_json1_1IPSetDescriptor = (input: IPSetDescriptor, context: __SerdeContext): any => {
  return {
    ...(input.Type !== undefined && { Type: input.Type }),
    ...(input.Value !== undefined && { Value: input.Value }),
  };
};

const serializeAws_json1_1IPSetUpdate = (input: IPSetUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.IPSetDescriptor !== undefined && {
      IPSetDescriptor: serializeAws_json1_1IPSetDescriptor(input.IPSetDescriptor, context),
    }),
  };
};

const serializeAws_json1_1IPSetUpdates = (input: IPSetUpdate[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1IPSetUpdate(entry, context));
};

const serializeAws_json1_1ListActivatedRulesInRuleGroupRequest = (
  input: ListActivatedRulesInRuleGroupRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
    ...(input.RuleGroupId !== undefined && { RuleGroupId: input.RuleGroupId }),
  };
};

const serializeAws_json1_1ListByteMatchSetsRequest = (
  input: ListByteMatchSetsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListGeoMatchSetsRequest = (input: ListGeoMatchSetsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListIPSetsRequest = (input: ListIPSetsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListLoggingConfigurationsRequest = (
  input: ListLoggingConfigurationsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListRateBasedRulesRequest = (
  input: ListRateBasedRulesRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListRegexMatchSetsRequest = (
  input: ListRegexMatchSetsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListRegexPatternSetsRequest = (
  input: ListRegexPatternSetsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListRuleGroupsRequest = (input: ListRuleGroupsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListRulesRequest = (input: ListRulesRequest, context: __SerdeContext): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListSizeConstraintSetsRequest = (
  input: ListSizeConstraintSetsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListSqlInjectionMatchSetsRequest = (
  input: ListSqlInjectionMatchSetsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListSubscribedRuleGroupsRequest = (
  input: ListSubscribedRuleGroupsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListTagsForResourceRequest = (
  input: ListTagsForResourceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
    ...(input.ResourceARN !== undefined && { ResourceARN: input.ResourceARN }),
  };
};

const serializeAws_json1_1ListWebACLsRequest = (input: ListWebACLsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1ListXssMatchSetsRequest = (input: ListXssMatchSetsRequest, context: __SerdeContext): any => {
  return {
    ...(input.Limit !== undefined && { Limit: input.Limit }),
    ...(input.NextMarker !== undefined && { NextMarker: input.NextMarker }),
  };
};

const serializeAws_json1_1LogDestinationConfigs = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1LoggingConfiguration = (input: LoggingConfiguration, context: __SerdeContext): any => {
  return {
    ...(input.LogDestinationConfigs !== undefined && {
      LogDestinationConfigs: serializeAws_json1_1LogDestinationConfigs(input.LogDestinationConfigs, context),
    }),
    ...(input.RedactedFields !== undefined && {
      RedactedFields: serializeAws_json1_1RedactedFields(input.RedactedFields, context),
    }),
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
  };
};

const serializeAws_json1_1Predicate = (input: Predicate, context: __SerdeContext): any => {
  return {
    ...(input.DataId !== undefined && { DataId: input.DataId }),
    ...(input.Negated !== undefined && { Negated: input.Negated }),
    ...(input.Type !== undefined && { Type: input.Type }),
  };
};

const serializeAws_json1_1PutLoggingConfigurationRequest = (
  input: PutLoggingConfigurationRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.LoggingConfiguration !== undefined && {
      LoggingConfiguration: serializeAws_json1_1LoggingConfiguration(input.LoggingConfiguration, context),
    }),
  };
};

const serializeAws_json1_1PutPermissionPolicyRequest = (
  input: PutPermissionPolicyRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Policy !== undefined && { Policy: input.Policy }),
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
  };
};

const serializeAws_json1_1RedactedFields = (input: FieldToMatch[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1FieldToMatch(entry, context));
};

const serializeAws_json1_1RegexMatchSetUpdate = (input: RegexMatchSetUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.RegexMatchTuple !== undefined && {
      RegexMatchTuple: serializeAws_json1_1RegexMatchTuple(input.RegexMatchTuple, context),
    }),
  };
};

const serializeAws_json1_1RegexMatchSetUpdates = (input: RegexMatchSetUpdate[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1RegexMatchSetUpdate(entry, context));
};

const serializeAws_json1_1RegexMatchTuple = (input: RegexMatchTuple, context: __SerdeContext): any => {
  return {
    ...(input.FieldToMatch !== undefined && {
      FieldToMatch: serializeAws_json1_1FieldToMatch(input.FieldToMatch, context),
    }),
    ...(input.RegexPatternSetId !== undefined && { RegexPatternSetId: input.RegexPatternSetId }),
    ...(input.TextTransformation !== undefined && { TextTransformation: input.TextTransformation }),
  };
};

const serializeAws_json1_1RegexPatternSetUpdate = (input: RegexPatternSetUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.RegexPatternString !== undefined && { RegexPatternString: input.RegexPatternString }),
  };
};

const serializeAws_json1_1RegexPatternSetUpdates = (input: RegexPatternSetUpdate[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1RegexPatternSetUpdate(entry, context));
};

const serializeAws_json1_1RuleGroupUpdate = (input: RuleGroupUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.ActivatedRule !== undefined && {
      ActivatedRule: serializeAws_json1_1ActivatedRule(input.ActivatedRule, context),
    }),
  };
};

const serializeAws_json1_1RuleGroupUpdates = (input: RuleGroupUpdate[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1RuleGroupUpdate(entry, context));
};

const serializeAws_json1_1RuleUpdate = (input: RuleUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.Predicate !== undefined && { Predicate: serializeAws_json1_1Predicate(input.Predicate, context) }),
  };
};

const serializeAws_json1_1RuleUpdates = (input: RuleUpdate[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1RuleUpdate(entry, context));
};

const serializeAws_json1_1SizeConstraint = (input: SizeConstraint, context: __SerdeContext): any => {
  return {
    ...(input.ComparisonOperator !== undefined && { ComparisonOperator: input.ComparisonOperator }),
    ...(input.FieldToMatch !== undefined && {
      FieldToMatch: serializeAws_json1_1FieldToMatch(input.FieldToMatch, context),
    }),
    ...(input.Size !== undefined && { Size: input.Size }),
    ...(input.TextTransformation !== undefined && { TextTransformation: input.TextTransformation }),
  };
};

const serializeAws_json1_1SizeConstraintSetUpdate = (input: SizeConstraintSetUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.SizeConstraint !== undefined && {
      SizeConstraint: serializeAws_json1_1SizeConstraint(input.SizeConstraint, context),
    }),
  };
};

const serializeAws_json1_1SizeConstraintSetUpdates = (
  input: SizeConstraintSetUpdate[],
  context: __SerdeContext
): any => {
  return input.map((entry) => serializeAws_json1_1SizeConstraintSetUpdate(entry, context));
};

const serializeAws_json1_1SqlInjectionMatchSetUpdate = (
  input: SqlInjectionMatchSetUpdate,
  context: __SerdeContext
): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.SqlInjectionMatchTuple !== undefined && {
      SqlInjectionMatchTuple: serializeAws_json1_1SqlInjectionMatchTuple(input.SqlInjectionMatchTuple, context),
    }),
  };
};

const serializeAws_json1_1SqlInjectionMatchSetUpdates = (
  input: SqlInjectionMatchSetUpdate[],
  context: __SerdeContext
): any => {
  return input.map((entry) => serializeAws_json1_1SqlInjectionMatchSetUpdate(entry, context));
};

const serializeAws_json1_1SqlInjectionMatchTuple = (input: SqlInjectionMatchTuple, context: __SerdeContext): any => {
  return {
    ...(input.FieldToMatch !== undefined && {
      FieldToMatch: serializeAws_json1_1FieldToMatch(input.FieldToMatch, context),
    }),
    ...(input.TextTransformation !== undefined && { TextTransformation: input.TextTransformation }),
  };
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  return {
    ...(input.Key !== undefined && { Key: input.Key }),
    ...(input.Value !== undefined && { Value: input.Value }),
  };
};

const serializeAws_json1_1TagKeyList = (input: string[], context: __SerdeContext): any => {
  return input.map((entry) => entry);
};

const serializeAws_json1_1TagList = (input: Tag[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1Tag(entry, context));
};

const serializeAws_json1_1TagResourceRequest = (input: TagResourceRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResourceARN !== undefined && { ResourceARN: input.ResourceARN }),
    ...(input.Tags !== undefined && { Tags: serializeAws_json1_1TagList(input.Tags, context) }),
  };
};

const serializeAws_json1_1TimeWindow = (input: TimeWindow, context: __SerdeContext): any => {
  return {
    ...(input.EndTime !== undefined && { EndTime: Math.round(input.EndTime.getTime() / 1000) }),
    ...(input.StartTime !== undefined && { StartTime: Math.round(input.StartTime.getTime() / 1000) }),
  };
};

const serializeAws_json1_1UntagResourceRequest = (input: UntagResourceRequest, context: __SerdeContext): any => {
  return {
    ...(input.ResourceARN !== undefined && { ResourceARN: input.ResourceARN }),
    ...(input.TagKeys !== undefined && { TagKeys: serializeAws_json1_1TagKeyList(input.TagKeys, context) }),
  };
};

const serializeAws_json1_1UpdateByteMatchSetRequest = (
  input: UpdateByteMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ByteMatchSetId !== undefined && { ByteMatchSetId: input.ByteMatchSetId }),
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.Updates !== undefined && { Updates: serializeAws_json1_1ByteMatchSetUpdates(input.Updates, context) }),
  };
};

const serializeAws_json1_1UpdateGeoMatchSetRequest = (
  input: UpdateGeoMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.GeoMatchSetId !== undefined && { GeoMatchSetId: input.GeoMatchSetId }),
    ...(input.Updates !== undefined && { Updates: serializeAws_json1_1GeoMatchSetUpdates(input.Updates, context) }),
  };
};

const serializeAws_json1_1UpdateIPSetRequest = (input: UpdateIPSetRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.IPSetId !== undefined && { IPSetId: input.IPSetId }),
    ...(input.Updates !== undefined && { Updates: serializeAws_json1_1IPSetUpdates(input.Updates, context) }),
  };
};

const serializeAws_json1_1UpdateRateBasedRuleRequest = (
  input: UpdateRateBasedRuleRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.RateLimit !== undefined && { RateLimit: input.RateLimit }),
    ...(input.RuleId !== undefined && { RuleId: input.RuleId }),
    ...(input.Updates !== undefined && { Updates: serializeAws_json1_1RuleUpdates(input.Updates, context) }),
  };
};

const serializeAws_json1_1UpdateRegexMatchSetRequest = (
  input: UpdateRegexMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.RegexMatchSetId !== undefined && { RegexMatchSetId: input.RegexMatchSetId }),
    ...(input.Updates !== undefined && { Updates: serializeAws_json1_1RegexMatchSetUpdates(input.Updates, context) }),
  };
};

const serializeAws_json1_1UpdateRegexPatternSetRequest = (
  input: UpdateRegexPatternSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.RegexPatternSetId !== undefined && { RegexPatternSetId: input.RegexPatternSetId }),
    ...(input.Updates !== undefined && { Updates: serializeAws_json1_1RegexPatternSetUpdates(input.Updates, context) }),
  };
};

const serializeAws_json1_1UpdateRuleGroupRequest = (input: UpdateRuleGroupRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.RuleGroupId !== undefined && { RuleGroupId: input.RuleGroupId }),
    ...(input.Updates !== undefined && { Updates: serializeAws_json1_1RuleGroupUpdates(input.Updates, context) }),
  };
};

const serializeAws_json1_1UpdateRuleRequest = (input: UpdateRuleRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.RuleId !== undefined && { RuleId: input.RuleId }),
    ...(input.Updates !== undefined && { Updates: serializeAws_json1_1RuleUpdates(input.Updates, context) }),
  };
};

const serializeAws_json1_1UpdateSizeConstraintSetRequest = (
  input: UpdateSizeConstraintSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.SizeConstraintSetId !== undefined && { SizeConstraintSetId: input.SizeConstraintSetId }),
    ...(input.Updates !== undefined && {
      Updates: serializeAws_json1_1SizeConstraintSetUpdates(input.Updates, context),
    }),
  };
};

const serializeAws_json1_1UpdateSqlInjectionMatchSetRequest = (
  input: UpdateSqlInjectionMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.SqlInjectionMatchSetId !== undefined && { SqlInjectionMatchSetId: input.SqlInjectionMatchSetId }),
    ...(input.Updates !== undefined && {
      Updates: serializeAws_json1_1SqlInjectionMatchSetUpdates(input.Updates, context),
    }),
  };
};

const serializeAws_json1_1UpdateWebACLRequest = (input: UpdateWebACLRequest, context: __SerdeContext): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.DefaultAction !== undefined && {
      DefaultAction: serializeAws_json1_1WafAction(input.DefaultAction, context),
    }),
    ...(input.Updates !== undefined && { Updates: serializeAws_json1_1WebACLUpdates(input.Updates, context) }),
    ...(input.WebACLId !== undefined && { WebACLId: input.WebACLId }),
  };
};

const serializeAws_json1_1UpdateXssMatchSetRequest = (
  input: UpdateXssMatchSetRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ChangeToken !== undefined && { ChangeToken: input.ChangeToken }),
    ...(input.Updates !== undefined && { Updates: serializeAws_json1_1XssMatchSetUpdates(input.Updates, context) }),
    ...(input.XssMatchSetId !== undefined && { XssMatchSetId: input.XssMatchSetId }),
  };
};

const serializeAws_json1_1WafAction = (input: WafAction, context: __SerdeContext): any => {
  return {
    ...(input.Type !== undefined && { Type: input.Type }),
  };
};

const serializeAws_json1_1WafOverrideAction = (input: WafOverrideAction, context: __SerdeContext): any => {
  return {
    ...(input.Type !== undefined && { Type: input.Type }),
  };
};

const serializeAws_json1_1WebACLUpdate = (input: WebACLUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.ActivatedRule !== undefined && {
      ActivatedRule: serializeAws_json1_1ActivatedRule(input.ActivatedRule, context),
    }),
  };
};

const serializeAws_json1_1WebACLUpdates = (input: WebACLUpdate[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1WebACLUpdate(entry, context));
};

const serializeAws_json1_1XssMatchSetUpdate = (input: XssMatchSetUpdate, context: __SerdeContext): any => {
  return {
    ...(input.Action !== undefined && { Action: input.Action }),
    ...(input.XssMatchTuple !== undefined && {
      XssMatchTuple: serializeAws_json1_1XssMatchTuple(input.XssMatchTuple, context),
    }),
  };
};

const serializeAws_json1_1XssMatchSetUpdates = (input: XssMatchSetUpdate[], context: __SerdeContext): any => {
  return input.map((entry) => serializeAws_json1_1XssMatchSetUpdate(entry, context));
};

const serializeAws_json1_1XssMatchTuple = (input: XssMatchTuple, context: __SerdeContext): any => {
  return {
    ...(input.FieldToMatch !== undefined && {
      FieldToMatch: serializeAws_json1_1FieldToMatch(input.FieldToMatch, context),
    }),
    ...(input.TextTransformation !== undefined && { TextTransformation: input.TextTransformation }),
  };
};

const deserializeAws_json1_1ActivatedRule = (output: any, context: __SerdeContext): ActivatedRule => {
  return {
    __type: "ActivatedRule",
    Action:
      output.Action !== undefined && output.Action !== null
        ? deserializeAws_json1_1WafAction(output.Action, context)
        : undefined,
    ExcludedRules:
      output.ExcludedRules !== undefined && output.ExcludedRules !== null
        ? deserializeAws_json1_1ExcludedRules(output.ExcludedRules, context)
        : undefined,
    OverrideAction:
      output.OverrideAction !== undefined && output.OverrideAction !== null
        ? deserializeAws_json1_1WafOverrideAction(output.OverrideAction, context)
        : undefined,
    Priority: output.Priority !== undefined && output.Priority !== null ? output.Priority : undefined,
    RuleId: output.RuleId !== undefined && output.RuleId !== null ? output.RuleId : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  } as any;
};

const deserializeAws_json1_1ActivatedRules = (output: any, context: __SerdeContext): ActivatedRule[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1ActivatedRule(entry, context));
};

const deserializeAws_json1_1ByteMatchSet = (output: any, context: __SerdeContext): ByteMatchSet => {
  return {
    __type: "ByteMatchSet",
    ByteMatchSetId:
      output.ByteMatchSetId !== undefined && output.ByteMatchSetId !== null ? output.ByteMatchSetId : undefined,
    ByteMatchTuples:
      output.ByteMatchTuples !== undefined && output.ByteMatchTuples !== null
        ? deserializeAws_json1_1ByteMatchTuples(output.ByteMatchTuples, context)
        : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1ByteMatchSetSummaries = (output: any, context: __SerdeContext): ByteMatchSetSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1ByteMatchSetSummary(entry, context));
};

const deserializeAws_json1_1ByteMatchSetSummary = (output: any, context: __SerdeContext): ByteMatchSetSummary => {
  return {
    __type: "ByteMatchSetSummary",
    ByteMatchSetId:
      output.ByteMatchSetId !== undefined && output.ByteMatchSetId !== null ? output.ByteMatchSetId : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1ByteMatchTuple = (output: any, context: __SerdeContext): ByteMatchTuple => {
  return {
    __type: "ByteMatchTuple",
    FieldToMatch:
      output.FieldToMatch !== undefined && output.FieldToMatch !== null
        ? deserializeAws_json1_1FieldToMatch(output.FieldToMatch, context)
        : undefined,
    PositionalConstraint:
      output.PositionalConstraint !== undefined && output.PositionalConstraint !== null
        ? output.PositionalConstraint
        : undefined,
    TargetString:
      output.TargetString !== undefined && output.TargetString !== null
        ? context.base64Decoder(output.TargetString)
        : undefined,
    TextTransformation:
      output.TextTransformation !== undefined && output.TextTransformation !== null
        ? output.TextTransformation
        : undefined,
  } as any;
};

const deserializeAws_json1_1ByteMatchTuples = (output: any, context: __SerdeContext): ByteMatchTuple[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1ByteMatchTuple(entry, context));
};

const deserializeAws_json1_1CreateByteMatchSetResponse = (
  output: any,
  context: __SerdeContext
): CreateByteMatchSetResponse => {
  return {
    __type: "CreateByteMatchSetResponse",
    ByteMatchSet:
      output.ByteMatchSet !== undefined && output.ByteMatchSet !== null
        ? deserializeAws_json1_1ByteMatchSet(output.ByteMatchSet, context)
        : undefined,
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1CreateGeoMatchSetResponse = (
  output: any,
  context: __SerdeContext
): CreateGeoMatchSetResponse => {
  return {
    __type: "CreateGeoMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    GeoMatchSet:
      output.GeoMatchSet !== undefined && output.GeoMatchSet !== null
        ? deserializeAws_json1_1GeoMatchSet(output.GeoMatchSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateIPSetResponse = (output: any, context: __SerdeContext): CreateIPSetResponse => {
  return {
    __type: "CreateIPSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    IPSet:
      output.IPSet !== undefined && output.IPSet !== null
        ? deserializeAws_json1_1IPSet(output.IPSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateRateBasedRuleResponse = (
  output: any,
  context: __SerdeContext
): CreateRateBasedRuleResponse => {
  return {
    __type: "CreateRateBasedRuleResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    Rule:
      output.Rule !== undefined && output.Rule !== null
        ? deserializeAws_json1_1RateBasedRule(output.Rule, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateRegexMatchSetResponse = (
  output: any,
  context: __SerdeContext
): CreateRegexMatchSetResponse => {
  return {
    __type: "CreateRegexMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    RegexMatchSet:
      output.RegexMatchSet !== undefined && output.RegexMatchSet !== null
        ? deserializeAws_json1_1RegexMatchSet(output.RegexMatchSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateRegexPatternSetResponse = (
  output: any,
  context: __SerdeContext
): CreateRegexPatternSetResponse => {
  return {
    __type: "CreateRegexPatternSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    RegexPatternSet:
      output.RegexPatternSet !== undefined && output.RegexPatternSet !== null
        ? deserializeAws_json1_1RegexPatternSet(output.RegexPatternSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateRuleGroupResponse = (
  output: any,
  context: __SerdeContext
): CreateRuleGroupResponse => {
  return {
    __type: "CreateRuleGroupResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    RuleGroup:
      output.RuleGroup !== undefined && output.RuleGroup !== null
        ? deserializeAws_json1_1RuleGroup(output.RuleGroup, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateRuleResponse = (output: any, context: __SerdeContext): CreateRuleResponse => {
  return {
    __type: "CreateRuleResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    Rule:
      output.Rule !== undefined && output.Rule !== null ? deserializeAws_json1_1Rule(output.Rule, context) : undefined,
  } as any;
};

const deserializeAws_json1_1CreateSizeConstraintSetResponse = (
  output: any,
  context: __SerdeContext
): CreateSizeConstraintSetResponse => {
  return {
    __type: "CreateSizeConstraintSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    SizeConstraintSet:
      output.SizeConstraintSet !== undefined && output.SizeConstraintSet !== null
        ? deserializeAws_json1_1SizeConstraintSet(output.SizeConstraintSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateSqlInjectionMatchSetResponse = (
  output: any,
  context: __SerdeContext
): CreateSqlInjectionMatchSetResponse => {
  return {
    __type: "CreateSqlInjectionMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    SqlInjectionMatchSet:
      output.SqlInjectionMatchSet !== undefined && output.SqlInjectionMatchSet !== null
        ? deserializeAws_json1_1SqlInjectionMatchSet(output.SqlInjectionMatchSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateWebACLResponse = (output: any, context: __SerdeContext): CreateWebACLResponse => {
  return {
    __type: "CreateWebACLResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    WebACL:
      output.WebACL !== undefined && output.WebACL !== null
        ? deserializeAws_json1_1WebACL(output.WebACL, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1CreateXssMatchSetResponse = (
  output: any,
  context: __SerdeContext
): CreateXssMatchSetResponse => {
  return {
    __type: "CreateXssMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
    XssMatchSet:
      output.XssMatchSet !== undefined && output.XssMatchSet !== null
        ? deserializeAws_json1_1XssMatchSet(output.XssMatchSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteByteMatchSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteByteMatchSetResponse => {
  return {
    __type: "DeleteByteMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteGeoMatchSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteGeoMatchSetResponse => {
  return {
    __type: "DeleteGeoMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteIPSetResponse = (output: any, context: __SerdeContext): DeleteIPSetResponse => {
  return {
    __type: "DeleteIPSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteLoggingConfigurationResponse = (
  output: any,
  context: __SerdeContext
): DeleteLoggingConfigurationResponse => {
  return {
    __type: "DeleteLoggingConfigurationResponse",
  } as any;
};

const deserializeAws_json1_1DeletePermissionPolicyResponse = (
  output: any,
  context: __SerdeContext
): DeletePermissionPolicyResponse => {
  return {
    __type: "DeletePermissionPolicyResponse",
  } as any;
};

const deserializeAws_json1_1DeleteRateBasedRuleResponse = (
  output: any,
  context: __SerdeContext
): DeleteRateBasedRuleResponse => {
  return {
    __type: "DeleteRateBasedRuleResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteRegexMatchSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteRegexMatchSetResponse => {
  return {
    __type: "DeleteRegexMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteRegexPatternSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteRegexPatternSetResponse => {
  return {
    __type: "DeleteRegexPatternSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteRuleGroupResponse = (
  output: any,
  context: __SerdeContext
): DeleteRuleGroupResponse => {
  return {
    __type: "DeleteRuleGroupResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteRuleResponse = (output: any, context: __SerdeContext): DeleteRuleResponse => {
  return {
    __type: "DeleteRuleResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteSizeConstraintSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteSizeConstraintSetResponse => {
  return {
    __type: "DeleteSizeConstraintSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteSqlInjectionMatchSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteSqlInjectionMatchSetResponse => {
  return {
    __type: "DeleteSqlInjectionMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteWebACLResponse = (output: any, context: __SerdeContext): DeleteWebACLResponse => {
  return {
    __type: "DeleteWebACLResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1DeleteXssMatchSetResponse = (
  output: any,
  context: __SerdeContext
): DeleteXssMatchSetResponse => {
  return {
    __type: "DeleteXssMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1ExcludedRule = (output: any, context: __SerdeContext): ExcludedRule => {
  return {
    __type: "ExcludedRule",
    RuleId: output.RuleId !== undefined && output.RuleId !== null ? output.RuleId : undefined,
  } as any;
};

const deserializeAws_json1_1ExcludedRules = (output: any, context: __SerdeContext): ExcludedRule[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1ExcludedRule(entry, context));
};

const deserializeAws_json1_1FieldToMatch = (output: any, context: __SerdeContext): FieldToMatch => {
  return {
    __type: "FieldToMatch",
    Data: output.Data !== undefined && output.Data !== null ? output.Data : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  } as any;
};

const deserializeAws_json1_1GeoMatchConstraint = (output: any, context: __SerdeContext): GeoMatchConstraint => {
  return {
    __type: "GeoMatchConstraint",
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
    Value: output.Value !== undefined && output.Value !== null ? output.Value : undefined,
  } as any;
};

const deserializeAws_json1_1GeoMatchConstraints = (output: any, context: __SerdeContext): GeoMatchConstraint[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1GeoMatchConstraint(entry, context));
};

const deserializeAws_json1_1GeoMatchSet = (output: any, context: __SerdeContext): GeoMatchSet => {
  return {
    __type: "GeoMatchSet",
    GeoMatchConstraints:
      output.GeoMatchConstraints !== undefined && output.GeoMatchConstraints !== null
        ? deserializeAws_json1_1GeoMatchConstraints(output.GeoMatchConstraints, context)
        : undefined,
    GeoMatchSetId:
      output.GeoMatchSetId !== undefined && output.GeoMatchSetId !== null ? output.GeoMatchSetId : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1GeoMatchSetSummaries = (output: any, context: __SerdeContext): GeoMatchSetSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1GeoMatchSetSummary(entry, context));
};

const deserializeAws_json1_1GeoMatchSetSummary = (output: any, context: __SerdeContext): GeoMatchSetSummary => {
  return {
    __type: "GeoMatchSetSummary",
    GeoMatchSetId:
      output.GeoMatchSetId !== undefined && output.GeoMatchSetId !== null ? output.GeoMatchSetId : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1GetByteMatchSetResponse = (
  output: any,
  context: __SerdeContext
): GetByteMatchSetResponse => {
  return {
    __type: "GetByteMatchSetResponse",
    ByteMatchSet:
      output.ByteMatchSet !== undefined && output.ByteMatchSet !== null
        ? deserializeAws_json1_1ByteMatchSet(output.ByteMatchSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetChangeTokenResponse = (output: any, context: __SerdeContext): GetChangeTokenResponse => {
  return {
    __type: "GetChangeTokenResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1GetChangeTokenStatusResponse = (
  output: any,
  context: __SerdeContext
): GetChangeTokenStatusResponse => {
  return {
    __type: "GetChangeTokenStatusResponse",
    ChangeTokenStatus:
      output.ChangeTokenStatus !== undefined && output.ChangeTokenStatus !== null
        ? output.ChangeTokenStatus
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetGeoMatchSetResponse = (output: any, context: __SerdeContext): GetGeoMatchSetResponse => {
  return {
    __type: "GetGeoMatchSetResponse",
    GeoMatchSet:
      output.GeoMatchSet !== undefined && output.GeoMatchSet !== null
        ? deserializeAws_json1_1GeoMatchSet(output.GeoMatchSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetIPSetResponse = (output: any, context: __SerdeContext): GetIPSetResponse => {
  return {
    __type: "GetIPSetResponse",
    IPSet:
      output.IPSet !== undefined && output.IPSet !== null
        ? deserializeAws_json1_1IPSet(output.IPSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetLoggingConfigurationResponse = (
  output: any,
  context: __SerdeContext
): GetLoggingConfigurationResponse => {
  return {
    __type: "GetLoggingConfigurationResponse",
    LoggingConfiguration:
      output.LoggingConfiguration !== undefined && output.LoggingConfiguration !== null
        ? deserializeAws_json1_1LoggingConfiguration(output.LoggingConfiguration, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetPermissionPolicyResponse = (
  output: any,
  context: __SerdeContext
): GetPermissionPolicyResponse => {
  return {
    __type: "GetPermissionPolicyResponse",
    Policy: output.Policy !== undefined && output.Policy !== null ? output.Policy : undefined,
  } as any;
};

const deserializeAws_json1_1GetRateBasedRuleManagedKeysResponse = (
  output: any,
  context: __SerdeContext
): GetRateBasedRuleManagedKeysResponse => {
  return {
    __type: "GetRateBasedRuleManagedKeysResponse",
    ManagedKeys:
      output.ManagedKeys !== undefined && output.ManagedKeys !== null
        ? deserializeAws_json1_1ManagedKeys(output.ManagedKeys, context)
        : undefined,
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
  } as any;
};

const deserializeAws_json1_1GetRateBasedRuleResponse = (
  output: any,
  context: __SerdeContext
): GetRateBasedRuleResponse => {
  return {
    __type: "GetRateBasedRuleResponse",
    Rule:
      output.Rule !== undefined && output.Rule !== null
        ? deserializeAws_json1_1RateBasedRule(output.Rule, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetRegexMatchSetResponse = (
  output: any,
  context: __SerdeContext
): GetRegexMatchSetResponse => {
  return {
    __type: "GetRegexMatchSetResponse",
    RegexMatchSet:
      output.RegexMatchSet !== undefined && output.RegexMatchSet !== null
        ? deserializeAws_json1_1RegexMatchSet(output.RegexMatchSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetRegexPatternSetResponse = (
  output: any,
  context: __SerdeContext
): GetRegexPatternSetResponse => {
  return {
    __type: "GetRegexPatternSetResponse",
    RegexPatternSet:
      output.RegexPatternSet !== undefined && output.RegexPatternSet !== null
        ? deserializeAws_json1_1RegexPatternSet(output.RegexPatternSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetRuleGroupResponse = (output: any, context: __SerdeContext): GetRuleGroupResponse => {
  return {
    __type: "GetRuleGroupResponse",
    RuleGroup:
      output.RuleGroup !== undefined && output.RuleGroup !== null
        ? deserializeAws_json1_1RuleGroup(output.RuleGroup, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetRuleResponse = (output: any, context: __SerdeContext): GetRuleResponse => {
  return {
    __type: "GetRuleResponse",
    Rule:
      output.Rule !== undefined && output.Rule !== null ? deserializeAws_json1_1Rule(output.Rule, context) : undefined,
  } as any;
};

const deserializeAws_json1_1GetSampledRequestsResponse = (
  output: any,
  context: __SerdeContext
): GetSampledRequestsResponse => {
  return {
    __type: "GetSampledRequestsResponse",
    PopulationSize:
      output.PopulationSize !== undefined && output.PopulationSize !== null ? output.PopulationSize : undefined,
    SampledRequests:
      output.SampledRequests !== undefined && output.SampledRequests !== null
        ? deserializeAws_json1_1SampledHTTPRequests(output.SampledRequests, context)
        : undefined,
    TimeWindow:
      output.TimeWindow !== undefined && output.TimeWindow !== null
        ? deserializeAws_json1_1TimeWindow(output.TimeWindow, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetSizeConstraintSetResponse = (
  output: any,
  context: __SerdeContext
): GetSizeConstraintSetResponse => {
  return {
    __type: "GetSizeConstraintSetResponse",
    SizeConstraintSet:
      output.SizeConstraintSet !== undefined && output.SizeConstraintSet !== null
        ? deserializeAws_json1_1SizeConstraintSet(output.SizeConstraintSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetSqlInjectionMatchSetResponse = (
  output: any,
  context: __SerdeContext
): GetSqlInjectionMatchSetResponse => {
  return {
    __type: "GetSqlInjectionMatchSetResponse",
    SqlInjectionMatchSet:
      output.SqlInjectionMatchSet !== undefined && output.SqlInjectionMatchSet !== null
        ? deserializeAws_json1_1SqlInjectionMatchSet(output.SqlInjectionMatchSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetWebACLResponse = (output: any, context: __SerdeContext): GetWebACLResponse => {
  return {
    __type: "GetWebACLResponse",
    WebACL:
      output.WebACL !== undefined && output.WebACL !== null
        ? deserializeAws_json1_1WebACL(output.WebACL, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1GetXssMatchSetResponse = (output: any, context: __SerdeContext): GetXssMatchSetResponse => {
  return {
    __type: "GetXssMatchSetResponse",
    XssMatchSet:
      output.XssMatchSet !== undefined && output.XssMatchSet !== null
        ? deserializeAws_json1_1XssMatchSet(output.XssMatchSet, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1HTTPHeader = (output: any, context: __SerdeContext): HTTPHeader => {
  return {
    __type: "HTTPHeader",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Value: output.Value !== undefined && output.Value !== null ? output.Value : undefined,
  } as any;
};

const deserializeAws_json1_1HTTPHeaders = (output: any, context: __SerdeContext): HTTPHeader[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1HTTPHeader(entry, context));
};

const deserializeAws_json1_1HTTPRequest = (output: any, context: __SerdeContext): HTTPRequest => {
  return {
    __type: "HTTPRequest",
    ClientIP: output.ClientIP !== undefined && output.ClientIP !== null ? output.ClientIP : undefined,
    Country: output.Country !== undefined && output.Country !== null ? output.Country : undefined,
    HTTPVersion: output.HTTPVersion !== undefined && output.HTTPVersion !== null ? output.HTTPVersion : undefined,
    Headers:
      output.Headers !== undefined && output.Headers !== null
        ? deserializeAws_json1_1HTTPHeaders(output.Headers, context)
        : undefined,
    Method: output.Method !== undefined && output.Method !== null ? output.Method : undefined,
    URI: output.URI !== undefined && output.URI !== null ? output.URI : undefined,
  } as any;
};

const deserializeAws_json1_1IPSet = (output: any, context: __SerdeContext): IPSet => {
  return {
    __type: "IPSet",
    IPSetDescriptors:
      output.IPSetDescriptors !== undefined && output.IPSetDescriptors !== null
        ? deserializeAws_json1_1IPSetDescriptors(output.IPSetDescriptors, context)
        : undefined,
    IPSetId: output.IPSetId !== undefined && output.IPSetId !== null ? output.IPSetId : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1IPSetDescriptor = (output: any, context: __SerdeContext): IPSetDescriptor => {
  return {
    __type: "IPSetDescriptor",
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
    Value: output.Value !== undefined && output.Value !== null ? output.Value : undefined,
  } as any;
};

const deserializeAws_json1_1IPSetDescriptors = (output: any, context: __SerdeContext): IPSetDescriptor[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1IPSetDescriptor(entry, context));
};

const deserializeAws_json1_1IPSetSummaries = (output: any, context: __SerdeContext): IPSetSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1IPSetSummary(entry, context));
};

const deserializeAws_json1_1IPSetSummary = (output: any, context: __SerdeContext): IPSetSummary => {
  return {
    __type: "IPSetSummary",
    IPSetId: output.IPSetId !== undefined && output.IPSetId !== null ? output.IPSetId : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
  } as any;
};

const deserializeAws_json1_1ListActivatedRulesInRuleGroupResponse = (
  output: any,
  context: __SerdeContext
): ListActivatedRulesInRuleGroupResponse => {
  return {
    __type: "ListActivatedRulesInRuleGroupResponse",
    ActivatedRules:
      output.ActivatedRules !== undefined && output.ActivatedRules !== null
        ? deserializeAws_json1_1ActivatedRules(output.ActivatedRules, context)
        : undefined,
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
  } as any;
};

const deserializeAws_json1_1ListByteMatchSetsResponse = (
  output: any,
  context: __SerdeContext
): ListByteMatchSetsResponse => {
  return {
    __type: "ListByteMatchSetsResponse",
    ByteMatchSets:
      output.ByteMatchSets !== undefined && output.ByteMatchSets !== null
        ? deserializeAws_json1_1ByteMatchSetSummaries(output.ByteMatchSets, context)
        : undefined,
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
  } as any;
};

const deserializeAws_json1_1ListGeoMatchSetsResponse = (
  output: any,
  context: __SerdeContext
): ListGeoMatchSetsResponse => {
  return {
    __type: "ListGeoMatchSetsResponse",
    GeoMatchSets:
      output.GeoMatchSets !== undefined && output.GeoMatchSets !== null
        ? deserializeAws_json1_1GeoMatchSetSummaries(output.GeoMatchSets, context)
        : undefined,
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
  } as any;
};

const deserializeAws_json1_1ListIPSetsResponse = (output: any, context: __SerdeContext): ListIPSetsResponse => {
  return {
    __type: "ListIPSetsResponse",
    IPSets:
      output.IPSets !== undefined && output.IPSets !== null
        ? deserializeAws_json1_1IPSetSummaries(output.IPSets, context)
        : undefined,
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
  } as any;
};

const deserializeAws_json1_1ListLoggingConfigurationsResponse = (
  output: any,
  context: __SerdeContext
): ListLoggingConfigurationsResponse => {
  return {
    __type: "ListLoggingConfigurationsResponse",
    LoggingConfigurations:
      output.LoggingConfigurations !== undefined && output.LoggingConfigurations !== null
        ? deserializeAws_json1_1LoggingConfigurations(output.LoggingConfigurations, context)
        : undefined,
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
  } as any;
};

const deserializeAws_json1_1ListRateBasedRulesResponse = (
  output: any,
  context: __SerdeContext
): ListRateBasedRulesResponse => {
  return {
    __type: "ListRateBasedRulesResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    Rules:
      output.Rules !== undefined && output.Rules !== null
        ? deserializeAws_json1_1RuleSummaries(output.Rules, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListRegexMatchSetsResponse = (
  output: any,
  context: __SerdeContext
): ListRegexMatchSetsResponse => {
  return {
    __type: "ListRegexMatchSetsResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    RegexMatchSets:
      output.RegexMatchSets !== undefined && output.RegexMatchSets !== null
        ? deserializeAws_json1_1RegexMatchSetSummaries(output.RegexMatchSets, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListRegexPatternSetsResponse = (
  output: any,
  context: __SerdeContext
): ListRegexPatternSetsResponse => {
  return {
    __type: "ListRegexPatternSetsResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    RegexPatternSets:
      output.RegexPatternSets !== undefined && output.RegexPatternSets !== null
        ? deserializeAws_json1_1RegexPatternSetSummaries(output.RegexPatternSets, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListRuleGroupsResponse = (output: any, context: __SerdeContext): ListRuleGroupsResponse => {
  return {
    __type: "ListRuleGroupsResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    RuleGroups:
      output.RuleGroups !== undefined && output.RuleGroups !== null
        ? deserializeAws_json1_1RuleGroupSummaries(output.RuleGroups, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListRulesResponse = (output: any, context: __SerdeContext): ListRulesResponse => {
  return {
    __type: "ListRulesResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    Rules:
      output.Rules !== undefined && output.Rules !== null
        ? deserializeAws_json1_1RuleSummaries(output.Rules, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListSizeConstraintSetsResponse = (
  output: any,
  context: __SerdeContext
): ListSizeConstraintSetsResponse => {
  return {
    __type: "ListSizeConstraintSetsResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    SizeConstraintSets:
      output.SizeConstraintSets !== undefined && output.SizeConstraintSets !== null
        ? deserializeAws_json1_1SizeConstraintSetSummaries(output.SizeConstraintSets, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListSqlInjectionMatchSetsResponse = (
  output: any,
  context: __SerdeContext
): ListSqlInjectionMatchSetsResponse => {
  return {
    __type: "ListSqlInjectionMatchSetsResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    SqlInjectionMatchSets:
      output.SqlInjectionMatchSets !== undefined && output.SqlInjectionMatchSets !== null
        ? deserializeAws_json1_1SqlInjectionMatchSetSummaries(output.SqlInjectionMatchSets, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListSubscribedRuleGroupsResponse = (
  output: any,
  context: __SerdeContext
): ListSubscribedRuleGroupsResponse => {
  return {
    __type: "ListSubscribedRuleGroupsResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    RuleGroups:
      output.RuleGroups !== undefined && output.RuleGroups !== null
        ? deserializeAws_json1_1SubscribedRuleGroupSummaries(output.RuleGroups, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListTagsForResourceResponse = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceResponse => {
  return {
    __type: "ListTagsForResourceResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    TagInfoForResource:
      output.TagInfoForResource !== undefined && output.TagInfoForResource !== null
        ? deserializeAws_json1_1TagInfoForResource(output.TagInfoForResource, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListWebACLsResponse = (output: any, context: __SerdeContext): ListWebACLsResponse => {
  return {
    __type: "ListWebACLsResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    WebACLs:
      output.WebACLs !== undefined && output.WebACLs !== null
        ? deserializeAws_json1_1WebACLSummaries(output.WebACLs, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1ListXssMatchSetsResponse = (
  output: any,
  context: __SerdeContext
): ListXssMatchSetsResponse => {
  return {
    __type: "ListXssMatchSetsResponse",
    NextMarker: output.NextMarker !== undefined && output.NextMarker !== null ? output.NextMarker : undefined,
    XssMatchSets:
      output.XssMatchSets !== undefined && output.XssMatchSets !== null
        ? deserializeAws_json1_1XssMatchSetSummaries(output.XssMatchSets, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1LogDestinationConfigs = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1LoggingConfiguration = (output: any, context: __SerdeContext): LoggingConfiguration => {
  return {
    __type: "LoggingConfiguration",
    LogDestinationConfigs:
      output.LogDestinationConfigs !== undefined && output.LogDestinationConfigs !== null
        ? deserializeAws_json1_1LogDestinationConfigs(output.LogDestinationConfigs, context)
        : undefined,
    RedactedFields:
      output.RedactedFields !== undefined && output.RedactedFields !== null
        ? deserializeAws_json1_1RedactedFields(output.RedactedFields, context)
        : undefined,
    ResourceArn: output.ResourceArn !== undefined && output.ResourceArn !== null ? output.ResourceArn : undefined,
  } as any;
};

const deserializeAws_json1_1LoggingConfigurations = (output: any, context: __SerdeContext): LoggingConfiguration[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1LoggingConfiguration(entry, context));
};

const deserializeAws_json1_1ManagedKeys = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Predicate = (output: any, context: __SerdeContext): Predicate => {
  return {
    __type: "Predicate",
    DataId: output.DataId !== undefined && output.DataId !== null ? output.DataId : undefined,
    Negated: output.Negated !== undefined && output.Negated !== null ? output.Negated : undefined,
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  } as any;
};

const deserializeAws_json1_1Predicates = (output: any, context: __SerdeContext): Predicate[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Predicate(entry, context));
};

const deserializeAws_json1_1PutLoggingConfigurationResponse = (
  output: any,
  context: __SerdeContext
): PutLoggingConfigurationResponse => {
  return {
    __type: "PutLoggingConfigurationResponse",
    LoggingConfiguration:
      output.LoggingConfiguration !== undefined && output.LoggingConfiguration !== null
        ? deserializeAws_json1_1LoggingConfiguration(output.LoggingConfiguration, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1PutPermissionPolicyResponse = (
  output: any,
  context: __SerdeContext
): PutPermissionPolicyResponse => {
  return {
    __type: "PutPermissionPolicyResponse",
  } as any;
};

const deserializeAws_json1_1RateBasedRule = (output: any, context: __SerdeContext): RateBasedRule => {
  return {
    __type: "RateBasedRule",
    MatchPredicates:
      output.MatchPredicates !== undefined && output.MatchPredicates !== null
        ? deserializeAws_json1_1Predicates(output.MatchPredicates, context)
        : undefined,
    MetricName: output.MetricName !== undefined && output.MetricName !== null ? output.MetricName : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RateKey: output.RateKey !== undefined && output.RateKey !== null ? output.RateKey : undefined,
    RateLimit: output.RateLimit !== undefined && output.RateLimit !== null ? output.RateLimit : undefined,
    RuleId: output.RuleId !== undefined && output.RuleId !== null ? output.RuleId : undefined,
  } as any;
};

const deserializeAws_json1_1RedactedFields = (output: any, context: __SerdeContext): FieldToMatch[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1FieldToMatch(entry, context));
};

const deserializeAws_json1_1RegexMatchSet = (output: any, context: __SerdeContext): RegexMatchSet => {
  return {
    __type: "RegexMatchSet",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RegexMatchSetId:
      output.RegexMatchSetId !== undefined && output.RegexMatchSetId !== null ? output.RegexMatchSetId : undefined,
    RegexMatchTuples:
      output.RegexMatchTuples !== undefined && output.RegexMatchTuples !== null
        ? deserializeAws_json1_1RegexMatchTuples(output.RegexMatchTuples, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1RegexMatchSetSummaries = (output: any, context: __SerdeContext): RegexMatchSetSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1RegexMatchSetSummary(entry, context));
};

const deserializeAws_json1_1RegexMatchSetSummary = (output: any, context: __SerdeContext): RegexMatchSetSummary => {
  return {
    __type: "RegexMatchSetSummary",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RegexMatchSetId:
      output.RegexMatchSetId !== undefined && output.RegexMatchSetId !== null ? output.RegexMatchSetId : undefined,
  } as any;
};

const deserializeAws_json1_1RegexMatchTuple = (output: any, context: __SerdeContext): RegexMatchTuple => {
  return {
    __type: "RegexMatchTuple",
    FieldToMatch:
      output.FieldToMatch !== undefined && output.FieldToMatch !== null
        ? deserializeAws_json1_1FieldToMatch(output.FieldToMatch, context)
        : undefined,
    RegexPatternSetId:
      output.RegexPatternSetId !== undefined && output.RegexPatternSetId !== null
        ? output.RegexPatternSetId
        : undefined,
    TextTransformation:
      output.TextTransformation !== undefined && output.TextTransformation !== null
        ? output.TextTransformation
        : undefined,
  } as any;
};

const deserializeAws_json1_1RegexMatchTuples = (output: any, context: __SerdeContext): RegexMatchTuple[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1RegexMatchTuple(entry, context));
};

const deserializeAws_json1_1RegexPatternSet = (output: any, context: __SerdeContext): RegexPatternSet => {
  return {
    __type: "RegexPatternSet",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RegexPatternSetId:
      output.RegexPatternSetId !== undefined && output.RegexPatternSetId !== null
        ? output.RegexPatternSetId
        : undefined,
    RegexPatternStrings:
      output.RegexPatternStrings !== undefined && output.RegexPatternStrings !== null
        ? deserializeAws_json1_1RegexPatternStrings(output.RegexPatternStrings, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1RegexPatternSetSummaries = (
  output: any,
  context: __SerdeContext
): RegexPatternSetSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1RegexPatternSetSummary(entry, context));
};

const deserializeAws_json1_1RegexPatternSetSummary = (output: any, context: __SerdeContext): RegexPatternSetSummary => {
  return {
    __type: "RegexPatternSetSummary",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RegexPatternSetId:
      output.RegexPatternSetId !== undefined && output.RegexPatternSetId !== null
        ? output.RegexPatternSetId
        : undefined,
  } as any;
};

const deserializeAws_json1_1RegexPatternStrings = (output: any, context: __SerdeContext): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Rule = (output: any, context: __SerdeContext): Rule => {
  return {
    __type: "Rule",
    MetricName: output.MetricName !== undefined && output.MetricName !== null ? output.MetricName : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Predicates:
      output.Predicates !== undefined && output.Predicates !== null
        ? deserializeAws_json1_1Predicates(output.Predicates, context)
        : undefined,
    RuleId: output.RuleId !== undefined && output.RuleId !== null ? output.RuleId : undefined,
  } as any;
};

const deserializeAws_json1_1RuleGroup = (output: any, context: __SerdeContext): RuleGroup => {
  return {
    __type: "RuleGroup",
    MetricName: output.MetricName !== undefined && output.MetricName !== null ? output.MetricName : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RuleGroupId: output.RuleGroupId !== undefined && output.RuleGroupId !== null ? output.RuleGroupId : undefined,
  } as any;
};

const deserializeAws_json1_1RuleGroupSummaries = (output: any, context: __SerdeContext): RuleGroupSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1RuleGroupSummary(entry, context));
};

const deserializeAws_json1_1RuleGroupSummary = (output: any, context: __SerdeContext): RuleGroupSummary => {
  return {
    __type: "RuleGroupSummary",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RuleGroupId: output.RuleGroupId !== undefined && output.RuleGroupId !== null ? output.RuleGroupId : undefined,
  } as any;
};

const deserializeAws_json1_1RuleSummaries = (output: any, context: __SerdeContext): RuleSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1RuleSummary(entry, context));
};

const deserializeAws_json1_1RuleSummary = (output: any, context: __SerdeContext): RuleSummary => {
  return {
    __type: "RuleSummary",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RuleId: output.RuleId !== undefined && output.RuleId !== null ? output.RuleId : undefined,
  } as any;
};

const deserializeAws_json1_1SampledHTTPRequest = (output: any, context: __SerdeContext): SampledHTTPRequest => {
  return {
    __type: "SampledHTTPRequest",
    Action: output.Action !== undefined && output.Action !== null ? output.Action : undefined,
    Request:
      output.Request !== undefined && output.Request !== null
        ? deserializeAws_json1_1HTTPRequest(output.Request, context)
        : undefined,
    RuleWithinRuleGroup:
      output.RuleWithinRuleGroup !== undefined && output.RuleWithinRuleGroup !== null
        ? output.RuleWithinRuleGroup
        : undefined,
    Timestamp:
      output.Timestamp !== undefined && output.Timestamp !== null
        ? new Date(Math.round(output.Timestamp * 1000))
        : undefined,
    Weight: output.Weight !== undefined && output.Weight !== null ? output.Weight : undefined,
  } as any;
};

const deserializeAws_json1_1SampledHTTPRequests = (output: any, context: __SerdeContext): SampledHTTPRequest[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1SampledHTTPRequest(entry, context));
};

const deserializeAws_json1_1SizeConstraint = (output: any, context: __SerdeContext): SizeConstraint => {
  return {
    __type: "SizeConstraint",
    ComparisonOperator:
      output.ComparisonOperator !== undefined && output.ComparisonOperator !== null
        ? output.ComparisonOperator
        : undefined,
    FieldToMatch:
      output.FieldToMatch !== undefined && output.FieldToMatch !== null
        ? deserializeAws_json1_1FieldToMatch(output.FieldToMatch, context)
        : undefined,
    Size: output.Size !== undefined && output.Size !== null ? output.Size : undefined,
    TextTransformation:
      output.TextTransformation !== undefined && output.TextTransformation !== null
        ? output.TextTransformation
        : undefined,
  } as any;
};

const deserializeAws_json1_1SizeConstraints = (output: any, context: __SerdeContext): SizeConstraint[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1SizeConstraint(entry, context));
};

const deserializeAws_json1_1SizeConstraintSet = (output: any, context: __SerdeContext): SizeConstraintSet => {
  return {
    __type: "SizeConstraintSet",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    SizeConstraintSetId:
      output.SizeConstraintSetId !== undefined && output.SizeConstraintSetId !== null
        ? output.SizeConstraintSetId
        : undefined,
    SizeConstraints:
      output.SizeConstraints !== undefined && output.SizeConstraints !== null
        ? deserializeAws_json1_1SizeConstraints(output.SizeConstraints, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1SizeConstraintSetSummaries = (
  output: any,
  context: __SerdeContext
): SizeConstraintSetSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1SizeConstraintSetSummary(entry, context));
};

const deserializeAws_json1_1SizeConstraintSetSummary = (
  output: any,
  context: __SerdeContext
): SizeConstraintSetSummary => {
  return {
    __type: "SizeConstraintSetSummary",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    SizeConstraintSetId:
      output.SizeConstraintSetId !== undefined && output.SizeConstraintSetId !== null
        ? output.SizeConstraintSetId
        : undefined,
  } as any;
};

const deserializeAws_json1_1SqlInjectionMatchSet = (output: any, context: __SerdeContext): SqlInjectionMatchSet => {
  return {
    __type: "SqlInjectionMatchSet",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    SqlInjectionMatchSetId:
      output.SqlInjectionMatchSetId !== undefined && output.SqlInjectionMatchSetId !== null
        ? output.SqlInjectionMatchSetId
        : undefined,
    SqlInjectionMatchTuples:
      output.SqlInjectionMatchTuples !== undefined && output.SqlInjectionMatchTuples !== null
        ? deserializeAws_json1_1SqlInjectionMatchTuples(output.SqlInjectionMatchTuples, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1SqlInjectionMatchSetSummaries = (
  output: any,
  context: __SerdeContext
): SqlInjectionMatchSetSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1SqlInjectionMatchSetSummary(entry, context));
};

const deserializeAws_json1_1SqlInjectionMatchSetSummary = (
  output: any,
  context: __SerdeContext
): SqlInjectionMatchSetSummary => {
  return {
    __type: "SqlInjectionMatchSetSummary",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    SqlInjectionMatchSetId:
      output.SqlInjectionMatchSetId !== undefined && output.SqlInjectionMatchSetId !== null
        ? output.SqlInjectionMatchSetId
        : undefined,
  } as any;
};

const deserializeAws_json1_1SqlInjectionMatchTuple = (output: any, context: __SerdeContext): SqlInjectionMatchTuple => {
  return {
    __type: "SqlInjectionMatchTuple",
    FieldToMatch:
      output.FieldToMatch !== undefined && output.FieldToMatch !== null
        ? deserializeAws_json1_1FieldToMatch(output.FieldToMatch, context)
        : undefined,
    TextTransformation:
      output.TextTransformation !== undefined && output.TextTransformation !== null
        ? output.TextTransformation
        : undefined,
  } as any;
};

const deserializeAws_json1_1SqlInjectionMatchTuples = (
  output: any,
  context: __SerdeContext
): SqlInjectionMatchTuple[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1SqlInjectionMatchTuple(entry, context));
};

const deserializeAws_json1_1SubscribedRuleGroupSummaries = (
  output: any,
  context: __SerdeContext
): SubscribedRuleGroupSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1SubscribedRuleGroupSummary(entry, context));
};

const deserializeAws_json1_1SubscribedRuleGroupSummary = (
  output: any,
  context: __SerdeContext
): SubscribedRuleGroupSummary => {
  return {
    __type: "SubscribedRuleGroupSummary",
    MetricName: output.MetricName !== undefined && output.MetricName !== null ? output.MetricName : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    RuleGroupId: output.RuleGroupId !== undefined && output.RuleGroupId !== null ? output.RuleGroupId : undefined,
  } as any;
};

const deserializeAws_json1_1Tag = (output: any, context: __SerdeContext): Tag => {
  return {
    __type: "Tag",
    Key: output.Key !== undefined && output.Key !== null ? output.Key : undefined,
    Value: output.Value !== undefined && output.Value !== null ? output.Value : undefined,
  } as any;
};

const deserializeAws_json1_1TagInfoForResource = (output: any, context: __SerdeContext): TagInfoForResource => {
  return {
    __type: "TagInfoForResource",
    ResourceARN: output.ResourceARN !== undefined && output.ResourceARN !== null ? output.ResourceARN : undefined,
    TagList:
      output.TagList !== undefined && output.TagList !== null
        ? deserializeAws_json1_1TagList(output.TagList, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1TagList = (output: any, context: __SerdeContext): Tag[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1Tag(entry, context));
};

const deserializeAws_json1_1TagResourceResponse = (output: any, context: __SerdeContext): TagResourceResponse => {
  return {
    __type: "TagResourceResponse",
  } as any;
};

const deserializeAws_json1_1TimeWindow = (output: any, context: __SerdeContext): TimeWindow => {
  return {
    __type: "TimeWindow",
    EndTime:
      output.EndTime !== undefined && output.EndTime !== null ? new Date(Math.round(output.EndTime * 1000)) : undefined,
    StartTime:
      output.StartTime !== undefined && output.StartTime !== null
        ? new Date(Math.round(output.StartTime * 1000))
        : undefined,
  } as any;
};

const deserializeAws_json1_1UntagResourceResponse = (output: any, context: __SerdeContext): UntagResourceResponse => {
  return {
    __type: "UntagResourceResponse",
  } as any;
};

const deserializeAws_json1_1UpdateByteMatchSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateByteMatchSetResponse => {
  return {
    __type: "UpdateByteMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateGeoMatchSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateGeoMatchSetResponse => {
  return {
    __type: "UpdateGeoMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateIPSetResponse = (output: any, context: __SerdeContext): UpdateIPSetResponse => {
  return {
    __type: "UpdateIPSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateRateBasedRuleResponse = (
  output: any,
  context: __SerdeContext
): UpdateRateBasedRuleResponse => {
  return {
    __type: "UpdateRateBasedRuleResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateRegexMatchSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateRegexMatchSetResponse => {
  return {
    __type: "UpdateRegexMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateRegexPatternSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateRegexPatternSetResponse => {
  return {
    __type: "UpdateRegexPatternSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateRuleGroupResponse = (
  output: any,
  context: __SerdeContext
): UpdateRuleGroupResponse => {
  return {
    __type: "UpdateRuleGroupResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateRuleResponse = (output: any, context: __SerdeContext): UpdateRuleResponse => {
  return {
    __type: "UpdateRuleResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateSizeConstraintSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateSizeConstraintSetResponse => {
  return {
    __type: "UpdateSizeConstraintSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateSqlInjectionMatchSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateSqlInjectionMatchSetResponse => {
  return {
    __type: "UpdateSqlInjectionMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateWebACLResponse = (output: any, context: __SerdeContext): UpdateWebACLResponse => {
  return {
    __type: "UpdateWebACLResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1UpdateXssMatchSetResponse = (
  output: any,
  context: __SerdeContext
): UpdateXssMatchSetResponse => {
  return {
    __type: "UpdateXssMatchSetResponse",
    ChangeToken: output.ChangeToken !== undefined && output.ChangeToken !== null ? output.ChangeToken : undefined,
  } as any;
};

const deserializeAws_json1_1WafAction = (output: any, context: __SerdeContext): WafAction => {
  return {
    __type: "WafAction",
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  } as any;
};

const deserializeAws_json1_1WAFBadRequestException = (output: any, context: __SerdeContext): WAFBadRequestException => {
  return {
    __type: "WAFBadRequestException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFDisallowedNameException = (
  output: any,
  context: __SerdeContext
): WAFDisallowedNameException => {
  return {
    __type: "WAFDisallowedNameException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFInternalErrorException = (
  output: any,
  context: __SerdeContext
): WAFInternalErrorException => {
  return {
    __type: "WAFInternalErrorException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFInvalidAccountException = (
  output: any,
  context: __SerdeContext
): WAFInvalidAccountException => {
  return {
    __type: "WAFInvalidAccountException",
  } as any;
};

const deserializeAws_json1_1WAFInvalidOperationException = (
  output: any,
  context: __SerdeContext
): WAFInvalidOperationException => {
  return {
    __type: "WAFInvalidOperationException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFInvalidParameterException = (
  output: any,
  context: __SerdeContext
): WAFInvalidParameterException => {
  return {
    __type: "WAFInvalidParameterException",
    field: output.field !== undefined && output.field !== null ? output.field : undefined,
    parameter: output.parameter !== undefined && output.parameter !== null ? output.parameter : undefined,
    reason: output.reason !== undefined && output.reason !== null ? output.reason : undefined,
  } as any;
};

const deserializeAws_json1_1WAFInvalidPermissionPolicyException = (
  output: any,
  context: __SerdeContext
): WAFInvalidPermissionPolicyException => {
  return {
    __type: "WAFInvalidPermissionPolicyException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFInvalidRegexPatternException = (
  output: any,
  context: __SerdeContext
): WAFInvalidRegexPatternException => {
  return {
    __type: "WAFInvalidRegexPatternException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFLimitsExceededException = (
  output: any,
  context: __SerdeContext
): WAFLimitsExceededException => {
  return {
    __type: "WAFLimitsExceededException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFNonEmptyEntityException = (
  output: any,
  context: __SerdeContext
): WAFNonEmptyEntityException => {
  return {
    __type: "WAFNonEmptyEntityException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFNonexistentContainerException = (
  output: any,
  context: __SerdeContext
): WAFNonexistentContainerException => {
  return {
    __type: "WAFNonexistentContainerException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFNonexistentItemException = (
  output: any,
  context: __SerdeContext
): WAFNonexistentItemException => {
  return {
    __type: "WAFNonexistentItemException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WafOverrideAction = (output: any, context: __SerdeContext): WafOverrideAction => {
  return {
    __type: "WafOverrideAction",
    Type: output.Type !== undefined && output.Type !== null ? output.Type : undefined,
  } as any;
};

const deserializeAws_json1_1WAFReferencedItemException = (
  output: any,
  context: __SerdeContext
): WAFReferencedItemException => {
  return {
    __type: "WAFReferencedItemException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFServiceLinkedRoleErrorException = (
  output: any,
  context: __SerdeContext
): WAFServiceLinkedRoleErrorException => {
  return {
    __type: "WAFServiceLinkedRoleErrorException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFStaleDataException = (output: any, context: __SerdeContext): WAFStaleDataException => {
  return {
    __type: "WAFStaleDataException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFSubscriptionNotFoundException = (
  output: any,
  context: __SerdeContext
): WAFSubscriptionNotFoundException => {
  return {
    __type: "WAFSubscriptionNotFoundException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFTagOperationException = (
  output: any,
  context: __SerdeContext
): WAFTagOperationException => {
  return {
    __type: "WAFTagOperationException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WAFTagOperationInternalErrorException = (
  output: any,
  context: __SerdeContext
): WAFTagOperationInternalErrorException => {
  return {
    __type: "WAFTagOperationInternalErrorException",
    message: output.message !== undefined && output.message !== null ? output.message : undefined,
  } as any;
};

const deserializeAws_json1_1WebACL = (output: any, context: __SerdeContext): WebACL => {
  return {
    __type: "WebACL",
    DefaultAction:
      output.DefaultAction !== undefined && output.DefaultAction !== null
        ? deserializeAws_json1_1WafAction(output.DefaultAction, context)
        : undefined,
    MetricName: output.MetricName !== undefined && output.MetricName !== null ? output.MetricName : undefined,
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    Rules:
      output.Rules !== undefined && output.Rules !== null
        ? deserializeAws_json1_1ActivatedRules(output.Rules, context)
        : undefined,
    WebACLArn: output.WebACLArn !== undefined && output.WebACLArn !== null ? output.WebACLArn : undefined,
    WebACLId: output.WebACLId !== undefined && output.WebACLId !== null ? output.WebACLId : undefined,
  } as any;
};

const deserializeAws_json1_1WebACLSummaries = (output: any, context: __SerdeContext): WebACLSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1WebACLSummary(entry, context));
};

const deserializeAws_json1_1WebACLSummary = (output: any, context: __SerdeContext): WebACLSummary => {
  return {
    __type: "WebACLSummary",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    WebACLId: output.WebACLId !== undefined && output.WebACLId !== null ? output.WebACLId : undefined,
  } as any;
};

const deserializeAws_json1_1XssMatchSet = (output: any, context: __SerdeContext): XssMatchSet => {
  return {
    __type: "XssMatchSet",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    XssMatchSetId:
      output.XssMatchSetId !== undefined && output.XssMatchSetId !== null ? output.XssMatchSetId : undefined,
    XssMatchTuples:
      output.XssMatchTuples !== undefined && output.XssMatchTuples !== null
        ? deserializeAws_json1_1XssMatchTuples(output.XssMatchTuples, context)
        : undefined,
  } as any;
};

const deserializeAws_json1_1XssMatchSetSummaries = (output: any, context: __SerdeContext): XssMatchSetSummary[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1XssMatchSetSummary(entry, context));
};

const deserializeAws_json1_1XssMatchSetSummary = (output: any, context: __SerdeContext): XssMatchSetSummary => {
  return {
    __type: "XssMatchSetSummary",
    Name: output.Name !== undefined && output.Name !== null ? output.Name : undefined,
    XssMatchSetId:
      output.XssMatchSetId !== undefined && output.XssMatchSetId !== null ? output.XssMatchSetId : undefined,
  } as any;
};

const deserializeAws_json1_1XssMatchTuple = (output: any, context: __SerdeContext): XssMatchTuple => {
  return {
    __type: "XssMatchTuple",
    FieldToMatch:
      output.FieldToMatch !== undefined && output.FieldToMatch !== null
        ? deserializeAws_json1_1FieldToMatch(output.FieldToMatch, context)
        : undefined,
    TextTransformation:
      output.TextTransformation !== undefined && output.TextTransformation !== null
        ? output.TextTransformation
        : undefined,
  } as any;
};

const deserializeAws_json1_1XssMatchTuples = (output: any, context: __SerdeContext): XssMatchTuple[] => {
  return (output || []).map((entry: any) => deserializeAws_json1_1XssMatchTuple(entry, context));
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"],
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody: any = new Uint8Array(), context: __SerdeContext): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody: any, context: __SerdeContext): Promise<string> =>
  collectBody(streamBody, context).then((body) => context.utf8Encoder(body));

const buildHttpRpcRequest = async (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port } = await context.endpoint();
  const contents: any = {
    protocol,
    hostname,
    port,
    method: "POST",
    path,
    headers,
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
