import {
  AssignInstanceCommandInput,
  AssignInstanceCommandOutput
} from "../commands/AssignInstanceCommand";
import {
  AssignVolumeCommandInput,
  AssignVolumeCommandOutput
} from "../commands/AssignVolumeCommand";
import {
  AssociateElasticIpCommandInput,
  AssociateElasticIpCommandOutput
} from "../commands/AssociateElasticIpCommand";
import {
  AttachElasticLoadBalancerCommandInput,
  AttachElasticLoadBalancerCommandOutput
} from "../commands/AttachElasticLoadBalancerCommand";
import {
  CloneStackCommandInput,
  CloneStackCommandOutput
} from "../commands/CloneStackCommand";
import {
  CreateAppCommandInput,
  CreateAppCommandOutput
} from "../commands/CreateAppCommand";
import {
  CreateDeploymentCommandInput,
  CreateDeploymentCommandOutput
} from "../commands/CreateDeploymentCommand";
import {
  CreateInstanceCommandInput,
  CreateInstanceCommandOutput
} from "../commands/CreateInstanceCommand";
import {
  CreateLayerCommandInput,
  CreateLayerCommandOutput
} from "../commands/CreateLayerCommand";
import {
  CreateStackCommandInput,
  CreateStackCommandOutput
} from "../commands/CreateStackCommand";
import {
  CreateUserProfileCommandInput,
  CreateUserProfileCommandOutput
} from "../commands/CreateUserProfileCommand";
import {
  DeleteAppCommandInput,
  DeleteAppCommandOutput
} from "../commands/DeleteAppCommand";
import {
  DeleteInstanceCommandInput,
  DeleteInstanceCommandOutput
} from "../commands/DeleteInstanceCommand";
import {
  DeleteLayerCommandInput,
  DeleteLayerCommandOutput
} from "../commands/DeleteLayerCommand";
import {
  DeleteStackCommandInput,
  DeleteStackCommandOutput
} from "../commands/DeleteStackCommand";
import {
  DeleteUserProfileCommandInput,
  DeleteUserProfileCommandOutput
} from "../commands/DeleteUserProfileCommand";
import {
  DeregisterEcsClusterCommandInput,
  DeregisterEcsClusterCommandOutput
} from "../commands/DeregisterEcsClusterCommand";
import {
  DeregisterElasticIpCommandInput,
  DeregisterElasticIpCommandOutput
} from "../commands/DeregisterElasticIpCommand";
import {
  DeregisterInstanceCommandInput,
  DeregisterInstanceCommandOutput
} from "../commands/DeregisterInstanceCommand";
import {
  DeregisterRdsDbInstanceCommandInput,
  DeregisterRdsDbInstanceCommandOutput
} from "../commands/DeregisterRdsDbInstanceCommand";
import {
  DeregisterVolumeCommandInput,
  DeregisterVolumeCommandOutput
} from "../commands/DeregisterVolumeCommand";
import {
  DescribeAgentVersionsCommandInput,
  DescribeAgentVersionsCommandOutput
} from "../commands/DescribeAgentVersionsCommand";
import {
  DescribeAppsCommandInput,
  DescribeAppsCommandOutput
} from "../commands/DescribeAppsCommand";
import {
  DescribeCommandsCommandInput,
  DescribeCommandsCommandOutput
} from "../commands/DescribeCommandsCommand";
import {
  DescribeDeploymentsCommandInput,
  DescribeDeploymentsCommandOutput
} from "../commands/DescribeDeploymentsCommand";
import {
  DescribeEcsClustersCommandInput,
  DescribeEcsClustersCommandOutput
} from "../commands/DescribeEcsClustersCommand";
import {
  DescribeElasticIpsCommandInput,
  DescribeElasticIpsCommandOutput
} from "../commands/DescribeElasticIpsCommand";
import {
  DescribeElasticLoadBalancersCommandInput,
  DescribeElasticLoadBalancersCommandOutput
} from "../commands/DescribeElasticLoadBalancersCommand";
import {
  DescribeInstancesCommandInput,
  DescribeInstancesCommandOutput
} from "../commands/DescribeInstancesCommand";
import {
  DescribeLayersCommandInput,
  DescribeLayersCommandOutput
} from "../commands/DescribeLayersCommand";
import {
  DescribeLoadBasedAutoScalingCommandInput,
  DescribeLoadBasedAutoScalingCommandOutput
} from "../commands/DescribeLoadBasedAutoScalingCommand";
import {
  DescribeMyUserProfileCommandInput,
  DescribeMyUserProfileCommandOutput
} from "../commands/DescribeMyUserProfileCommand";
import {
  DescribeOperatingSystemsCommandInput,
  DescribeOperatingSystemsCommandOutput
} from "../commands/DescribeOperatingSystemsCommand";
import {
  DescribePermissionsCommandInput,
  DescribePermissionsCommandOutput
} from "../commands/DescribePermissionsCommand";
import {
  DescribeRaidArraysCommandInput,
  DescribeRaidArraysCommandOutput
} from "../commands/DescribeRaidArraysCommand";
import {
  DescribeRdsDbInstancesCommandInput,
  DescribeRdsDbInstancesCommandOutput
} from "../commands/DescribeRdsDbInstancesCommand";
import {
  DescribeServiceErrorsCommandInput,
  DescribeServiceErrorsCommandOutput
} from "../commands/DescribeServiceErrorsCommand";
import {
  DescribeStackProvisioningParametersCommandInput,
  DescribeStackProvisioningParametersCommandOutput
} from "../commands/DescribeStackProvisioningParametersCommand";
import {
  DescribeStackSummaryCommandInput,
  DescribeStackSummaryCommandOutput
} from "../commands/DescribeStackSummaryCommand";
import {
  DescribeStacksCommandInput,
  DescribeStacksCommandOutput
} from "../commands/DescribeStacksCommand";
import {
  DescribeTimeBasedAutoScalingCommandInput,
  DescribeTimeBasedAutoScalingCommandOutput
} from "../commands/DescribeTimeBasedAutoScalingCommand";
import {
  DescribeUserProfilesCommandInput,
  DescribeUserProfilesCommandOutput
} from "../commands/DescribeUserProfilesCommand";
import {
  DescribeVolumesCommandInput,
  DescribeVolumesCommandOutput
} from "../commands/DescribeVolumesCommand";
import {
  DetachElasticLoadBalancerCommandInput,
  DetachElasticLoadBalancerCommandOutput
} from "../commands/DetachElasticLoadBalancerCommand";
import {
  DisassociateElasticIpCommandInput,
  DisassociateElasticIpCommandOutput
} from "../commands/DisassociateElasticIpCommand";
import {
  GetHostnameSuggestionCommandInput,
  GetHostnameSuggestionCommandOutput
} from "../commands/GetHostnameSuggestionCommand";
import {
  GrantAccessCommandInput,
  GrantAccessCommandOutput
} from "../commands/GrantAccessCommand";
import {
  ListTagsCommandInput,
  ListTagsCommandOutput
} from "../commands/ListTagsCommand";
import {
  RebootInstanceCommandInput,
  RebootInstanceCommandOutput
} from "../commands/RebootInstanceCommand";
import {
  RegisterEcsClusterCommandInput,
  RegisterEcsClusterCommandOutput
} from "../commands/RegisterEcsClusterCommand";
import {
  RegisterElasticIpCommandInput,
  RegisterElasticIpCommandOutput
} from "../commands/RegisterElasticIpCommand";
import {
  RegisterInstanceCommandInput,
  RegisterInstanceCommandOutput
} from "../commands/RegisterInstanceCommand";
import {
  RegisterRdsDbInstanceCommandInput,
  RegisterRdsDbInstanceCommandOutput
} from "../commands/RegisterRdsDbInstanceCommand";
import {
  RegisterVolumeCommandInput,
  RegisterVolumeCommandOutput
} from "../commands/RegisterVolumeCommand";
import {
  SetLoadBasedAutoScalingCommandInput,
  SetLoadBasedAutoScalingCommandOutput
} from "../commands/SetLoadBasedAutoScalingCommand";
import {
  SetPermissionCommandInput,
  SetPermissionCommandOutput
} from "../commands/SetPermissionCommand";
import {
  SetTimeBasedAutoScalingCommandInput,
  SetTimeBasedAutoScalingCommandOutput
} from "../commands/SetTimeBasedAutoScalingCommand";
import {
  StartInstanceCommandInput,
  StartInstanceCommandOutput
} from "../commands/StartInstanceCommand";
import {
  StartStackCommandInput,
  StartStackCommandOutput
} from "../commands/StartStackCommand";
import {
  StopInstanceCommandInput,
  StopInstanceCommandOutput
} from "../commands/StopInstanceCommand";
import {
  StopStackCommandInput,
  StopStackCommandOutput
} from "../commands/StopStackCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UnassignInstanceCommandInput,
  UnassignInstanceCommandOutput
} from "../commands/UnassignInstanceCommand";
import {
  UnassignVolumeCommandInput,
  UnassignVolumeCommandOutput
} from "../commands/UnassignVolumeCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateAppCommandInput,
  UpdateAppCommandOutput
} from "../commands/UpdateAppCommand";
import {
  UpdateElasticIpCommandInput,
  UpdateElasticIpCommandOutput
} from "../commands/UpdateElasticIpCommand";
import {
  UpdateInstanceCommandInput,
  UpdateInstanceCommandOutput
} from "../commands/UpdateInstanceCommand";
import {
  UpdateLayerCommandInput,
  UpdateLayerCommandOutput
} from "../commands/UpdateLayerCommand";
import {
  UpdateMyUserProfileCommandInput,
  UpdateMyUserProfileCommandOutput
} from "../commands/UpdateMyUserProfileCommand";
import {
  UpdateRdsDbInstanceCommandInput,
  UpdateRdsDbInstanceCommandOutput
} from "../commands/UpdateRdsDbInstanceCommand";
import {
  UpdateStackCommandInput,
  UpdateStackCommandOutput
} from "../commands/UpdateStackCommand";
import {
  UpdateUserProfileCommandInput,
  UpdateUserProfileCommandOutput
} from "../commands/UpdateUserProfileCommand";
import {
  UpdateVolumeCommandInput,
  UpdateVolumeCommandOutput
} from "../commands/UpdateVolumeCommand";
import {
  AgentVersion,
  App,
  AppAttributesKeys,
  AssignInstanceRequest,
  AssignVolumeRequest,
  AssociateElasticIpRequest,
  AttachElasticLoadBalancerRequest,
  AutoScalingThresholds,
  BlockDeviceMapping,
  ChefConfiguration,
  CloneStackRequest,
  CloneStackResult,
  CloudWatchLogsConfiguration,
  CloudWatchLogsLogStream,
  Command,
  CreateAppRequest,
  CreateAppResult,
  CreateDeploymentRequest,
  CreateDeploymentResult,
  CreateInstanceRequest,
  CreateInstanceResult,
  CreateLayerRequest,
  CreateLayerResult,
  CreateStackRequest,
  CreateStackResult,
  CreateUserProfileRequest,
  CreateUserProfileResult,
  DataSource,
  DeleteAppRequest,
  DeleteInstanceRequest,
  DeleteLayerRequest,
  DeleteStackRequest,
  DeleteUserProfileRequest,
  Deployment,
  DeploymentCommand,
  DeregisterEcsClusterRequest,
  DeregisterElasticIpRequest,
  DeregisterInstanceRequest,
  DeregisterRdsDbInstanceRequest,
  DeregisterVolumeRequest,
  DescribeAgentVersionsRequest,
  DescribeAgentVersionsResult,
  DescribeAppsRequest,
  DescribeAppsResult,
  DescribeCommandsRequest,
  DescribeCommandsResult,
  DescribeDeploymentsRequest,
  DescribeDeploymentsResult,
  DescribeEcsClustersRequest,
  DescribeEcsClustersResult,
  DescribeElasticIpsRequest,
  DescribeElasticIpsResult,
  DescribeElasticLoadBalancersRequest,
  DescribeElasticLoadBalancersResult,
  DescribeInstancesRequest,
  DescribeInstancesResult,
  DescribeLayersRequest,
  DescribeLayersResult,
  DescribeLoadBasedAutoScalingRequest,
  DescribeLoadBasedAutoScalingResult,
  DescribeMyUserProfileResult,
  DescribeOperatingSystemsResponse,
  DescribePermissionsRequest,
  DescribePermissionsResult,
  DescribeRaidArraysRequest,
  DescribeRaidArraysResult,
  DescribeRdsDbInstancesRequest,
  DescribeRdsDbInstancesResult,
  DescribeServiceErrorsRequest,
  DescribeServiceErrorsResult,
  DescribeStackProvisioningParametersRequest,
  DescribeStackProvisioningParametersResult,
  DescribeStackSummaryRequest,
  DescribeStackSummaryResult,
  DescribeStacksRequest,
  DescribeStacksResult,
  DescribeTimeBasedAutoScalingRequest,
  DescribeTimeBasedAutoScalingResult,
  DescribeUserProfilesRequest,
  DescribeUserProfilesResult,
  DescribeVolumesRequest,
  DescribeVolumesResult,
  DetachElasticLoadBalancerRequest,
  DisassociateElasticIpRequest,
  EbsBlockDevice,
  EcsCluster,
  ElasticIp,
  ElasticLoadBalancer,
  EnvironmentVariable,
  GetHostnameSuggestionRequest,
  GetHostnameSuggestionResult,
  GrantAccessRequest,
  GrantAccessResult,
  Instance,
  InstanceIdentity,
  InstancesCount,
  Layer,
  LayerAttributesKeys,
  LifecycleEventConfiguration,
  ListTagsRequest,
  ListTagsResult,
  LoadBasedAutoScalingConfiguration,
  OperatingSystem,
  OperatingSystemConfigurationManager,
  Permission,
  RaidArray,
  RdsDbInstance,
  RebootInstanceRequest,
  Recipes,
  RegisterEcsClusterRequest,
  RegisterEcsClusterResult,
  RegisterElasticIpRequest,
  RegisterElasticIpResult,
  RegisterInstanceRequest,
  RegisterInstanceResult,
  RegisterRdsDbInstanceRequest,
  RegisterVolumeRequest,
  RegisterVolumeResult,
  ReportedOs,
  ResourceNotFoundException,
  SelfUserProfile,
  ServiceError,
  SetLoadBasedAutoScalingRequest,
  SetPermissionRequest,
  SetTimeBasedAutoScalingRequest,
  ShutdownEventConfiguration,
  Source,
  SslConfiguration,
  Stack,
  StackAttributesKeys,
  StackConfigurationManager,
  StackSummary,
  StartInstanceRequest,
  StartStackRequest,
  StopInstanceRequest,
  StopStackRequest,
  TagResourceRequest,
  TemporaryCredential,
  TimeBasedAutoScalingConfiguration,
  UnassignInstanceRequest,
  UnassignVolumeRequest,
  UntagResourceRequest,
  UpdateAppRequest,
  UpdateElasticIpRequest,
  UpdateInstanceRequest,
  UpdateLayerRequest,
  UpdateMyUserProfileRequest,
  UpdateRdsDbInstanceRequest,
  UpdateStackRequest,
  UpdateUserProfileRequest,
  UpdateVolumeRequest,
  UserProfile,
  ValidationException,
  Volume,
  VolumeConfiguration,
  WeeklyAutoScalingSchedule
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export const serializeAws_json1_1AssignInstanceCommand = async (
  input: AssignInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.AssignInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssignInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AssignVolumeCommand = async (
  input: AssignVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.AssignVolume"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssignVolumeRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AssociateElasticIpCommand = async (
  input: AssociateElasticIpCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.AssociateElasticIp"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AssociateElasticIpRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1AttachElasticLoadBalancerCommand = async (
  input: AttachElasticLoadBalancerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.AttachElasticLoadBalancer"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AttachElasticLoadBalancerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CloneStackCommand = async (
  input: CloneStackCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.CloneStack"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CloneStackRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateAppCommand = async (
  input: CreateAppCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.CreateApp"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateAppRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateDeploymentCommand = async (
  input: CreateDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.CreateDeployment"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateDeploymentRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateInstanceCommand = async (
  input: CreateInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.CreateInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateLayerCommand = async (
  input: CreateLayerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.CreateLayer"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateLayerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateStackCommand = async (
  input: CreateStackCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.CreateStack"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateStackRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateUserProfileCommand = async (
  input: CreateUserProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.CreateUserProfile"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateUserProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteAppCommand = async (
  input: DeleteAppCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DeleteApp"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteAppRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteInstanceCommand = async (
  input: DeleteInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DeleteInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteLayerCommand = async (
  input: DeleteLayerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DeleteLayer"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteLayerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteStackCommand = async (
  input: DeleteStackCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DeleteStack"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteStackRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteUserProfileCommand = async (
  input: DeleteUserProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DeleteUserProfile"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteUserProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeregisterEcsClusterCommand = async (
  input: DeregisterEcsClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DeregisterEcsCluster"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterEcsClusterRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeregisterElasticIpCommand = async (
  input: DeregisterElasticIpCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DeregisterElasticIp"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterElasticIpRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeregisterInstanceCommand = async (
  input: DeregisterInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DeregisterInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeregisterRdsDbInstanceCommand = async (
  input: DeregisterRdsDbInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DeregisterRdsDbInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterRdsDbInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeregisterVolumeCommand = async (
  input: DeregisterVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DeregisterVolume"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeregisterVolumeRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeAgentVersionsCommand = async (
  input: DescribeAgentVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeAgentVersions"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeAgentVersionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeAppsCommand = async (
  input: DescribeAppsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeApps"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeAppsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeCommandsCommand = async (
  input: DescribeCommandsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeCommands"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeCommandsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeDeploymentsCommand = async (
  input: DescribeDeploymentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeDeployments"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeDeploymentsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeEcsClustersCommand = async (
  input: DescribeEcsClustersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeEcsClusters"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEcsClustersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeElasticIpsCommand = async (
  input: DescribeElasticIpsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeElasticIps"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeElasticIpsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeElasticLoadBalancersCommand = async (
  input: DescribeElasticLoadBalancersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeElasticLoadBalancers"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeElasticLoadBalancersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeInstancesCommand = async (
  input: DescribeInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeInstances"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeInstancesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeLayersCommand = async (
  input: DescribeLayersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeLayers"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeLayersRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeLoadBasedAutoScalingCommand = async (
  input: DescribeLoadBasedAutoScalingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeLoadBasedAutoScaling"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeLoadBasedAutoScalingRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeMyUserProfileCommand = async (
  input: DescribeMyUserProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeMyUserProfile"
  };
  return buildHttpRpcRequest(context, headers, "/", undefined, undefined);
};

export const serializeAws_json1_1DescribeOperatingSystemsCommand = async (
  input: DescribeOperatingSystemsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeOperatingSystems"
  };
  return buildHttpRpcRequest(context, headers, "/", undefined, undefined);
};

export const serializeAws_json1_1DescribePermissionsCommand = async (
  input: DescribePermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribePermissions"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribePermissionsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeRaidArraysCommand = async (
  input: DescribeRaidArraysCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeRaidArrays"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeRaidArraysRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeRdsDbInstancesCommand = async (
  input: DescribeRdsDbInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeRdsDbInstances"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeRdsDbInstancesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeServiceErrorsCommand = async (
  input: DescribeServiceErrorsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeServiceErrors"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeServiceErrorsRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeStackProvisioningParametersCommand = async (
  input: DescribeStackProvisioningParametersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeStackProvisioningParameters"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeStackProvisioningParametersRequest(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeStacksCommand = async (
  input: DescribeStacksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeStacks"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeStacksRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeStackSummaryCommand = async (
  input: DescribeStackSummaryCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeStackSummary"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeStackSummaryRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeTimeBasedAutoScalingCommand = async (
  input: DescribeTimeBasedAutoScalingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeTimeBasedAutoScaling"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeTimeBasedAutoScalingRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeUserProfilesCommand = async (
  input: DescribeUserProfilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeUserProfiles"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeUserProfilesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeVolumesCommand = async (
  input: DescribeVolumesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DescribeVolumes"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeVolumesRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DetachElasticLoadBalancerCommand = async (
  input: DetachElasticLoadBalancerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DetachElasticLoadBalancer"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DetachElasticLoadBalancerRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DisassociateElasticIpCommand = async (
  input: DisassociateElasticIpCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.DisassociateElasticIp"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DisassociateElasticIpRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GetHostnameSuggestionCommand = async (
  input: GetHostnameSuggestionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.GetHostnameSuggestion"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetHostnameSuggestionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1GrantAccessCommand = async (
  input: GrantAccessCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.GrantAccess"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1GrantAccessRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListTagsCommand = async (
  input: ListTagsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.ListTags"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListTagsRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1RebootInstanceCommand = async (
  input: RebootInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.RebootInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RebootInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1RegisterEcsClusterCommand = async (
  input: RegisterEcsClusterCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.RegisterEcsCluster"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterEcsClusterRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1RegisterElasticIpCommand = async (
  input: RegisterElasticIpCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.RegisterElasticIp"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterElasticIpRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1RegisterInstanceCommand = async (
  input: RegisterInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.RegisterInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1RegisterRdsDbInstanceCommand = async (
  input: RegisterRdsDbInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.RegisterRdsDbInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterRdsDbInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1RegisterVolumeCommand = async (
  input: RegisterVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.RegisterVolume"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RegisterVolumeRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1SetLoadBasedAutoScalingCommand = async (
  input: SetLoadBasedAutoScalingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.SetLoadBasedAutoScaling"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SetLoadBasedAutoScalingRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1SetPermissionCommand = async (
  input: SetPermissionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.SetPermission"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SetPermissionRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1SetTimeBasedAutoScalingCommand = async (
  input: SetTimeBasedAutoScalingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.SetTimeBasedAutoScaling"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SetTimeBasedAutoScalingRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartInstanceCommand = async (
  input: StartInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.StartInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartStackCommand = async (
  input: StartStackCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.StartStack"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StartStackRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StopInstanceCommand = async (
  input: StopInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.StopInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StopStackCommand = async (
  input: StopStackCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.StopStack"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1StopStackRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1TagResourceCommand = async (
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.TagResource"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UnassignInstanceCommand = async (
  input: UnassignInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UnassignInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UnassignInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UnassignVolumeCommand = async (
  input: UnassignVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UnassignVolume"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UnassignVolumeRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UntagResourceCommand = async (
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UntagResource"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UntagResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateAppCommand = async (
  input: UpdateAppCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UpdateApp"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateAppRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateElasticIpCommand = async (
  input: UpdateElasticIpCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UpdateElasticIp"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateElasticIpRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateInstanceCommand = async (
  input: UpdateInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UpdateInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateLayerCommand = async (
  input: UpdateLayerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UpdateLayer"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateLayerRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateMyUserProfileCommand = async (
  input: UpdateMyUserProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UpdateMyUserProfile"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateMyUserProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateRdsDbInstanceCommand = async (
  input: UpdateRdsDbInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UpdateRdsDbInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateRdsDbInstanceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateStackCommand = async (
  input: UpdateStackCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UpdateStack"
  };
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateStackRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateUserProfileCommand = async (
  input: UpdateUserProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UpdateUserProfile"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateUserProfileRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1UpdateVolumeCommand = async (
  input: UpdateVolumeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "OpsWorks_20130218.UpdateVolume"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateVolumeRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const deserializeAws_json1_1AssignInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssignInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssignInstanceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: AssignInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AssignInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssignInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AssignVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssignVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssignVolumeCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: AssignVolumeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AssignVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssignVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AssociateElasticIpCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateElasticIpCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AssociateElasticIpCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: AssociateElasticIpCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AssociateElasticIpCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateElasticIpCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1AttachElasticLoadBalancerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachElasticLoadBalancerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AttachElasticLoadBalancerCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: AttachElasticLoadBalancerCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AttachElasticLoadBalancerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachElasticLoadBalancerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CloneStackCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CloneStackCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CloneStackCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CloneStackResult(data, context);
  const response: CloneStackCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CloneStackResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CloneStackCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CloneStackCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateAppCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAppCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateAppCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateAppResult(data, context);
  const response: CreateAppCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAppResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateAppCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAppCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateDeploymentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeploymentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateDeploymentCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateDeploymentResult(data, context);
  const response: CreateDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDeploymentResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateDeploymentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeploymentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateInstanceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateInstanceResult(data, context);
  const response: CreateInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateLayerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLayerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateLayerCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateLayerResult(data, context);
  const response: CreateLayerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateLayerResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateLayerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLayerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateStackCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStackCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateStackCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateStackResult(data, context);
  const response: CreateStackCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateStackResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateStackCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStackCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateUserProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserProfileCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateUserProfileCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateUserProfileResult(data, context);
  const response: CreateUserProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateUserProfileResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateUserProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateUserProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteAppCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAppCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteAppCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteAppCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteAppCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAppCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteInstanceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteLayerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLayerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteLayerCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteLayerCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteLayerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLayerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteStackCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStackCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteStackCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteStackCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteStackCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStackCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteUserProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserProfileCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteUserProfileCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteUserProfileCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteUserProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeregisterEcsClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterEcsClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterEcsClusterCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeregisterEcsClusterCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeregisterEcsClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterEcsClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeregisterElasticIpCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterElasticIpCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterElasticIpCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeregisterElasticIpCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeregisterElasticIpCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterElasticIpCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeregisterInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterInstanceCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeregisterInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeregisterInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeregisterRdsDbInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterRdsDbInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterRdsDbInstanceCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeregisterRdsDbInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeregisterRdsDbInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterRdsDbInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeregisterVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeregisterVolumeCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeregisterVolumeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeregisterVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeregisterVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeAgentVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAgentVersionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAgentVersionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAgentVersionsResult(data, context);
  const response: DescribeAgentVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAgentVersionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeAgentVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAgentVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeAppsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAppsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAppsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAppsResult(data, context);
  const response: DescribeAppsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAppsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeAppsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAppsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeCommandsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCommandsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeCommandsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeCommandsResult(data, context);
  const response: DescribeCommandsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCommandsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeCommandsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCommandsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeDeploymentsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDeploymentsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeDeploymentsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeDeploymentsResult(data, context);
  const response: DescribeDeploymentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDeploymentsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeDeploymentsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDeploymentsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeEcsClustersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEcsClustersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEcsClustersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEcsClustersResult(data, context);
  const response: DescribeEcsClustersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEcsClustersResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeEcsClustersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEcsClustersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeElasticIpsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeElasticIpsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeElasticIpsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeElasticIpsResult(data, context);
  const response: DescribeElasticIpsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeElasticIpsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeElasticIpsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeElasticIpsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeElasticLoadBalancersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeElasticLoadBalancersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeElasticLoadBalancersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeElasticLoadBalancersResult(
    data,
    context
  );
  const response: DescribeElasticLoadBalancersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeElasticLoadBalancersResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeElasticLoadBalancersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeElasticLoadBalancersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeInstancesResult(data, context);
  const response: DescribeInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeLayersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLayersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeLayersCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeLayersResult(data, context);
  const response: DescribeLayersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLayersResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeLayersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLayersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeLoadBasedAutoScalingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLoadBasedAutoScalingCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeLoadBasedAutoScalingCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeLoadBasedAutoScalingResult(
    data,
    context
  );
  const response: DescribeLoadBasedAutoScalingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeLoadBasedAutoScalingResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeLoadBasedAutoScalingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeLoadBasedAutoScalingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeMyUserProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMyUserProfileCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMyUserProfileCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMyUserProfileResult(data, context);
  const response: DescribeMyUserProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMyUserProfileResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeMyUserProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMyUserProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeOperatingSystemsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOperatingSystemsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeOperatingSystemsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeOperatingSystemsResponse(
    data,
    context
  );
  const response: DescribeOperatingSystemsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeOperatingSystemsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeOperatingSystemsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOperatingSystemsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribePermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePermissionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribePermissionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribePermissionsResult(data, context);
  const response: DescribePermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePermissionsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribePermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeRaidArraysCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRaidArraysCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeRaidArraysCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeRaidArraysResult(data, context);
  const response: DescribeRaidArraysCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeRaidArraysResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeRaidArraysCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRaidArraysCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeRdsDbInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRdsDbInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeRdsDbInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeRdsDbInstancesResult(data, context);
  const response: DescribeRdsDbInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeRdsDbInstancesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeRdsDbInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRdsDbInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeServiceErrorsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeServiceErrorsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeServiceErrorsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeServiceErrorsResult(data, context);
  const response: DescribeServiceErrorsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeServiceErrorsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeServiceErrorsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeServiceErrorsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeStackProvisioningParametersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStackProvisioningParametersCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeStackProvisioningParametersCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeStackProvisioningParametersResult(
    data,
    context
  );
  const response: DescribeStackProvisioningParametersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeStackProvisioningParametersResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeStackProvisioningParametersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStackProvisioningParametersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeStacksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStacksCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeStacksCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeStacksResult(data, context);
  const response: DescribeStacksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeStacksResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeStacksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStacksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeStackSummaryCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStackSummaryCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeStackSummaryCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeStackSummaryResult(data, context);
  const response: DescribeStackSummaryCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeStackSummaryResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeStackSummaryCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStackSummaryCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeTimeBasedAutoScalingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTimeBasedAutoScalingCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTimeBasedAutoScalingCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTimeBasedAutoScalingResult(
    data,
    context
  );
  const response: DescribeTimeBasedAutoScalingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTimeBasedAutoScalingResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeTimeBasedAutoScalingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTimeBasedAutoScalingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeUserProfilesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeUserProfilesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeUserProfilesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeUserProfilesResult(data, context);
  const response: DescribeUserProfilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeUserProfilesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeUserProfilesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeUserProfilesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeVolumesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVolumesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeVolumesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeVolumesResult(data, context);
  const response: DescribeVolumesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVolumesResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeVolumesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVolumesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DetachElasticLoadBalancerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachElasticLoadBalancerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DetachElasticLoadBalancerCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DetachElasticLoadBalancerCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DetachElasticLoadBalancerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachElasticLoadBalancerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DisassociateElasticIpCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateElasticIpCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DisassociateElasticIpCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DisassociateElasticIpCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DisassociateElasticIpCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateElasticIpCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GetHostnameSuggestionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostnameSuggestionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetHostnameSuggestionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetHostnameSuggestionResult(data, context);
  const response: GetHostnameSuggestionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHostnameSuggestionResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GetHostnameSuggestionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostnameSuggestionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1GrantAccessCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GrantAccessCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GrantAccessCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GrantAccessResult(data, context);
  const response: GrantAccessCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GrantAccessResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1GrantAccessCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GrantAccessCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListTagsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsResult(data, context);
  const response: ListTagsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListTagsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1RebootInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RebootInstanceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: RebootInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1RebootInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1RegisterEcsClusterCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterEcsClusterCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterEcsClusterCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterEcsClusterResult(data, context);
  const response: RegisterEcsClusterCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterEcsClusterResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1RegisterEcsClusterCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterEcsClusterCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1RegisterElasticIpCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterElasticIpCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterElasticIpCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterElasticIpResult(data, context);
  const response: RegisterElasticIpCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterElasticIpResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1RegisterElasticIpCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterElasticIpCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1RegisterInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterInstanceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterInstanceResult(data, context);
  const response: RegisterInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterInstanceResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1RegisterInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1RegisterRdsDbInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterRdsDbInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterRdsDbInstanceCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: RegisterRdsDbInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1RegisterRdsDbInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterRdsDbInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1RegisterVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RegisterVolumeCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RegisterVolumeResult(data, context);
  const response: RegisterVolumeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterVolumeResult",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1RegisterVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1SetLoadBasedAutoScalingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetLoadBasedAutoScalingCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SetLoadBasedAutoScalingCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: SetLoadBasedAutoScalingCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1SetLoadBasedAutoScalingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetLoadBasedAutoScalingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1SetPermissionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetPermissionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SetPermissionCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: SetPermissionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1SetPermissionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetPermissionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1SetTimeBasedAutoScalingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetTimeBasedAutoScalingCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SetTimeBasedAutoScalingCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: SetTimeBasedAutoScalingCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1SetTimeBasedAutoScalingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetTimeBasedAutoScalingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartInstanceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: StartInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartStackCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartStackCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartStackCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: StartStackCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartStackCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartStackCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StopInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopInstanceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: StopInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StopInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StopStackCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopStackCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopStackCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: StopStackCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StopStackCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopStackCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1TagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1TagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UnassignInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnassignInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UnassignInstanceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UnassignInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UnassignInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnassignInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UnassignVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnassignVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UnassignVolumeCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UnassignVolumeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UnassignVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UnassignVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UntagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UntagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateAppCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAppCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateAppCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UpdateAppCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateAppCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAppCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateElasticIpCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateElasticIpCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateElasticIpCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UpdateElasticIpCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateElasticIpCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateElasticIpCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateInstanceCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UpdateInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateLayerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateLayerCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateLayerCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UpdateLayerCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateLayerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateLayerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateMyUserProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMyUserProfileCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateMyUserProfileCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: UpdateMyUserProfileCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateMyUserProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMyUserProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateRdsDbInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRdsDbInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRdsDbInstanceCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: UpdateRdsDbInstanceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateRdsDbInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRdsDbInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateStackCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStackCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateStackCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UpdateStackCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateStackCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStackCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateUserProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserProfileCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateUserProfileCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UpdateUserProfileCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateUserProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1UpdateVolumeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVolumeCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateVolumeCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: UpdateVolumeCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1UpdateVolumeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateVolumeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundException":
    case "com.amazonaws.opsworks#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ValidationException":
    case "com.amazonaws.opsworks#ValidationException":
      response = {
        ...(await deserializeAws_json1_1ValidationExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_json1_1ResourceNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceNotFoundException(
    body,
    context
  );
  const contents: ResourceNotFoundException = {
    name: "ResourceNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ValidationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ValidationException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ValidationException(
    body,
    context
  );
  const contents: ValidationException = {
    name: "ValidationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1AppAttributes = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (
      acc: { [key: string]: string },
      [key, value]: [AppAttributesKeys | string, any]
    ) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const serializeAws_json1_1AssignInstanceRequest = (
  input: AssignInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId }),
    ...(input.LayerIds !== undefined && {
      LayerIds: serializeAws_json1_1Strings(input.LayerIds, context)
    })
  };
};

const serializeAws_json1_1AssignVolumeRequest = (
  input: AssignVolumeRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId }),
    ...(input.VolumeId !== undefined && { VolumeId: input.VolumeId })
  };
};

const serializeAws_json1_1AssociateElasticIpRequest = (
  input: AssociateElasticIpRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ElasticIp !== undefined && { ElasticIp: input.ElasticIp }),
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId })
  };
};

const serializeAws_json1_1AttachElasticLoadBalancerRequest = (
  input: AttachElasticLoadBalancerRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ElasticLoadBalancerName !== undefined && {
      ElasticLoadBalancerName: input.ElasticLoadBalancerName
    }),
    ...(input.LayerId !== undefined && { LayerId: input.LayerId })
  };
};

const serializeAws_json1_1AutoScalingThresholds = (
  input: AutoScalingThresholds,
  context: __SerdeContext
): any => {
  return {
    ...(input.Alarms !== undefined && {
      Alarms: serializeAws_json1_1Strings(input.Alarms, context)
    }),
    ...(input.CpuThreshold !== undefined && {
      CpuThreshold: input.CpuThreshold
    }),
    ...(input.IgnoreMetricsTime !== undefined && {
      IgnoreMetricsTime: input.IgnoreMetricsTime
    }),
    ...(input.InstanceCount !== undefined && {
      InstanceCount: input.InstanceCount
    }),
    ...(input.LoadThreshold !== undefined && {
      LoadThreshold: input.LoadThreshold
    }),
    ...(input.MemoryThreshold !== undefined && {
      MemoryThreshold: input.MemoryThreshold
    }),
    ...(input.ThresholdsWaitTime !== undefined && {
      ThresholdsWaitTime: input.ThresholdsWaitTime
    })
  };
};

const serializeAws_json1_1BlockDeviceMapping = (
  input: BlockDeviceMapping,
  context: __SerdeContext
): any => {
  return {
    ...(input.DeviceName !== undefined && { DeviceName: input.DeviceName }),
    ...(input.Ebs !== undefined && {
      Ebs: serializeAws_json1_1EbsBlockDevice(input.Ebs, context)
    }),
    ...(input.NoDevice !== undefined && { NoDevice: input.NoDevice }),
    ...(input.VirtualName !== undefined && { VirtualName: input.VirtualName })
  };
};

const serializeAws_json1_1BlockDeviceMappings = (
  input: BlockDeviceMapping[],
  context: __SerdeContext
): any => {
  return input.map(entry =>
    serializeAws_json1_1BlockDeviceMapping(entry, context)
  );
};

const serializeAws_json1_1ChefConfiguration = (
  input: ChefConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.BerkshelfVersion !== undefined && {
      BerkshelfVersion: input.BerkshelfVersion
    }),
    ...(input.ManageBerkshelf !== undefined && {
      ManageBerkshelf: input.ManageBerkshelf
    })
  };
};

const serializeAws_json1_1CloneStackRequest = (
  input: CloneStackRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AgentVersion !== undefined && {
      AgentVersion: input.AgentVersion
    }),
    ...(input.Attributes !== undefined && {
      Attributes: serializeAws_json1_1StackAttributes(input.Attributes, context)
    }),
    ...(input.ChefConfiguration !== undefined && {
      ChefConfiguration: serializeAws_json1_1ChefConfiguration(
        input.ChefConfiguration,
        context
      )
    }),
    ...(input.CloneAppIds !== undefined && {
      CloneAppIds: serializeAws_json1_1Strings(input.CloneAppIds, context)
    }),
    ...(input.ClonePermissions !== undefined && {
      ClonePermissions: input.ClonePermissions
    }),
    ...(input.ConfigurationManager !== undefined && {
      ConfigurationManager: serializeAws_json1_1StackConfigurationManager(
        input.ConfigurationManager,
        context
      )
    }),
    ...(input.CustomCookbooksSource !== undefined && {
      CustomCookbooksSource: serializeAws_json1_1Source(
        input.CustomCookbooksSource,
        context
      )
    }),
    ...(input.CustomJson !== undefined && { CustomJson: input.CustomJson }),
    ...(input.DefaultAvailabilityZone !== undefined && {
      DefaultAvailabilityZone: input.DefaultAvailabilityZone
    }),
    ...(input.DefaultInstanceProfileArn !== undefined && {
      DefaultInstanceProfileArn: input.DefaultInstanceProfileArn
    }),
    ...(input.DefaultOs !== undefined && { DefaultOs: input.DefaultOs }),
    ...(input.DefaultRootDeviceType !== undefined && {
      DefaultRootDeviceType: input.DefaultRootDeviceType
    }),
    ...(input.DefaultSshKeyName !== undefined && {
      DefaultSshKeyName: input.DefaultSshKeyName
    }),
    ...(input.DefaultSubnetId !== undefined && {
      DefaultSubnetId: input.DefaultSubnetId
    }),
    ...(input.HostnameTheme !== undefined && {
      HostnameTheme: input.HostnameTheme
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Region !== undefined && { Region: input.Region }),
    ...(input.ServiceRoleArn !== undefined && {
      ServiceRoleArn: input.ServiceRoleArn
    }),
    ...(input.SourceStackId !== undefined && {
      SourceStackId: input.SourceStackId
    }),
    ...(input.UseCustomCookbooks !== undefined && {
      UseCustomCookbooks: input.UseCustomCookbooks
    }),
    ...(input.UseOpsworksSecurityGroups !== undefined && {
      UseOpsworksSecurityGroups: input.UseOpsworksSecurityGroups
    }),
    ...(input.VpcId !== undefined && { VpcId: input.VpcId })
  };
};

const serializeAws_json1_1CloudWatchLogsConfiguration = (
  input: CloudWatchLogsConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.Enabled !== undefined && { Enabled: input.Enabled }),
    ...(input.LogStreams !== undefined && {
      LogStreams: serializeAws_json1_1CloudWatchLogsLogStreams(
        input.LogStreams,
        context
      )
    })
  };
};

const serializeAws_json1_1CloudWatchLogsLogStream = (
  input: CloudWatchLogsLogStream,
  context: __SerdeContext
): any => {
  return {
    ...(input.BatchCount !== undefined && { BatchCount: input.BatchCount }),
    ...(input.BatchSize !== undefined && { BatchSize: input.BatchSize }),
    ...(input.BufferDuration !== undefined && {
      BufferDuration: input.BufferDuration
    }),
    ...(input.DatetimeFormat !== undefined && {
      DatetimeFormat: input.DatetimeFormat
    }),
    ...(input.Encoding !== undefined && { Encoding: input.Encoding }),
    ...(input.File !== undefined && { File: input.File }),
    ...(input.FileFingerprintLines !== undefined && {
      FileFingerprintLines: input.FileFingerprintLines
    }),
    ...(input.InitialPosition !== undefined && {
      InitialPosition: input.InitialPosition
    }),
    ...(input.LogGroupName !== undefined && {
      LogGroupName: input.LogGroupName
    }),
    ...(input.MultiLineStartPattern !== undefined && {
      MultiLineStartPattern: input.MultiLineStartPattern
    }),
    ...(input.TimeZone !== undefined && { TimeZone: input.TimeZone })
  };
};

const serializeAws_json1_1CloudWatchLogsLogStreams = (
  input: CloudWatchLogsLogStream[],
  context: __SerdeContext
): any => {
  return input.map(entry =>
    serializeAws_json1_1CloudWatchLogsLogStream(entry, context)
  );
};

const serializeAws_json1_1CreateAppRequest = (
  input: CreateAppRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AppSource !== undefined && {
      AppSource: serializeAws_json1_1Source(input.AppSource, context)
    }),
    ...(input.Attributes !== undefined && {
      Attributes: serializeAws_json1_1AppAttributes(input.Attributes, context)
    }),
    ...(input.DataSources !== undefined && {
      DataSources: serializeAws_json1_1DataSources(input.DataSources, context)
    }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.Domains !== undefined && {
      Domains: serializeAws_json1_1Strings(input.Domains, context)
    }),
    ...(input.EnableSsl !== undefined && { EnableSsl: input.EnableSsl }),
    ...(input.Environment !== undefined && {
      Environment: serializeAws_json1_1EnvironmentVariables(
        input.Environment,
        context
      )
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Shortname !== undefined && { Shortname: input.Shortname }),
    ...(input.SslConfiguration !== undefined && {
      SslConfiguration: serializeAws_json1_1SslConfiguration(
        input.SslConfiguration,
        context
      )
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId }),
    ...(input.Type !== undefined && { Type: input.Type })
  };
};

const serializeAws_json1_1CreateDeploymentRequest = (
  input: CreateDeploymentRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AppId !== undefined && { AppId: input.AppId }),
    ...(input.Command !== undefined && {
      Command: serializeAws_json1_1DeploymentCommand(input.Command, context)
    }),
    ...(input.Comment !== undefined && { Comment: input.Comment }),
    ...(input.CustomJson !== undefined && { CustomJson: input.CustomJson }),
    ...(input.InstanceIds !== undefined && {
      InstanceIds: serializeAws_json1_1Strings(input.InstanceIds, context)
    }),
    ...(input.LayerIds !== undefined && {
      LayerIds: serializeAws_json1_1Strings(input.LayerIds, context)
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1CreateInstanceRequest = (
  input: CreateInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AgentVersion !== undefined && {
      AgentVersion: input.AgentVersion
    }),
    ...(input.AmiId !== undefined && { AmiId: input.AmiId }),
    ...(input.Architecture !== undefined && {
      Architecture: input.Architecture
    }),
    ...(input.AutoScalingType !== undefined && {
      AutoScalingType: input.AutoScalingType
    }),
    ...(input.AvailabilityZone !== undefined && {
      AvailabilityZone: input.AvailabilityZone
    }),
    ...(input.BlockDeviceMappings !== undefined && {
      BlockDeviceMappings: serializeAws_json1_1BlockDeviceMappings(
        input.BlockDeviceMappings,
        context
      )
    }),
    ...(input.EbsOptimized !== undefined && {
      EbsOptimized: input.EbsOptimized
    }),
    ...(input.Hostname !== undefined && { Hostname: input.Hostname }),
    ...(input.InstallUpdatesOnBoot !== undefined && {
      InstallUpdatesOnBoot: input.InstallUpdatesOnBoot
    }),
    ...(input.InstanceType !== undefined && {
      InstanceType: input.InstanceType
    }),
    ...(input.LayerIds !== undefined && {
      LayerIds: serializeAws_json1_1Strings(input.LayerIds, context)
    }),
    ...(input.Os !== undefined && { Os: input.Os }),
    ...(input.RootDeviceType !== undefined && {
      RootDeviceType: input.RootDeviceType
    }),
    ...(input.SshKeyName !== undefined && { SshKeyName: input.SshKeyName }),
    ...(input.StackId !== undefined && { StackId: input.StackId }),
    ...(input.SubnetId !== undefined && { SubnetId: input.SubnetId }),
    ...(input.Tenancy !== undefined && { Tenancy: input.Tenancy }),
    ...(input.VirtualizationType !== undefined && {
      VirtualizationType: input.VirtualizationType
    })
  };
};

const serializeAws_json1_1CreateLayerRequest = (
  input: CreateLayerRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Attributes !== undefined && {
      Attributes: serializeAws_json1_1LayerAttributes(input.Attributes, context)
    }),
    ...(input.AutoAssignElasticIps !== undefined && {
      AutoAssignElasticIps: input.AutoAssignElasticIps
    }),
    ...(input.AutoAssignPublicIps !== undefined && {
      AutoAssignPublicIps: input.AutoAssignPublicIps
    }),
    ...(input.CloudWatchLogsConfiguration !== undefined && {
      CloudWatchLogsConfiguration: serializeAws_json1_1CloudWatchLogsConfiguration(
        input.CloudWatchLogsConfiguration,
        context
      )
    }),
    ...(input.CustomInstanceProfileArn !== undefined && {
      CustomInstanceProfileArn: input.CustomInstanceProfileArn
    }),
    ...(input.CustomJson !== undefined && { CustomJson: input.CustomJson }),
    ...(input.CustomRecipes !== undefined && {
      CustomRecipes: serializeAws_json1_1Recipes(input.CustomRecipes, context)
    }),
    ...(input.CustomSecurityGroupIds !== undefined && {
      CustomSecurityGroupIds: serializeAws_json1_1Strings(
        input.CustomSecurityGroupIds,
        context
      )
    }),
    ...(input.EnableAutoHealing !== undefined && {
      EnableAutoHealing: input.EnableAutoHealing
    }),
    ...(input.InstallUpdatesOnBoot !== undefined && {
      InstallUpdatesOnBoot: input.InstallUpdatesOnBoot
    }),
    ...(input.LifecycleEventConfiguration !== undefined && {
      LifecycleEventConfiguration: serializeAws_json1_1LifecycleEventConfiguration(
        input.LifecycleEventConfiguration,
        context
      )
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Packages !== undefined && {
      Packages: serializeAws_json1_1Strings(input.Packages, context)
    }),
    ...(input.Shortname !== undefined && { Shortname: input.Shortname }),
    ...(input.StackId !== undefined && { StackId: input.StackId }),
    ...(input.Type !== undefined && { Type: input.Type }),
    ...(input.UseEbsOptimizedInstances !== undefined && {
      UseEbsOptimizedInstances: input.UseEbsOptimizedInstances
    }),
    ...(input.VolumeConfigurations !== undefined && {
      VolumeConfigurations: serializeAws_json1_1VolumeConfigurations(
        input.VolumeConfigurations,
        context
      )
    })
  };
};

const serializeAws_json1_1CreateStackRequest = (
  input: CreateStackRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AgentVersion !== undefined && {
      AgentVersion: input.AgentVersion
    }),
    ...(input.Attributes !== undefined && {
      Attributes: serializeAws_json1_1StackAttributes(input.Attributes, context)
    }),
    ...(input.ChefConfiguration !== undefined && {
      ChefConfiguration: serializeAws_json1_1ChefConfiguration(
        input.ChefConfiguration,
        context
      )
    }),
    ...(input.ConfigurationManager !== undefined && {
      ConfigurationManager: serializeAws_json1_1StackConfigurationManager(
        input.ConfigurationManager,
        context
      )
    }),
    ...(input.CustomCookbooksSource !== undefined && {
      CustomCookbooksSource: serializeAws_json1_1Source(
        input.CustomCookbooksSource,
        context
      )
    }),
    ...(input.CustomJson !== undefined && { CustomJson: input.CustomJson }),
    ...(input.DefaultAvailabilityZone !== undefined && {
      DefaultAvailabilityZone: input.DefaultAvailabilityZone
    }),
    ...(input.DefaultInstanceProfileArn !== undefined && {
      DefaultInstanceProfileArn: input.DefaultInstanceProfileArn
    }),
    ...(input.DefaultOs !== undefined && { DefaultOs: input.DefaultOs }),
    ...(input.DefaultRootDeviceType !== undefined && {
      DefaultRootDeviceType: input.DefaultRootDeviceType
    }),
    ...(input.DefaultSshKeyName !== undefined && {
      DefaultSshKeyName: input.DefaultSshKeyName
    }),
    ...(input.DefaultSubnetId !== undefined && {
      DefaultSubnetId: input.DefaultSubnetId
    }),
    ...(input.HostnameTheme !== undefined && {
      HostnameTheme: input.HostnameTheme
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Region !== undefined && { Region: input.Region }),
    ...(input.ServiceRoleArn !== undefined && {
      ServiceRoleArn: input.ServiceRoleArn
    }),
    ...(input.UseCustomCookbooks !== undefined && {
      UseCustomCookbooks: input.UseCustomCookbooks
    }),
    ...(input.UseOpsworksSecurityGroups !== undefined && {
      UseOpsworksSecurityGroups: input.UseOpsworksSecurityGroups
    }),
    ...(input.VpcId !== undefined && { VpcId: input.VpcId })
  };
};

const serializeAws_json1_1CreateUserProfileRequest = (
  input: CreateUserProfileRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AllowSelfManagement !== undefined && {
      AllowSelfManagement: input.AllowSelfManagement
    }),
    ...(input.IamUserArn !== undefined && { IamUserArn: input.IamUserArn }),
    ...(input.SshPublicKey !== undefined && {
      SshPublicKey: input.SshPublicKey
    }),
    ...(input.SshUsername !== undefined && { SshUsername: input.SshUsername })
  };
};

const serializeAws_json1_1DailyAutoScalingSchedule = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const serializeAws_json1_1DataSource = (
  input: DataSource,
  context: __SerdeContext
): any => {
  return {
    ...(input.Arn !== undefined && { Arn: input.Arn }),
    ...(input.DatabaseName !== undefined && {
      DatabaseName: input.DatabaseName
    }),
    ...(input.Type !== undefined && { Type: input.Type })
  };
};

const serializeAws_json1_1DataSources = (
  input: DataSource[],
  context: __SerdeContext
): any => {
  return input.map(entry => serializeAws_json1_1DataSource(entry, context));
};

const serializeAws_json1_1DeleteAppRequest = (
  input: DeleteAppRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AppId !== undefined && { AppId: input.AppId })
  };
};

const serializeAws_json1_1DeleteInstanceRequest = (
  input: DeleteInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.DeleteElasticIp !== undefined && {
      DeleteElasticIp: input.DeleteElasticIp
    }),
    ...(input.DeleteVolumes !== undefined && {
      DeleteVolumes: input.DeleteVolumes
    }),
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId })
  };
};

const serializeAws_json1_1DeleteLayerRequest = (
  input: DeleteLayerRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.LayerId !== undefined && { LayerId: input.LayerId })
  };
};

const serializeAws_json1_1DeleteStackRequest = (
  input: DeleteStackRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DeleteUserProfileRequest = (
  input: DeleteUserProfileRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.IamUserArn !== undefined && { IamUserArn: input.IamUserArn })
  };
};

const serializeAws_json1_1DeploymentCommand = (
  input: DeploymentCommand,
  context: __SerdeContext
): any => {
  return {
    ...(input.Args !== undefined && {
      Args: serializeAws_json1_1DeploymentCommandArgs(input.Args, context)
    }),
    ...(input.Name !== undefined && { Name: input.Name })
  };
};

const serializeAws_json1_1DeploymentCommandArgs = (
  input: { [key: string]: string[] },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string[] }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: serializeAws_json1_1Strings(value, context)
    }),
    {}
  );
};

const serializeAws_json1_1DeregisterEcsClusterRequest = (
  input: DeregisterEcsClusterRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.EcsClusterArn !== undefined && {
      EcsClusterArn: input.EcsClusterArn
    })
  };
};

const serializeAws_json1_1DeregisterElasticIpRequest = (
  input: DeregisterElasticIpRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ElasticIp !== undefined && { ElasticIp: input.ElasticIp })
  };
};

const serializeAws_json1_1DeregisterInstanceRequest = (
  input: DeregisterInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId })
  };
};

const serializeAws_json1_1DeregisterRdsDbInstanceRequest = (
  input: DeregisterRdsDbInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.RdsDbInstanceArn !== undefined && {
      RdsDbInstanceArn: input.RdsDbInstanceArn
    })
  };
};

const serializeAws_json1_1DeregisterVolumeRequest = (
  input: DeregisterVolumeRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.VolumeId !== undefined && { VolumeId: input.VolumeId })
  };
};

const serializeAws_json1_1DescribeAgentVersionsRequest = (
  input: DescribeAgentVersionsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ConfigurationManager !== undefined && {
      ConfigurationManager: serializeAws_json1_1StackConfigurationManager(
        input.ConfigurationManager,
        context
      )
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeAppsRequest = (
  input: DescribeAppsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AppIds !== undefined && {
      AppIds: serializeAws_json1_1Strings(input.AppIds, context)
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeCommandsRequest = (
  input: DescribeCommandsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.CommandIds !== undefined && {
      CommandIds: serializeAws_json1_1Strings(input.CommandIds, context)
    }),
    ...(input.DeploymentId !== undefined && {
      DeploymentId: input.DeploymentId
    }),
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId })
  };
};

const serializeAws_json1_1DescribeDeploymentsRequest = (
  input: DescribeDeploymentsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AppId !== undefined && { AppId: input.AppId }),
    ...(input.DeploymentIds !== undefined && {
      DeploymentIds: serializeAws_json1_1Strings(input.DeploymentIds, context)
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeEcsClustersRequest = (
  input: DescribeEcsClustersRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.EcsClusterArns !== undefined && {
      EcsClusterArns: serializeAws_json1_1Strings(input.EcsClusterArns, context)
    }),
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeElasticIpsRequest = (
  input: DescribeElasticIpsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId }),
    ...(input.Ips !== undefined && {
      Ips: serializeAws_json1_1Strings(input.Ips, context)
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeElasticLoadBalancersRequest = (
  input: DescribeElasticLoadBalancersRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.LayerIds !== undefined && {
      LayerIds: serializeAws_json1_1Strings(input.LayerIds, context)
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeInstancesRequest = (
  input: DescribeInstancesRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceIds !== undefined && {
      InstanceIds: serializeAws_json1_1Strings(input.InstanceIds, context)
    }),
    ...(input.LayerId !== undefined && { LayerId: input.LayerId }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeLayersRequest = (
  input: DescribeLayersRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.LayerIds !== undefined && {
      LayerIds: serializeAws_json1_1Strings(input.LayerIds, context)
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeLoadBasedAutoScalingRequest = (
  input: DescribeLoadBasedAutoScalingRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.LayerIds !== undefined && {
      LayerIds: serializeAws_json1_1Strings(input.LayerIds, context)
    })
  };
};

const serializeAws_json1_1DescribePermissionsRequest = (
  input: DescribePermissionsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.IamUserArn !== undefined && { IamUserArn: input.IamUserArn }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeRaidArraysRequest = (
  input: DescribeRaidArraysRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId }),
    ...(input.RaidArrayIds !== undefined && {
      RaidArrayIds: serializeAws_json1_1Strings(input.RaidArrayIds, context)
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeRdsDbInstancesRequest = (
  input: DescribeRdsDbInstancesRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.RdsDbInstanceArns !== undefined && {
      RdsDbInstanceArns: serializeAws_json1_1Strings(
        input.RdsDbInstanceArns,
        context
      )
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeServiceErrorsRequest = (
  input: DescribeServiceErrorsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId }),
    ...(input.ServiceErrorIds !== undefined && {
      ServiceErrorIds: serializeAws_json1_1Strings(
        input.ServiceErrorIds,
        context
      )
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeStackProvisioningParametersRequest = (
  input: DescribeStackProvisioningParametersRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeStacksRequest = (
  input: DescribeStacksRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.StackIds !== undefined && {
      StackIds: serializeAws_json1_1Strings(input.StackIds, context)
    })
  };
};

const serializeAws_json1_1DescribeStackSummaryRequest = (
  input: DescribeStackSummaryRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1DescribeTimeBasedAutoScalingRequest = (
  input: DescribeTimeBasedAutoScalingRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceIds !== undefined && {
      InstanceIds: serializeAws_json1_1Strings(input.InstanceIds, context)
    })
  };
};

const serializeAws_json1_1DescribeUserProfilesRequest = (
  input: DescribeUserProfilesRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.IamUserArns !== undefined && {
      IamUserArns: serializeAws_json1_1Strings(input.IamUserArns, context)
    })
  };
};

const serializeAws_json1_1DescribeVolumesRequest = (
  input: DescribeVolumesRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId }),
    ...(input.RaidArrayId !== undefined && { RaidArrayId: input.RaidArrayId }),
    ...(input.StackId !== undefined && { StackId: input.StackId }),
    ...(input.VolumeIds !== undefined && {
      VolumeIds: serializeAws_json1_1Strings(input.VolumeIds, context)
    })
  };
};

const serializeAws_json1_1DetachElasticLoadBalancerRequest = (
  input: DetachElasticLoadBalancerRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ElasticLoadBalancerName !== undefined && {
      ElasticLoadBalancerName: input.ElasticLoadBalancerName
    }),
    ...(input.LayerId !== undefined && { LayerId: input.LayerId })
  };
};

const serializeAws_json1_1DisassociateElasticIpRequest = (
  input: DisassociateElasticIpRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ElasticIp !== undefined && { ElasticIp: input.ElasticIp })
  };
};

const serializeAws_json1_1EbsBlockDevice = (
  input: EbsBlockDevice,
  context: __SerdeContext
): any => {
  return {
    ...(input.DeleteOnTermination !== undefined && {
      DeleteOnTermination: input.DeleteOnTermination
    }),
    ...(input.Iops !== undefined && { Iops: input.Iops }),
    ...(input.SnapshotId !== undefined && { SnapshotId: input.SnapshotId }),
    ...(input.VolumeSize !== undefined && { VolumeSize: input.VolumeSize }),
    ...(input.VolumeType !== undefined && { VolumeType: input.VolumeType })
  };
};

const serializeAws_json1_1EnvironmentVariable = (
  input: EnvironmentVariable,
  context: __SerdeContext
): any => {
  return {
    ...(input.Key !== undefined && { Key: input.Key }),
    ...(input.Secure !== undefined && { Secure: input.Secure }),
    ...(input.Value !== undefined && { Value: input.Value })
  };
};

const serializeAws_json1_1EnvironmentVariables = (
  input: EnvironmentVariable[],
  context: __SerdeContext
): any => {
  return input.map(entry =>
    serializeAws_json1_1EnvironmentVariable(entry, context)
  );
};

const serializeAws_json1_1GetHostnameSuggestionRequest = (
  input: GetHostnameSuggestionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.LayerId !== undefined && { LayerId: input.LayerId })
  };
};

const serializeAws_json1_1GrantAccessRequest = (
  input: GrantAccessRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId }),
    ...(input.ValidForInMinutes !== undefined && {
      ValidForInMinutes: input.ValidForInMinutes
    })
  };
};

const serializeAws_json1_1InstanceIdentity = (
  input: InstanceIdentity,
  context: __SerdeContext
): any => {
  return {
    ...(input.Document !== undefined && { Document: input.Document }),
    ...(input.Signature !== undefined && { Signature: input.Signature })
  };
};

const serializeAws_json1_1LayerAttributes = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (
      acc: { [key: string]: string },
      [key, value]: [LayerAttributesKeys | string, any]
    ) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const serializeAws_json1_1LifecycleEventConfiguration = (
  input: LifecycleEventConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.Shutdown !== undefined && {
      Shutdown: serializeAws_json1_1ShutdownEventConfiguration(
        input.Shutdown,
        context
      )
    })
  };
};

const serializeAws_json1_1ListTagsRequest = (
  input: ListTagsRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.MaxResults !== undefined && { MaxResults: input.MaxResults }),
    ...(input.NextToken !== undefined && { NextToken: input.NextToken }),
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn })
  };
};

const serializeAws_json1_1RebootInstanceRequest = (
  input: RebootInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId })
  };
};

const serializeAws_json1_1Recipes = (
  input: Recipes,
  context: __SerdeContext
): any => {
  return {
    ...(input.Configure !== undefined && {
      Configure: serializeAws_json1_1Strings(input.Configure, context)
    }),
    ...(input.Deploy !== undefined && {
      Deploy: serializeAws_json1_1Strings(input.Deploy, context)
    }),
    ...(input.Setup !== undefined && {
      Setup: serializeAws_json1_1Strings(input.Setup, context)
    }),
    ...(input.Shutdown !== undefined && {
      Shutdown: serializeAws_json1_1Strings(input.Shutdown, context)
    }),
    ...(input.Undeploy !== undefined && {
      Undeploy: serializeAws_json1_1Strings(input.Undeploy, context)
    })
  };
};

const serializeAws_json1_1RegisterEcsClusterRequest = (
  input: RegisterEcsClusterRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.EcsClusterArn !== undefined && {
      EcsClusterArn: input.EcsClusterArn
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1RegisterElasticIpRequest = (
  input: RegisterElasticIpRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ElasticIp !== undefined && { ElasticIp: input.ElasticIp }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1RegisterInstanceRequest = (
  input: RegisterInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Hostname !== undefined && { Hostname: input.Hostname }),
    ...(input.InstanceIdentity !== undefined && {
      InstanceIdentity: serializeAws_json1_1InstanceIdentity(
        input.InstanceIdentity,
        context
      )
    }),
    ...(input.PrivateIp !== undefined && { PrivateIp: input.PrivateIp }),
    ...(input.PublicIp !== undefined && { PublicIp: input.PublicIp }),
    ...(input.RsaPublicKey !== undefined && {
      RsaPublicKey: input.RsaPublicKey
    }),
    ...(input.RsaPublicKeyFingerprint !== undefined && {
      RsaPublicKeyFingerprint: input.RsaPublicKeyFingerprint
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1RegisterRdsDbInstanceRequest = (
  input: RegisterRdsDbInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.DbPassword !== undefined && { DbPassword: input.DbPassword }),
    ...(input.DbUser !== undefined && { DbUser: input.DbUser }),
    ...(input.RdsDbInstanceArn !== undefined && {
      RdsDbInstanceArn: input.RdsDbInstanceArn
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1RegisterVolumeRequest = (
  input: RegisterVolumeRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Ec2VolumeId !== undefined && { Ec2VolumeId: input.Ec2VolumeId }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1SetLoadBasedAutoScalingRequest = (
  input: SetLoadBasedAutoScalingRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.DownScaling !== undefined && {
      DownScaling: serializeAws_json1_1AutoScalingThresholds(
        input.DownScaling,
        context
      )
    }),
    ...(input.Enable !== undefined && { Enable: input.Enable }),
    ...(input.LayerId !== undefined && { LayerId: input.LayerId }),
    ...(input.UpScaling !== undefined && {
      UpScaling: serializeAws_json1_1AutoScalingThresholds(
        input.UpScaling,
        context
      )
    })
  };
};

const serializeAws_json1_1SetPermissionRequest = (
  input: SetPermissionRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AllowSsh !== undefined && { AllowSsh: input.AllowSsh }),
    ...(input.AllowSudo !== undefined && { AllowSudo: input.AllowSudo }),
    ...(input.IamUserArn !== undefined && { IamUserArn: input.IamUserArn }),
    ...(input.Level !== undefined && { Level: input.Level }),
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1SetTimeBasedAutoScalingRequest = (
  input: SetTimeBasedAutoScalingRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AutoScalingSchedule !== undefined && {
      AutoScalingSchedule: serializeAws_json1_1WeeklyAutoScalingSchedule(
        input.AutoScalingSchedule,
        context
      )
    }),
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId })
  };
};

const serializeAws_json1_1ShutdownEventConfiguration = (
  input: ShutdownEventConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.DelayUntilElbConnectionsDrained !== undefined && {
      DelayUntilElbConnectionsDrained: input.DelayUntilElbConnectionsDrained
    }),
    ...(input.ExecutionTimeout !== undefined && {
      ExecutionTimeout: input.ExecutionTimeout
    })
  };
};

const serializeAws_json1_1Source = (
  input: Source,
  context: __SerdeContext
): any => {
  return {
    ...(input.Password !== undefined && { Password: input.Password }),
    ...(input.Revision !== undefined && { Revision: input.Revision }),
    ...(input.SshKey !== undefined && { SshKey: input.SshKey }),
    ...(input.Type !== undefined && { Type: input.Type }),
    ...(input.Url !== undefined && { Url: input.Url }),
    ...(input.Username !== undefined && { Username: input.Username })
  };
};

const serializeAws_json1_1SslConfiguration = (
  input: SslConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.Certificate !== undefined && { Certificate: input.Certificate }),
    ...(input.Chain !== undefined && { Chain: input.Chain }),
    ...(input.PrivateKey !== undefined && { PrivateKey: input.PrivateKey })
  };
};

const serializeAws_json1_1StackAttributes = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (
      acc: { [key: string]: string },
      [key, value]: [StackAttributesKeys | string, any]
    ) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const serializeAws_json1_1StackConfigurationManager = (
  input: StackConfigurationManager,
  context: __SerdeContext
): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Version !== undefined && { Version: input.Version })
  };
};

const serializeAws_json1_1StartInstanceRequest = (
  input: StartInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId })
  };
};

const serializeAws_json1_1StartStackRequest = (
  input: StartStackRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1StopInstanceRequest = (
  input: StopInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Force !== undefined && { Force: input.Force }),
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId })
  };
};

const serializeAws_json1_1StopStackRequest = (
  input: StopStackRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.StackId !== undefined && { StackId: input.StackId })
  };
};

const serializeAws_json1_1Strings = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const serializeAws_json1_1TagKeys = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const serializeAws_json1_1TagResourceRequest = (
  input: TagResourceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
    ...(input.Tags !== undefined && {
      Tags: serializeAws_json1_1Tags(input.Tags, context)
    })
  };
};

const serializeAws_json1_1Tags = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const serializeAws_json1_1UnassignInstanceRequest = (
  input: UnassignInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId })
  };
};

const serializeAws_json1_1UnassignVolumeRequest = (
  input: UnassignVolumeRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.VolumeId !== undefined && { VolumeId: input.VolumeId })
  };
};

const serializeAws_json1_1UntagResourceRequest = (
  input: UntagResourceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
    ...(input.TagKeys !== undefined && {
      TagKeys: serializeAws_json1_1TagKeys(input.TagKeys, context)
    })
  };
};

const serializeAws_json1_1UpdateAppRequest = (
  input: UpdateAppRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AppId !== undefined && { AppId: input.AppId }),
    ...(input.AppSource !== undefined && {
      AppSource: serializeAws_json1_1Source(input.AppSource, context)
    }),
    ...(input.Attributes !== undefined && {
      Attributes: serializeAws_json1_1AppAttributes(input.Attributes, context)
    }),
    ...(input.DataSources !== undefined && {
      DataSources: serializeAws_json1_1DataSources(input.DataSources, context)
    }),
    ...(input.Description !== undefined && { Description: input.Description }),
    ...(input.Domains !== undefined && {
      Domains: serializeAws_json1_1Strings(input.Domains, context)
    }),
    ...(input.EnableSsl !== undefined && { EnableSsl: input.EnableSsl }),
    ...(input.Environment !== undefined && {
      Environment: serializeAws_json1_1EnvironmentVariables(
        input.Environment,
        context
      )
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.SslConfiguration !== undefined && {
      SslConfiguration: serializeAws_json1_1SslConfiguration(
        input.SslConfiguration,
        context
      )
    }),
    ...(input.Type !== undefined && { Type: input.Type })
  };
};

const serializeAws_json1_1UpdateElasticIpRequest = (
  input: UpdateElasticIpRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.ElasticIp !== undefined && { ElasticIp: input.ElasticIp }),
    ...(input.Name !== undefined && { Name: input.Name })
  };
};

const serializeAws_json1_1UpdateInstanceRequest = (
  input: UpdateInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AgentVersion !== undefined && {
      AgentVersion: input.AgentVersion
    }),
    ...(input.AmiId !== undefined && { AmiId: input.AmiId }),
    ...(input.Architecture !== undefined && {
      Architecture: input.Architecture
    }),
    ...(input.AutoScalingType !== undefined && {
      AutoScalingType: input.AutoScalingType
    }),
    ...(input.EbsOptimized !== undefined && {
      EbsOptimized: input.EbsOptimized
    }),
    ...(input.Hostname !== undefined && { Hostname: input.Hostname }),
    ...(input.InstallUpdatesOnBoot !== undefined && {
      InstallUpdatesOnBoot: input.InstallUpdatesOnBoot
    }),
    ...(input.InstanceId !== undefined && { InstanceId: input.InstanceId }),
    ...(input.InstanceType !== undefined && {
      InstanceType: input.InstanceType
    }),
    ...(input.LayerIds !== undefined && {
      LayerIds: serializeAws_json1_1Strings(input.LayerIds, context)
    }),
    ...(input.Os !== undefined && { Os: input.Os }),
    ...(input.SshKeyName !== undefined && { SshKeyName: input.SshKeyName })
  };
};

const serializeAws_json1_1UpdateLayerRequest = (
  input: UpdateLayerRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.Attributes !== undefined && {
      Attributes: serializeAws_json1_1LayerAttributes(input.Attributes, context)
    }),
    ...(input.AutoAssignElasticIps !== undefined && {
      AutoAssignElasticIps: input.AutoAssignElasticIps
    }),
    ...(input.AutoAssignPublicIps !== undefined && {
      AutoAssignPublicIps: input.AutoAssignPublicIps
    }),
    ...(input.CloudWatchLogsConfiguration !== undefined && {
      CloudWatchLogsConfiguration: serializeAws_json1_1CloudWatchLogsConfiguration(
        input.CloudWatchLogsConfiguration,
        context
      )
    }),
    ...(input.CustomInstanceProfileArn !== undefined && {
      CustomInstanceProfileArn: input.CustomInstanceProfileArn
    }),
    ...(input.CustomJson !== undefined && { CustomJson: input.CustomJson }),
    ...(input.CustomRecipes !== undefined && {
      CustomRecipes: serializeAws_json1_1Recipes(input.CustomRecipes, context)
    }),
    ...(input.CustomSecurityGroupIds !== undefined && {
      CustomSecurityGroupIds: serializeAws_json1_1Strings(
        input.CustomSecurityGroupIds,
        context
      )
    }),
    ...(input.EnableAutoHealing !== undefined && {
      EnableAutoHealing: input.EnableAutoHealing
    }),
    ...(input.InstallUpdatesOnBoot !== undefined && {
      InstallUpdatesOnBoot: input.InstallUpdatesOnBoot
    }),
    ...(input.LayerId !== undefined && { LayerId: input.LayerId }),
    ...(input.LifecycleEventConfiguration !== undefined && {
      LifecycleEventConfiguration: serializeAws_json1_1LifecycleEventConfiguration(
        input.LifecycleEventConfiguration,
        context
      )
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Packages !== undefined && {
      Packages: serializeAws_json1_1Strings(input.Packages, context)
    }),
    ...(input.Shortname !== undefined && { Shortname: input.Shortname }),
    ...(input.UseEbsOptimizedInstances !== undefined && {
      UseEbsOptimizedInstances: input.UseEbsOptimizedInstances
    }),
    ...(input.VolumeConfigurations !== undefined && {
      VolumeConfigurations: serializeAws_json1_1VolumeConfigurations(
        input.VolumeConfigurations,
        context
      )
    })
  };
};

const serializeAws_json1_1UpdateMyUserProfileRequest = (
  input: UpdateMyUserProfileRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.SshPublicKey !== undefined && {
      SshPublicKey: input.SshPublicKey
    })
  };
};

const serializeAws_json1_1UpdateRdsDbInstanceRequest = (
  input: UpdateRdsDbInstanceRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.DbPassword !== undefined && { DbPassword: input.DbPassword }),
    ...(input.DbUser !== undefined && { DbUser: input.DbUser }),
    ...(input.RdsDbInstanceArn !== undefined && {
      RdsDbInstanceArn: input.RdsDbInstanceArn
    })
  };
};

const serializeAws_json1_1UpdateStackRequest = (
  input: UpdateStackRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AgentVersion !== undefined && {
      AgentVersion: input.AgentVersion
    }),
    ...(input.Attributes !== undefined && {
      Attributes: serializeAws_json1_1StackAttributes(input.Attributes, context)
    }),
    ...(input.ChefConfiguration !== undefined && {
      ChefConfiguration: serializeAws_json1_1ChefConfiguration(
        input.ChefConfiguration,
        context
      )
    }),
    ...(input.ConfigurationManager !== undefined && {
      ConfigurationManager: serializeAws_json1_1StackConfigurationManager(
        input.ConfigurationManager,
        context
      )
    }),
    ...(input.CustomCookbooksSource !== undefined && {
      CustomCookbooksSource: serializeAws_json1_1Source(
        input.CustomCookbooksSource,
        context
      )
    }),
    ...(input.CustomJson !== undefined && { CustomJson: input.CustomJson }),
    ...(input.DefaultAvailabilityZone !== undefined && {
      DefaultAvailabilityZone: input.DefaultAvailabilityZone
    }),
    ...(input.DefaultInstanceProfileArn !== undefined && {
      DefaultInstanceProfileArn: input.DefaultInstanceProfileArn
    }),
    ...(input.DefaultOs !== undefined && { DefaultOs: input.DefaultOs }),
    ...(input.DefaultRootDeviceType !== undefined && {
      DefaultRootDeviceType: input.DefaultRootDeviceType
    }),
    ...(input.DefaultSshKeyName !== undefined && {
      DefaultSshKeyName: input.DefaultSshKeyName
    }),
    ...(input.DefaultSubnetId !== undefined && {
      DefaultSubnetId: input.DefaultSubnetId
    }),
    ...(input.HostnameTheme !== undefined && {
      HostnameTheme: input.HostnameTheme
    }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.ServiceRoleArn !== undefined && {
      ServiceRoleArn: input.ServiceRoleArn
    }),
    ...(input.StackId !== undefined && { StackId: input.StackId }),
    ...(input.UseCustomCookbooks !== undefined && {
      UseCustomCookbooks: input.UseCustomCookbooks
    }),
    ...(input.UseOpsworksSecurityGroups !== undefined && {
      UseOpsworksSecurityGroups: input.UseOpsworksSecurityGroups
    })
  };
};

const serializeAws_json1_1UpdateUserProfileRequest = (
  input: UpdateUserProfileRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.AllowSelfManagement !== undefined && {
      AllowSelfManagement: input.AllowSelfManagement
    }),
    ...(input.IamUserArn !== undefined && { IamUserArn: input.IamUserArn }),
    ...(input.SshPublicKey !== undefined && {
      SshPublicKey: input.SshPublicKey
    }),
    ...(input.SshUsername !== undefined && { SshUsername: input.SshUsername })
  };
};

const serializeAws_json1_1UpdateVolumeRequest = (
  input: UpdateVolumeRequest,
  context: __SerdeContext
): any => {
  return {
    ...(input.MountPoint !== undefined && { MountPoint: input.MountPoint }),
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.VolumeId !== undefined && { VolumeId: input.VolumeId })
  };
};

const serializeAws_json1_1VolumeConfiguration = (
  input: VolumeConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.Encrypted !== undefined && { Encrypted: input.Encrypted }),
    ...(input.Iops !== undefined && { Iops: input.Iops }),
    ...(input.MountPoint !== undefined && { MountPoint: input.MountPoint }),
    ...(input.NumberOfDisks !== undefined && {
      NumberOfDisks: input.NumberOfDisks
    }),
    ...(input.RaidLevel !== undefined && { RaidLevel: input.RaidLevel }),
    ...(input.Size !== undefined && { Size: input.Size }),
    ...(input.VolumeType !== undefined && { VolumeType: input.VolumeType })
  };
};

const serializeAws_json1_1VolumeConfigurations = (
  input: VolumeConfiguration[],
  context: __SerdeContext
): any => {
  return input.map(entry =>
    serializeAws_json1_1VolumeConfiguration(entry, context)
  );
};

const serializeAws_json1_1WeeklyAutoScalingSchedule = (
  input: WeeklyAutoScalingSchedule,
  context: __SerdeContext
): any => {
  return {
    ...(input.Friday !== undefined && {
      Friday: serializeAws_json1_1DailyAutoScalingSchedule(
        input.Friday,
        context
      )
    }),
    ...(input.Monday !== undefined && {
      Monday: serializeAws_json1_1DailyAutoScalingSchedule(
        input.Monday,
        context
      )
    }),
    ...(input.Saturday !== undefined && {
      Saturday: serializeAws_json1_1DailyAutoScalingSchedule(
        input.Saturday,
        context
      )
    }),
    ...(input.Sunday !== undefined && {
      Sunday: serializeAws_json1_1DailyAutoScalingSchedule(
        input.Sunday,
        context
      )
    }),
    ...(input.Thursday !== undefined && {
      Thursday: serializeAws_json1_1DailyAutoScalingSchedule(
        input.Thursday,
        context
      )
    }),
    ...(input.Tuesday !== undefined && {
      Tuesday: serializeAws_json1_1DailyAutoScalingSchedule(
        input.Tuesday,
        context
      )
    }),
    ...(input.Wednesday !== undefined && {
      Wednesday: serializeAws_json1_1DailyAutoScalingSchedule(
        input.Wednesday,
        context
      )
    })
  };
};

const deserializeAws_json1_1AgentVersion = (
  output: any,
  context: __SerdeContext
): AgentVersion => {
  return {
    __type: "AgentVersion",
    ConfigurationManager:
      output.ConfigurationManager !== undefined &&
      output.ConfigurationManager !== null
        ? deserializeAws_json1_1StackConfigurationManager(
            output.ConfigurationManager,
            context
          )
        : undefined,
    Version:
      output.Version !== undefined && output.Version !== null
        ? output.Version
        : undefined
  } as any;
};

const deserializeAws_json1_1AgentVersions = (
  output: any,
  context: __SerdeContext
): AgentVersion[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AgentVersion(entry, context)
  );
};

const deserializeAws_json1_1App = (
  output: any,
  context: __SerdeContext
): App => {
  return {
    __type: "App",
    AppId:
      output.AppId !== undefined && output.AppId !== null
        ? output.AppId
        : undefined,
    AppSource:
      output.AppSource !== undefined && output.AppSource !== null
        ? deserializeAws_json1_1Source(output.AppSource, context)
        : undefined,
    Attributes:
      output.Attributes !== undefined && output.Attributes !== null
        ? deserializeAws_json1_1AppAttributes(output.Attributes, context)
        : undefined,
    CreatedAt:
      output.CreatedAt !== undefined && output.CreatedAt !== null
        ? output.CreatedAt
        : undefined,
    DataSources:
      output.DataSources !== undefined && output.DataSources !== null
        ? deserializeAws_json1_1DataSources(output.DataSources, context)
        : undefined,
    Description:
      output.Description !== undefined && output.Description !== null
        ? output.Description
        : undefined,
    Domains:
      output.Domains !== undefined && output.Domains !== null
        ? deserializeAws_json1_1Strings(output.Domains, context)
        : undefined,
    EnableSsl:
      output.EnableSsl !== undefined && output.EnableSsl !== null
        ? output.EnableSsl
        : undefined,
    Environment:
      output.Environment !== undefined && output.Environment !== null
        ? deserializeAws_json1_1EnvironmentVariables(
            output.Environment,
            context
          )
        : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    Shortname:
      output.Shortname !== undefined && output.Shortname !== null
        ? output.Shortname
        : undefined,
    SslConfiguration:
      output.SslConfiguration !== undefined && output.SslConfiguration !== null
        ? deserializeAws_json1_1SslConfiguration(
            output.SslConfiguration,
            context
          )
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined,
    Type:
      output.Type !== undefined && output.Type !== null
        ? output.Type
        : undefined
  } as any;
};

const deserializeAws_json1_1AppAttributes = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (
      acc: { [key: string]: string },
      [key, value]: [AppAttributesKeys | string, any]
    ) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const deserializeAws_json1_1Apps = (
  output: any,
  context: __SerdeContext
): App[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1App(entry, context)
  );
};

const deserializeAws_json1_1AutoScalingThresholds = (
  output: any,
  context: __SerdeContext
): AutoScalingThresholds => {
  return {
    __type: "AutoScalingThresholds",
    Alarms:
      output.Alarms !== undefined && output.Alarms !== null
        ? deserializeAws_json1_1Strings(output.Alarms, context)
        : undefined,
    CpuThreshold:
      output.CpuThreshold !== undefined && output.CpuThreshold !== null
        ? output.CpuThreshold
        : undefined,
    IgnoreMetricsTime:
      output.IgnoreMetricsTime !== undefined &&
      output.IgnoreMetricsTime !== null
        ? output.IgnoreMetricsTime
        : undefined,
    InstanceCount:
      output.InstanceCount !== undefined && output.InstanceCount !== null
        ? output.InstanceCount
        : undefined,
    LoadThreshold:
      output.LoadThreshold !== undefined && output.LoadThreshold !== null
        ? output.LoadThreshold
        : undefined,
    MemoryThreshold:
      output.MemoryThreshold !== undefined && output.MemoryThreshold !== null
        ? output.MemoryThreshold
        : undefined,
    ThresholdsWaitTime:
      output.ThresholdsWaitTime !== undefined &&
      output.ThresholdsWaitTime !== null
        ? output.ThresholdsWaitTime
        : undefined
  } as any;
};

const deserializeAws_json1_1BlockDeviceMapping = (
  output: any,
  context: __SerdeContext
): BlockDeviceMapping => {
  return {
    __type: "BlockDeviceMapping",
    DeviceName:
      output.DeviceName !== undefined && output.DeviceName !== null
        ? output.DeviceName
        : undefined,
    Ebs:
      output.Ebs !== undefined && output.Ebs !== null
        ? deserializeAws_json1_1EbsBlockDevice(output.Ebs, context)
        : undefined,
    NoDevice:
      output.NoDevice !== undefined && output.NoDevice !== null
        ? output.NoDevice
        : undefined,
    VirtualName:
      output.VirtualName !== undefined && output.VirtualName !== null
        ? output.VirtualName
        : undefined
  } as any;
};

const deserializeAws_json1_1BlockDeviceMappings = (
  output: any,
  context: __SerdeContext
): BlockDeviceMapping[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1BlockDeviceMapping(entry, context)
  );
};

const deserializeAws_json1_1ChefConfiguration = (
  output: any,
  context: __SerdeContext
): ChefConfiguration => {
  return {
    __type: "ChefConfiguration",
    BerkshelfVersion:
      output.BerkshelfVersion !== undefined && output.BerkshelfVersion !== null
        ? output.BerkshelfVersion
        : undefined,
    ManageBerkshelf:
      output.ManageBerkshelf !== undefined && output.ManageBerkshelf !== null
        ? output.ManageBerkshelf
        : undefined
  } as any;
};

const deserializeAws_json1_1CloneStackResult = (
  output: any,
  context: __SerdeContext
): CloneStackResult => {
  return {
    __type: "CloneStackResult",
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined
  } as any;
};

const deserializeAws_json1_1CloudWatchLogsConfiguration = (
  output: any,
  context: __SerdeContext
): CloudWatchLogsConfiguration => {
  return {
    __type: "CloudWatchLogsConfiguration",
    Enabled:
      output.Enabled !== undefined && output.Enabled !== null
        ? output.Enabled
        : undefined,
    LogStreams:
      output.LogStreams !== undefined && output.LogStreams !== null
        ? deserializeAws_json1_1CloudWatchLogsLogStreams(
            output.LogStreams,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1CloudWatchLogsLogStream = (
  output: any,
  context: __SerdeContext
): CloudWatchLogsLogStream => {
  return {
    __type: "CloudWatchLogsLogStream",
    BatchCount:
      output.BatchCount !== undefined && output.BatchCount !== null
        ? output.BatchCount
        : undefined,
    BatchSize:
      output.BatchSize !== undefined && output.BatchSize !== null
        ? output.BatchSize
        : undefined,
    BufferDuration:
      output.BufferDuration !== undefined && output.BufferDuration !== null
        ? output.BufferDuration
        : undefined,
    DatetimeFormat:
      output.DatetimeFormat !== undefined && output.DatetimeFormat !== null
        ? output.DatetimeFormat
        : undefined,
    Encoding:
      output.Encoding !== undefined && output.Encoding !== null
        ? output.Encoding
        : undefined,
    File:
      output.File !== undefined && output.File !== null
        ? output.File
        : undefined,
    FileFingerprintLines:
      output.FileFingerprintLines !== undefined &&
      output.FileFingerprintLines !== null
        ? output.FileFingerprintLines
        : undefined,
    InitialPosition:
      output.InitialPosition !== undefined && output.InitialPosition !== null
        ? output.InitialPosition
        : undefined,
    LogGroupName:
      output.LogGroupName !== undefined && output.LogGroupName !== null
        ? output.LogGroupName
        : undefined,
    MultiLineStartPattern:
      output.MultiLineStartPattern !== undefined &&
      output.MultiLineStartPattern !== null
        ? output.MultiLineStartPattern
        : undefined,
    TimeZone:
      output.TimeZone !== undefined && output.TimeZone !== null
        ? output.TimeZone
        : undefined
  } as any;
};

const deserializeAws_json1_1CloudWatchLogsLogStreams = (
  output: any,
  context: __SerdeContext
): CloudWatchLogsLogStream[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1CloudWatchLogsLogStream(entry, context)
  );
};

const deserializeAws_json1_1Command = (
  output: any,
  context: __SerdeContext
): Command => {
  return {
    __type: "Command",
    AcknowledgedAt:
      output.AcknowledgedAt !== undefined && output.AcknowledgedAt !== null
        ? output.AcknowledgedAt
        : undefined,
    CommandId:
      output.CommandId !== undefined && output.CommandId !== null
        ? output.CommandId
        : undefined,
    CompletedAt:
      output.CompletedAt !== undefined && output.CompletedAt !== null
        ? output.CompletedAt
        : undefined,
    CreatedAt:
      output.CreatedAt !== undefined && output.CreatedAt !== null
        ? output.CreatedAt
        : undefined,
    DeploymentId:
      output.DeploymentId !== undefined && output.DeploymentId !== null
        ? output.DeploymentId
        : undefined,
    ExitCode:
      output.ExitCode !== undefined && output.ExitCode !== null
        ? output.ExitCode
        : undefined,
    InstanceId:
      output.InstanceId !== undefined && output.InstanceId !== null
        ? output.InstanceId
        : undefined,
    LogUrl:
      output.LogUrl !== undefined && output.LogUrl !== null
        ? output.LogUrl
        : undefined,
    Status:
      output.Status !== undefined && output.Status !== null
        ? output.Status
        : undefined,
    Type:
      output.Type !== undefined && output.Type !== null
        ? output.Type
        : undefined
  } as any;
};

const deserializeAws_json1_1Commands = (
  output: any,
  context: __SerdeContext
): Command[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Command(entry, context)
  );
};

const deserializeAws_json1_1CreateAppResult = (
  output: any,
  context: __SerdeContext
): CreateAppResult => {
  return {
    __type: "CreateAppResult",
    AppId:
      output.AppId !== undefined && output.AppId !== null
        ? output.AppId
        : undefined
  } as any;
};

const deserializeAws_json1_1CreateDeploymentResult = (
  output: any,
  context: __SerdeContext
): CreateDeploymentResult => {
  return {
    __type: "CreateDeploymentResult",
    DeploymentId:
      output.DeploymentId !== undefined && output.DeploymentId !== null
        ? output.DeploymentId
        : undefined
  } as any;
};

const deserializeAws_json1_1CreateInstanceResult = (
  output: any,
  context: __SerdeContext
): CreateInstanceResult => {
  return {
    __type: "CreateInstanceResult",
    InstanceId:
      output.InstanceId !== undefined && output.InstanceId !== null
        ? output.InstanceId
        : undefined
  } as any;
};

const deserializeAws_json1_1CreateLayerResult = (
  output: any,
  context: __SerdeContext
): CreateLayerResult => {
  return {
    __type: "CreateLayerResult",
    LayerId:
      output.LayerId !== undefined && output.LayerId !== null
        ? output.LayerId
        : undefined
  } as any;
};

const deserializeAws_json1_1CreateStackResult = (
  output: any,
  context: __SerdeContext
): CreateStackResult => {
  return {
    __type: "CreateStackResult",
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined
  } as any;
};

const deserializeAws_json1_1CreateUserProfileResult = (
  output: any,
  context: __SerdeContext
): CreateUserProfileResult => {
  return {
    __type: "CreateUserProfileResult",
    IamUserArn:
      output.IamUserArn !== undefined && output.IamUserArn !== null
        ? output.IamUserArn
        : undefined
  } as any;
};

const deserializeAws_json1_1DailyAutoScalingSchedule = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const deserializeAws_json1_1DataSource = (
  output: any,
  context: __SerdeContext
): DataSource => {
  return {
    __type: "DataSource",
    Arn:
      output.Arn !== undefined && output.Arn !== null ? output.Arn : undefined,
    DatabaseName:
      output.DatabaseName !== undefined && output.DatabaseName !== null
        ? output.DatabaseName
        : undefined,
    Type:
      output.Type !== undefined && output.Type !== null
        ? output.Type
        : undefined
  } as any;
};

const deserializeAws_json1_1DataSources = (
  output: any,
  context: __SerdeContext
): DataSource[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1DataSource(entry, context)
  );
};

const deserializeAws_json1_1Deployment = (
  output: any,
  context: __SerdeContext
): Deployment => {
  return {
    __type: "Deployment",
    AppId:
      output.AppId !== undefined && output.AppId !== null
        ? output.AppId
        : undefined,
    Command:
      output.Command !== undefined && output.Command !== null
        ? deserializeAws_json1_1DeploymentCommand(output.Command, context)
        : undefined,
    Comment:
      output.Comment !== undefined && output.Comment !== null
        ? output.Comment
        : undefined,
    CompletedAt:
      output.CompletedAt !== undefined && output.CompletedAt !== null
        ? output.CompletedAt
        : undefined,
    CreatedAt:
      output.CreatedAt !== undefined && output.CreatedAt !== null
        ? output.CreatedAt
        : undefined,
    CustomJson:
      output.CustomJson !== undefined && output.CustomJson !== null
        ? output.CustomJson
        : undefined,
    DeploymentId:
      output.DeploymentId !== undefined && output.DeploymentId !== null
        ? output.DeploymentId
        : undefined,
    Duration:
      output.Duration !== undefined && output.Duration !== null
        ? output.Duration
        : undefined,
    IamUserArn:
      output.IamUserArn !== undefined && output.IamUserArn !== null
        ? output.IamUserArn
        : undefined,
    InstanceIds:
      output.InstanceIds !== undefined && output.InstanceIds !== null
        ? deserializeAws_json1_1Strings(output.InstanceIds, context)
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined,
    Status:
      output.Status !== undefined && output.Status !== null
        ? output.Status
        : undefined
  } as any;
};

const deserializeAws_json1_1DeploymentCommand = (
  output: any,
  context: __SerdeContext
): DeploymentCommand => {
  return {
    __type: "DeploymentCommand",
    Args:
      output.Args !== undefined && output.Args !== null
        ? deserializeAws_json1_1DeploymentCommandArgs(output.Args, context)
        : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined
  } as any;
};

const deserializeAws_json1_1DeploymentCommandArgs = (
  output: any,
  context: __SerdeContext
): { [key: string]: string[] } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string[] }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: deserializeAws_json1_1Strings(value, context)
    }),
    {}
  );
};

const deserializeAws_json1_1Deployments = (
  output: any,
  context: __SerdeContext
): Deployment[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Deployment(entry, context)
  );
};

const deserializeAws_json1_1DescribeAgentVersionsResult = (
  output: any,
  context: __SerdeContext
): DescribeAgentVersionsResult => {
  return {
    __type: "DescribeAgentVersionsResult",
    AgentVersions:
      output.AgentVersions !== undefined && output.AgentVersions !== null
        ? deserializeAws_json1_1AgentVersions(output.AgentVersions, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeAppsResult = (
  output: any,
  context: __SerdeContext
): DescribeAppsResult => {
  return {
    __type: "DescribeAppsResult",
    Apps:
      output.Apps !== undefined && output.Apps !== null
        ? deserializeAws_json1_1Apps(output.Apps, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeCommandsResult = (
  output: any,
  context: __SerdeContext
): DescribeCommandsResult => {
  return {
    __type: "DescribeCommandsResult",
    Commands:
      output.Commands !== undefined && output.Commands !== null
        ? deserializeAws_json1_1Commands(output.Commands, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeDeploymentsResult = (
  output: any,
  context: __SerdeContext
): DescribeDeploymentsResult => {
  return {
    __type: "DescribeDeploymentsResult",
    Deployments:
      output.Deployments !== undefined && output.Deployments !== null
        ? deserializeAws_json1_1Deployments(output.Deployments, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeEcsClustersResult = (
  output: any,
  context: __SerdeContext
): DescribeEcsClustersResult => {
  return {
    __type: "DescribeEcsClustersResult",
    EcsClusters:
      output.EcsClusters !== undefined && output.EcsClusters !== null
        ? deserializeAws_json1_1EcsClusters(output.EcsClusters, context)
        : undefined,
    NextToken:
      output.NextToken !== undefined && output.NextToken !== null
        ? output.NextToken
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeElasticIpsResult = (
  output: any,
  context: __SerdeContext
): DescribeElasticIpsResult => {
  return {
    __type: "DescribeElasticIpsResult",
    ElasticIps:
      output.ElasticIps !== undefined && output.ElasticIps !== null
        ? deserializeAws_json1_1ElasticIps(output.ElasticIps, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeElasticLoadBalancersResult = (
  output: any,
  context: __SerdeContext
): DescribeElasticLoadBalancersResult => {
  return {
    __type: "DescribeElasticLoadBalancersResult",
    ElasticLoadBalancers:
      output.ElasticLoadBalancers !== undefined &&
      output.ElasticLoadBalancers !== null
        ? deserializeAws_json1_1ElasticLoadBalancers(
            output.ElasticLoadBalancers,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeInstancesResult = (
  output: any,
  context: __SerdeContext
): DescribeInstancesResult => {
  return {
    __type: "DescribeInstancesResult",
    Instances:
      output.Instances !== undefined && output.Instances !== null
        ? deserializeAws_json1_1Instances(output.Instances, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeLayersResult = (
  output: any,
  context: __SerdeContext
): DescribeLayersResult => {
  return {
    __type: "DescribeLayersResult",
    Layers:
      output.Layers !== undefined && output.Layers !== null
        ? deserializeAws_json1_1Layers(output.Layers, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeLoadBasedAutoScalingResult = (
  output: any,
  context: __SerdeContext
): DescribeLoadBasedAutoScalingResult => {
  return {
    __type: "DescribeLoadBasedAutoScalingResult",
    LoadBasedAutoScalingConfigurations:
      output.LoadBasedAutoScalingConfigurations !== undefined &&
      output.LoadBasedAutoScalingConfigurations !== null
        ? deserializeAws_json1_1LoadBasedAutoScalingConfigurations(
            output.LoadBasedAutoScalingConfigurations,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeMyUserProfileResult = (
  output: any,
  context: __SerdeContext
): DescribeMyUserProfileResult => {
  return {
    __type: "DescribeMyUserProfileResult",
    UserProfile:
      output.UserProfile !== undefined && output.UserProfile !== null
        ? deserializeAws_json1_1SelfUserProfile(output.UserProfile, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeOperatingSystemsResponse = (
  output: any,
  context: __SerdeContext
): DescribeOperatingSystemsResponse => {
  return {
    __type: "DescribeOperatingSystemsResponse",
    OperatingSystems:
      output.OperatingSystems !== undefined && output.OperatingSystems !== null
        ? deserializeAws_json1_1OperatingSystems(
            output.OperatingSystems,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribePermissionsResult = (
  output: any,
  context: __SerdeContext
): DescribePermissionsResult => {
  return {
    __type: "DescribePermissionsResult",
    Permissions:
      output.Permissions !== undefined && output.Permissions !== null
        ? deserializeAws_json1_1Permissions(output.Permissions, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeRaidArraysResult = (
  output: any,
  context: __SerdeContext
): DescribeRaidArraysResult => {
  return {
    __type: "DescribeRaidArraysResult",
    RaidArrays:
      output.RaidArrays !== undefined && output.RaidArrays !== null
        ? deserializeAws_json1_1RaidArrays(output.RaidArrays, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeRdsDbInstancesResult = (
  output: any,
  context: __SerdeContext
): DescribeRdsDbInstancesResult => {
  return {
    __type: "DescribeRdsDbInstancesResult",
    RdsDbInstances:
      output.RdsDbInstances !== undefined && output.RdsDbInstances !== null
        ? deserializeAws_json1_1RdsDbInstances(output.RdsDbInstances, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeServiceErrorsResult = (
  output: any,
  context: __SerdeContext
): DescribeServiceErrorsResult => {
  return {
    __type: "DescribeServiceErrorsResult",
    ServiceErrors:
      output.ServiceErrors !== undefined && output.ServiceErrors !== null
        ? deserializeAws_json1_1ServiceErrors(output.ServiceErrors, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeStackProvisioningParametersResult = (
  output: any,
  context: __SerdeContext
): DescribeStackProvisioningParametersResult => {
  return {
    __type: "DescribeStackProvisioningParametersResult",
    AgentInstallerUrl:
      output.AgentInstallerUrl !== undefined &&
      output.AgentInstallerUrl !== null
        ? output.AgentInstallerUrl
        : undefined,
    Parameters:
      output.Parameters !== undefined && output.Parameters !== null
        ? deserializeAws_json1_1Parameters(output.Parameters, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeStacksResult = (
  output: any,
  context: __SerdeContext
): DescribeStacksResult => {
  return {
    __type: "DescribeStacksResult",
    Stacks:
      output.Stacks !== undefined && output.Stacks !== null
        ? deserializeAws_json1_1Stacks(output.Stacks, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeStackSummaryResult = (
  output: any,
  context: __SerdeContext
): DescribeStackSummaryResult => {
  return {
    __type: "DescribeStackSummaryResult",
    StackSummary:
      output.StackSummary !== undefined && output.StackSummary !== null
        ? deserializeAws_json1_1StackSummary(output.StackSummary, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeTimeBasedAutoScalingResult = (
  output: any,
  context: __SerdeContext
): DescribeTimeBasedAutoScalingResult => {
  return {
    __type: "DescribeTimeBasedAutoScalingResult",
    TimeBasedAutoScalingConfigurations:
      output.TimeBasedAutoScalingConfigurations !== undefined &&
      output.TimeBasedAutoScalingConfigurations !== null
        ? deserializeAws_json1_1TimeBasedAutoScalingConfigurations(
            output.TimeBasedAutoScalingConfigurations,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeUserProfilesResult = (
  output: any,
  context: __SerdeContext
): DescribeUserProfilesResult => {
  return {
    __type: "DescribeUserProfilesResult",
    UserProfiles:
      output.UserProfiles !== undefined && output.UserProfiles !== null
        ? deserializeAws_json1_1UserProfiles(output.UserProfiles, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeVolumesResult = (
  output: any,
  context: __SerdeContext
): DescribeVolumesResult => {
  return {
    __type: "DescribeVolumesResult",
    Volumes:
      output.Volumes !== undefined && output.Volumes !== null
        ? deserializeAws_json1_1Volumes(output.Volumes, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1EbsBlockDevice = (
  output: any,
  context: __SerdeContext
): EbsBlockDevice => {
  return {
    __type: "EbsBlockDevice",
    DeleteOnTermination:
      output.DeleteOnTermination !== undefined &&
      output.DeleteOnTermination !== null
        ? output.DeleteOnTermination
        : undefined,
    Iops:
      output.Iops !== undefined && output.Iops !== null
        ? output.Iops
        : undefined,
    SnapshotId:
      output.SnapshotId !== undefined && output.SnapshotId !== null
        ? output.SnapshotId
        : undefined,
    VolumeSize:
      output.VolumeSize !== undefined && output.VolumeSize !== null
        ? output.VolumeSize
        : undefined,
    VolumeType:
      output.VolumeType !== undefined && output.VolumeType !== null
        ? output.VolumeType
        : undefined
  } as any;
};

const deserializeAws_json1_1EcsCluster = (
  output: any,
  context: __SerdeContext
): EcsCluster => {
  return {
    __type: "EcsCluster",
    EcsClusterArn:
      output.EcsClusterArn !== undefined && output.EcsClusterArn !== null
        ? output.EcsClusterArn
        : undefined,
    EcsClusterName:
      output.EcsClusterName !== undefined && output.EcsClusterName !== null
        ? output.EcsClusterName
        : undefined,
    RegisteredAt:
      output.RegisteredAt !== undefined && output.RegisteredAt !== null
        ? output.RegisteredAt
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined
  } as any;
};

const deserializeAws_json1_1EcsClusters = (
  output: any,
  context: __SerdeContext
): EcsCluster[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EcsCluster(entry, context)
  );
};

const deserializeAws_json1_1ElasticIp = (
  output: any,
  context: __SerdeContext
): ElasticIp => {
  return {
    __type: "ElasticIp",
    Domain:
      output.Domain !== undefined && output.Domain !== null
        ? output.Domain
        : undefined,
    InstanceId:
      output.InstanceId !== undefined && output.InstanceId !== null
        ? output.InstanceId
        : undefined,
    Ip: output.Ip !== undefined && output.Ip !== null ? output.Ip : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    Region:
      output.Region !== undefined && output.Region !== null
        ? output.Region
        : undefined
  } as any;
};

const deserializeAws_json1_1ElasticIps = (
  output: any,
  context: __SerdeContext
): ElasticIp[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ElasticIp(entry, context)
  );
};

const deserializeAws_json1_1ElasticLoadBalancer = (
  output: any,
  context: __SerdeContext
): ElasticLoadBalancer => {
  return {
    __type: "ElasticLoadBalancer",
    AvailabilityZones:
      output.AvailabilityZones !== undefined &&
      output.AvailabilityZones !== null
        ? deserializeAws_json1_1Strings(output.AvailabilityZones, context)
        : undefined,
    DnsName:
      output.DnsName !== undefined && output.DnsName !== null
        ? output.DnsName
        : undefined,
    Ec2InstanceIds:
      output.Ec2InstanceIds !== undefined && output.Ec2InstanceIds !== null
        ? deserializeAws_json1_1Strings(output.Ec2InstanceIds, context)
        : undefined,
    ElasticLoadBalancerName:
      output.ElasticLoadBalancerName !== undefined &&
      output.ElasticLoadBalancerName !== null
        ? output.ElasticLoadBalancerName
        : undefined,
    LayerId:
      output.LayerId !== undefined && output.LayerId !== null
        ? output.LayerId
        : undefined,
    Region:
      output.Region !== undefined && output.Region !== null
        ? output.Region
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined,
    SubnetIds:
      output.SubnetIds !== undefined && output.SubnetIds !== null
        ? deserializeAws_json1_1Strings(output.SubnetIds, context)
        : undefined,
    VpcId:
      output.VpcId !== undefined && output.VpcId !== null
        ? output.VpcId
        : undefined
  } as any;
};

const deserializeAws_json1_1ElasticLoadBalancers = (
  output: any,
  context: __SerdeContext
): ElasticLoadBalancer[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ElasticLoadBalancer(entry, context)
  );
};

const deserializeAws_json1_1EnvironmentVariable = (
  output: any,
  context: __SerdeContext
): EnvironmentVariable => {
  return {
    __type: "EnvironmentVariable",
    Key:
      output.Key !== undefined && output.Key !== null ? output.Key : undefined,
    Secure:
      output.Secure !== undefined && output.Secure !== null
        ? output.Secure
        : undefined,
    Value:
      output.Value !== undefined && output.Value !== null
        ? output.Value
        : undefined
  } as any;
};

const deserializeAws_json1_1EnvironmentVariables = (
  output: any,
  context: __SerdeContext
): EnvironmentVariable[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EnvironmentVariable(entry, context)
  );
};

const deserializeAws_json1_1GetHostnameSuggestionResult = (
  output: any,
  context: __SerdeContext
): GetHostnameSuggestionResult => {
  return {
    __type: "GetHostnameSuggestionResult",
    Hostname:
      output.Hostname !== undefined && output.Hostname !== null
        ? output.Hostname
        : undefined,
    LayerId:
      output.LayerId !== undefined && output.LayerId !== null
        ? output.LayerId
        : undefined
  } as any;
};

const deserializeAws_json1_1GrantAccessResult = (
  output: any,
  context: __SerdeContext
): GrantAccessResult => {
  return {
    __type: "GrantAccessResult",
    TemporaryCredential:
      output.TemporaryCredential !== undefined &&
      output.TemporaryCredential !== null
        ? deserializeAws_json1_1TemporaryCredential(
            output.TemporaryCredential,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1Instance = (
  output: any,
  context: __SerdeContext
): Instance => {
  return {
    __type: "Instance",
    AgentVersion:
      output.AgentVersion !== undefined && output.AgentVersion !== null
        ? output.AgentVersion
        : undefined,
    AmiId:
      output.AmiId !== undefined && output.AmiId !== null
        ? output.AmiId
        : undefined,
    Architecture:
      output.Architecture !== undefined && output.Architecture !== null
        ? output.Architecture
        : undefined,
    Arn:
      output.Arn !== undefined && output.Arn !== null ? output.Arn : undefined,
    AutoScalingType:
      output.AutoScalingType !== undefined && output.AutoScalingType !== null
        ? output.AutoScalingType
        : undefined,
    AvailabilityZone:
      output.AvailabilityZone !== undefined && output.AvailabilityZone !== null
        ? output.AvailabilityZone
        : undefined,
    BlockDeviceMappings:
      output.BlockDeviceMappings !== undefined &&
      output.BlockDeviceMappings !== null
        ? deserializeAws_json1_1BlockDeviceMappings(
            output.BlockDeviceMappings,
            context
          )
        : undefined,
    CreatedAt:
      output.CreatedAt !== undefined && output.CreatedAt !== null
        ? output.CreatedAt
        : undefined,
    EbsOptimized:
      output.EbsOptimized !== undefined && output.EbsOptimized !== null
        ? output.EbsOptimized
        : undefined,
    Ec2InstanceId:
      output.Ec2InstanceId !== undefined && output.Ec2InstanceId !== null
        ? output.Ec2InstanceId
        : undefined,
    EcsClusterArn:
      output.EcsClusterArn !== undefined && output.EcsClusterArn !== null
        ? output.EcsClusterArn
        : undefined,
    EcsContainerInstanceArn:
      output.EcsContainerInstanceArn !== undefined &&
      output.EcsContainerInstanceArn !== null
        ? output.EcsContainerInstanceArn
        : undefined,
    ElasticIp:
      output.ElasticIp !== undefined && output.ElasticIp !== null
        ? output.ElasticIp
        : undefined,
    Hostname:
      output.Hostname !== undefined && output.Hostname !== null
        ? output.Hostname
        : undefined,
    InfrastructureClass:
      output.InfrastructureClass !== undefined &&
      output.InfrastructureClass !== null
        ? output.InfrastructureClass
        : undefined,
    InstallUpdatesOnBoot:
      output.InstallUpdatesOnBoot !== undefined &&
      output.InstallUpdatesOnBoot !== null
        ? output.InstallUpdatesOnBoot
        : undefined,
    InstanceId:
      output.InstanceId !== undefined && output.InstanceId !== null
        ? output.InstanceId
        : undefined,
    InstanceProfileArn:
      output.InstanceProfileArn !== undefined &&
      output.InstanceProfileArn !== null
        ? output.InstanceProfileArn
        : undefined,
    InstanceType:
      output.InstanceType !== undefined && output.InstanceType !== null
        ? output.InstanceType
        : undefined,
    LastServiceErrorId:
      output.LastServiceErrorId !== undefined &&
      output.LastServiceErrorId !== null
        ? output.LastServiceErrorId
        : undefined,
    LayerIds:
      output.LayerIds !== undefined && output.LayerIds !== null
        ? deserializeAws_json1_1Strings(output.LayerIds, context)
        : undefined,
    Os: output.Os !== undefined && output.Os !== null ? output.Os : undefined,
    Platform:
      output.Platform !== undefined && output.Platform !== null
        ? output.Platform
        : undefined,
    PrivateDns:
      output.PrivateDns !== undefined && output.PrivateDns !== null
        ? output.PrivateDns
        : undefined,
    PrivateIp:
      output.PrivateIp !== undefined && output.PrivateIp !== null
        ? output.PrivateIp
        : undefined,
    PublicDns:
      output.PublicDns !== undefined && output.PublicDns !== null
        ? output.PublicDns
        : undefined,
    PublicIp:
      output.PublicIp !== undefined && output.PublicIp !== null
        ? output.PublicIp
        : undefined,
    RegisteredBy:
      output.RegisteredBy !== undefined && output.RegisteredBy !== null
        ? output.RegisteredBy
        : undefined,
    ReportedAgentVersion:
      output.ReportedAgentVersion !== undefined &&
      output.ReportedAgentVersion !== null
        ? output.ReportedAgentVersion
        : undefined,
    ReportedOs:
      output.ReportedOs !== undefined && output.ReportedOs !== null
        ? deserializeAws_json1_1ReportedOs(output.ReportedOs, context)
        : undefined,
    RootDeviceType:
      output.RootDeviceType !== undefined && output.RootDeviceType !== null
        ? output.RootDeviceType
        : undefined,
    RootDeviceVolumeId:
      output.RootDeviceVolumeId !== undefined &&
      output.RootDeviceVolumeId !== null
        ? output.RootDeviceVolumeId
        : undefined,
    SecurityGroupIds:
      output.SecurityGroupIds !== undefined && output.SecurityGroupIds !== null
        ? deserializeAws_json1_1Strings(output.SecurityGroupIds, context)
        : undefined,
    SshHostDsaKeyFingerprint:
      output.SshHostDsaKeyFingerprint !== undefined &&
      output.SshHostDsaKeyFingerprint !== null
        ? output.SshHostDsaKeyFingerprint
        : undefined,
    SshHostRsaKeyFingerprint:
      output.SshHostRsaKeyFingerprint !== undefined &&
      output.SshHostRsaKeyFingerprint !== null
        ? output.SshHostRsaKeyFingerprint
        : undefined,
    SshKeyName:
      output.SshKeyName !== undefined && output.SshKeyName !== null
        ? output.SshKeyName
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined,
    Status:
      output.Status !== undefined && output.Status !== null
        ? output.Status
        : undefined,
    SubnetId:
      output.SubnetId !== undefined && output.SubnetId !== null
        ? output.SubnetId
        : undefined,
    Tenancy:
      output.Tenancy !== undefined && output.Tenancy !== null
        ? output.Tenancy
        : undefined,
    VirtualizationType:
      output.VirtualizationType !== undefined &&
      output.VirtualizationType !== null
        ? output.VirtualizationType
        : undefined
  } as any;
};

const deserializeAws_json1_1Instances = (
  output: any,
  context: __SerdeContext
): Instance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Instance(entry, context)
  );
};

const deserializeAws_json1_1InstancesCount = (
  output: any,
  context: __SerdeContext
): InstancesCount => {
  return {
    __type: "InstancesCount",
    Assigning:
      output.Assigning !== undefined && output.Assigning !== null
        ? output.Assigning
        : undefined,
    Booting:
      output.Booting !== undefined && output.Booting !== null
        ? output.Booting
        : undefined,
    ConnectionLost:
      output.ConnectionLost !== undefined && output.ConnectionLost !== null
        ? output.ConnectionLost
        : undefined,
    Deregistering:
      output.Deregistering !== undefined && output.Deregistering !== null
        ? output.Deregistering
        : undefined,
    Online:
      output.Online !== undefined && output.Online !== null
        ? output.Online
        : undefined,
    Pending:
      output.Pending !== undefined && output.Pending !== null
        ? output.Pending
        : undefined,
    Rebooting:
      output.Rebooting !== undefined && output.Rebooting !== null
        ? output.Rebooting
        : undefined,
    Registered:
      output.Registered !== undefined && output.Registered !== null
        ? output.Registered
        : undefined,
    Registering:
      output.Registering !== undefined && output.Registering !== null
        ? output.Registering
        : undefined,
    Requested:
      output.Requested !== undefined && output.Requested !== null
        ? output.Requested
        : undefined,
    RunningSetup:
      output.RunningSetup !== undefined && output.RunningSetup !== null
        ? output.RunningSetup
        : undefined,
    SetupFailed:
      output.SetupFailed !== undefined && output.SetupFailed !== null
        ? output.SetupFailed
        : undefined,
    ShuttingDown:
      output.ShuttingDown !== undefined && output.ShuttingDown !== null
        ? output.ShuttingDown
        : undefined,
    StartFailed:
      output.StartFailed !== undefined && output.StartFailed !== null
        ? output.StartFailed
        : undefined,
    StopFailed:
      output.StopFailed !== undefined && output.StopFailed !== null
        ? output.StopFailed
        : undefined,
    Stopped:
      output.Stopped !== undefined && output.Stopped !== null
        ? output.Stopped
        : undefined,
    Stopping:
      output.Stopping !== undefined && output.Stopping !== null
        ? output.Stopping
        : undefined,
    Terminated:
      output.Terminated !== undefined && output.Terminated !== null
        ? output.Terminated
        : undefined,
    Terminating:
      output.Terminating !== undefined && output.Terminating !== null
        ? output.Terminating
        : undefined,
    Unassigning:
      output.Unassigning !== undefined && output.Unassigning !== null
        ? output.Unassigning
        : undefined
  } as any;
};

const deserializeAws_json1_1Layer = (
  output: any,
  context: __SerdeContext
): Layer => {
  return {
    __type: "Layer",
    Arn:
      output.Arn !== undefined && output.Arn !== null ? output.Arn : undefined,
    Attributes:
      output.Attributes !== undefined && output.Attributes !== null
        ? deserializeAws_json1_1LayerAttributes(output.Attributes, context)
        : undefined,
    AutoAssignElasticIps:
      output.AutoAssignElasticIps !== undefined &&
      output.AutoAssignElasticIps !== null
        ? output.AutoAssignElasticIps
        : undefined,
    AutoAssignPublicIps:
      output.AutoAssignPublicIps !== undefined &&
      output.AutoAssignPublicIps !== null
        ? output.AutoAssignPublicIps
        : undefined,
    CloudWatchLogsConfiguration:
      output.CloudWatchLogsConfiguration !== undefined &&
      output.CloudWatchLogsConfiguration !== null
        ? deserializeAws_json1_1CloudWatchLogsConfiguration(
            output.CloudWatchLogsConfiguration,
            context
          )
        : undefined,
    CreatedAt:
      output.CreatedAt !== undefined && output.CreatedAt !== null
        ? output.CreatedAt
        : undefined,
    CustomInstanceProfileArn:
      output.CustomInstanceProfileArn !== undefined &&
      output.CustomInstanceProfileArn !== null
        ? output.CustomInstanceProfileArn
        : undefined,
    CustomJson:
      output.CustomJson !== undefined && output.CustomJson !== null
        ? output.CustomJson
        : undefined,
    CustomRecipes:
      output.CustomRecipes !== undefined && output.CustomRecipes !== null
        ? deserializeAws_json1_1Recipes(output.CustomRecipes, context)
        : undefined,
    CustomSecurityGroupIds:
      output.CustomSecurityGroupIds !== undefined &&
      output.CustomSecurityGroupIds !== null
        ? deserializeAws_json1_1Strings(output.CustomSecurityGroupIds, context)
        : undefined,
    DefaultRecipes:
      output.DefaultRecipes !== undefined && output.DefaultRecipes !== null
        ? deserializeAws_json1_1Recipes(output.DefaultRecipes, context)
        : undefined,
    DefaultSecurityGroupNames:
      output.DefaultSecurityGroupNames !== undefined &&
      output.DefaultSecurityGroupNames !== null
        ? deserializeAws_json1_1Strings(
            output.DefaultSecurityGroupNames,
            context
          )
        : undefined,
    EnableAutoHealing:
      output.EnableAutoHealing !== undefined &&
      output.EnableAutoHealing !== null
        ? output.EnableAutoHealing
        : undefined,
    InstallUpdatesOnBoot:
      output.InstallUpdatesOnBoot !== undefined &&
      output.InstallUpdatesOnBoot !== null
        ? output.InstallUpdatesOnBoot
        : undefined,
    LayerId:
      output.LayerId !== undefined && output.LayerId !== null
        ? output.LayerId
        : undefined,
    LifecycleEventConfiguration:
      output.LifecycleEventConfiguration !== undefined &&
      output.LifecycleEventConfiguration !== null
        ? deserializeAws_json1_1LifecycleEventConfiguration(
            output.LifecycleEventConfiguration,
            context
          )
        : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    Packages:
      output.Packages !== undefined && output.Packages !== null
        ? deserializeAws_json1_1Strings(output.Packages, context)
        : undefined,
    Shortname:
      output.Shortname !== undefined && output.Shortname !== null
        ? output.Shortname
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined,
    Type:
      output.Type !== undefined && output.Type !== null
        ? output.Type
        : undefined,
    UseEbsOptimizedInstances:
      output.UseEbsOptimizedInstances !== undefined &&
      output.UseEbsOptimizedInstances !== null
        ? output.UseEbsOptimizedInstances
        : undefined,
    VolumeConfigurations:
      output.VolumeConfigurations !== undefined &&
      output.VolumeConfigurations !== null
        ? deserializeAws_json1_1VolumeConfigurations(
            output.VolumeConfigurations,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1LayerAttributes = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (
      acc: { [key: string]: string },
      [key, value]: [LayerAttributesKeys | string, any]
    ) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const deserializeAws_json1_1Layers = (
  output: any,
  context: __SerdeContext
): Layer[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Layer(entry, context)
  );
};

const deserializeAws_json1_1LifecycleEventConfiguration = (
  output: any,
  context: __SerdeContext
): LifecycleEventConfiguration => {
  return {
    __type: "LifecycleEventConfiguration",
    Shutdown:
      output.Shutdown !== undefined && output.Shutdown !== null
        ? deserializeAws_json1_1ShutdownEventConfiguration(
            output.Shutdown,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1ListTagsResult = (
  output: any,
  context: __SerdeContext
): ListTagsResult => {
  return {
    __type: "ListTagsResult",
    NextToken:
      output.NextToken !== undefined && output.NextToken !== null
        ? output.NextToken
        : undefined,
    Tags:
      output.Tags !== undefined && output.Tags !== null
        ? deserializeAws_json1_1Tags(output.Tags, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1LoadBasedAutoScalingConfiguration = (
  output: any,
  context: __SerdeContext
): LoadBasedAutoScalingConfiguration => {
  return {
    __type: "LoadBasedAutoScalingConfiguration",
    DownScaling:
      output.DownScaling !== undefined && output.DownScaling !== null
        ? deserializeAws_json1_1AutoScalingThresholds(
            output.DownScaling,
            context
          )
        : undefined,
    Enable:
      output.Enable !== undefined && output.Enable !== null
        ? output.Enable
        : undefined,
    LayerId:
      output.LayerId !== undefined && output.LayerId !== null
        ? output.LayerId
        : undefined,
    UpScaling:
      output.UpScaling !== undefined && output.UpScaling !== null
        ? deserializeAws_json1_1AutoScalingThresholds(output.UpScaling, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1LoadBasedAutoScalingConfigurations = (
  output: any,
  context: __SerdeContext
): LoadBasedAutoScalingConfiguration[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1LoadBasedAutoScalingConfiguration(entry, context)
  );
};

const deserializeAws_json1_1OperatingSystem = (
  output: any,
  context: __SerdeContext
): OperatingSystem => {
  return {
    __type: "OperatingSystem",
    ConfigurationManagers:
      output.ConfigurationManagers !== undefined &&
      output.ConfigurationManagers !== null
        ? deserializeAws_json1_1OperatingSystemConfigurationManagers(
            output.ConfigurationManagers,
            context
          )
        : undefined,
    Id: output.Id !== undefined && output.Id !== null ? output.Id : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    ReportedName:
      output.ReportedName !== undefined && output.ReportedName !== null
        ? output.ReportedName
        : undefined,
    ReportedVersion:
      output.ReportedVersion !== undefined && output.ReportedVersion !== null
        ? output.ReportedVersion
        : undefined,
    Supported:
      output.Supported !== undefined && output.Supported !== null
        ? output.Supported
        : undefined,
    Type:
      output.Type !== undefined && output.Type !== null
        ? output.Type
        : undefined
  } as any;
};

const deserializeAws_json1_1OperatingSystemConfigurationManager = (
  output: any,
  context: __SerdeContext
): OperatingSystemConfigurationManager => {
  return {
    __type: "OperatingSystemConfigurationManager",
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    Version:
      output.Version !== undefined && output.Version !== null
        ? output.Version
        : undefined
  } as any;
};

const deserializeAws_json1_1OperatingSystemConfigurationManagers = (
  output: any,
  context: __SerdeContext
): OperatingSystemConfigurationManager[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1OperatingSystemConfigurationManager(entry, context)
  );
};

const deserializeAws_json1_1OperatingSystems = (
  output: any,
  context: __SerdeContext
): OperatingSystem[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1OperatingSystem(entry, context)
  );
};

const deserializeAws_json1_1Parameters = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const deserializeAws_json1_1Permission = (
  output: any,
  context: __SerdeContext
): Permission => {
  return {
    __type: "Permission",
    AllowSsh:
      output.AllowSsh !== undefined && output.AllowSsh !== null
        ? output.AllowSsh
        : undefined,
    AllowSudo:
      output.AllowSudo !== undefined && output.AllowSudo !== null
        ? output.AllowSudo
        : undefined,
    IamUserArn:
      output.IamUserArn !== undefined && output.IamUserArn !== null
        ? output.IamUserArn
        : undefined,
    Level:
      output.Level !== undefined && output.Level !== null
        ? output.Level
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined
  } as any;
};

const deserializeAws_json1_1Permissions = (
  output: any,
  context: __SerdeContext
): Permission[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Permission(entry, context)
  );
};

const deserializeAws_json1_1RaidArray = (
  output: any,
  context: __SerdeContext
): RaidArray => {
  return {
    __type: "RaidArray",
    AvailabilityZone:
      output.AvailabilityZone !== undefined && output.AvailabilityZone !== null
        ? output.AvailabilityZone
        : undefined,
    CreatedAt:
      output.CreatedAt !== undefined && output.CreatedAt !== null
        ? output.CreatedAt
        : undefined,
    Device:
      output.Device !== undefined && output.Device !== null
        ? output.Device
        : undefined,
    InstanceId:
      output.InstanceId !== undefined && output.InstanceId !== null
        ? output.InstanceId
        : undefined,
    Iops:
      output.Iops !== undefined && output.Iops !== null
        ? output.Iops
        : undefined,
    MountPoint:
      output.MountPoint !== undefined && output.MountPoint !== null
        ? output.MountPoint
        : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    NumberOfDisks:
      output.NumberOfDisks !== undefined && output.NumberOfDisks !== null
        ? output.NumberOfDisks
        : undefined,
    RaidArrayId:
      output.RaidArrayId !== undefined && output.RaidArrayId !== null
        ? output.RaidArrayId
        : undefined,
    RaidLevel:
      output.RaidLevel !== undefined && output.RaidLevel !== null
        ? output.RaidLevel
        : undefined,
    Size:
      output.Size !== undefined && output.Size !== null
        ? output.Size
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined,
    VolumeType:
      output.VolumeType !== undefined && output.VolumeType !== null
        ? output.VolumeType
        : undefined
  } as any;
};

const deserializeAws_json1_1RaidArrays = (
  output: any,
  context: __SerdeContext
): RaidArray[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RaidArray(entry, context)
  );
};

const deserializeAws_json1_1RdsDbInstance = (
  output: any,
  context: __SerdeContext
): RdsDbInstance => {
  return {
    __type: "RdsDbInstance",
    Address:
      output.Address !== undefined && output.Address !== null
        ? output.Address
        : undefined,
    DbInstanceIdentifier:
      output.DbInstanceIdentifier !== undefined &&
      output.DbInstanceIdentifier !== null
        ? output.DbInstanceIdentifier
        : undefined,
    DbPassword:
      output.DbPassword !== undefined && output.DbPassword !== null
        ? output.DbPassword
        : undefined,
    DbUser:
      output.DbUser !== undefined && output.DbUser !== null
        ? output.DbUser
        : undefined,
    Engine:
      output.Engine !== undefined && output.Engine !== null
        ? output.Engine
        : undefined,
    MissingOnRds:
      output.MissingOnRds !== undefined && output.MissingOnRds !== null
        ? output.MissingOnRds
        : undefined,
    RdsDbInstanceArn:
      output.RdsDbInstanceArn !== undefined && output.RdsDbInstanceArn !== null
        ? output.RdsDbInstanceArn
        : undefined,
    Region:
      output.Region !== undefined && output.Region !== null
        ? output.Region
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined
  } as any;
};

const deserializeAws_json1_1RdsDbInstances = (
  output: any,
  context: __SerdeContext
): RdsDbInstance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1RdsDbInstance(entry, context)
  );
};

const deserializeAws_json1_1Recipes = (
  output: any,
  context: __SerdeContext
): Recipes => {
  return {
    __type: "Recipes",
    Configure:
      output.Configure !== undefined && output.Configure !== null
        ? deserializeAws_json1_1Strings(output.Configure, context)
        : undefined,
    Deploy:
      output.Deploy !== undefined && output.Deploy !== null
        ? deserializeAws_json1_1Strings(output.Deploy, context)
        : undefined,
    Setup:
      output.Setup !== undefined && output.Setup !== null
        ? deserializeAws_json1_1Strings(output.Setup, context)
        : undefined,
    Shutdown:
      output.Shutdown !== undefined && output.Shutdown !== null
        ? deserializeAws_json1_1Strings(output.Shutdown, context)
        : undefined,
    Undeploy:
      output.Undeploy !== undefined && output.Undeploy !== null
        ? deserializeAws_json1_1Strings(output.Undeploy, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1RegisterEcsClusterResult = (
  output: any,
  context: __SerdeContext
): RegisterEcsClusterResult => {
  return {
    __type: "RegisterEcsClusterResult",
    EcsClusterArn:
      output.EcsClusterArn !== undefined && output.EcsClusterArn !== null
        ? output.EcsClusterArn
        : undefined
  } as any;
};

const deserializeAws_json1_1RegisterElasticIpResult = (
  output: any,
  context: __SerdeContext
): RegisterElasticIpResult => {
  return {
    __type: "RegisterElasticIpResult",
    ElasticIp:
      output.ElasticIp !== undefined && output.ElasticIp !== null
        ? output.ElasticIp
        : undefined
  } as any;
};

const deserializeAws_json1_1RegisterInstanceResult = (
  output: any,
  context: __SerdeContext
): RegisterInstanceResult => {
  return {
    __type: "RegisterInstanceResult",
    InstanceId:
      output.InstanceId !== undefined && output.InstanceId !== null
        ? output.InstanceId
        : undefined
  } as any;
};

const deserializeAws_json1_1RegisterVolumeResult = (
  output: any,
  context: __SerdeContext
): RegisterVolumeResult => {
  return {
    __type: "RegisterVolumeResult",
    VolumeId:
      output.VolumeId !== undefined && output.VolumeId !== null
        ? output.VolumeId
        : undefined
  } as any;
};

const deserializeAws_json1_1ReportedOs = (
  output: any,
  context: __SerdeContext
): ReportedOs => {
  return {
    __type: "ReportedOs",
    Family:
      output.Family !== undefined && output.Family !== null
        ? output.Family
        : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    Version:
      output.Version !== undefined && output.Version !== null
        ? output.Version
        : undefined
  } as any;
};

const deserializeAws_json1_1ResourceNotFoundException = (
  output: any,
  context: __SerdeContext
): ResourceNotFoundException => {
  return {
    __type: "ResourceNotFoundException",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1SelfUserProfile = (
  output: any,
  context: __SerdeContext
): SelfUserProfile => {
  return {
    __type: "SelfUserProfile",
    IamUserArn:
      output.IamUserArn !== undefined && output.IamUserArn !== null
        ? output.IamUserArn
        : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    SshPublicKey:
      output.SshPublicKey !== undefined && output.SshPublicKey !== null
        ? output.SshPublicKey
        : undefined,
    SshUsername:
      output.SshUsername !== undefined && output.SshUsername !== null
        ? output.SshUsername
        : undefined
  } as any;
};

const deserializeAws_json1_1ServiceError = (
  output: any,
  context: __SerdeContext
): ServiceError => {
  return {
    __type: "ServiceError",
    CreatedAt:
      output.CreatedAt !== undefined && output.CreatedAt !== null
        ? output.CreatedAt
        : undefined,
    InstanceId:
      output.InstanceId !== undefined && output.InstanceId !== null
        ? output.InstanceId
        : undefined,
    Message:
      output.Message !== undefined && output.Message !== null
        ? output.Message
        : undefined,
    ServiceErrorId:
      output.ServiceErrorId !== undefined && output.ServiceErrorId !== null
        ? output.ServiceErrorId
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined,
    Type:
      output.Type !== undefined && output.Type !== null
        ? output.Type
        : undefined
  } as any;
};

const deserializeAws_json1_1ServiceErrors = (
  output: any,
  context: __SerdeContext
): ServiceError[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ServiceError(entry, context)
  );
};

const deserializeAws_json1_1ShutdownEventConfiguration = (
  output: any,
  context: __SerdeContext
): ShutdownEventConfiguration => {
  return {
    __type: "ShutdownEventConfiguration",
    DelayUntilElbConnectionsDrained:
      output.DelayUntilElbConnectionsDrained !== undefined &&
      output.DelayUntilElbConnectionsDrained !== null
        ? output.DelayUntilElbConnectionsDrained
        : undefined,
    ExecutionTimeout:
      output.ExecutionTimeout !== undefined && output.ExecutionTimeout !== null
        ? output.ExecutionTimeout
        : undefined
  } as any;
};

const deserializeAws_json1_1Source = (
  output: any,
  context: __SerdeContext
): Source => {
  return {
    __type: "Source",
    Password:
      output.Password !== undefined && output.Password !== null
        ? output.Password
        : undefined,
    Revision:
      output.Revision !== undefined && output.Revision !== null
        ? output.Revision
        : undefined,
    SshKey:
      output.SshKey !== undefined && output.SshKey !== null
        ? output.SshKey
        : undefined,
    Type:
      output.Type !== undefined && output.Type !== null
        ? output.Type
        : undefined,
    Url:
      output.Url !== undefined && output.Url !== null ? output.Url : undefined,
    Username:
      output.Username !== undefined && output.Username !== null
        ? output.Username
        : undefined
  } as any;
};

const deserializeAws_json1_1SslConfiguration = (
  output: any,
  context: __SerdeContext
): SslConfiguration => {
  return {
    __type: "SslConfiguration",
    Certificate:
      output.Certificate !== undefined && output.Certificate !== null
        ? output.Certificate
        : undefined,
    Chain:
      output.Chain !== undefined && output.Chain !== null
        ? output.Chain
        : undefined,
    PrivateKey:
      output.PrivateKey !== undefined && output.PrivateKey !== null
        ? output.PrivateKey
        : undefined
  } as any;
};

const deserializeAws_json1_1Stack = (
  output: any,
  context: __SerdeContext
): Stack => {
  return {
    __type: "Stack",
    AgentVersion:
      output.AgentVersion !== undefined && output.AgentVersion !== null
        ? output.AgentVersion
        : undefined,
    Arn:
      output.Arn !== undefined && output.Arn !== null ? output.Arn : undefined,
    Attributes:
      output.Attributes !== undefined && output.Attributes !== null
        ? deserializeAws_json1_1StackAttributes(output.Attributes, context)
        : undefined,
    ChefConfiguration:
      output.ChefConfiguration !== undefined &&
      output.ChefConfiguration !== null
        ? deserializeAws_json1_1ChefConfiguration(
            output.ChefConfiguration,
            context
          )
        : undefined,
    ConfigurationManager:
      output.ConfigurationManager !== undefined &&
      output.ConfigurationManager !== null
        ? deserializeAws_json1_1StackConfigurationManager(
            output.ConfigurationManager,
            context
          )
        : undefined,
    CreatedAt:
      output.CreatedAt !== undefined && output.CreatedAt !== null
        ? output.CreatedAt
        : undefined,
    CustomCookbooksSource:
      output.CustomCookbooksSource !== undefined &&
      output.CustomCookbooksSource !== null
        ? deserializeAws_json1_1Source(output.CustomCookbooksSource, context)
        : undefined,
    CustomJson:
      output.CustomJson !== undefined && output.CustomJson !== null
        ? output.CustomJson
        : undefined,
    DefaultAvailabilityZone:
      output.DefaultAvailabilityZone !== undefined &&
      output.DefaultAvailabilityZone !== null
        ? output.DefaultAvailabilityZone
        : undefined,
    DefaultInstanceProfileArn:
      output.DefaultInstanceProfileArn !== undefined &&
      output.DefaultInstanceProfileArn !== null
        ? output.DefaultInstanceProfileArn
        : undefined,
    DefaultOs:
      output.DefaultOs !== undefined && output.DefaultOs !== null
        ? output.DefaultOs
        : undefined,
    DefaultRootDeviceType:
      output.DefaultRootDeviceType !== undefined &&
      output.DefaultRootDeviceType !== null
        ? output.DefaultRootDeviceType
        : undefined,
    DefaultSshKeyName:
      output.DefaultSshKeyName !== undefined &&
      output.DefaultSshKeyName !== null
        ? output.DefaultSshKeyName
        : undefined,
    DefaultSubnetId:
      output.DefaultSubnetId !== undefined && output.DefaultSubnetId !== null
        ? output.DefaultSubnetId
        : undefined,
    HostnameTheme:
      output.HostnameTheme !== undefined && output.HostnameTheme !== null
        ? output.HostnameTheme
        : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    Region:
      output.Region !== undefined && output.Region !== null
        ? output.Region
        : undefined,
    ServiceRoleArn:
      output.ServiceRoleArn !== undefined && output.ServiceRoleArn !== null
        ? output.ServiceRoleArn
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined,
    UseCustomCookbooks:
      output.UseCustomCookbooks !== undefined &&
      output.UseCustomCookbooks !== null
        ? output.UseCustomCookbooks
        : undefined,
    UseOpsworksSecurityGroups:
      output.UseOpsworksSecurityGroups !== undefined &&
      output.UseOpsworksSecurityGroups !== null
        ? output.UseOpsworksSecurityGroups
        : undefined,
    VpcId:
      output.VpcId !== undefined && output.VpcId !== null
        ? output.VpcId
        : undefined
  } as any;
};

const deserializeAws_json1_1StackAttributes = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (
      acc: { [key: string]: string },
      [key, value]: [StackAttributesKeys | string, any]
    ) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const deserializeAws_json1_1StackConfigurationManager = (
  output: any,
  context: __SerdeContext
): StackConfigurationManager => {
  return {
    __type: "StackConfigurationManager",
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    Version:
      output.Version !== undefined && output.Version !== null
        ? output.Version
        : undefined
  } as any;
};

const deserializeAws_json1_1Stacks = (
  output: any,
  context: __SerdeContext
): Stack[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Stack(entry, context)
  );
};

const deserializeAws_json1_1StackSummary = (
  output: any,
  context: __SerdeContext
): StackSummary => {
  return {
    __type: "StackSummary",
    AppsCount:
      output.AppsCount !== undefined && output.AppsCount !== null
        ? output.AppsCount
        : undefined,
    Arn:
      output.Arn !== undefined && output.Arn !== null ? output.Arn : undefined,
    InstancesCount:
      output.InstancesCount !== undefined && output.InstancesCount !== null
        ? deserializeAws_json1_1InstancesCount(output.InstancesCount, context)
        : undefined,
    LayersCount:
      output.LayersCount !== undefined && output.LayersCount !== null
        ? output.LayersCount
        : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    StackId:
      output.StackId !== undefined && output.StackId !== null
        ? output.StackId
        : undefined
  } as any;
};

const deserializeAws_json1_1Strings = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Tags = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: string }, [key, value]: [string, any]) => ({
      ...acc,
      [key]: value
    }),
    {}
  );
};

const deserializeAws_json1_1TemporaryCredential = (
  output: any,
  context: __SerdeContext
): TemporaryCredential => {
  return {
    __type: "TemporaryCredential",
    InstanceId:
      output.InstanceId !== undefined && output.InstanceId !== null
        ? output.InstanceId
        : undefined,
    Password:
      output.Password !== undefined && output.Password !== null
        ? output.Password
        : undefined,
    Username:
      output.Username !== undefined && output.Username !== null
        ? output.Username
        : undefined,
    ValidForInMinutes:
      output.ValidForInMinutes !== undefined &&
      output.ValidForInMinutes !== null
        ? output.ValidForInMinutes
        : undefined
  } as any;
};

const deserializeAws_json1_1TimeBasedAutoScalingConfiguration = (
  output: any,
  context: __SerdeContext
): TimeBasedAutoScalingConfiguration => {
  return {
    __type: "TimeBasedAutoScalingConfiguration",
    AutoScalingSchedule:
      output.AutoScalingSchedule !== undefined &&
      output.AutoScalingSchedule !== null
        ? deserializeAws_json1_1WeeklyAutoScalingSchedule(
            output.AutoScalingSchedule,
            context
          )
        : undefined,
    InstanceId:
      output.InstanceId !== undefined && output.InstanceId !== null
        ? output.InstanceId
        : undefined
  } as any;
};

const deserializeAws_json1_1TimeBasedAutoScalingConfigurations = (
  output: any,
  context: __SerdeContext
): TimeBasedAutoScalingConfiguration[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TimeBasedAutoScalingConfiguration(entry, context)
  );
};

const deserializeAws_json1_1UserProfile = (
  output: any,
  context: __SerdeContext
): UserProfile => {
  return {
    __type: "UserProfile",
    AllowSelfManagement:
      output.AllowSelfManagement !== undefined &&
      output.AllowSelfManagement !== null
        ? output.AllowSelfManagement
        : undefined,
    IamUserArn:
      output.IamUserArn !== undefined && output.IamUserArn !== null
        ? output.IamUserArn
        : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    SshPublicKey:
      output.SshPublicKey !== undefined && output.SshPublicKey !== null
        ? output.SshPublicKey
        : undefined,
    SshUsername:
      output.SshUsername !== undefined && output.SshUsername !== null
        ? output.SshUsername
        : undefined
  } as any;
};

const deserializeAws_json1_1UserProfiles = (
  output: any,
  context: __SerdeContext
): UserProfile[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1UserProfile(entry, context)
  );
};

const deserializeAws_json1_1ValidationException = (
  output: any,
  context: __SerdeContext
): ValidationException => {
  return {
    __type: "ValidationException",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1Volume = (
  output: any,
  context: __SerdeContext
): Volume => {
  return {
    __type: "Volume",
    AvailabilityZone:
      output.AvailabilityZone !== undefined && output.AvailabilityZone !== null
        ? output.AvailabilityZone
        : undefined,
    Device:
      output.Device !== undefined && output.Device !== null
        ? output.Device
        : undefined,
    Ec2VolumeId:
      output.Ec2VolumeId !== undefined && output.Ec2VolumeId !== null
        ? output.Ec2VolumeId
        : undefined,
    Encrypted:
      output.Encrypted !== undefined && output.Encrypted !== null
        ? output.Encrypted
        : undefined,
    InstanceId:
      output.InstanceId !== undefined && output.InstanceId !== null
        ? output.InstanceId
        : undefined,
    Iops:
      output.Iops !== undefined && output.Iops !== null
        ? output.Iops
        : undefined,
    MountPoint:
      output.MountPoint !== undefined && output.MountPoint !== null
        ? output.MountPoint
        : undefined,
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined,
    RaidArrayId:
      output.RaidArrayId !== undefined && output.RaidArrayId !== null
        ? output.RaidArrayId
        : undefined,
    Region:
      output.Region !== undefined && output.Region !== null
        ? output.Region
        : undefined,
    Size:
      output.Size !== undefined && output.Size !== null
        ? output.Size
        : undefined,
    Status:
      output.Status !== undefined && output.Status !== null
        ? output.Status
        : undefined,
    VolumeId:
      output.VolumeId !== undefined && output.VolumeId !== null
        ? output.VolumeId
        : undefined,
    VolumeType:
      output.VolumeType !== undefined && output.VolumeType !== null
        ? output.VolumeType
        : undefined
  } as any;
};

const deserializeAws_json1_1VolumeConfiguration = (
  output: any,
  context: __SerdeContext
): VolumeConfiguration => {
  return {
    __type: "VolumeConfiguration",
    Encrypted:
      output.Encrypted !== undefined && output.Encrypted !== null
        ? output.Encrypted
        : undefined,
    Iops:
      output.Iops !== undefined && output.Iops !== null
        ? output.Iops
        : undefined,
    MountPoint:
      output.MountPoint !== undefined && output.MountPoint !== null
        ? output.MountPoint
        : undefined,
    NumberOfDisks:
      output.NumberOfDisks !== undefined && output.NumberOfDisks !== null
        ? output.NumberOfDisks
        : undefined,
    RaidLevel:
      output.RaidLevel !== undefined && output.RaidLevel !== null
        ? output.RaidLevel
        : undefined,
    Size:
      output.Size !== undefined && output.Size !== null
        ? output.Size
        : undefined,
    VolumeType:
      output.VolumeType !== undefined && output.VolumeType !== null
        ? output.VolumeType
        : undefined
  } as any;
};

const deserializeAws_json1_1VolumeConfigurations = (
  output: any,
  context: __SerdeContext
): VolumeConfiguration[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1VolumeConfiguration(entry, context)
  );
};

const deserializeAws_json1_1Volumes = (
  output: any,
  context: __SerdeContext
): Volume[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Volume(entry, context)
  );
};

const deserializeAws_json1_1WeeklyAutoScalingSchedule = (
  output: any,
  context: __SerdeContext
): WeeklyAutoScalingSchedule => {
  return {
    __type: "WeeklyAutoScalingSchedule",
    Friday:
      output.Friday !== undefined && output.Friday !== null
        ? deserializeAws_json1_1DailyAutoScalingSchedule(output.Friday, context)
        : undefined,
    Monday:
      output.Monday !== undefined && output.Monday !== null
        ? deserializeAws_json1_1DailyAutoScalingSchedule(output.Monday, context)
        : undefined,
    Saturday:
      output.Saturday !== undefined && output.Saturday !== null
        ? deserializeAws_json1_1DailyAutoScalingSchedule(
            output.Saturday,
            context
          )
        : undefined,
    Sunday:
      output.Sunday !== undefined && output.Sunday !== null
        ? deserializeAws_json1_1DailyAutoScalingSchedule(output.Sunday, context)
        : undefined,
    Thursday:
      output.Thursday !== undefined && output.Thursday !== null
        ? deserializeAws_json1_1DailyAutoScalingSchedule(
            output.Thursday,
            context
          )
        : undefined,
    Tuesday:
      output.Tuesday !== undefined && output.Tuesday !== null
        ? deserializeAws_json1_1DailyAutoScalingSchedule(
            output.Tuesday,
            context
          )
        : undefined,
    Wednesday:
      output.Wednesday !== undefined && output.Wednesday !== null
        ? deserializeAws_json1_1DailyAutoScalingSchedule(
            output.Wednesday,
            context
          )
        : undefined
  } as any;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any = new Uint8Array(),
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> =>
  collectBody(streamBody, context).then(body => context.utf8Encoder(body));

const buildHttpRpcRequest = async (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port } = await context.endpoint();
  const contents: any = {
    protocol,
    hostname,
    port,
    method: "POST",
    path,
    headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
