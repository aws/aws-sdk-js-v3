import {
  CancelIngestionCommandInput,
  CancelIngestionCommandOutput
} from "../commands/CancelIngestionCommand";
import {
  CreateDashboardCommandInput,
  CreateDashboardCommandOutput
} from "../commands/CreateDashboardCommand";
import {
  CreateDataSetCommandInput,
  CreateDataSetCommandOutput
} from "../commands/CreateDataSetCommand";
import {
  CreateDataSourceCommandInput,
  CreateDataSourceCommandOutput
} from "../commands/CreateDataSourceCommand";
import {
  CreateGroupCommandInput,
  CreateGroupCommandOutput
} from "../commands/CreateGroupCommand";
import {
  CreateGroupMembershipCommandInput,
  CreateGroupMembershipCommandOutput
} from "../commands/CreateGroupMembershipCommand";
import {
  CreateIAMPolicyAssignmentCommandInput,
  CreateIAMPolicyAssignmentCommandOutput
} from "../commands/CreateIAMPolicyAssignmentCommand";
import {
  CreateIngestionCommandInput,
  CreateIngestionCommandOutput
} from "../commands/CreateIngestionCommand";
import {
  CreateTemplateAliasCommandInput,
  CreateTemplateAliasCommandOutput
} from "../commands/CreateTemplateAliasCommand";
import {
  CreateTemplateCommandInput,
  CreateTemplateCommandOutput
} from "../commands/CreateTemplateCommand";
import {
  DeleteDashboardCommandInput,
  DeleteDashboardCommandOutput
} from "../commands/DeleteDashboardCommand";
import {
  DeleteDataSetCommandInput,
  DeleteDataSetCommandOutput
} from "../commands/DeleteDataSetCommand";
import {
  DeleteDataSourceCommandInput,
  DeleteDataSourceCommandOutput
} from "../commands/DeleteDataSourceCommand";
import {
  DeleteGroupCommandInput,
  DeleteGroupCommandOutput
} from "../commands/DeleteGroupCommand";
import {
  DeleteGroupMembershipCommandInput,
  DeleteGroupMembershipCommandOutput
} from "../commands/DeleteGroupMembershipCommand";
import {
  DeleteIAMPolicyAssignmentCommandInput,
  DeleteIAMPolicyAssignmentCommandOutput
} from "../commands/DeleteIAMPolicyAssignmentCommand";
import {
  DeleteTemplateAliasCommandInput,
  DeleteTemplateAliasCommandOutput
} from "../commands/DeleteTemplateAliasCommand";
import {
  DeleteTemplateCommandInput,
  DeleteTemplateCommandOutput
} from "../commands/DeleteTemplateCommand";
import {
  DeleteUserByPrincipalIdCommandInput,
  DeleteUserByPrincipalIdCommandOutput
} from "../commands/DeleteUserByPrincipalIdCommand";
import {
  DeleteUserCommandInput,
  DeleteUserCommandOutput
} from "../commands/DeleteUserCommand";
import {
  DescribeDashboardCommandInput,
  DescribeDashboardCommandOutput
} from "../commands/DescribeDashboardCommand";
import {
  DescribeDashboardPermissionsCommandInput,
  DescribeDashboardPermissionsCommandOutput
} from "../commands/DescribeDashboardPermissionsCommand";
import {
  DescribeDataSetCommandInput,
  DescribeDataSetCommandOutput
} from "../commands/DescribeDataSetCommand";
import {
  DescribeDataSetPermissionsCommandInput,
  DescribeDataSetPermissionsCommandOutput
} from "../commands/DescribeDataSetPermissionsCommand";
import {
  DescribeDataSourceCommandInput,
  DescribeDataSourceCommandOutput
} from "../commands/DescribeDataSourceCommand";
import {
  DescribeDataSourcePermissionsCommandInput,
  DescribeDataSourcePermissionsCommandOutput
} from "../commands/DescribeDataSourcePermissionsCommand";
import {
  DescribeGroupCommandInput,
  DescribeGroupCommandOutput
} from "../commands/DescribeGroupCommand";
import {
  DescribeIAMPolicyAssignmentCommandInput,
  DescribeIAMPolicyAssignmentCommandOutput
} from "../commands/DescribeIAMPolicyAssignmentCommand";
import {
  DescribeIngestionCommandInput,
  DescribeIngestionCommandOutput
} from "../commands/DescribeIngestionCommand";
import {
  DescribeTemplateAliasCommandInput,
  DescribeTemplateAliasCommandOutput
} from "../commands/DescribeTemplateAliasCommand";
import {
  DescribeTemplateCommandInput,
  DescribeTemplateCommandOutput
} from "../commands/DescribeTemplateCommand";
import {
  DescribeTemplatePermissionsCommandInput,
  DescribeTemplatePermissionsCommandOutput
} from "../commands/DescribeTemplatePermissionsCommand";
import {
  DescribeUserCommandInput,
  DescribeUserCommandOutput
} from "../commands/DescribeUserCommand";
import {
  GetDashboardEmbedUrlCommandInput,
  GetDashboardEmbedUrlCommandOutput
} from "../commands/GetDashboardEmbedUrlCommand";
import {
  ListDashboardVersionsCommandInput,
  ListDashboardVersionsCommandOutput
} from "../commands/ListDashboardVersionsCommand";
import {
  ListDashboardsCommandInput,
  ListDashboardsCommandOutput
} from "../commands/ListDashboardsCommand";
import {
  ListDataSetsCommandInput,
  ListDataSetsCommandOutput
} from "../commands/ListDataSetsCommand";
import {
  ListDataSourcesCommandInput,
  ListDataSourcesCommandOutput
} from "../commands/ListDataSourcesCommand";
import {
  ListGroupMembershipsCommandInput,
  ListGroupMembershipsCommandOutput
} from "../commands/ListGroupMembershipsCommand";
import {
  ListGroupsCommandInput,
  ListGroupsCommandOutput
} from "../commands/ListGroupsCommand";
import {
  ListIAMPolicyAssignmentsCommandInput,
  ListIAMPolicyAssignmentsCommandOutput
} from "../commands/ListIAMPolicyAssignmentsCommand";
import {
  ListIAMPolicyAssignmentsForUserCommandInput,
  ListIAMPolicyAssignmentsForUserCommandOutput
} from "../commands/ListIAMPolicyAssignmentsForUserCommand";
import {
  ListIngestionsCommandInput,
  ListIngestionsCommandOutput
} from "../commands/ListIngestionsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ListTemplateAliasesCommandInput,
  ListTemplateAliasesCommandOutput
} from "../commands/ListTemplateAliasesCommand";
import {
  ListTemplateVersionsCommandInput,
  ListTemplateVersionsCommandOutput
} from "../commands/ListTemplateVersionsCommand";
import {
  ListTemplatesCommandInput,
  ListTemplatesCommandOutput
} from "../commands/ListTemplatesCommand";
import {
  ListUserGroupsCommandInput,
  ListUserGroupsCommandOutput
} from "../commands/ListUserGroupsCommand";
import {
  ListUsersCommandInput,
  ListUsersCommandOutput
} from "../commands/ListUsersCommand";
import {
  RegisterUserCommandInput,
  RegisterUserCommandOutput
} from "../commands/RegisterUserCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateDashboardCommandInput,
  UpdateDashboardCommandOutput
} from "../commands/UpdateDashboardCommand";
import {
  UpdateDashboardPermissionsCommandInput,
  UpdateDashboardPermissionsCommandOutput
} from "../commands/UpdateDashboardPermissionsCommand";
import {
  UpdateDashboardPublishedVersionCommandInput,
  UpdateDashboardPublishedVersionCommandOutput
} from "../commands/UpdateDashboardPublishedVersionCommand";
import {
  UpdateDataSetCommandInput,
  UpdateDataSetCommandOutput
} from "../commands/UpdateDataSetCommand";
import {
  UpdateDataSetPermissionsCommandInput,
  UpdateDataSetPermissionsCommandOutput
} from "../commands/UpdateDataSetPermissionsCommand";
import {
  UpdateDataSourceCommandInput,
  UpdateDataSourceCommandOutput
} from "../commands/UpdateDataSourceCommand";
import {
  UpdateDataSourcePermissionsCommandInput,
  UpdateDataSourcePermissionsCommandOutput
} from "../commands/UpdateDataSourcePermissionsCommand";
import {
  UpdateGroupCommandInput,
  UpdateGroupCommandOutput
} from "../commands/UpdateGroupCommand";
import {
  UpdateIAMPolicyAssignmentCommandInput,
  UpdateIAMPolicyAssignmentCommandOutput
} from "../commands/UpdateIAMPolicyAssignmentCommand";
import {
  UpdateTemplateAliasCommandInput,
  UpdateTemplateAliasCommandOutput
} from "../commands/UpdateTemplateAliasCommand";
import {
  UpdateTemplateCommandInput,
  UpdateTemplateCommandOutput
} from "../commands/UpdateTemplateCommand";
import {
  UpdateTemplatePermissionsCommandInput,
  UpdateTemplatePermissionsCommandOutput
} from "../commands/UpdateTemplatePermissionsCommand";
import {
  UpdateUserCommandInput,
  UpdateUserCommandOutput
} from "../commands/UpdateUserCommand";
import {
  AccessDeniedException,
  ActiveIAMPolicyAssignment,
  AdHocFilteringOption,
  AmazonElasticsearchParameters,
  AthenaParameters,
  AuroraParameters,
  AuroraPostgreSqlParameters,
  AwsIotAnalyticsParameters,
  CalculatedColumn,
  CastColumnTypeOperation,
  ColumnGroup,
  ColumnGroupColumnSchema,
  ColumnGroupSchema,
  ColumnSchema,
  ColumnTag,
  ConcurrentUpdatingException,
  ConflictException,
  CreateColumnsOperation,
  CredentialPair,
  CustomSql,
  Dashboard,
  DashboardError,
  DashboardPublishOptions,
  DashboardSourceEntity,
  DashboardSourceTemplate,
  DashboardSummary,
  DashboardVersion,
  DashboardVersionSummary,
  DataSet,
  DataSetConfiguration,
  DataSetReference,
  DataSetSchema,
  DataSetSummary,
  DataSource,
  DataSourceCredentials,
  DataSourceErrorInfo,
  DataSourceParameters,
  DateTimeParameter,
  DecimalParameter,
  DomainNotWhitelistedException,
  ErrorInfo,
  ExportToCSVOption,
  FilterOperation,
  GeoSpatialColumnGroup,
  Group,
  GroupMember,
  IAMPolicyAssignment,
  IAMPolicyAssignmentSummary,
  IdentityTypeNotSupportedException,
  Ingestion,
  InputColumn,
  IntegerParameter,
  InternalFailureException,
  InvalidNextTokenException,
  InvalidParameterValueException,
  JiraParameters,
  JoinInstruction,
  LimitExceededException,
  LogicalTable,
  LogicalTableSource,
  ManifestFileLocation,
  MariaDbParameters,
  MySqlParameters,
  OutputColumn,
  PhysicalTable,
  PostgreSqlParameters,
  PreconditionNotMetException,
  PrestoParameters,
  ProjectOperation,
  QueueInfo,
  QuickSightUserNotFoundException,
  RdsParameters,
  RedshiftParameters,
  RelationalTable,
  RenameColumnOperation,
  ResourceExistsException,
  ResourceNotFoundException,
  ResourcePermission,
  ResourceUnavailableException,
  RowInfo,
  RowLevelPermissionDataSet,
  S3Parameters,
  S3Source,
  ServiceNowParameters,
  SessionLifetimeInMinutesInvalidException,
  SheetControlsOption,
  SnowflakeParameters,
  SparkParameters,
  SqlServerParameters,
  SslProperties,
  StringParameter,
  Tag,
  TagColumnOperation,
  Template,
  TemplateAlias,
  TemplateError,
  TemplateSourceAnalysis,
  TemplateSourceEntity,
  TemplateSourceTemplate,
  TemplateSummary,
  TemplateVersion,
  TemplateVersionSummary,
  TeradataParameters,
  ThrottlingException,
  TransformOperation,
  TwitterParameters,
  UnsupportedUserEditionException,
  UploadSettings,
  User,
  VpcConnectionProperties,
  _Parameters
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export const serializeAws_restJson1_1CancelIngestionCommand = async (
  input: CancelIngestionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/data-sets/{DataSetId}/ingestions/{IngestionId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSetId !== undefined) {
    const labelValue: string = input.DataSetId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DataSetId.");
    }
    resolvedPath = resolvedPath.replace(
      "{DataSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSetId.");
  }
  if (input.IngestionId !== undefined) {
    const labelValue: string = input.IngestionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: IngestionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{IngestionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: IngestionId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1CreateDashboardCommand = async (
  input: CreateDashboardCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AwsAccountId}/dashboards/{DashboardId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DashboardId !== undefined) {
    const labelValue: string = input.DashboardId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DashboardId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DashboardId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DashboardId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.DashboardPublishOptions !== undefined) {
    bodyParams[
      "DashboardPublishOptions"
    ] = serializeAws_restJson1_1DashboardPublishOptions(
      input.DashboardPublishOptions,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_restJson1_1_Parameters(
      input.Parameters,
      context
    );
  }
  if (input.Permissions !== undefined) {
    bodyParams["Permissions"] = serializeAws_restJson1_1ResourcePermissionList(
      input.Permissions,
      context
    );
  }
  if (input.SourceEntity !== undefined) {
    bodyParams["SourceEntity"] = serializeAws_restJson1_1DashboardSourceEntity(
      input.SourceEntity,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_restJson1_1TagList(input.Tags, context);
  }
  if (input.VersionDescription !== undefined) {
    bodyParams["VersionDescription"] = input.VersionDescription;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1CreateDataSetCommand = async (
  input: CreateDataSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AwsAccountId}/data-sets";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.ColumnGroups !== undefined) {
    bodyParams["ColumnGroups"] = serializeAws_restJson1_1ColumnGroupList(
      input.ColumnGroups,
      context
    );
  }
  if (input.DataSetId !== undefined) {
    bodyParams["DataSetId"] = input.DataSetId;
  }
  if (input.ImportMode !== undefined) {
    bodyParams["ImportMode"] = input.ImportMode;
  }
  if (input.LogicalTableMap !== undefined) {
    bodyParams["LogicalTableMap"] = serializeAws_restJson1_1LogicalTableMap(
      input.LogicalTableMap,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Permissions !== undefined) {
    bodyParams["Permissions"] = serializeAws_restJson1_1ResourcePermissionList(
      input.Permissions,
      context
    );
  }
  if (input.PhysicalTableMap !== undefined) {
    bodyParams["PhysicalTableMap"] = serializeAws_restJson1_1PhysicalTableMap(
      input.PhysicalTableMap,
      context
    );
  }
  if (input.RowLevelPermissionDataSet !== undefined) {
    bodyParams[
      "RowLevelPermissionDataSet"
    ] = serializeAws_restJson1_1RowLevelPermissionDataSet(
      input.RowLevelPermissionDataSet,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_restJson1_1TagList(input.Tags, context);
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1CreateDataSourceCommand = async (
  input: CreateDataSourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AwsAccountId}/data-sources";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Credentials !== undefined) {
    bodyParams["Credentials"] = serializeAws_restJson1_1DataSourceCredentials(
      input.Credentials,
      context
    );
  }
  if (input.DataSourceId !== undefined) {
    bodyParams["DataSourceId"] = input.DataSourceId;
  }
  if (input.DataSourceParameters !== undefined) {
    bodyParams[
      "DataSourceParameters"
    ] = serializeAws_restJson1_1DataSourceParameters(
      input.DataSourceParameters,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Permissions !== undefined) {
    bodyParams["Permissions"] = serializeAws_restJson1_1ResourcePermissionList(
      input.Permissions,
      context
    );
  }
  if (input.SslProperties !== undefined) {
    bodyParams["SslProperties"] = serializeAws_restJson1_1SslProperties(
      input.SslProperties,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_restJson1_1TagList(input.Tags, context);
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  if (input.VpcConnectionProperties !== undefined) {
    bodyParams[
      "VpcConnectionProperties"
    ] = serializeAws_restJson1_1VpcConnectionProperties(
      input.VpcConnectionProperties,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1CreateGroupCommand = async (
  input: CreateGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.GroupName !== undefined) {
    bodyParams["GroupName"] = input.GroupName;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1CreateGroupMembershipCommand = async (
  input: CreateGroupMembershipCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}/members/{MemberName}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.GroupName !== undefined) {
    const labelValue: string = input.GroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupName.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupName.");
  }
  if (input.MemberName !== undefined) {
    const labelValue: string = input.MemberName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MemberName.");
    }
    resolvedPath = resolvedPath.replace(
      "{MemberName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MemberName.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1CreateIAMPolicyAssignmentCommand = async (
  input: CreateIAMPolicyAssignmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/iam-policy-assignments";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.AssignmentName !== undefined) {
    bodyParams["AssignmentName"] = input.AssignmentName;
  }
  if (input.AssignmentStatus !== undefined) {
    bodyParams["AssignmentStatus"] = input.AssignmentStatus;
  }
  if (input.Identities !== undefined) {
    bodyParams["Identities"] = serializeAws_restJson1_1IdentityMap(
      input.Identities,
      context
    );
  }
  if (input.PolicyArn !== undefined) {
    bodyParams["PolicyArn"] = input.PolicyArn;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1CreateIngestionCommand = async (
  input: CreateIngestionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/data-sets/{DataSetId}/ingestions/{IngestionId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSetId !== undefined) {
    const labelValue: string = input.DataSetId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DataSetId.");
    }
    resolvedPath = resolvedPath.replace(
      "{DataSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSetId.");
  }
  if (input.IngestionId !== undefined) {
    const labelValue: string = input.IngestionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: IngestionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{IngestionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: IngestionId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1CreateTemplateCommand = async (
  input: CreateTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AwsAccountId}/templates/{TemplateId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Permissions !== undefined) {
    bodyParams["Permissions"] = serializeAws_restJson1_1ResourcePermissionList(
      input.Permissions,
      context
    );
  }
  if (input.SourceEntity !== undefined) {
    bodyParams["SourceEntity"] = serializeAws_restJson1_1TemplateSourceEntity(
      input.SourceEntity,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_restJson1_1TagList(input.Tags, context);
  }
  if (input.VersionDescription !== undefined) {
    bodyParams["VersionDescription"] = input.VersionDescription;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1CreateTemplateAliasCommand = async (
  input: CreateTemplateAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/templates/{TemplateId}/aliases/{AliasName}";
  if (input.AliasName !== undefined) {
    const labelValue: string = input.AliasName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AliasName.");
    }
    resolvedPath = resolvedPath.replace(
      "{AliasName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AliasName.");
  }
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.TemplateVersionNumber !== undefined) {
    bodyParams["TemplateVersionNumber"] = input.TemplateVersionNumber;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DeleteDashboardCommand = async (
  input: DeleteDashboardCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/dashboards/{DashboardId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DashboardId !== undefined) {
    const labelValue: string = input.DashboardId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DashboardId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DashboardId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DashboardId.");
  }
  const query: any = {};
  if (input.VersionNumber !== undefined) {
    query["version-number"] = input.VersionNumber.toString();
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1DeleteDataSetCommand = async (
  input: DeleteDataSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/data-sets/{DataSetId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSetId !== undefined) {
    const labelValue: string = input.DataSetId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DataSetId.");
    }
    resolvedPath = resolvedPath.replace(
      "{DataSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSetId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DeleteDataSourceCommand = async (
  input: DeleteDataSourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/data-sources/{DataSourceId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSourceId !== undefined) {
    const labelValue: string = input.DataSourceId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DataSourceId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DataSourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSourceId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DeleteGroupCommand = async (
  input: DeleteGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.GroupName !== undefined) {
    const labelValue: string = input.GroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupName.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupName.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DeleteGroupMembershipCommand = async (
  input: DeleteGroupMembershipCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}/members/{MemberName}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.GroupName !== undefined) {
    const labelValue: string = input.GroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupName.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupName.");
  }
  if (input.MemberName !== undefined) {
    const labelValue: string = input.MemberName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: MemberName.");
    }
    resolvedPath = resolvedPath.replace(
      "{MemberName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: MemberName.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DeleteIAMPolicyAssignmentCommand = async (
  input: DeleteIAMPolicyAssignmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespace/{Namespace}/iam-policy-assignments/{AssignmentName}";
  if (input.AssignmentName !== undefined) {
    const labelValue: string = input.AssignmentName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AssignmentName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AssignmentName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AssignmentName.");
  }
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DeleteTemplateCommand = async (
  input: DeleteTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/templates/{TemplateId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  const query: any = {};
  if (input.VersionNumber !== undefined) {
    query["version-number"] = input.VersionNumber.toString();
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1DeleteTemplateAliasCommand = async (
  input: DeleteTemplateAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/templates/{TemplateId}/aliases/{AliasName}";
  if (input.AliasName !== undefined) {
    const labelValue: string = input.AliasName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AliasName.");
    }
    resolvedPath = resolvedPath.replace(
      "{AliasName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AliasName.");
  }
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DeleteUserCommand = async (
  input: DeleteUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  if (input.UserName !== undefined) {
    const labelValue: string = input.UserName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserName.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserName.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DeleteUserByPrincipalIdCommand = async (
  input: DeleteUserByPrincipalIdCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/user-principals/{PrincipalId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  if (input.PrincipalId !== undefined) {
    const labelValue: string = input.PrincipalId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: PrincipalId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{PrincipalId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: PrincipalId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeDashboardCommand = async (
  input: DescribeDashboardCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/dashboards/{DashboardId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DashboardId !== undefined) {
    const labelValue: string = input.DashboardId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DashboardId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DashboardId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DashboardId.");
  }
  const query: any = {};
  if (input.AliasName !== undefined) {
    query["alias-name"] = input.AliasName;
  }
  if (input.VersionNumber !== undefined) {
    query["version-number"] = input.VersionNumber.toString();
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1DescribeDashboardPermissionsCommand = async (
  input: DescribeDashboardPermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/dashboards/{DashboardId}/permissions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DashboardId !== undefined) {
    const labelValue: string = input.DashboardId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DashboardId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DashboardId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DashboardId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeDataSetCommand = async (
  input: DescribeDataSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/data-sets/{DataSetId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSetId !== undefined) {
    const labelValue: string = input.DataSetId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DataSetId.");
    }
    resolvedPath = resolvedPath.replace(
      "{DataSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSetId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeDataSetPermissionsCommand = async (
  input: DescribeDataSetPermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/data-sets/{DataSetId}/permissions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSetId !== undefined) {
    const labelValue: string = input.DataSetId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DataSetId.");
    }
    resolvedPath = resolvedPath.replace(
      "{DataSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSetId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeDataSourceCommand = async (
  input: DescribeDataSourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/data-sources/{DataSourceId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSourceId !== undefined) {
    const labelValue: string = input.DataSourceId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DataSourceId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DataSourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSourceId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeDataSourcePermissionsCommand = async (
  input: DescribeDataSourcePermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/data-sources/{DataSourceId}/permissions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSourceId !== undefined) {
    const labelValue: string = input.DataSourceId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DataSourceId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DataSourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSourceId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeGroupCommand = async (
  input: DescribeGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.GroupName !== undefined) {
    const labelValue: string = input.GroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupName.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupName.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeIAMPolicyAssignmentCommand = async (
  input: DescribeIAMPolicyAssignmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/iam-policy-assignments/{AssignmentName}";
  if (input.AssignmentName !== undefined) {
    const labelValue: string = input.AssignmentName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AssignmentName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AssignmentName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AssignmentName.");
  }
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeIngestionCommand = async (
  input: DescribeIngestionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/data-sets/{DataSetId}/ingestions/{IngestionId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSetId !== undefined) {
    const labelValue: string = input.DataSetId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DataSetId.");
    }
    resolvedPath = resolvedPath.replace(
      "{DataSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSetId.");
  }
  if (input.IngestionId !== undefined) {
    const labelValue: string = input.IngestionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: IngestionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{IngestionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: IngestionId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeTemplateCommand = async (
  input: DescribeTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/templates/{TemplateId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  const query: any = {};
  if (input.AliasName !== undefined) {
    query["alias-name"] = input.AliasName;
  }
  if (input.VersionNumber !== undefined) {
    query["version-number"] = input.VersionNumber.toString();
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1DescribeTemplateAliasCommand = async (
  input: DescribeTemplateAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/templates/{TemplateId}/aliases/{AliasName}";
  if (input.AliasName !== undefined) {
    const labelValue: string = input.AliasName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AliasName.");
    }
    resolvedPath = resolvedPath.replace(
      "{AliasName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AliasName.");
  }
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeTemplatePermissionsCommand = async (
  input: DescribeTemplatePermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/templates/{TemplateId}/permissions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1DescribeUserCommand = async (
  input: DescribeUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  if (input.UserName !== undefined) {
    const labelValue: string = input.UserName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserName.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserName.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1GetDashboardEmbedUrlCommand = async (
  input: GetDashboardEmbedUrlCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/dashboards/{DashboardId}/embed-url";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DashboardId !== undefined) {
    const labelValue: string = input.DashboardId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DashboardId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DashboardId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DashboardId.");
  }
  const query: any = {};
  if (input.IdentityType !== undefined) {
    query["creds-type"] = input.IdentityType;
  }
  if (input.ResetDisabled !== undefined) {
    query["reset-disabled"] = input.ResetDisabled.toString();
  }
  if (input.SessionLifetimeInMinutes !== undefined) {
    query["session-lifetime"] = input.SessionLifetimeInMinutes.toString();
  }
  if (input.UndoRedoDisabled !== undefined) {
    query["undo-redo-disabled"] = input.UndoRedoDisabled.toString();
  }
  if (input.UserArn !== undefined) {
    query["user-arn"] = input.UserArn;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListDashboardVersionsCommand = async (
  input: ListDashboardVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/dashboards/{DashboardId}/versions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DashboardId !== undefined) {
    const labelValue: string = input.DashboardId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DashboardId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DashboardId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DashboardId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListDashboardsCommand = async (
  input: ListDashboardsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/dashboards";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListDataSetsCommand = async (
  input: ListDataSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/data-sets";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListDataSourcesCommand = async (
  input: ListDataSourcesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/data-sources";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListGroupMembershipsCommand = async (
  input: ListGroupMembershipsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}/members";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.GroupName !== undefined) {
    const labelValue: string = input.GroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupName.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupName.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListGroupsCommand = async (
  input: ListGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListIAMPolicyAssignmentsCommand = async (
  input: ListIAMPolicyAssignmentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/iam-policy-assignments";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const bodyParams: any = {};
  if (input.AssignmentStatus !== undefined) {
    bodyParams["AssignmentStatus"] = input.AssignmentStatus;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListIAMPolicyAssignmentsForUserCommand = async (
  input: ListIAMPolicyAssignmentsForUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}/iam-policy-assignments";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  if (input.UserName !== undefined) {
    const labelValue: string = input.UserName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserName.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserName.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListIngestionsCommand = async (
  input: ListIngestionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/data-sets/{DataSetId}/ingestions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSetId !== undefined) {
    const labelValue: string = input.DataSetId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DataSetId.");
    }
    resolvedPath = resolvedPath.replace(
      "{DataSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSetId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListTagsForResourceCommand = async (
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/resources/{ResourceArn}/tags";
  if (input.ResourceArn !== undefined) {
    const labelValue: string = input.ResourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceArn.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1ListTemplateAliasesCommand = async (
  input: ListTemplateAliasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/templates/{TemplateId}/aliases";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-result"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListTemplateVersionsCommand = async (
  input: ListTemplateVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/templates/{TemplateId}/versions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListTemplatesCommand = async (
  input: ListTemplatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/templates";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-result"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListUserGroupsCommand = async (
  input: ListUserGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}/groups";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  if (input.UserName !== undefined) {
    const labelValue: string = input.UserName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserName.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserName.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1ListUsersCommand = async (
  input: ListUsersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accounts/{AwsAccountId}/namespaces/{Namespace}/users";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["max-results"] = input.MaxResults.toString();
  }
  if (input.NextToken !== undefined) {
    query["next-token"] = input.NextToken;
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1RegisterUserCommand = async (
  input: RegisterUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AwsAccountId}/namespaces/{Namespace}/users";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Email !== undefined) {
    bodyParams["Email"] = input.Email;
  }
  if (input.IamArn !== undefined) {
    bodyParams["IamArn"] = input.IamArn;
  }
  if (input.IdentityType !== undefined) {
    bodyParams["IdentityType"] = input.IdentityType;
  }
  if (input.SessionName !== undefined) {
    bodyParams["SessionName"] = input.SessionName;
  }
  if (input.UserName !== undefined) {
    bodyParams["UserName"] = input.UserName;
  }
  if (input.UserRole !== undefined) {
    bodyParams["UserRole"] = input.UserRole;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1TagResourceCommand = async (
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/resources/{ResourceArn}/tags";
  if (input.ResourceArn !== undefined) {
    const labelValue: string = input.ResourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceArn.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_restJson1_1TagList(input.Tags, context);
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UntagResourceCommand = async (
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/resources/{ResourceArn}/tags";
  if (input.ResourceArn !== undefined) {
    const labelValue: string = input.ResourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceArn.");
  }
  const query: any = {};
  if (input.TagKeys !== undefined) {
    query["keys"] = (input.TagKeys || []).map(_entry => _entry);
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restJson1_1UpdateDashboardCommand = async (
  input: UpdateDashboardCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AwsAccountId}/dashboards/{DashboardId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DashboardId !== undefined) {
    const labelValue: string = input.DashboardId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DashboardId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DashboardId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DashboardId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.DashboardPublishOptions !== undefined) {
    bodyParams[
      "DashboardPublishOptions"
    ] = serializeAws_restJson1_1DashboardPublishOptions(
      input.DashboardPublishOptions,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_restJson1_1_Parameters(
      input.Parameters,
      context
    );
  }
  if (input.SourceEntity !== undefined) {
    bodyParams["SourceEntity"] = serializeAws_restJson1_1DashboardSourceEntity(
      input.SourceEntity,
      context
    );
  }
  if (input.VersionDescription !== undefined) {
    bodyParams["VersionDescription"] = input.VersionDescription;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateDashboardPermissionsCommand = async (
  input: UpdateDashboardPermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/dashboards/{DashboardId}/permissions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DashboardId !== undefined) {
    const labelValue: string = input.DashboardId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DashboardId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DashboardId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DashboardId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.GrantPermissions !== undefined) {
    bodyParams[
      "GrantPermissions"
    ] = serializeAws_restJson1_1UpdateResourcePermissionList(
      input.GrantPermissions,
      context
    );
  }
  if (input.RevokePermissions !== undefined) {
    bodyParams[
      "RevokePermissions"
    ] = serializeAws_restJson1_1UpdateResourcePermissionList(
      input.RevokePermissions,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateDashboardPublishedVersionCommand = async (
  input: UpdateDashboardPublishedVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/accounts/{AwsAccountId}/dashboards/{DashboardId}/versions/{VersionNumber}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DashboardId !== undefined) {
    const labelValue: string = input.DashboardId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DashboardId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DashboardId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DashboardId.");
  }
  if (input.VersionNumber !== undefined) {
    const labelValue: string = input.VersionNumber.toString();
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: VersionNumber."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{VersionNumber}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: VersionNumber.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateDataSetCommand = async (
  input: UpdateDataSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AwsAccountId}/data-sets/{DataSetId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSetId !== undefined) {
    const labelValue: string = input.DataSetId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DataSetId.");
    }
    resolvedPath = resolvedPath.replace(
      "{DataSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSetId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.ColumnGroups !== undefined) {
    bodyParams["ColumnGroups"] = serializeAws_restJson1_1ColumnGroupList(
      input.ColumnGroups,
      context
    );
  }
  if (input.ImportMode !== undefined) {
    bodyParams["ImportMode"] = input.ImportMode;
  }
  if (input.LogicalTableMap !== undefined) {
    bodyParams["LogicalTableMap"] = serializeAws_restJson1_1LogicalTableMap(
      input.LogicalTableMap,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.PhysicalTableMap !== undefined) {
    bodyParams["PhysicalTableMap"] = serializeAws_restJson1_1PhysicalTableMap(
      input.PhysicalTableMap,
      context
    );
  }
  if (input.RowLevelPermissionDataSet !== undefined) {
    bodyParams[
      "RowLevelPermissionDataSet"
    ] = serializeAws_restJson1_1RowLevelPermissionDataSet(
      input.RowLevelPermissionDataSet,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateDataSetPermissionsCommand = async (
  input: UpdateDataSetPermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/data-sets/{DataSetId}/permissions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSetId !== undefined) {
    const labelValue: string = input.DataSetId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: DataSetId.");
    }
    resolvedPath = resolvedPath.replace(
      "{DataSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSetId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.GrantPermissions !== undefined) {
    bodyParams[
      "GrantPermissions"
    ] = serializeAws_restJson1_1ResourcePermissionList(
      input.GrantPermissions,
      context
    );
  }
  if (input.RevokePermissions !== undefined) {
    bodyParams[
      "RevokePermissions"
    ] = serializeAws_restJson1_1ResourcePermissionList(
      input.RevokePermissions,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateDataSourceCommand = async (
  input: UpdateDataSourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AwsAccountId}/data-sources/{DataSourceId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSourceId !== undefined) {
    const labelValue: string = input.DataSourceId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DataSourceId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DataSourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSourceId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Credentials !== undefined) {
    bodyParams["Credentials"] = serializeAws_restJson1_1DataSourceCredentials(
      input.Credentials,
      context
    );
  }
  if (input.DataSourceParameters !== undefined) {
    bodyParams[
      "DataSourceParameters"
    ] = serializeAws_restJson1_1DataSourceParameters(
      input.DataSourceParameters,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.SslProperties !== undefined) {
    bodyParams["SslProperties"] = serializeAws_restJson1_1SslProperties(
      input.SslProperties,
      context
    );
  }
  if (input.VpcConnectionProperties !== undefined) {
    bodyParams[
      "VpcConnectionProperties"
    ] = serializeAws_restJson1_1VpcConnectionProperties(
      input.VpcConnectionProperties,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateDataSourcePermissionsCommand = async (
  input: UpdateDataSourcePermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/data-sources/{DataSourceId}/permissions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.DataSourceId !== undefined) {
    const labelValue: string = input.DataSourceId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DataSourceId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DataSourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DataSourceId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.GrantPermissions !== undefined) {
    bodyParams[
      "GrantPermissions"
    ] = serializeAws_restJson1_1ResourcePermissionList(
      input.GrantPermissions,
      context
    );
  }
  if (input.RevokePermissions !== undefined) {
    bodyParams[
      "RevokePermissions"
    ] = serializeAws_restJson1_1ResourcePermissionList(
      input.RevokePermissions,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateGroupCommand = async (
  input: UpdateGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/groups/{GroupName}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.GroupName !== undefined) {
    const labelValue: string = input.GroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupName.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupName.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateIAMPolicyAssignmentCommand = async (
  input: UpdateIAMPolicyAssignmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/iam-policy-assignments/{AssignmentName}";
  if (input.AssignmentName !== undefined) {
    const labelValue: string = input.AssignmentName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AssignmentName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AssignmentName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AssignmentName.");
  }
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.AssignmentStatus !== undefined) {
    bodyParams["AssignmentStatus"] = input.AssignmentStatus;
  }
  if (input.Identities !== undefined) {
    bodyParams["Identities"] = serializeAws_restJson1_1IdentityMap(
      input.Identities,
      context
    );
  }
  if (input.PolicyArn !== undefined) {
    bodyParams["PolicyArn"] = input.PolicyArn;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateTemplateCommand = async (
  input: UpdateTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/accounts/{AwsAccountId}/templates/{TemplateId}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.SourceEntity !== undefined) {
    bodyParams["SourceEntity"] = serializeAws_restJson1_1TemplateSourceEntity(
      input.SourceEntity,
      context
    );
  }
  if (input.VersionDescription !== undefined) {
    bodyParams["VersionDescription"] = input.VersionDescription;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateTemplateAliasCommand = async (
  input: UpdateTemplateAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/templates/{TemplateId}/aliases/{AliasName}";
  if (input.AliasName !== undefined) {
    const labelValue: string = input.AliasName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: AliasName.");
    }
    resolvedPath = resolvedPath.replace(
      "{AliasName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AliasName.");
  }
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.TemplateVersionNumber !== undefined) {
    bodyParams["TemplateVersionNumber"] = input.TemplateVersionNumber;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateTemplatePermissionsCommand = async (
  input: UpdateTemplatePermissionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/templates/{TemplateId}/permissions";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.TemplateId !== undefined) {
    const labelValue: string = input.TemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: TemplateId.");
    }
    resolvedPath = resolvedPath.replace(
      "{TemplateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: TemplateId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.GrantPermissions !== undefined) {
    bodyParams[
      "GrantPermissions"
    ] = serializeAws_restJson1_1UpdateResourcePermissionList(
      input.GrantPermissions,
      context
    );
  }
  if (input.RevokePermissions !== undefined) {
    bodyParams[
      "RevokePermissions"
    ] = serializeAws_restJson1_1UpdateResourcePermissionList(
      input.RevokePermissions,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restJson1_1UpdateUserCommand = async (
  input: UpdateUserCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/accounts/{AwsAccountId}/namespaces/{Namespace}/users/{UserName}";
  if (input.AwsAccountId !== undefined) {
    const labelValue: string = input.AwsAccountId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: AwsAccountId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{AwsAccountId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: AwsAccountId.");
  }
  if (input.Namespace !== undefined) {
    const labelValue: string = input.Namespace;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Namespace.");
    }
    resolvedPath = resolvedPath.replace(
      "{Namespace}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Namespace.");
  }
  if (input.UserName !== undefined) {
    const labelValue: string = input.UserName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: UserName.");
    }
    resolvedPath = resolvedPath.replace(
      "{UserName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: UserName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Email !== undefined) {
    bodyParams["Email"] = input.Email;
  }
  if (input.Role !== undefined) {
    bodyParams["Role"] = input.Role;
  }
  body = JSON.stringify(bodyParams);
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body
  });
};

export const deserializeAws_restJson1_1CancelIngestionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelIngestionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CancelIngestionCommandError(
      output,
      context
    );
  }
  const contents: CancelIngestionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelIngestionResponse",
    Arn: undefined,
    IngestionId: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.IngestionId !== undefined && data.IngestionId !== null) {
    contents.IngestionId = data.IngestionId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1CancelIngestionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelIngestionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1CreateDashboardCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDashboardCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateDashboardCommandError(
      output,
      context
    );
  }
  const contents: CreateDashboardCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDashboardResponse",
    Arn: undefined,
    CreationStatus: undefined,
    DashboardId: undefined,
    RequestId: undefined,
    VersionArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationStatus !== undefined && data.CreationStatus !== null) {
    contents.CreationStatus = data.CreationStatus;
  }
  if (data.DashboardId !== undefined && data.DashboardId !== null) {
    contents.DashboardId = data.DashboardId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.VersionArn !== undefined && data.VersionArn !== null) {
    contents.VersionArn = data.VersionArn;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1CreateDashboardCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDashboardCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1CreateDataSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDataSetCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateDataSetCommandError(output, context);
  }
  const contents: CreateDataSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDataSetResponse",
    Arn: undefined,
    DataSetId: undefined,
    IngestionArn: undefined,
    IngestionId: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.DataSetId !== undefined && data.DataSetId !== null) {
    contents.DataSetId = data.DataSetId;
  }
  if (data.IngestionArn !== undefined && data.IngestionArn !== null) {
    contents.IngestionArn = data.IngestionArn;
  }
  if (data.IngestionId !== undefined && data.IngestionId !== null) {
    contents.IngestionId = data.IngestionId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1CreateDataSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDataSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1CreateDataSourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDataSourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateDataSourceCommandError(
      output,
      context
    );
  }
  const contents: CreateDataSourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDataSourceResponse",
    Arn: undefined,
    CreationStatus: undefined,
    DataSourceId: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationStatus !== undefined && data.CreationStatus !== null) {
    contents.CreationStatus = data.CreationStatus;
  }
  if (data.DataSourceId !== undefined && data.DataSourceId !== null) {
    contents.DataSourceId = data.DataSourceId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1CreateDataSourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDataSourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1CreateGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateGroupCommandError(output, context);
  }
  const contents: CreateGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGroupResponse",
    Group: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Group !== undefined && data.Group !== null) {
    contents.Group = deserializeAws_restJson1_1Group(data.Group, context);
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1CreateGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionNotMetException":
    case "com.amazonaws.services.quicksight.common#PreconditionNotMetException":
      response = {
        ...(await deserializeAws_restJson1_1PreconditionNotMetExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1CreateGroupMembershipCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGroupMembershipCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateGroupMembershipCommandError(
      output,
      context
    );
  }
  const contents: CreateGroupMembershipCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGroupMembershipResponse",
    GroupMember: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.GroupMember !== undefined && data.GroupMember !== null) {
    contents.GroupMember = deserializeAws_restJson1_1GroupMember(
      data.GroupMember,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1CreateGroupMembershipCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGroupMembershipCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionNotMetException":
    case "com.amazonaws.services.quicksight.common#PreconditionNotMetException":
      response = {
        ...(await deserializeAws_restJson1_1PreconditionNotMetExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1CreateIAMPolicyAssignmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateIAMPolicyAssignmentCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateIAMPolicyAssignmentCommandError(
      output,
      context
    );
  }
  const contents: CreateIAMPolicyAssignmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateIAMPolicyAssignmentResponse",
    AssignmentId: undefined,
    AssignmentName: undefined,
    AssignmentStatus: undefined,
    Identities: undefined,
    PolicyArn: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AssignmentId !== undefined && data.AssignmentId !== null) {
    contents.AssignmentId = data.AssignmentId;
  }
  if (data.AssignmentName !== undefined && data.AssignmentName !== null) {
    contents.AssignmentName = data.AssignmentName;
  }
  if (data.AssignmentStatus !== undefined && data.AssignmentStatus !== null) {
    contents.AssignmentStatus = data.AssignmentStatus;
  }
  if (data.Identities !== undefined && data.Identities !== null) {
    contents.Identities = deserializeAws_restJson1_1IdentityMap(
      data.Identities,
      context
    );
  }
  if (data.PolicyArn !== undefined && data.PolicyArn !== null) {
    contents.PolicyArn = data.PolicyArn;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1CreateIAMPolicyAssignmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateIAMPolicyAssignmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentUpdatingException":
    case "com.amazonaws.services.quicksight#ConcurrentUpdatingException":
      response = {
        ...(await deserializeAws_restJson1_1ConcurrentUpdatingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1CreateIngestionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateIngestionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateIngestionCommandError(
      output,
      context
    );
  }
  const contents: CreateIngestionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateIngestionResponse",
    Arn: undefined,
    IngestionId: undefined,
    IngestionStatus: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.IngestionId !== undefined && data.IngestionId !== null) {
    contents.IngestionId = data.IngestionId;
  }
  if (data.IngestionStatus !== undefined && data.IngestionStatus !== null) {
    contents.IngestionStatus = data.IngestionStatus;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1CreateIngestionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateIngestionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1CreateTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateTemplateCommandError(
      output,
      context
    );
  }
  const contents: CreateTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTemplateResponse",
    Arn: undefined,
    CreationStatus: undefined,
    RequestId: undefined,
    TemplateId: undefined,
    VersionArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationStatus !== undefined && data.CreationStatus !== null) {
    contents.CreationStatus = data.CreationStatus;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.TemplateId !== undefined && data.TemplateId !== null) {
    contents.TemplateId = data.TemplateId;
  }
  if (data.VersionArn !== undefined && data.VersionArn !== null) {
    contents.VersionArn = data.VersionArn;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1CreateTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1CreateTemplateAliasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTemplateAliasCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateTemplateAliasCommandError(
      output,
      context
    );
  }
  const contents: CreateTemplateAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTemplateAliasResponse",
    RequestId: undefined,
    TemplateAlias: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.TemplateAlias !== undefined && data.TemplateAlias !== null) {
    contents.TemplateAlias = deserializeAws_restJson1_1TemplateAlias(
      data.TemplateAlias,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1CreateTemplateAliasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTemplateAliasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DeleteDashboardCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDashboardCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteDashboardCommandError(
      output,
      context
    );
  }
  const contents: DeleteDashboardCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDashboardResponse",
    Arn: undefined,
    DashboardId: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.DashboardId !== undefined && data.DashboardId !== null) {
    contents.DashboardId = data.DashboardId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DeleteDashboardCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDashboardCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DeleteDataSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDataSetCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteDataSetCommandError(output, context);
  }
  const contents: DeleteDataSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDataSetResponse",
    Arn: undefined,
    DataSetId: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.DataSetId !== undefined && data.DataSetId !== null) {
    contents.DataSetId = data.DataSetId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DeleteDataSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDataSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DeleteDataSourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDataSourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteDataSourceCommandError(
      output,
      context
    );
  }
  const contents: DeleteDataSourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDataSourceResponse",
    Arn: undefined,
    DataSourceId: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.DataSourceId !== undefined && data.DataSourceId !== null) {
    contents.DataSourceId = data.DataSourceId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DeleteDataSourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDataSourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DeleteGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteGroupCommandError(output, context);
  }
  const contents: DeleteGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteGroupResponse",
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DeleteGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionNotMetException":
    case "com.amazonaws.services.quicksight.common#PreconditionNotMetException":
      response = {
        ...(await deserializeAws_restJson1_1PreconditionNotMetExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DeleteGroupMembershipCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGroupMembershipCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteGroupMembershipCommandError(
      output,
      context
    );
  }
  const contents: DeleteGroupMembershipCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteGroupMembershipResponse",
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DeleteGroupMembershipCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGroupMembershipCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionNotMetException":
    case "com.amazonaws.services.quicksight.common#PreconditionNotMetException":
      response = {
        ...(await deserializeAws_restJson1_1PreconditionNotMetExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DeleteIAMPolicyAssignmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIAMPolicyAssignmentCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteIAMPolicyAssignmentCommandError(
      output,
      context
    );
  }
  const contents: DeleteIAMPolicyAssignmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteIAMPolicyAssignmentResponse",
    AssignmentName: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AssignmentName !== undefined && data.AssignmentName !== null) {
    contents.AssignmentName = data.AssignmentName;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DeleteIAMPolicyAssignmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteIAMPolicyAssignmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentUpdatingException":
    case "com.amazonaws.services.quicksight#ConcurrentUpdatingException":
      response = {
        ...(await deserializeAws_restJson1_1ConcurrentUpdatingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DeleteTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteTemplateCommandError(
      output,
      context
    );
  }
  const contents: DeleteTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTemplateResponse",
    Arn: undefined,
    RequestId: undefined,
    TemplateId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.TemplateId !== undefined && data.TemplateId !== null) {
    contents.TemplateId = data.TemplateId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DeleteTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DeleteTemplateAliasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTemplateAliasCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteTemplateAliasCommandError(
      output,
      context
    );
  }
  const contents: DeleteTemplateAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTemplateAliasResponse",
    AliasName: undefined,
    Arn: undefined,
    RequestId: undefined,
    TemplateId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AliasName !== undefined && data.AliasName !== null) {
    contents.AliasName = data.AliasName;
  }
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.TemplateId !== undefined && data.TemplateId !== null) {
    contents.TemplateId = data.TemplateId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DeleteTemplateAliasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTemplateAliasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DeleteUserCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteUserCommandError(output, context);
  }
  const contents: DeleteUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteUserResponse",
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DeleteUserCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DeleteUserByPrincipalIdCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserByPrincipalIdCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteUserByPrincipalIdCommandError(
      output,
      context
    );
  }
  const contents: DeleteUserByPrincipalIdCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteUserByPrincipalIdResponse",
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DeleteUserByPrincipalIdCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteUserByPrincipalIdCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeDashboardCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDashboardCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeDashboardCommandError(
      output,
      context
    );
  }
  const contents: DescribeDashboardCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDashboardResponse",
    Dashboard: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Dashboard !== undefined && data.Dashboard !== null) {
    contents.Dashboard = deserializeAws_restJson1_1Dashboard(
      data.Dashboard,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeDashboardCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDashboardCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeDashboardPermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDashboardPermissionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeDashboardPermissionsCommandError(
      output,
      context
    );
  }
  const contents: DescribeDashboardPermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDashboardPermissionsResponse",
    DashboardArn: undefined,
    DashboardId: undefined,
    Permissions: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DashboardArn !== undefined && data.DashboardArn !== null) {
    contents.DashboardArn = data.DashboardArn;
  }
  if (data.DashboardId !== undefined && data.DashboardId !== null) {
    contents.DashboardId = data.DashboardId;
  }
  if (data.Permissions !== undefined && data.Permissions !== null) {
    contents.Permissions = deserializeAws_restJson1_1ResourcePermissionList(
      data.Permissions,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeDashboardPermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDashboardPermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeDataSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDataSetCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeDataSetCommandError(
      output,
      context
    );
  }
  const contents: DescribeDataSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDataSetResponse",
    DataSet: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DataSet !== undefined && data.DataSet !== null) {
    contents.DataSet = deserializeAws_restJson1_1DataSet(data.DataSet, context);
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeDataSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDataSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeDataSetPermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDataSetPermissionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeDataSetPermissionsCommandError(
      output,
      context
    );
  }
  const contents: DescribeDataSetPermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDataSetPermissionsResponse",
    DataSetArn: undefined,
    DataSetId: undefined,
    Permissions: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DataSetArn !== undefined && data.DataSetArn !== null) {
    contents.DataSetArn = data.DataSetArn;
  }
  if (data.DataSetId !== undefined && data.DataSetId !== null) {
    contents.DataSetId = data.DataSetId;
  }
  if (data.Permissions !== undefined && data.Permissions !== null) {
    contents.Permissions = deserializeAws_restJson1_1ResourcePermissionList(
      data.Permissions,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeDataSetPermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDataSetPermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeDataSourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDataSourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeDataSourceCommandError(
      output,
      context
    );
  }
  const contents: DescribeDataSourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDataSourceResponse",
    DataSource: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DataSource !== undefined && data.DataSource !== null) {
    contents.DataSource = deserializeAws_restJson1_1DataSource(
      data.DataSource,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeDataSourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDataSourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeDataSourcePermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDataSourcePermissionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeDataSourcePermissionsCommandError(
      output,
      context
    );
  }
  const contents: DescribeDataSourcePermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDataSourcePermissionsResponse",
    DataSourceArn: undefined,
    DataSourceId: undefined,
    Permissions: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DataSourceArn !== undefined && data.DataSourceArn !== null) {
    contents.DataSourceArn = data.DataSourceArn;
  }
  if (data.DataSourceId !== undefined && data.DataSourceId !== null) {
    contents.DataSourceId = data.DataSourceId;
  }
  if (data.Permissions !== undefined && data.Permissions !== null) {
    contents.Permissions = deserializeAws_restJson1_1ResourcePermissionList(
      data.Permissions,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeDataSourcePermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDataSourcePermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeGroupCommandError(output, context);
  }
  const contents: DescribeGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeGroupResponse",
    Group: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Group !== undefined && data.Group !== null) {
    contents.Group = deserializeAws_restJson1_1Group(data.Group, context);
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionNotMetException":
    case "com.amazonaws.services.quicksight.common#PreconditionNotMetException":
      response = {
        ...(await deserializeAws_restJson1_1PreconditionNotMetExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeIAMPolicyAssignmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIAMPolicyAssignmentCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeIAMPolicyAssignmentCommandError(
      output,
      context
    );
  }
  const contents: DescribeIAMPolicyAssignmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeIAMPolicyAssignmentResponse",
    IAMPolicyAssignment: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.IAMPolicyAssignment !== undefined &&
    data.IAMPolicyAssignment !== null
  ) {
    contents.IAMPolicyAssignment = deserializeAws_restJson1_1IAMPolicyAssignment(
      data.IAMPolicyAssignment,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeIAMPolicyAssignmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIAMPolicyAssignmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeIngestionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIngestionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeIngestionCommandError(
      output,
      context
    );
  }
  const contents: DescribeIngestionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeIngestionResponse",
    Ingestion: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Ingestion !== undefined && data.Ingestion !== null) {
    contents.Ingestion = deserializeAws_restJson1_1Ingestion(
      data.Ingestion,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeIngestionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIngestionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeTemplateCommandError(
      output,
      context
    );
  }
  const contents: DescribeTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTemplateResponse",
    Template: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Template !== undefined && data.Template !== null) {
    contents.Template = deserializeAws_restJson1_1Template(
      data.Template,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeTemplateAliasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTemplateAliasCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeTemplateAliasCommandError(
      output,
      context
    );
  }
  const contents: DescribeTemplateAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTemplateAliasResponse",
    RequestId: undefined,
    TemplateAlias: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.TemplateAlias !== undefined && data.TemplateAlias !== null) {
    contents.TemplateAlias = deserializeAws_restJson1_1TemplateAlias(
      data.TemplateAlias,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeTemplateAliasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTemplateAliasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeTemplatePermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTemplatePermissionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeTemplatePermissionsCommandError(
      output,
      context
    );
  }
  const contents: DescribeTemplatePermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTemplatePermissionsResponse",
    Permissions: undefined,
    RequestId: undefined,
    TemplateArn: undefined,
    TemplateId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Permissions !== undefined && data.Permissions !== null) {
    contents.Permissions = deserializeAws_restJson1_1ResourcePermissionList(
      data.Permissions,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.TemplateArn !== undefined && data.TemplateArn !== null) {
    contents.TemplateArn = data.TemplateArn;
  }
  if (data.TemplateId !== undefined && data.TemplateId !== null) {
    contents.TemplateId = data.TemplateId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeTemplatePermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTemplatePermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1DescribeUserCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeUserCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeUserCommandError(output, context);
  }
  const contents: DescribeUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeUserResponse",
    RequestId: undefined,
    User: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1_1User(data.User, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1DescribeUserCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeUserCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1GetDashboardEmbedUrlCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDashboardEmbedUrlCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetDashboardEmbedUrlCommandError(
      output,
      context
    );
  }
  const contents: GetDashboardEmbedUrlCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDashboardEmbedUrlResponse",
    EmbedUrl: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.EmbedUrl !== undefined && data.EmbedUrl !== null) {
    contents.EmbedUrl = data.EmbedUrl;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1GetDashboardEmbedUrlCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDashboardEmbedUrlCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DomainNotWhitelistedException":
    case "com.amazonaws.services.quicksight#DomainNotWhitelistedException":
      response = {
        ...(await deserializeAws_restJson1_1DomainNotWhitelistedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdentityTypeNotSupportedException":
    case "com.amazonaws.services.quicksight#IdentityTypeNotSupportedException":
      response = {
        ...(await deserializeAws_restJson1_1IdentityTypeNotSupportedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "QuickSightUserNotFoundException":
    case "com.amazonaws.services.quicksight#QuickSightUserNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1QuickSightUserNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SessionLifetimeInMinutesInvalidException":
    case "com.amazonaws.services.quicksight#SessionLifetimeInMinutesInvalidException":
      response = {
        ...(await deserializeAws_restJson1_1SessionLifetimeInMinutesInvalidExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListDashboardVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDashboardVersionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListDashboardVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListDashboardVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDashboardVersionsResponse",
    DashboardVersionSummaryList: undefined,
    NextToken: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.DashboardVersionSummaryList !== undefined &&
    data.DashboardVersionSummaryList !== null
  ) {
    contents.DashboardVersionSummaryList = deserializeAws_restJson1_1DashboardVersionSummaryList(
      data.DashboardVersionSummaryList,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListDashboardVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDashboardVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListDashboardsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDashboardsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListDashboardsCommandError(
      output,
      context
    );
  }
  const contents: ListDashboardsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDashboardsResponse",
    DashboardSummaryList: undefined,
    NextToken: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.DashboardSummaryList !== undefined &&
    data.DashboardSummaryList !== null
  ) {
    contents.DashboardSummaryList = deserializeAws_restJson1_1DashboardSummaryList(
      data.DashboardSummaryList,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListDashboardsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDashboardsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListDataSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataSetsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListDataSetsCommandError(output, context);
  }
  const contents: ListDataSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDataSetsResponse",
    DataSetSummaries: undefined,
    NextToken: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DataSetSummaries !== undefined && data.DataSetSummaries !== null) {
    contents.DataSetSummaries = deserializeAws_restJson1_1DataSetSummaryList(
      data.DataSetSummaries,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListDataSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListDataSourcesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataSourcesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListDataSourcesCommandError(
      output,
      context
    );
  }
  const contents: ListDataSourcesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDataSourcesResponse",
    DataSources: undefined,
    NextToken: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DataSources !== undefined && data.DataSources !== null) {
    contents.DataSources = deserializeAws_restJson1_1DataSourceList(
      data.DataSources,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListDataSourcesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDataSourcesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListGroupMembershipsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGroupMembershipsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListGroupMembershipsCommandError(
      output,
      context
    );
  }
  const contents: ListGroupMembershipsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGroupMembershipsResponse",
    GroupMemberList: undefined,
    NextToken: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.GroupMemberList !== undefined && data.GroupMemberList !== null) {
    contents.GroupMemberList = deserializeAws_restJson1_1GroupMemberList(
      data.GroupMemberList,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListGroupMembershipsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGroupMembershipsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionNotMetException":
    case "com.amazonaws.services.quicksight.common#PreconditionNotMetException":
      response = {
        ...(await deserializeAws_restJson1_1PreconditionNotMetExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGroupsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListGroupsCommandError(output, context);
  }
  const contents: ListGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGroupsResponse",
    GroupList: undefined,
    NextToken: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.GroupList !== undefined && data.GroupList !== null) {
    contents.GroupList = deserializeAws_restJson1_1GroupList(
      data.GroupList,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionNotMetException":
    case "com.amazonaws.services.quicksight.common#PreconditionNotMetException":
      response = {
        ...(await deserializeAws_restJson1_1PreconditionNotMetExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListIAMPolicyAssignmentsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIAMPolicyAssignmentsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListIAMPolicyAssignmentsCommandError(
      output,
      context
    );
  }
  const contents: ListIAMPolicyAssignmentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListIAMPolicyAssignmentsResponse",
    IAMPolicyAssignments: undefined,
    NextToken: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.IAMPolicyAssignments !== undefined &&
    data.IAMPolicyAssignments !== null
  ) {
    contents.IAMPolicyAssignments = deserializeAws_restJson1_1IAMPolicyAssignmentSummaryList(
      data.IAMPolicyAssignments,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListIAMPolicyAssignmentsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIAMPolicyAssignmentsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListIAMPolicyAssignmentsForUserCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIAMPolicyAssignmentsForUserCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListIAMPolicyAssignmentsForUserCommandError(
      output,
      context
    );
  }
  const contents: ListIAMPolicyAssignmentsForUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListIAMPolicyAssignmentsForUserResponse",
    ActiveAssignments: undefined,
    NextToken: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.ActiveAssignments !== undefined && data.ActiveAssignments !== null) {
    contents.ActiveAssignments = deserializeAws_restJson1_1ActiveIAMPolicyAssignmentList(
      data.ActiveAssignments,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListIAMPolicyAssignmentsForUserCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIAMPolicyAssignmentsForUserCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentUpdatingException":
    case "com.amazonaws.services.quicksight#ConcurrentUpdatingException":
      response = {
        ...(await deserializeAws_restJson1_1ConcurrentUpdatingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListIngestionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIngestionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListIngestionsCommandError(
      output,
      context
    );
  }
  const contents: ListIngestionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListIngestionsResponse",
    Ingestions: undefined,
    NextToken: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Ingestions !== undefined && data.Ingestions !== null) {
    contents.Ingestions = deserializeAws_restJson1_1Ingestions(
      data.Ingestions,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListIngestionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIngestionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListTagsForResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const contents: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    RequestId: undefined,
    Tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.Tags !== undefined && data.Tags !== null) {
    contents.Tags = deserializeAws_restJson1_1TagList(data.Tags, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListTagsForResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListTemplateAliasesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTemplateAliasesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTemplateAliasesCommandError(
      output,
      context
    );
  }
  const contents: ListTemplateAliasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTemplateAliasesResponse",
    NextToken: undefined,
    RequestId: undefined,
    TemplateAliasList: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.TemplateAliasList !== undefined && data.TemplateAliasList !== null) {
    contents.TemplateAliasList = deserializeAws_restJson1_1TemplateAliasList(
      data.TemplateAliasList,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListTemplateAliasesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTemplateAliasesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListTemplateVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTemplateVersionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTemplateVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListTemplateVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTemplateVersionsResponse",
    NextToken: undefined,
    RequestId: undefined,
    TemplateVersionSummaryList: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (
    data.TemplateVersionSummaryList !== undefined &&
    data.TemplateVersionSummaryList !== null
  ) {
    contents.TemplateVersionSummaryList = deserializeAws_restJson1_1TemplateVersionSummaryList(
      data.TemplateVersionSummaryList,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListTemplateVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTemplateVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListTemplatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTemplatesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTemplatesCommandError(output, context);
  }
  const contents: ListTemplatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTemplatesResponse",
    NextToken: undefined,
    RequestId: undefined,
    TemplateSummaryList: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (
    data.TemplateSummaryList !== undefined &&
    data.TemplateSummaryList !== null
  ) {
    contents.TemplateSummaryList = deserializeAws_restJson1_1TemplateSummaryList(
      data.TemplateSummaryList,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListTemplatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTemplatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListUserGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListUserGroupsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListUserGroupsCommandError(
      output,
      context
    );
  }
  const contents: ListUserGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListUserGroupsResponse",
    GroupList: undefined,
    NextToken: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.GroupList !== undefined && data.GroupList !== null) {
    contents.GroupList = deserializeAws_restJson1_1GroupList(
      data.GroupList,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListUserGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListUserGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1ListUsersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListUsersCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListUsersCommandError(output, context);
  }
  const contents: ListUsersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListUsersResponse",
    NextToken: undefined,
    RequestId: undefined,
    UserList: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.UserList !== undefined && data.UserList !== null) {
    contents.UserList = deserializeAws_restJson1_1UserList(
      data.UserList,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1ListUsersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListUsersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidNextTokenException":
    case "com.amazonaws.services.quicksight.common#InvalidNextTokenException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidNextTokenExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1RegisterUserCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterUserCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1RegisterUserCommandError(output, context);
  }
  const contents: RegisterUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterUserResponse",
    RequestId: undefined,
    User: undefined,
    UserInvitationUrl: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1_1User(data.User, context);
  }
  if (data.UserInvitationUrl !== undefined && data.UserInvitationUrl !== null) {
    contents.UserInvitationUrl = data.UserInvitationUrl;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1RegisterUserCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterUserCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionNotMetException":
    case "com.amazonaws.services.quicksight.common#PreconditionNotMetException":
      response = {
        ...(await deserializeAws_restJson1_1PreconditionNotMetExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1TagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1TagResourceCommandError(output, context);
  }
  const contents: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse",
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1TagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UntagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UntagResourceCommandError(output, context);
  }
  const contents: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse",
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UntagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateDashboardCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDashboardCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateDashboardCommandError(
      output,
      context
    );
  }
  const contents: UpdateDashboardCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDashboardResponse",
    Arn: undefined,
    CreationStatus: undefined,
    DashboardId: undefined,
    RequestId: undefined,
    Status: undefined,
    VersionArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationStatus !== undefined && data.CreationStatus !== null) {
    contents.CreationStatus = data.CreationStatus;
  }
  if (data.DashboardId !== undefined && data.DashboardId !== null) {
    contents.DashboardId = data.DashboardId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.Status !== undefined && data.Status !== null) {
    contents.Status = data.Status;
  }
  if (data.VersionArn !== undefined && data.VersionArn !== null) {
    contents.VersionArn = data.VersionArn;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateDashboardCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDashboardCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateDashboardPermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDashboardPermissionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateDashboardPermissionsCommandError(
      output,
      context
    );
  }
  const contents: UpdateDashboardPermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDashboardPermissionsResponse",
    DashboardArn: undefined,
    DashboardId: undefined,
    Permissions: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DashboardArn !== undefined && data.DashboardArn !== null) {
    contents.DashboardArn = data.DashboardArn;
  }
  if (data.DashboardId !== undefined && data.DashboardId !== null) {
    contents.DashboardId = data.DashboardId;
  }
  if (data.Permissions !== undefined && data.Permissions !== null) {
    contents.Permissions = deserializeAws_restJson1_1ResourcePermissionList(
      data.Permissions,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateDashboardPermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDashboardPermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateDashboardPublishedVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDashboardPublishedVersionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateDashboardPublishedVersionCommandError(
      output,
      context
    );
  }
  const contents: UpdateDashboardPublishedVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDashboardPublishedVersionResponse",
    DashboardArn: undefined,
    DashboardId: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DashboardArn !== undefined && data.DashboardArn !== null) {
    contents.DashboardArn = data.DashboardArn;
  }
  if (data.DashboardId !== undefined && data.DashboardId !== null) {
    contents.DashboardId = data.DashboardId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateDashboardPublishedVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDashboardPublishedVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateDataSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDataSetCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateDataSetCommandError(output, context);
  }
  const contents: UpdateDataSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDataSetResponse",
    Arn: undefined,
    DataSetId: undefined,
    IngestionArn: undefined,
    IngestionId: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.DataSetId !== undefined && data.DataSetId !== null) {
    contents.DataSetId = data.DataSetId;
  }
  if (data.IngestionArn !== undefined && data.IngestionArn !== null) {
    contents.IngestionArn = data.IngestionArn;
  }
  if (data.IngestionId !== undefined && data.IngestionId !== null) {
    contents.IngestionId = data.IngestionId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateDataSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDataSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateDataSetPermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDataSetPermissionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateDataSetPermissionsCommandError(
      output,
      context
    );
  }
  const contents: UpdateDataSetPermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDataSetPermissionsResponse",
    DataSetArn: undefined,
    DataSetId: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DataSetArn !== undefined && data.DataSetArn !== null) {
    contents.DataSetArn = data.DataSetArn;
  }
  if (data.DataSetId !== undefined && data.DataSetId !== null) {
    contents.DataSetId = data.DataSetId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateDataSetPermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDataSetPermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateDataSourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDataSourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateDataSourceCommandError(
      output,
      context
    );
  }
  const contents: UpdateDataSourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDataSourceResponse",
    Arn: undefined,
    DataSourceId: undefined,
    RequestId: undefined,
    UpdateStatus: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.DataSourceId !== undefined && data.DataSourceId !== null) {
    contents.DataSourceId = data.DataSourceId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.UpdateStatus !== undefined && data.UpdateStatus !== null) {
    contents.UpdateStatus = data.UpdateStatus;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateDataSourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDataSourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateDataSourcePermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDataSourcePermissionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateDataSourcePermissionsCommandError(
      output,
      context
    );
  }
  const contents: UpdateDataSourcePermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDataSourcePermissionsResponse",
    DataSourceArn: undefined,
    DataSourceId: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DataSourceArn !== undefined && data.DataSourceArn !== null) {
    contents.DataSourceArn = data.DataSourceArn;
  }
  if (data.DataSourceId !== undefined && data.DataSourceId !== null) {
    contents.DataSourceId = data.DataSourceId;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateDataSourcePermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDataSourcePermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateGroupCommandError(output, context);
  }
  const contents: UpdateGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateGroupResponse",
    Group: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Group !== undefined && data.Group !== null) {
    contents.Group = deserializeAws_restJson1_1Group(data.Group, context);
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PreconditionNotMetException":
    case "com.amazonaws.services.quicksight.common#PreconditionNotMetException":
      response = {
        ...(await deserializeAws_restJson1_1PreconditionNotMetExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateIAMPolicyAssignmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIAMPolicyAssignmentCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateIAMPolicyAssignmentCommandError(
      output,
      context
    );
  }
  const contents: UpdateIAMPolicyAssignmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateIAMPolicyAssignmentResponse",
    AssignmentId: undefined,
    AssignmentName: undefined,
    AssignmentStatus: undefined,
    Identities: undefined,
    PolicyArn: undefined,
    RequestId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AssignmentId !== undefined && data.AssignmentId !== null) {
    contents.AssignmentId = data.AssignmentId;
  }
  if (data.AssignmentName !== undefined && data.AssignmentName !== null) {
    contents.AssignmentName = data.AssignmentName;
  }
  if (data.AssignmentStatus !== undefined && data.AssignmentStatus !== null) {
    contents.AssignmentStatus = data.AssignmentStatus;
  }
  if (data.Identities !== undefined && data.Identities !== null) {
    contents.Identities = deserializeAws_restJson1_1IdentityMap(
      data.Identities,
      context
    );
  }
  if (data.PolicyArn !== undefined && data.PolicyArn !== null) {
    contents.PolicyArn = data.PolicyArn;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateIAMPolicyAssignmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIAMPolicyAssignmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentUpdatingException":
    case "com.amazonaws.services.quicksight#ConcurrentUpdatingException":
      response = {
        ...(await deserializeAws_restJson1_1ConcurrentUpdatingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateTemplateCommandError(
      output,
      context
    );
  }
  const contents: UpdateTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTemplateResponse",
    Arn: undefined,
    CreationStatus: undefined,
    RequestId: undefined,
    TemplateId: undefined,
    VersionArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationStatus !== undefined && data.CreationStatus !== null) {
    contents.CreationStatus = data.CreationStatus;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.TemplateId !== undefined && data.TemplateId !== null) {
    contents.TemplateId = data.TemplateId;
  }
  if (data.VersionArn !== undefined && data.VersionArn !== null) {
    contents.VersionArn = data.VersionArn;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.services.quicksight.common#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceExistsException":
    case "com.amazonaws.services.quicksight.common#ResourceExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceExistsExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateTemplateAliasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTemplateAliasCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateTemplateAliasCommandError(
      output,
      context
    );
  }
  const contents: UpdateTemplateAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTemplateAliasResponse",
    RequestId: undefined,
    TemplateAlias: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.TemplateAlias !== undefined && data.TemplateAlias !== null) {
    contents.TemplateAlias = deserializeAws_restJson1_1TemplateAlias(
      data.TemplateAlias,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateTemplateAliasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTemplateAliasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateTemplatePermissionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTemplatePermissionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateTemplatePermissionsCommandError(
      output,
      context
    );
  }
  const contents: UpdateTemplatePermissionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTemplatePermissionsResponse",
    Permissions: undefined,
    RequestId: undefined,
    TemplateArn: undefined,
    TemplateId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Permissions !== undefined && data.Permissions !== null) {
    contents.Permissions = deserializeAws_restJson1_1ResourcePermissionList(
      data.Permissions,
      context
    );
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.TemplateArn !== undefined && data.TemplateArn !== null) {
    contents.TemplateArn = data.TemplateArn;
  }
  if (data.TemplateId !== undefined && data.TemplateId !== null) {
    contents.TemplateId = data.TemplateId;
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateTemplatePermissionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTemplatePermissionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.services.quicksight.common#ConflictException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedUserEditionException":
    case "com.amazonaws.services.quicksight.common#UnsupportedUserEditionException":
      response = {
        ...(await deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1_1UpdateUserCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateUserCommandError(output, context);
  }
  const contents: UpdateUserCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateUserResponse",
    RequestId: undefined,
    User: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.User !== undefined && data.User !== null) {
    contents.User = deserializeAws_restJson1_1User(data.User, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1_1UpdateUserCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateUserCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "AccessDeniedException":
    case "com.amazonaws.services.quicksight.common#AccessDeniedException":
      response = {
        ...(await deserializeAws_restJson1_1AccessDeniedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.services.quicksight.common#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidParameterValueException":
    case "com.amazonaws.services.quicksight.common#InvalidParameterValueException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidParameterValueExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.services.quicksight.common#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceUnavailableException":
    case "com.amazonaws.services.quicksight.common#ResourceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceUnavailableExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.services.quicksight.common#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_restJson1_1ConcurrentUpdatingExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentUpdatingException> => {
  const contents: ConcurrentUpdatingException = {
    name: "ConcurrentUpdatingException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1DomainNotWhitelistedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DomainNotWhitelistedException> => {
  const contents: DomainNotWhitelistedException = {
    name: "DomainNotWhitelistedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1IdentityTypeNotSupportedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IdentityTypeNotSupportedException> => {
  const contents: IdentityTypeNotSupportedException = {
    name: "IdentityTypeNotSupportedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1QuickSightUserNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<QuickSightUserNotFoundException> => {
  const contents: QuickSightUserNotFoundException = {
    name: "QuickSightUserNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1SessionLifetimeInMinutesInvalidExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SessionLifetimeInMinutesInvalidException> => {
  const contents: SessionLifetimeInMinutesInvalidException = {
    name: "SessionLifetimeInMinutesInvalidException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1AccessDeniedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AccessDeniedException> => {
  const contents: AccessDeniedException = {
    name: "AccessDeniedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1ConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConflictException> => {
  const contents: ConflictException = {
    name: "ConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1InternalFailureExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InternalFailureException> => {
  const contents: InternalFailureException = {
    name: "InternalFailureException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1InvalidNextTokenExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidNextTokenException> => {
  const contents: InvalidNextTokenException = {
    name: "InvalidNextTokenException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1InvalidParameterValueExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidParameterValueException> => {
  const contents: InvalidParameterValueException = {
    name: "InvalidParameterValueException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1LimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<LimitExceededException> => {
  const contents: LimitExceededException = {
    name: "LimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined,
    ResourceType: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.ResourceType !== undefined && data.ResourceType !== null) {
    contents.ResourceType = data.ResourceType;
  }
  return contents;
};

const deserializeAws_restJson1_1PreconditionNotMetExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PreconditionNotMetException> => {
  const contents: PreconditionNotMetException = {
    name: "PreconditionNotMetException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceExistsException> => {
  const contents: ResourceExistsException = {
    name: "ResourceExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined,
    ResourceType: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.ResourceType !== undefined && data.ResourceType !== null) {
    contents.ResourceType = data.ResourceType;
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNotFoundException> => {
  const contents: ResourceNotFoundException = {
    name: "ResourceNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined,
    ResourceType: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.ResourceType !== undefined && data.ResourceType !== null) {
    contents.ResourceType = data.ResourceType;
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceUnavailableExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceUnavailableException> => {
  const contents: ResourceUnavailableException = {
    name: "ResourceUnavailableException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined,
    ResourceType: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  if (data.ResourceType !== undefined && data.ResourceType !== null) {
    contents.ResourceType = data.ResourceType;
  }
  return contents;
};

const deserializeAws_restJson1_1ThrottlingExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ThrottlingException> => {
  const contents: ThrottlingException = {
    name: "ThrottlingException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const deserializeAws_restJson1_1UnsupportedUserEditionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedUserEditionException> => {
  const contents: UnsupportedUserEditionException = {
    name: "UnsupportedUserEditionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    Message: undefined,
    RequestId: undefined
  };
  const data: any = parsedOutput.body;
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  if (data.RequestId !== undefined && data.RequestId !== null) {
    contents.RequestId = data.RequestId;
  }
  return contents;
};

const serializeAws_restJson1_1AdHocFilteringOption = (
  input: AdHocFilteringOption,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AvailabilityStatus !== undefined) {
    bodyParams["AvailabilityStatus"] = input.AvailabilityStatus;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AmazonElasticsearchParameters = (
  input: AmazonElasticsearchParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Domain !== undefined) {
    bodyParams["Domain"] = input.Domain;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AthenaParameters = (
  input: AthenaParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.WorkGroup !== undefined) {
    bodyParams["WorkGroup"] = input.WorkGroup;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AuroraParameters = (
  input: AuroraParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Database !== undefined) {
    bodyParams["Database"] = input.Database;
  }
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AuroraPostgreSqlParameters = (
  input: AuroraPostgreSqlParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Database !== undefined) {
    bodyParams["Database"] = input.Database;
  }
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AwsIotAnalyticsParameters = (
  input: AwsIotAnalyticsParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DataSetName !== undefined) {
    bodyParams["DataSetName"] = input.DataSetName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CalculatedColumn = (
  input: CalculatedColumn,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ColumnId !== undefined) {
    bodyParams["ColumnId"] = input.ColumnId;
  }
  if (input.ColumnName !== undefined) {
    bodyParams["ColumnName"] = input.ColumnName;
  }
  if (input.Expression !== undefined) {
    bodyParams["Expression"] = input.Expression;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CalculatedColumnList = (
  input: CalculatedColumn[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1CalculatedColumn(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1CastColumnTypeOperation = (
  input: CastColumnTypeOperation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ColumnName !== undefined) {
    bodyParams["ColumnName"] = input.ColumnName;
  }
  if (input.Format !== undefined) {
    bodyParams["Format"] = input.Format;
  }
  if (input.NewColumnType !== undefined) {
    bodyParams["NewColumnType"] = input.NewColumnType;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ColumnGroup = (
  input: ColumnGroup,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GeoSpatialColumnGroup !== undefined) {
    bodyParams[
      "GeoSpatialColumnGroup"
    ] = serializeAws_restJson1_1GeoSpatialColumnGroup(
      input.GeoSpatialColumnGroup,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1ColumnGroupList = (
  input: ColumnGroup[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1ColumnGroup(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1ColumnList = (
  input: string[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1ColumnTag = (
  input: ColumnTag,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ColumnGeographicRole !== undefined) {
    bodyParams["ColumnGeographicRole"] = input.ColumnGeographicRole;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ColumnTagList = (
  input: ColumnTag[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1ColumnTag(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1CreateColumnsOperation = (
  input: CreateColumnsOperation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Columns !== undefined) {
    bodyParams["Columns"] = serializeAws_restJson1_1CalculatedColumnList(
      input.Columns,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1CredentialPair = (
  input: CredentialPair,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CustomSql = (
  input: CustomSql,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Columns !== undefined) {
    bodyParams["Columns"] = serializeAws_restJson1_1InputColumnList(
      input.Columns,
      context
    );
  }
  if (input.DataSourceArn !== undefined) {
    bodyParams["DataSourceArn"] = input.DataSourceArn;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.SqlQuery !== undefined) {
    bodyParams["SqlQuery"] = input.SqlQuery;
  }
  return bodyParams;
};

const serializeAws_restJson1_1DashboardPublishOptions = (
  input: DashboardPublishOptions,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AdHocFilteringOption !== undefined) {
    bodyParams[
      "AdHocFilteringOption"
    ] = serializeAws_restJson1_1AdHocFilteringOption(
      input.AdHocFilteringOption,
      context
    );
  }
  if (input.ExportToCSVOption !== undefined) {
    bodyParams["ExportToCSVOption"] = serializeAws_restJson1_1ExportToCSVOption(
      input.ExportToCSVOption,
      context
    );
  }
  if (input.SheetControlsOption !== undefined) {
    bodyParams[
      "SheetControlsOption"
    ] = serializeAws_restJson1_1SheetControlsOption(
      input.SheetControlsOption,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1DashboardSourceEntity = (
  input: DashboardSourceEntity,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SourceTemplate !== undefined) {
    bodyParams[
      "SourceTemplate"
    ] = serializeAws_restJson1_1DashboardSourceTemplate(
      input.SourceTemplate,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1DashboardSourceTemplate = (
  input: DashboardSourceTemplate,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Arn !== undefined) {
    bodyParams["Arn"] = input.Arn;
  }
  if (input.DataSetReferences !== undefined) {
    bodyParams[
      "DataSetReferences"
    ] = serializeAws_restJson1_1DataSetReferenceList(
      input.DataSetReferences,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1DataSetReference = (
  input: DataSetReference,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DataSetArn !== undefined) {
    bodyParams["DataSetArn"] = input.DataSetArn;
  }
  if (input.DataSetPlaceholder !== undefined) {
    bodyParams["DataSetPlaceholder"] = input.DataSetPlaceholder;
  }
  return bodyParams;
};

const serializeAws_restJson1_1DataSetReferenceList = (
  input: DataSetReference[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1DataSetReference(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1DataSourceCredentials = (
  input: DataSourceCredentials,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CredentialPair !== undefined) {
    bodyParams["CredentialPair"] = serializeAws_restJson1_1CredentialPair(
      input.CredentialPair,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1DataSourceParameters = (
  input: DataSourceParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AmazonElasticsearchParameters !== undefined) {
    bodyParams[
      "AmazonElasticsearchParameters"
    ] = serializeAws_restJson1_1AmazonElasticsearchParameters(
      input.AmazonElasticsearchParameters,
      context
    );
  }
  if (input.AthenaParameters !== undefined) {
    bodyParams["AthenaParameters"] = serializeAws_restJson1_1AthenaParameters(
      input.AthenaParameters,
      context
    );
  }
  if (input.AuroraParameters !== undefined) {
    bodyParams["AuroraParameters"] = serializeAws_restJson1_1AuroraParameters(
      input.AuroraParameters,
      context
    );
  }
  if (input.AuroraPostgreSqlParameters !== undefined) {
    bodyParams[
      "AuroraPostgreSqlParameters"
    ] = serializeAws_restJson1_1AuroraPostgreSqlParameters(
      input.AuroraPostgreSqlParameters,
      context
    );
  }
  if (input.AwsIotAnalyticsParameters !== undefined) {
    bodyParams[
      "AwsIotAnalyticsParameters"
    ] = serializeAws_restJson1_1AwsIotAnalyticsParameters(
      input.AwsIotAnalyticsParameters,
      context
    );
  }
  if (input.JiraParameters !== undefined) {
    bodyParams["JiraParameters"] = serializeAws_restJson1_1JiraParameters(
      input.JiraParameters,
      context
    );
  }
  if (input.MariaDbParameters !== undefined) {
    bodyParams["MariaDbParameters"] = serializeAws_restJson1_1MariaDbParameters(
      input.MariaDbParameters,
      context
    );
  }
  if (input.MySqlParameters !== undefined) {
    bodyParams["MySqlParameters"] = serializeAws_restJson1_1MySqlParameters(
      input.MySqlParameters,
      context
    );
  }
  if (input.PostgreSqlParameters !== undefined) {
    bodyParams[
      "PostgreSqlParameters"
    ] = serializeAws_restJson1_1PostgreSqlParameters(
      input.PostgreSqlParameters,
      context
    );
  }
  if (input.PrestoParameters !== undefined) {
    bodyParams["PrestoParameters"] = serializeAws_restJson1_1PrestoParameters(
      input.PrestoParameters,
      context
    );
  }
  if (input.RdsParameters !== undefined) {
    bodyParams["RdsParameters"] = serializeAws_restJson1_1RdsParameters(
      input.RdsParameters,
      context
    );
  }
  if (input.RedshiftParameters !== undefined) {
    bodyParams[
      "RedshiftParameters"
    ] = serializeAws_restJson1_1RedshiftParameters(
      input.RedshiftParameters,
      context
    );
  }
  if (input.S3Parameters !== undefined) {
    bodyParams["S3Parameters"] = serializeAws_restJson1_1S3Parameters(
      input.S3Parameters,
      context
    );
  }
  if (input.ServiceNowParameters !== undefined) {
    bodyParams[
      "ServiceNowParameters"
    ] = serializeAws_restJson1_1ServiceNowParameters(
      input.ServiceNowParameters,
      context
    );
  }
  if (input.SnowflakeParameters !== undefined) {
    bodyParams[
      "SnowflakeParameters"
    ] = serializeAws_restJson1_1SnowflakeParameters(
      input.SnowflakeParameters,
      context
    );
  }
  if (input.SparkParameters !== undefined) {
    bodyParams["SparkParameters"] = serializeAws_restJson1_1SparkParameters(
      input.SparkParameters,
      context
    );
  }
  if (input.SqlServerParameters !== undefined) {
    bodyParams[
      "SqlServerParameters"
    ] = serializeAws_restJson1_1SqlServerParameters(
      input.SqlServerParameters,
      context
    );
  }
  if (input.TeradataParameters !== undefined) {
    bodyParams[
      "TeradataParameters"
    ] = serializeAws_restJson1_1TeradataParameters(
      input.TeradataParameters,
      context
    );
  }
  if (input.TwitterParameters !== undefined) {
    bodyParams["TwitterParameters"] = serializeAws_restJson1_1TwitterParameters(
      input.TwitterParameters,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1DateTimeParameter = (
  input: DateTimeParameter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_restJson1_1TimestampList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1DateTimeParameterList = (
  input: DateTimeParameter[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1DateTimeParameter(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1DecimalParameter = (
  input: DecimalParameter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_restJson1_1DoubleList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1DecimalParameterList = (
  input: DecimalParameter[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1DecimalParameter(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1ExportToCSVOption = (
  input: ExportToCSVOption,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AvailabilityStatus !== undefined) {
    bodyParams["AvailabilityStatus"] = input.AvailabilityStatus;
  }
  return bodyParams;
};

const serializeAws_restJson1_1FilterOperation = (
  input: FilterOperation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConditionExpression !== undefined) {
    bodyParams["ConditionExpression"] = input.ConditionExpression;
  }
  return bodyParams;
};

const serializeAws_restJson1_1GeoSpatialColumnGroup = (
  input: GeoSpatialColumnGroup,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Columns !== undefined) {
    bodyParams["Columns"] = serializeAws_restJson1_1ColumnList(
      input.Columns,
      context
    );
  }
  if (input.CountryCode !== undefined) {
    bodyParams["CountryCode"] = input.CountryCode;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_restJson1_1IdentityMap = (
  input: { [key: string]: string[] },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1IdentityNameList(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_restJson1_1IdentityNameList = (
  input: string[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1InputColumn = (
  input: InputColumn,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_restJson1_1InputColumnList = (
  input: InputColumn[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1InputColumn(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1IntegerParameter = (
  input: IntegerParameter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_restJson1_1LongList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1IntegerParameterList = (
  input: IntegerParameter[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1IntegerParameter(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1JiraParameters = (
  input: JiraParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SiteBaseUrl !== undefined) {
    bodyParams["SiteBaseUrl"] = input.SiteBaseUrl;
  }
  return bodyParams;
};

const serializeAws_restJson1_1JoinInstruction = (
  input: JoinInstruction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LeftOperand !== undefined) {
    bodyParams["LeftOperand"] = input.LeftOperand;
  }
  if (input.OnClause !== undefined) {
    bodyParams["OnClause"] = input.OnClause;
  }
  if (input.RightOperand !== undefined) {
    bodyParams["RightOperand"] = input.RightOperand;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_restJson1_1LogicalTable = (
  input: LogicalTable,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Alias !== undefined) {
    bodyParams["Alias"] = input.Alias;
  }
  if (input.DataTransforms !== undefined) {
    bodyParams[
      "DataTransforms"
    ] = serializeAws_restJson1_1TransformOperationList(
      input.DataTransforms,
      context
    );
  }
  if (input.Source !== undefined) {
    bodyParams["Source"] = serializeAws_restJson1_1LogicalTableSource(
      input.Source,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1LogicalTableMap = (
  input: { [key: string]: LogicalTable },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1LogicalTable(input[key], context);
  });
  return mapParams;
};

const serializeAws_restJson1_1LogicalTableSource = (
  input: LogicalTableSource,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.JoinInstruction !== undefined) {
    bodyParams["JoinInstruction"] = serializeAws_restJson1_1JoinInstruction(
      input.JoinInstruction,
      context
    );
  }
  if (input.PhysicalTableId !== undefined) {
    bodyParams["PhysicalTableId"] = input.PhysicalTableId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ManifestFileLocation = (
  input: ManifestFileLocation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Bucket !== undefined) {
    bodyParams["Bucket"] = input.Bucket;
  }
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  return bodyParams;
};

const serializeAws_restJson1_1MariaDbParameters = (
  input: MariaDbParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Database !== undefined) {
    bodyParams["Database"] = input.Database;
  }
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  return bodyParams;
};

const serializeAws_restJson1_1MySqlParameters = (
  input: MySqlParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Database !== undefined) {
    bodyParams["Database"] = input.Database;
  }
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  return bodyParams;
};

const serializeAws_restJson1_1_Parameters = (
  input: _Parameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DateTimeParameters !== undefined) {
    bodyParams[
      "DateTimeParameters"
    ] = serializeAws_restJson1_1DateTimeParameterList(
      input.DateTimeParameters,
      context
    );
  }
  if (input.DecimalParameters !== undefined) {
    bodyParams[
      "DecimalParameters"
    ] = serializeAws_restJson1_1DecimalParameterList(
      input.DecimalParameters,
      context
    );
  }
  if (input.IntegerParameters !== undefined) {
    bodyParams[
      "IntegerParameters"
    ] = serializeAws_restJson1_1IntegerParameterList(
      input.IntegerParameters,
      context
    );
  }
  if (input.StringParameters !== undefined) {
    bodyParams[
      "StringParameters"
    ] = serializeAws_restJson1_1StringParameterList(
      input.StringParameters,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1PhysicalTable = (
  input: PhysicalTable,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CustomSql !== undefined) {
    bodyParams["CustomSql"] = serializeAws_restJson1_1CustomSql(
      input.CustomSql,
      context
    );
  }
  if (input.RelationalTable !== undefined) {
    bodyParams["RelationalTable"] = serializeAws_restJson1_1RelationalTable(
      input.RelationalTable,
      context
    );
  }
  if (input.S3Source !== undefined) {
    bodyParams["S3Source"] = serializeAws_restJson1_1S3Source(
      input.S3Source,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1PhysicalTableMap = (
  input: { [key: string]: PhysicalTable },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1PhysicalTable(input[key], context);
  });
  return mapParams;
};

const serializeAws_restJson1_1PostgreSqlParameters = (
  input: PostgreSqlParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Database !== undefined) {
    bodyParams["Database"] = input.Database;
  }
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  return bodyParams;
};

const serializeAws_restJson1_1PrestoParameters = (
  input: PrestoParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Catalog !== undefined) {
    bodyParams["Catalog"] = input.Catalog;
  }
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ProjectOperation = (
  input: ProjectOperation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ProjectedColumns !== undefined) {
    bodyParams[
      "ProjectedColumns"
    ] = serializeAws_restJson1_1ProjectedColumnList(
      input.ProjectedColumns,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1ProjectedColumnList = (
  input: string[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1RdsParameters = (
  input: RdsParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Database !== undefined) {
    bodyParams["Database"] = input.Database;
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1RedshiftParameters = (
  input: RedshiftParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ClusterId !== undefined) {
    bodyParams["ClusterId"] = input.ClusterId;
  }
  if (input.Database !== undefined) {
    bodyParams["Database"] = input.Database;
  }
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  return bodyParams;
};

const serializeAws_restJson1_1RelationalTable = (
  input: RelationalTable,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DataSourceArn !== undefined) {
    bodyParams["DataSourceArn"] = input.DataSourceArn;
  }
  if (input.InputColumns !== undefined) {
    bodyParams["InputColumns"] = serializeAws_restJson1_1InputColumnList(
      input.InputColumns,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Schema !== undefined) {
    bodyParams["Schema"] = input.Schema;
  }
  return bodyParams;
};

const serializeAws_restJson1_1RenameColumnOperation = (
  input: RenameColumnOperation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ColumnName !== undefined) {
    bodyParams["ColumnName"] = input.ColumnName;
  }
  if (input.NewColumnName !== undefined) {
    bodyParams["NewColumnName"] = input.NewColumnName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1RowLevelPermissionDataSet = (
  input: RowLevelPermissionDataSet,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Arn !== undefined) {
    bodyParams["Arn"] = input.Arn;
  }
  if (input.PermissionPolicy !== undefined) {
    bodyParams["PermissionPolicy"] = input.PermissionPolicy;
  }
  return bodyParams;
};

const serializeAws_restJson1_1S3Parameters = (
  input: S3Parameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ManifestFileLocation !== undefined) {
    bodyParams[
      "ManifestFileLocation"
    ] = serializeAws_restJson1_1ManifestFileLocation(
      input.ManifestFileLocation,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1S3Source = (
  input: S3Source,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DataSourceArn !== undefined) {
    bodyParams["DataSourceArn"] = input.DataSourceArn;
  }
  if (input.InputColumns !== undefined) {
    bodyParams["InputColumns"] = serializeAws_restJson1_1InputColumnList(
      input.InputColumns,
      context
    );
  }
  if (input.UploadSettings !== undefined) {
    bodyParams["UploadSettings"] = serializeAws_restJson1_1UploadSettings(
      input.UploadSettings,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1ServiceNowParameters = (
  input: ServiceNowParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SiteBaseUrl !== undefined) {
    bodyParams["SiteBaseUrl"] = input.SiteBaseUrl;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SheetControlsOption = (
  input: SheetControlsOption,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.VisibilityState !== undefined) {
    bodyParams["VisibilityState"] = input.VisibilityState;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SnowflakeParameters = (
  input: SnowflakeParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Database !== undefined) {
    bodyParams["Database"] = input.Database;
  }
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Warehouse !== undefined) {
    bodyParams["Warehouse"] = input.Warehouse;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SparkParameters = (
  input: SparkParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SqlServerParameters = (
  input: SqlServerParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Database !== undefined) {
    bodyParams["Database"] = input.Database;
  }
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SslProperties = (
  input: SslProperties,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DisableSsl !== undefined) {
    bodyParams["DisableSsl"] = input.DisableSsl;
  }
  return bodyParams;
};

const serializeAws_restJson1_1StringParameter = (
  input: StringParameter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_restJson1_1StringList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1StringParameterList = (
  input: StringParameter[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1StringParameter(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1TagColumnOperation = (
  input: TagColumnOperation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ColumnName !== undefined) {
    bodyParams["ColumnName"] = input.ColumnName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_restJson1_1ColumnTagList(
      input.Tags,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1TemplateSourceAnalysis = (
  input: TemplateSourceAnalysis,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Arn !== undefined) {
    bodyParams["Arn"] = input.Arn;
  }
  if (input.DataSetReferences !== undefined) {
    bodyParams[
      "DataSetReferences"
    ] = serializeAws_restJson1_1DataSetReferenceList(
      input.DataSetReferences,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1TemplateSourceEntity = (
  input: TemplateSourceEntity,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SourceAnalysis !== undefined) {
    bodyParams[
      "SourceAnalysis"
    ] = serializeAws_restJson1_1TemplateSourceAnalysis(
      input.SourceAnalysis,
      context
    );
  }
  if (input.SourceTemplate !== undefined) {
    bodyParams[
      "SourceTemplate"
    ] = serializeAws_restJson1_1TemplateSourceTemplate(
      input.SourceTemplate,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1TemplateSourceTemplate = (
  input: TemplateSourceTemplate,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Arn !== undefined) {
    bodyParams["Arn"] = input.Arn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1TeradataParameters = (
  input: TeradataParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Database !== undefined) {
    bodyParams["Database"] = input.Database;
  }
  if (input.Host !== undefined) {
    bodyParams["Host"] = input.Host;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  return bodyParams;
};

const serializeAws_restJson1_1TransformOperation = (
  input: TransformOperation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CastColumnTypeOperation !== undefined) {
    bodyParams[
      "CastColumnTypeOperation"
    ] = serializeAws_restJson1_1CastColumnTypeOperation(
      input.CastColumnTypeOperation,
      context
    );
  }
  if (input.CreateColumnsOperation !== undefined) {
    bodyParams[
      "CreateColumnsOperation"
    ] = serializeAws_restJson1_1CreateColumnsOperation(
      input.CreateColumnsOperation,
      context
    );
  }
  if (input.FilterOperation !== undefined) {
    bodyParams["FilterOperation"] = serializeAws_restJson1_1FilterOperation(
      input.FilterOperation,
      context
    );
  }
  if (input.ProjectOperation !== undefined) {
    bodyParams["ProjectOperation"] = serializeAws_restJson1_1ProjectOperation(
      input.ProjectOperation,
      context
    );
  }
  if (input.RenameColumnOperation !== undefined) {
    bodyParams[
      "RenameColumnOperation"
    ] = serializeAws_restJson1_1RenameColumnOperation(
      input.RenameColumnOperation,
      context
    );
  }
  if (input.TagColumnOperation !== undefined) {
    bodyParams[
      "TagColumnOperation"
    ] = serializeAws_restJson1_1TagColumnOperation(
      input.TagColumnOperation,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1TransformOperationList = (
  input: TransformOperation[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1TransformOperation(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1TwitterParameters = (
  input: TwitterParameters,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaxRows !== undefined) {
    bodyParams["MaxRows"] = input.MaxRows;
  }
  if (input.Query !== undefined) {
    bodyParams["Query"] = input.Query;
  }
  return bodyParams;
};

const serializeAws_restJson1_1UpdateResourcePermissionList = (
  input: ResourcePermission[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1ResourcePermission(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1UploadSettings = (
  input: UploadSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ContainsHeader !== undefined) {
    bodyParams["ContainsHeader"] = input.ContainsHeader;
  }
  if (input.Delimiter !== undefined) {
    bodyParams["Delimiter"] = input.Delimiter;
  }
  if (input.Format !== undefined) {
    bodyParams["Format"] = input.Format;
  }
  if (input.StartFromRow !== undefined) {
    bodyParams["StartFromRow"] = input.StartFromRow;
  }
  if (input.TextQualifier !== undefined) {
    bodyParams["TextQualifier"] = input.TextQualifier;
  }
  return bodyParams;
};

const serializeAws_restJson1_1VpcConnectionProperties = (
  input: VpcConnectionProperties,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.VpcConnectionArn !== undefined) {
    bodyParams["VpcConnectionArn"] = input.VpcConnectionArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ActionList = (
  input: string[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1DoubleList = (
  input: number[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1LongList = (
  input: number[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1ResourcePermission = (
  input: ResourcePermission,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Actions !== undefined) {
    bodyParams["Actions"] = serializeAws_restJson1_1ActionList(
      input.Actions,
      context
    );
  }
  if (input.Principal !== undefined) {
    bodyParams["Principal"] = input.Principal;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ResourcePermissionList = (
  input: ResourcePermission[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1ResourcePermission(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1StringList = (
  input: string[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1Tag = (
  input: Tag,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_restJson1_1TagList = (
  input: Tag[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1Tag(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1TimestampList = (
  input: Date[],
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(Math.round(entry.getTime() / 1000));
  }
  return contents;
};

const deserializeAws_restJson1_1ActiveIAMPolicyAssignment = (
  output: any,
  context: __SerdeContext
): ActiveIAMPolicyAssignment => {
  let contents: any = {
    __type: "ActiveIAMPolicyAssignment",
    AssignmentName: undefined,
    PolicyArn: undefined
  };
  if (output.AssignmentName !== undefined && output.AssignmentName !== null) {
    contents.AssignmentName = output.AssignmentName;
  }
  if (output.PolicyArn !== undefined && output.PolicyArn !== null) {
    contents.PolicyArn = output.PolicyArn;
  }
  return contents;
};

const deserializeAws_restJson1_1ActiveIAMPolicyAssignmentList = (
  output: any,
  context: __SerdeContext
): ActiveIAMPolicyAssignment[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ActiveIAMPolicyAssignment(entry, context)
  );
};

const deserializeAws_restJson1_1AmazonElasticsearchParameters = (
  output: any,
  context: __SerdeContext
): AmazonElasticsearchParameters => {
  let contents: any = {
    __type: "AmazonElasticsearchParameters",
    Domain: undefined
  };
  if (output.Domain !== undefined && output.Domain !== null) {
    contents.Domain = output.Domain;
  }
  return contents;
};

const deserializeAws_restJson1_1AthenaParameters = (
  output: any,
  context: __SerdeContext
): AthenaParameters => {
  let contents: any = {
    __type: "AthenaParameters",
    WorkGroup: undefined
  };
  if (output.WorkGroup !== undefined && output.WorkGroup !== null) {
    contents.WorkGroup = output.WorkGroup;
  }
  return contents;
};

const deserializeAws_restJson1_1AuroraParameters = (
  output: any,
  context: __SerdeContext
): AuroraParameters => {
  let contents: any = {
    __type: "AuroraParameters",
    Database: undefined,
    Host: undefined,
    Port: undefined
  };
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = output.Database;
  }
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_restJson1_1AuroraPostgreSqlParameters = (
  output: any,
  context: __SerdeContext
): AuroraPostgreSqlParameters => {
  let contents: any = {
    __type: "AuroraPostgreSqlParameters",
    Database: undefined,
    Host: undefined,
    Port: undefined
  };
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = output.Database;
  }
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_restJson1_1AwsIotAnalyticsParameters = (
  output: any,
  context: __SerdeContext
): AwsIotAnalyticsParameters => {
  let contents: any = {
    __type: "AwsIotAnalyticsParameters",
    DataSetName: undefined
  };
  if (output.DataSetName !== undefined && output.DataSetName !== null) {
    contents.DataSetName = output.DataSetName;
  }
  return contents;
};

const deserializeAws_restJson1_1CalculatedColumn = (
  output: any,
  context: __SerdeContext
): CalculatedColumn => {
  let contents: any = {
    __type: "CalculatedColumn",
    ColumnId: undefined,
    ColumnName: undefined,
    Expression: undefined
  };
  if (output.ColumnId !== undefined && output.ColumnId !== null) {
    contents.ColumnId = output.ColumnId;
  }
  if (output.ColumnName !== undefined && output.ColumnName !== null) {
    contents.ColumnName = output.ColumnName;
  }
  if (output.Expression !== undefined && output.Expression !== null) {
    contents.Expression = output.Expression;
  }
  return contents;
};

const deserializeAws_restJson1_1CalculatedColumnList = (
  output: any,
  context: __SerdeContext
): CalculatedColumn[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1CalculatedColumn(entry, context)
  );
};

const deserializeAws_restJson1_1CastColumnTypeOperation = (
  output: any,
  context: __SerdeContext
): CastColumnTypeOperation => {
  let contents: any = {
    __type: "CastColumnTypeOperation",
    ColumnName: undefined,
    Format: undefined,
    NewColumnType: undefined
  };
  if (output.ColumnName !== undefined && output.ColumnName !== null) {
    contents.ColumnName = output.ColumnName;
  }
  if (output.Format !== undefined && output.Format !== null) {
    contents.Format = output.Format;
  }
  if (output.NewColumnType !== undefined && output.NewColumnType !== null) {
    contents.NewColumnType = output.NewColumnType;
  }
  return contents;
};

const deserializeAws_restJson1_1ColumnGroup = (
  output: any,
  context: __SerdeContext
): ColumnGroup => {
  let contents: any = {
    __type: "ColumnGroup",
    GeoSpatialColumnGroup: undefined
  };
  if (
    output.GeoSpatialColumnGroup !== undefined &&
    output.GeoSpatialColumnGroup !== null
  ) {
    contents.GeoSpatialColumnGroup = deserializeAws_restJson1_1GeoSpatialColumnGroup(
      output.GeoSpatialColumnGroup,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ColumnGroupColumnSchema = (
  output: any,
  context: __SerdeContext
): ColumnGroupColumnSchema => {
  let contents: any = {
    __type: "ColumnGroupColumnSchema",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_restJson1_1ColumnGroupColumnSchemaList = (
  output: any,
  context: __SerdeContext
): ColumnGroupColumnSchema[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ColumnGroupColumnSchema(entry, context)
  );
};

const deserializeAws_restJson1_1ColumnGroupList = (
  output: any,
  context: __SerdeContext
): ColumnGroup[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ColumnGroup(entry, context)
  );
};

const deserializeAws_restJson1_1ColumnGroupSchema = (
  output: any,
  context: __SerdeContext
): ColumnGroupSchema => {
  let contents: any = {
    __type: "ColumnGroupSchema",
    ColumnGroupColumnSchemaList: undefined,
    Name: undefined
  };
  if (
    output.ColumnGroupColumnSchemaList !== undefined &&
    output.ColumnGroupColumnSchemaList !== null
  ) {
    contents.ColumnGroupColumnSchemaList = deserializeAws_restJson1_1ColumnGroupColumnSchemaList(
      output.ColumnGroupColumnSchemaList,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_restJson1_1ColumnGroupSchemaList = (
  output: any,
  context: __SerdeContext
): ColumnGroupSchema[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ColumnGroupSchema(entry, context)
  );
};

const deserializeAws_restJson1_1ColumnList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1ColumnSchema = (
  output: any,
  context: __SerdeContext
): ColumnSchema => {
  let contents: any = {
    __type: "ColumnSchema",
    DataType: undefined,
    GeographicRole: undefined,
    Name: undefined
  };
  if (output.DataType !== undefined && output.DataType !== null) {
    contents.DataType = output.DataType;
  }
  if (output.GeographicRole !== undefined && output.GeographicRole !== null) {
    contents.GeographicRole = output.GeographicRole;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_restJson1_1ColumnSchemaList = (
  output: any,
  context: __SerdeContext
): ColumnSchema[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ColumnSchema(entry, context)
  );
};

const deserializeAws_restJson1_1ColumnTag = (
  output: any,
  context: __SerdeContext
): ColumnTag => {
  let contents: any = {
    __type: "ColumnTag",
    ColumnGeographicRole: undefined
  };
  if (
    output.ColumnGeographicRole !== undefined &&
    output.ColumnGeographicRole !== null
  ) {
    contents.ColumnGeographicRole = output.ColumnGeographicRole;
  }
  return contents;
};

const deserializeAws_restJson1_1ColumnTagList = (
  output: any,
  context: __SerdeContext
): ColumnTag[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ColumnTag(entry, context)
  );
};

const deserializeAws_restJson1_1CreateColumnsOperation = (
  output: any,
  context: __SerdeContext
): CreateColumnsOperation => {
  let contents: any = {
    __type: "CreateColumnsOperation",
    Columns: undefined
  };
  if (output.Columns !== undefined && output.Columns !== null) {
    contents.Columns = deserializeAws_restJson1_1CalculatedColumnList(
      output.Columns,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1CustomSql = (
  output: any,
  context: __SerdeContext
): CustomSql => {
  let contents: any = {
    __type: "CustomSql",
    Columns: undefined,
    DataSourceArn: undefined,
    Name: undefined,
    SqlQuery: undefined
  };
  if (output.Columns !== undefined && output.Columns !== null) {
    contents.Columns = deserializeAws_restJson1_1InputColumnList(
      output.Columns,
      context
    );
  }
  if (output.DataSourceArn !== undefined && output.DataSourceArn !== null) {
    contents.DataSourceArn = output.DataSourceArn;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.SqlQuery !== undefined && output.SqlQuery !== null) {
    contents.SqlQuery = output.SqlQuery;
  }
  return contents;
};

const deserializeAws_restJson1_1Dashboard = (
  output: any,
  context: __SerdeContext
): Dashboard => {
  let contents: any = {
    __type: "Dashboard",
    Arn: undefined,
    CreatedTime: undefined,
    DashboardId: undefined,
    LastPublishedTime: undefined,
    LastUpdatedTime: undefined,
    Name: undefined,
    Version: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.DashboardId !== undefined && output.DashboardId !== null) {
    contents.DashboardId = output.DashboardId;
  }
  if (
    output.LastPublishedTime !== undefined &&
    output.LastPublishedTime !== null
  ) {
    contents.LastPublishedTime = new Date(
      Math.round(output.LastPublishedTime * 1000)
    );
  }
  if (output.LastUpdatedTime !== undefined && output.LastUpdatedTime !== null) {
    contents.LastUpdatedTime = new Date(
      Math.round(output.LastUpdatedTime * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = deserializeAws_restJson1_1DashboardVersion(
      output.Version,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1DashboardError = (
  output: any,
  context: __SerdeContext
): DashboardError => {
  let contents: any = {
    __type: "DashboardError",
    Message: undefined,
    Type: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1DashboardErrorList = (
  output: any,
  context: __SerdeContext
): DashboardError[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DashboardError(entry, context)
  );
};

const deserializeAws_restJson1_1DashboardSummary = (
  output: any,
  context: __SerdeContext
): DashboardSummary => {
  let contents: any = {
    __type: "DashboardSummary",
    Arn: undefined,
    CreatedTime: undefined,
    DashboardId: undefined,
    LastPublishedTime: undefined,
    LastUpdatedTime: undefined,
    Name: undefined,
    PublishedVersionNumber: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.DashboardId !== undefined && output.DashboardId !== null) {
    contents.DashboardId = output.DashboardId;
  }
  if (
    output.LastPublishedTime !== undefined &&
    output.LastPublishedTime !== null
  ) {
    contents.LastPublishedTime = new Date(
      Math.round(output.LastPublishedTime * 1000)
    );
  }
  if (output.LastUpdatedTime !== undefined && output.LastUpdatedTime !== null) {
    contents.LastUpdatedTime = new Date(
      Math.round(output.LastUpdatedTime * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.PublishedVersionNumber !== undefined &&
    output.PublishedVersionNumber !== null
  ) {
    contents.PublishedVersionNumber = output.PublishedVersionNumber;
  }
  return contents;
};

const deserializeAws_restJson1_1DashboardSummaryList = (
  output: any,
  context: __SerdeContext
): DashboardSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DashboardSummary(entry, context)
  );
};

const deserializeAws_restJson1_1DashboardVersion = (
  output: any,
  context: __SerdeContext
): DashboardVersion => {
  let contents: any = {
    __type: "DashboardVersion",
    Arn: undefined,
    CreatedTime: undefined,
    Description: undefined,
    Errors: undefined,
    SourceEntityArn: undefined,
    Status: undefined,
    VersionNumber: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Errors !== undefined && output.Errors !== null) {
    contents.Errors = deserializeAws_restJson1_1DashboardErrorList(
      output.Errors,
      context
    );
  }
  if (output.SourceEntityArn !== undefined && output.SourceEntityArn !== null) {
    contents.SourceEntityArn = output.SourceEntityArn;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.VersionNumber !== undefined && output.VersionNumber !== null) {
    contents.VersionNumber = output.VersionNumber;
  }
  return contents;
};

const deserializeAws_restJson1_1DashboardVersionSummary = (
  output: any,
  context: __SerdeContext
): DashboardVersionSummary => {
  let contents: any = {
    __type: "DashboardVersionSummary",
    Arn: undefined,
    CreatedTime: undefined,
    Description: undefined,
    SourceEntityArn: undefined,
    Status: undefined,
    VersionNumber: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.SourceEntityArn !== undefined && output.SourceEntityArn !== null) {
    contents.SourceEntityArn = output.SourceEntityArn;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.VersionNumber !== undefined && output.VersionNumber !== null) {
    contents.VersionNumber = output.VersionNumber;
  }
  return contents;
};

const deserializeAws_restJson1_1DashboardVersionSummaryList = (
  output: any,
  context: __SerdeContext
): DashboardVersionSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DashboardVersionSummary(entry, context)
  );
};

const deserializeAws_restJson1_1DataSet = (
  output: any,
  context: __SerdeContext
): DataSet => {
  let contents: any = {
    __type: "DataSet",
    Arn: undefined,
    ColumnGroups: undefined,
    ConsumedSpiceCapacityInBytes: undefined,
    CreatedTime: undefined,
    DataSetId: undefined,
    ImportMode: undefined,
    LastUpdatedTime: undefined,
    LogicalTableMap: undefined,
    Name: undefined,
    OutputColumns: undefined,
    PhysicalTableMap: undefined,
    RowLevelPermissionDataSet: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.ColumnGroups !== undefined && output.ColumnGroups !== null) {
    contents.ColumnGroups = deserializeAws_restJson1_1ColumnGroupList(
      output.ColumnGroups,
      context
    );
  }
  if (
    output.ConsumedSpiceCapacityInBytes !== undefined &&
    output.ConsumedSpiceCapacityInBytes !== null
  ) {
    contents.ConsumedSpiceCapacityInBytes = output.ConsumedSpiceCapacityInBytes;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.DataSetId !== undefined && output.DataSetId !== null) {
    contents.DataSetId = output.DataSetId;
  }
  if (output.ImportMode !== undefined && output.ImportMode !== null) {
    contents.ImportMode = output.ImportMode;
  }
  if (output.LastUpdatedTime !== undefined && output.LastUpdatedTime !== null) {
    contents.LastUpdatedTime = new Date(
      Math.round(output.LastUpdatedTime * 1000)
    );
  }
  if (output.LogicalTableMap !== undefined && output.LogicalTableMap !== null) {
    contents.LogicalTableMap = deserializeAws_restJson1_1LogicalTableMap(
      output.LogicalTableMap,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.OutputColumns !== undefined && output.OutputColumns !== null) {
    contents.OutputColumns = deserializeAws_restJson1_1OutputColumnList(
      output.OutputColumns,
      context
    );
  }
  if (
    output.PhysicalTableMap !== undefined &&
    output.PhysicalTableMap !== null
  ) {
    contents.PhysicalTableMap = deserializeAws_restJson1_1PhysicalTableMap(
      output.PhysicalTableMap,
      context
    );
  }
  if (
    output.RowLevelPermissionDataSet !== undefined &&
    output.RowLevelPermissionDataSet !== null
  ) {
    contents.RowLevelPermissionDataSet = deserializeAws_restJson1_1RowLevelPermissionDataSet(
      output.RowLevelPermissionDataSet,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1DataSetConfiguration = (
  output: any,
  context: __SerdeContext
): DataSetConfiguration => {
  let contents: any = {
    __type: "DataSetConfiguration",
    ColumnGroupSchemaList: undefined,
    DataSetSchema: undefined,
    Placeholder: undefined
  };
  if (
    output.ColumnGroupSchemaList !== undefined &&
    output.ColumnGroupSchemaList !== null
  ) {
    contents.ColumnGroupSchemaList = deserializeAws_restJson1_1ColumnGroupSchemaList(
      output.ColumnGroupSchemaList,
      context
    );
  }
  if (output.DataSetSchema !== undefined && output.DataSetSchema !== null) {
    contents.DataSetSchema = deserializeAws_restJson1_1DataSetSchema(
      output.DataSetSchema,
      context
    );
  }
  if (output.Placeholder !== undefined && output.Placeholder !== null) {
    contents.Placeholder = output.Placeholder;
  }
  return contents;
};

const deserializeAws_restJson1_1DataSetConfigurationList = (
  output: any,
  context: __SerdeContext
): DataSetConfiguration[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DataSetConfiguration(entry, context)
  );
};

const deserializeAws_restJson1_1DataSetSchema = (
  output: any,
  context: __SerdeContext
): DataSetSchema => {
  let contents: any = {
    __type: "DataSetSchema",
    ColumnSchemaList: undefined
  };
  if (
    output.ColumnSchemaList !== undefined &&
    output.ColumnSchemaList !== null
  ) {
    contents.ColumnSchemaList = deserializeAws_restJson1_1ColumnSchemaList(
      output.ColumnSchemaList,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1DataSetSummary = (
  output: any,
  context: __SerdeContext
): DataSetSummary => {
  let contents: any = {
    __type: "DataSetSummary",
    Arn: undefined,
    CreatedTime: undefined,
    DataSetId: undefined,
    ImportMode: undefined,
    LastUpdatedTime: undefined,
    Name: undefined,
    RowLevelPermissionDataSet: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.DataSetId !== undefined && output.DataSetId !== null) {
    contents.DataSetId = output.DataSetId;
  }
  if (output.ImportMode !== undefined && output.ImportMode !== null) {
    contents.ImportMode = output.ImportMode;
  }
  if (output.LastUpdatedTime !== undefined && output.LastUpdatedTime !== null) {
    contents.LastUpdatedTime = new Date(
      Math.round(output.LastUpdatedTime * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.RowLevelPermissionDataSet !== undefined &&
    output.RowLevelPermissionDataSet !== null
  ) {
    contents.RowLevelPermissionDataSet = deserializeAws_restJson1_1RowLevelPermissionDataSet(
      output.RowLevelPermissionDataSet,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1DataSetSummaryList = (
  output: any,
  context: __SerdeContext
): DataSetSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DataSetSummary(entry, context)
  );
};

const deserializeAws_restJson1_1DataSource = (
  output: any,
  context: __SerdeContext
): DataSource => {
  let contents: any = {
    __type: "DataSource",
    Arn: undefined,
    CreatedTime: undefined,
    DataSourceId: undefined,
    DataSourceParameters: undefined,
    ErrorInfo: undefined,
    LastUpdatedTime: undefined,
    Name: undefined,
    SslProperties: undefined,
    Status: undefined,
    Type: undefined,
    VpcConnectionProperties: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.DataSourceId !== undefined && output.DataSourceId !== null) {
    contents.DataSourceId = output.DataSourceId;
  }
  if (
    output.DataSourceParameters !== undefined &&
    output.DataSourceParameters !== null
  ) {
    contents.DataSourceParameters = deserializeAws_restJson1_1DataSourceParameters(
      output.DataSourceParameters,
      context
    );
  }
  if (output.ErrorInfo !== undefined && output.ErrorInfo !== null) {
    contents.ErrorInfo = deserializeAws_restJson1_1DataSourceErrorInfo(
      output.ErrorInfo,
      context
    );
  }
  if (output.LastUpdatedTime !== undefined && output.LastUpdatedTime !== null) {
    contents.LastUpdatedTime = new Date(
      Math.round(output.LastUpdatedTime * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.SslProperties !== undefined && output.SslProperties !== null) {
    contents.SslProperties = deserializeAws_restJson1_1SslProperties(
      output.SslProperties,
      context
    );
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  if (
    output.VpcConnectionProperties !== undefined &&
    output.VpcConnectionProperties !== null
  ) {
    contents.VpcConnectionProperties = deserializeAws_restJson1_1VpcConnectionProperties(
      output.VpcConnectionProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1DataSourceErrorInfo = (
  output: any,
  context: __SerdeContext
): DataSourceErrorInfo => {
  let contents: any = {
    __type: "DataSourceErrorInfo",
    Message: undefined,
    Type: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1DataSourceList = (
  output: any,
  context: __SerdeContext
): DataSource[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DataSource(entry, context)
  );
};

const deserializeAws_restJson1_1DataSourceParameters = (
  output: any,
  context: __SerdeContext
): DataSourceParameters => {
  let contents: any = {
    __type: "DataSourceParameters",
    AmazonElasticsearchParameters: undefined,
    AthenaParameters: undefined,
    AuroraParameters: undefined,
    AuroraPostgreSqlParameters: undefined,
    AwsIotAnalyticsParameters: undefined,
    JiraParameters: undefined,
    MariaDbParameters: undefined,
    MySqlParameters: undefined,
    PostgreSqlParameters: undefined,
    PrestoParameters: undefined,
    RdsParameters: undefined,
    RedshiftParameters: undefined,
    S3Parameters: undefined,
    ServiceNowParameters: undefined,
    SnowflakeParameters: undefined,
    SparkParameters: undefined,
    SqlServerParameters: undefined,
    TeradataParameters: undefined,
    TwitterParameters: undefined
  };
  if (
    output.AmazonElasticsearchParameters !== undefined &&
    output.AmazonElasticsearchParameters !== null
  ) {
    contents.AmazonElasticsearchParameters = deserializeAws_restJson1_1AmazonElasticsearchParameters(
      output.AmazonElasticsearchParameters,
      context
    );
  }
  if (
    output.AthenaParameters !== undefined &&
    output.AthenaParameters !== null
  ) {
    contents.AthenaParameters = deserializeAws_restJson1_1AthenaParameters(
      output.AthenaParameters,
      context
    );
  }
  if (
    output.AuroraParameters !== undefined &&
    output.AuroraParameters !== null
  ) {
    contents.AuroraParameters = deserializeAws_restJson1_1AuroraParameters(
      output.AuroraParameters,
      context
    );
  }
  if (
    output.AuroraPostgreSqlParameters !== undefined &&
    output.AuroraPostgreSqlParameters !== null
  ) {
    contents.AuroraPostgreSqlParameters = deserializeAws_restJson1_1AuroraPostgreSqlParameters(
      output.AuroraPostgreSqlParameters,
      context
    );
  }
  if (
    output.AwsIotAnalyticsParameters !== undefined &&
    output.AwsIotAnalyticsParameters !== null
  ) {
    contents.AwsIotAnalyticsParameters = deserializeAws_restJson1_1AwsIotAnalyticsParameters(
      output.AwsIotAnalyticsParameters,
      context
    );
  }
  if (output.JiraParameters !== undefined && output.JiraParameters !== null) {
    contents.JiraParameters = deserializeAws_restJson1_1JiraParameters(
      output.JiraParameters,
      context
    );
  }
  if (
    output.MariaDbParameters !== undefined &&
    output.MariaDbParameters !== null
  ) {
    contents.MariaDbParameters = deserializeAws_restJson1_1MariaDbParameters(
      output.MariaDbParameters,
      context
    );
  }
  if (output.MySqlParameters !== undefined && output.MySqlParameters !== null) {
    contents.MySqlParameters = deserializeAws_restJson1_1MySqlParameters(
      output.MySqlParameters,
      context
    );
  }
  if (
    output.PostgreSqlParameters !== undefined &&
    output.PostgreSqlParameters !== null
  ) {
    contents.PostgreSqlParameters = deserializeAws_restJson1_1PostgreSqlParameters(
      output.PostgreSqlParameters,
      context
    );
  }
  if (
    output.PrestoParameters !== undefined &&
    output.PrestoParameters !== null
  ) {
    contents.PrestoParameters = deserializeAws_restJson1_1PrestoParameters(
      output.PrestoParameters,
      context
    );
  }
  if (output.RdsParameters !== undefined && output.RdsParameters !== null) {
    contents.RdsParameters = deserializeAws_restJson1_1RdsParameters(
      output.RdsParameters,
      context
    );
  }
  if (
    output.RedshiftParameters !== undefined &&
    output.RedshiftParameters !== null
  ) {
    contents.RedshiftParameters = deserializeAws_restJson1_1RedshiftParameters(
      output.RedshiftParameters,
      context
    );
  }
  if (output.S3Parameters !== undefined && output.S3Parameters !== null) {
    contents.S3Parameters = deserializeAws_restJson1_1S3Parameters(
      output.S3Parameters,
      context
    );
  }
  if (
    output.ServiceNowParameters !== undefined &&
    output.ServiceNowParameters !== null
  ) {
    contents.ServiceNowParameters = deserializeAws_restJson1_1ServiceNowParameters(
      output.ServiceNowParameters,
      context
    );
  }
  if (
    output.SnowflakeParameters !== undefined &&
    output.SnowflakeParameters !== null
  ) {
    contents.SnowflakeParameters = deserializeAws_restJson1_1SnowflakeParameters(
      output.SnowflakeParameters,
      context
    );
  }
  if (output.SparkParameters !== undefined && output.SparkParameters !== null) {
    contents.SparkParameters = deserializeAws_restJson1_1SparkParameters(
      output.SparkParameters,
      context
    );
  }
  if (
    output.SqlServerParameters !== undefined &&
    output.SqlServerParameters !== null
  ) {
    contents.SqlServerParameters = deserializeAws_restJson1_1SqlServerParameters(
      output.SqlServerParameters,
      context
    );
  }
  if (
    output.TeradataParameters !== undefined &&
    output.TeradataParameters !== null
  ) {
    contents.TeradataParameters = deserializeAws_restJson1_1TeradataParameters(
      output.TeradataParameters,
      context
    );
  }
  if (
    output.TwitterParameters !== undefined &&
    output.TwitterParameters !== null
  ) {
    contents.TwitterParameters = deserializeAws_restJson1_1TwitterParameters(
      output.TwitterParameters,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ErrorInfo = (
  output: any,
  context: __SerdeContext
): ErrorInfo => {
  let contents: any = {
    __type: "ErrorInfo",
    Message: undefined,
    Type: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1FilterOperation = (
  output: any,
  context: __SerdeContext
): FilterOperation => {
  let contents: any = {
    __type: "FilterOperation",
    ConditionExpression: undefined
  };
  if (
    output.ConditionExpression !== undefined &&
    output.ConditionExpression !== null
  ) {
    contents.ConditionExpression = output.ConditionExpression;
  }
  return contents;
};

const deserializeAws_restJson1_1GeoSpatialColumnGroup = (
  output: any,
  context: __SerdeContext
): GeoSpatialColumnGroup => {
  let contents: any = {
    __type: "GeoSpatialColumnGroup",
    Columns: undefined,
    CountryCode: undefined,
    Name: undefined
  };
  if (output.Columns !== undefined && output.Columns !== null) {
    contents.Columns = deserializeAws_restJson1_1ColumnList(
      output.Columns,
      context
    );
  }
  if (output.CountryCode !== undefined && output.CountryCode !== null) {
    contents.CountryCode = output.CountryCode;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_restJson1_1Group = (
  output: any,
  context: __SerdeContext
): Group => {
  let contents: any = {
    __type: "Group",
    Arn: undefined,
    Description: undefined,
    GroupName: undefined,
    PrincipalId: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.GroupName !== undefined && output.GroupName !== null) {
    contents.GroupName = output.GroupName;
  }
  if (output.PrincipalId !== undefined && output.PrincipalId !== null) {
    contents.PrincipalId = output.PrincipalId;
  }
  return contents;
};

const deserializeAws_restJson1_1GroupList = (
  output: any,
  context: __SerdeContext
): Group[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Group(entry, context)
  );
};

const deserializeAws_restJson1_1GroupMember = (
  output: any,
  context: __SerdeContext
): GroupMember => {
  let contents: any = {
    __type: "GroupMember",
    Arn: undefined,
    MemberName: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.MemberName !== undefined && output.MemberName !== null) {
    contents.MemberName = output.MemberName;
  }
  return contents;
};

const deserializeAws_restJson1_1GroupMemberList = (
  output: any,
  context: __SerdeContext
): GroupMember[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1GroupMember(entry, context)
  );
};

const deserializeAws_restJson1_1IAMPolicyAssignment = (
  output: any,
  context: __SerdeContext
): IAMPolicyAssignment => {
  let contents: any = {
    __type: "IAMPolicyAssignment",
    AssignmentId: undefined,
    AssignmentName: undefined,
    AssignmentStatus: undefined,
    AwsAccountId: undefined,
    Identities: undefined,
    PolicyArn: undefined
  };
  if (output.AssignmentId !== undefined && output.AssignmentId !== null) {
    contents.AssignmentId = output.AssignmentId;
  }
  if (output.AssignmentName !== undefined && output.AssignmentName !== null) {
    contents.AssignmentName = output.AssignmentName;
  }
  if (
    output.AssignmentStatus !== undefined &&
    output.AssignmentStatus !== null
  ) {
    contents.AssignmentStatus = output.AssignmentStatus;
  }
  if (output.AwsAccountId !== undefined && output.AwsAccountId !== null) {
    contents.AwsAccountId = output.AwsAccountId;
  }
  if (output.Identities !== undefined && output.Identities !== null) {
    contents.Identities = deserializeAws_restJson1_1IdentityMap(
      output.Identities,
      context
    );
  }
  if (output.PolicyArn !== undefined && output.PolicyArn !== null) {
    contents.PolicyArn = output.PolicyArn;
  }
  return contents;
};

const deserializeAws_restJson1_1IAMPolicyAssignmentSummary = (
  output: any,
  context: __SerdeContext
): IAMPolicyAssignmentSummary => {
  let contents: any = {
    __type: "IAMPolicyAssignmentSummary",
    AssignmentName: undefined,
    AssignmentStatus: undefined
  };
  if (output.AssignmentName !== undefined && output.AssignmentName !== null) {
    contents.AssignmentName = output.AssignmentName;
  }
  if (
    output.AssignmentStatus !== undefined &&
    output.AssignmentStatus !== null
  ) {
    contents.AssignmentStatus = output.AssignmentStatus;
  }
  return contents;
};

const deserializeAws_restJson1_1IAMPolicyAssignmentSummaryList = (
  output: any,
  context: __SerdeContext
): IAMPolicyAssignmentSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1IAMPolicyAssignmentSummary(entry, context)
  );
};

const deserializeAws_restJson1_1IdentityMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string[] } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1IdentityNameList(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1IdentityNameList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1Ingestion = (
  output: any,
  context: __SerdeContext
): Ingestion => {
  let contents: any = {
    __type: "Ingestion",
    Arn: undefined,
    CreatedTime: undefined,
    ErrorInfo: undefined,
    IngestionId: undefined,
    IngestionSizeInBytes: undefined,
    IngestionStatus: undefined,
    IngestionTimeInSeconds: undefined,
    QueueInfo: undefined,
    RequestSource: undefined,
    RequestType: undefined,
    RowInfo: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.ErrorInfo !== undefined && output.ErrorInfo !== null) {
    contents.ErrorInfo = deserializeAws_restJson1_1ErrorInfo(
      output.ErrorInfo,
      context
    );
  }
  if (output.IngestionId !== undefined && output.IngestionId !== null) {
    contents.IngestionId = output.IngestionId;
  }
  if (
    output.IngestionSizeInBytes !== undefined &&
    output.IngestionSizeInBytes !== null
  ) {
    contents.IngestionSizeInBytes = output.IngestionSizeInBytes;
  }
  if (output.IngestionStatus !== undefined && output.IngestionStatus !== null) {
    contents.IngestionStatus = output.IngestionStatus;
  }
  if (
    output.IngestionTimeInSeconds !== undefined &&
    output.IngestionTimeInSeconds !== null
  ) {
    contents.IngestionTimeInSeconds = output.IngestionTimeInSeconds;
  }
  if (output.QueueInfo !== undefined && output.QueueInfo !== null) {
    contents.QueueInfo = deserializeAws_restJson1_1QueueInfo(
      output.QueueInfo,
      context
    );
  }
  if (output.RequestSource !== undefined && output.RequestSource !== null) {
    contents.RequestSource = output.RequestSource;
  }
  if (output.RequestType !== undefined && output.RequestType !== null) {
    contents.RequestType = output.RequestType;
  }
  if (output.RowInfo !== undefined && output.RowInfo !== null) {
    contents.RowInfo = deserializeAws_restJson1_1RowInfo(
      output.RowInfo,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Ingestions = (
  output: any,
  context: __SerdeContext
): Ingestion[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Ingestion(entry, context)
  );
};

const deserializeAws_restJson1_1InputColumn = (
  output: any,
  context: __SerdeContext
): InputColumn => {
  let contents: any = {
    __type: "InputColumn",
    Name: undefined,
    Type: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1InputColumnList = (
  output: any,
  context: __SerdeContext
): InputColumn[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1InputColumn(entry, context)
  );
};

const deserializeAws_restJson1_1JiraParameters = (
  output: any,
  context: __SerdeContext
): JiraParameters => {
  let contents: any = {
    __type: "JiraParameters",
    SiteBaseUrl: undefined
  };
  if (output.SiteBaseUrl !== undefined && output.SiteBaseUrl !== null) {
    contents.SiteBaseUrl = output.SiteBaseUrl;
  }
  return contents;
};

const deserializeAws_restJson1_1JoinInstruction = (
  output: any,
  context: __SerdeContext
): JoinInstruction => {
  let contents: any = {
    __type: "JoinInstruction",
    LeftOperand: undefined,
    OnClause: undefined,
    RightOperand: undefined,
    Type: undefined
  };
  if (output.LeftOperand !== undefined && output.LeftOperand !== null) {
    contents.LeftOperand = output.LeftOperand;
  }
  if (output.OnClause !== undefined && output.OnClause !== null) {
    contents.OnClause = output.OnClause;
  }
  if (output.RightOperand !== undefined && output.RightOperand !== null) {
    contents.RightOperand = output.RightOperand;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1LogicalTable = (
  output: any,
  context: __SerdeContext
): LogicalTable => {
  let contents: any = {
    __type: "LogicalTable",
    Alias: undefined,
    DataTransforms: undefined,
    Source: undefined
  };
  if (output.Alias !== undefined && output.Alias !== null) {
    contents.Alias = output.Alias;
  }
  if (output.DataTransforms !== undefined && output.DataTransforms !== null) {
    contents.DataTransforms = deserializeAws_restJson1_1TransformOperationList(
      output.DataTransforms,
      context
    );
  }
  if (output.Source !== undefined && output.Source !== null) {
    contents.Source = deserializeAws_restJson1_1LogicalTableSource(
      output.Source,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1LogicalTableMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: LogicalTable } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1LogicalTable(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1LogicalTableSource = (
  output: any,
  context: __SerdeContext
): LogicalTableSource => {
  let contents: any = {
    __type: "LogicalTableSource",
    JoinInstruction: undefined,
    PhysicalTableId: undefined
  };
  if (output.JoinInstruction !== undefined && output.JoinInstruction !== null) {
    contents.JoinInstruction = deserializeAws_restJson1_1JoinInstruction(
      output.JoinInstruction,
      context
    );
  }
  if (output.PhysicalTableId !== undefined && output.PhysicalTableId !== null) {
    contents.PhysicalTableId = output.PhysicalTableId;
  }
  return contents;
};

const deserializeAws_restJson1_1ManifestFileLocation = (
  output: any,
  context: __SerdeContext
): ManifestFileLocation => {
  let contents: any = {
    __type: "ManifestFileLocation",
    Bucket: undefined,
    Key: undefined
  };
  if (output.Bucket !== undefined && output.Bucket !== null) {
    contents.Bucket = output.Bucket;
  }
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  return contents;
};

const deserializeAws_restJson1_1MariaDbParameters = (
  output: any,
  context: __SerdeContext
): MariaDbParameters => {
  let contents: any = {
    __type: "MariaDbParameters",
    Database: undefined,
    Host: undefined,
    Port: undefined
  };
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = output.Database;
  }
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_restJson1_1MySqlParameters = (
  output: any,
  context: __SerdeContext
): MySqlParameters => {
  let contents: any = {
    __type: "MySqlParameters",
    Database: undefined,
    Host: undefined,
    Port: undefined
  };
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = output.Database;
  }
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_restJson1_1OutputColumn = (
  output: any,
  context: __SerdeContext
): OutputColumn => {
  let contents: any = {
    __type: "OutputColumn",
    Name: undefined,
    Type: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1OutputColumnList = (
  output: any,
  context: __SerdeContext
): OutputColumn[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1OutputColumn(entry, context)
  );
};

const deserializeAws_restJson1_1PhysicalTable = (
  output: any,
  context: __SerdeContext
): PhysicalTable => {
  let contents: any = {
    __type: "PhysicalTable",
    CustomSql: undefined,
    RelationalTable: undefined,
    S3Source: undefined
  };
  if (output.CustomSql !== undefined && output.CustomSql !== null) {
    contents.CustomSql = deserializeAws_restJson1_1CustomSql(
      output.CustomSql,
      context
    );
  }
  if (output.RelationalTable !== undefined && output.RelationalTable !== null) {
    contents.RelationalTable = deserializeAws_restJson1_1RelationalTable(
      output.RelationalTable,
      context
    );
  }
  if (output.S3Source !== undefined && output.S3Source !== null) {
    contents.S3Source = deserializeAws_restJson1_1S3Source(
      output.S3Source,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1PhysicalTableMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: PhysicalTable } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1PhysicalTable(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1PostgreSqlParameters = (
  output: any,
  context: __SerdeContext
): PostgreSqlParameters => {
  let contents: any = {
    __type: "PostgreSqlParameters",
    Database: undefined,
    Host: undefined,
    Port: undefined
  };
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = output.Database;
  }
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_restJson1_1PrestoParameters = (
  output: any,
  context: __SerdeContext
): PrestoParameters => {
  let contents: any = {
    __type: "PrestoParameters",
    Catalog: undefined,
    Host: undefined,
    Port: undefined
  };
  if (output.Catalog !== undefined && output.Catalog !== null) {
    contents.Catalog = output.Catalog;
  }
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_restJson1_1ProjectOperation = (
  output: any,
  context: __SerdeContext
): ProjectOperation => {
  let contents: any = {
    __type: "ProjectOperation",
    ProjectedColumns: undefined
  };
  if (
    output.ProjectedColumns !== undefined &&
    output.ProjectedColumns !== null
  ) {
    contents.ProjectedColumns = deserializeAws_restJson1_1ProjectedColumnList(
      output.ProjectedColumns,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ProjectedColumnList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1QueueInfo = (
  output: any,
  context: __SerdeContext
): QueueInfo => {
  let contents: any = {
    __type: "QueueInfo",
    QueuedIngestion: undefined,
    WaitingOnIngestion: undefined
  };
  if (output.QueuedIngestion !== undefined && output.QueuedIngestion !== null) {
    contents.QueuedIngestion = output.QueuedIngestion;
  }
  if (
    output.WaitingOnIngestion !== undefined &&
    output.WaitingOnIngestion !== null
  ) {
    contents.WaitingOnIngestion = output.WaitingOnIngestion;
  }
  return contents;
};

const deserializeAws_restJson1_1RdsParameters = (
  output: any,
  context: __SerdeContext
): RdsParameters => {
  let contents: any = {
    __type: "RdsParameters",
    Database: undefined,
    InstanceId: undefined
  };
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = output.Database;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  return contents;
};

const deserializeAws_restJson1_1RedshiftParameters = (
  output: any,
  context: __SerdeContext
): RedshiftParameters => {
  let contents: any = {
    __type: "RedshiftParameters",
    ClusterId: undefined,
    Database: undefined,
    Host: undefined,
    Port: undefined
  };
  if (output.ClusterId !== undefined && output.ClusterId !== null) {
    contents.ClusterId = output.ClusterId;
  }
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = output.Database;
  }
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_restJson1_1RelationalTable = (
  output: any,
  context: __SerdeContext
): RelationalTable => {
  let contents: any = {
    __type: "RelationalTable",
    DataSourceArn: undefined,
    InputColumns: undefined,
    Name: undefined,
    Schema: undefined
  };
  if (output.DataSourceArn !== undefined && output.DataSourceArn !== null) {
    contents.DataSourceArn = output.DataSourceArn;
  }
  if (output.InputColumns !== undefined && output.InputColumns !== null) {
    contents.InputColumns = deserializeAws_restJson1_1InputColumnList(
      output.InputColumns,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.Schema !== undefined && output.Schema !== null) {
    contents.Schema = output.Schema;
  }
  return contents;
};

const deserializeAws_restJson1_1RenameColumnOperation = (
  output: any,
  context: __SerdeContext
): RenameColumnOperation => {
  let contents: any = {
    __type: "RenameColumnOperation",
    ColumnName: undefined,
    NewColumnName: undefined
  };
  if (output.ColumnName !== undefined && output.ColumnName !== null) {
    contents.ColumnName = output.ColumnName;
  }
  if (output.NewColumnName !== undefined && output.NewColumnName !== null) {
    contents.NewColumnName = output.NewColumnName;
  }
  return contents;
};

const deserializeAws_restJson1_1RowInfo = (
  output: any,
  context: __SerdeContext
): RowInfo => {
  let contents: any = {
    __type: "RowInfo",
    RowsDropped: undefined,
    RowsIngested: undefined
  };
  if (output.RowsDropped !== undefined && output.RowsDropped !== null) {
    contents.RowsDropped = output.RowsDropped;
  }
  if (output.RowsIngested !== undefined && output.RowsIngested !== null) {
    contents.RowsIngested = output.RowsIngested;
  }
  return contents;
};

const deserializeAws_restJson1_1RowLevelPermissionDataSet = (
  output: any,
  context: __SerdeContext
): RowLevelPermissionDataSet => {
  let contents: any = {
    __type: "RowLevelPermissionDataSet",
    Arn: undefined,
    PermissionPolicy: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (
    output.PermissionPolicy !== undefined &&
    output.PermissionPolicy !== null
  ) {
    contents.PermissionPolicy = output.PermissionPolicy;
  }
  return contents;
};

const deserializeAws_restJson1_1S3Parameters = (
  output: any,
  context: __SerdeContext
): S3Parameters => {
  let contents: any = {
    __type: "S3Parameters",
    ManifestFileLocation: undefined
  };
  if (
    output.ManifestFileLocation !== undefined &&
    output.ManifestFileLocation !== null
  ) {
    contents.ManifestFileLocation = deserializeAws_restJson1_1ManifestFileLocation(
      output.ManifestFileLocation,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1S3Source = (
  output: any,
  context: __SerdeContext
): S3Source => {
  let contents: any = {
    __type: "S3Source",
    DataSourceArn: undefined,
    InputColumns: undefined,
    UploadSettings: undefined
  };
  if (output.DataSourceArn !== undefined && output.DataSourceArn !== null) {
    contents.DataSourceArn = output.DataSourceArn;
  }
  if (output.InputColumns !== undefined && output.InputColumns !== null) {
    contents.InputColumns = deserializeAws_restJson1_1InputColumnList(
      output.InputColumns,
      context
    );
  }
  if (output.UploadSettings !== undefined && output.UploadSettings !== null) {
    contents.UploadSettings = deserializeAws_restJson1_1UploadSettings(
      output.UploadSettings,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ServiceNowParameters = (
  output: any,
  context: __SerdeContext
): ServiceNowParameters => {
  let contents: any = {
    __type: "ServiceNowParameters",
    SiteBaseUrl: undefined
  };
  if (output.SiteBaseUrl !== undefined && output.SiteBaseUrl !== null) {
    contents.SiteBaseUrl = output.SiteBaseUrl;
  }
  return contents;
};

const deserializeAws_restJson1_1SnowflakeParameters = (
  output: any,
  context: __SerdeContext
): SnowflakeParameters => {
  let contents: any = {
    __type: "SnowflakeParameters",
    Database: undefined,
    Host: undefined,
    Warehouse: undefined
  };
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = output.Database;
  }
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Warehouse !== undefined && output.Warehouse !== null) {
    contents.Warehouse = output.Warehouse;
  }
  return contents;
};

const deserializeAws_restJson1_1SparkParameters = (
  output: any,
  context: __SerdeContext
): SparkParameters => {
  let contents: any = {
    __type: "SparkParameters",
    Host: undefined,
    Port: undefined
  };
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_restJson1_1SqlServerParameters = (
  output: any,
  context: __SerdeContext
): SqlServerParameters => {
  let contents: any = {
    __type: "SqlServerParameters",
    Database: undefined,
    Host: undefined,
    Port: undefined
  };
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = output.Database;
  }
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_restJson1_1SslProperties = (
  output: any,
  context: __SerdeContext
): SslProperties => {
  let contents: any = {
    __type: "SslProperties",
    DisableSsl: undefined
  };
  if (output.DisableSsl !== undefined && output.DisableSsl !== null) {
    contents.DisableSsl = output.DisableSsl;
  }
  return contents;
};

const deserializeAws_restJson1_1TagColumnOperation = (
  output: any,
  context: __SerdeContext
): TagColumnOperation => {
  let contents: any = {
    __type: "TagColumnOperation",
    ColumnName: undefined,
    Tags: undefined
  };
  if (output.ColumnName !== undefined && output.ColumnName !== null) {
    contents.ColumnName = output.ColumnName;
  }
  if (output.Tags !== undefined && output.Tags !== null) {
    contents.Tags = deserializeAws_restJson1_1ColumnTagList(
      output.Tags,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Template = (
  output: any,
  context: __SerdeContext
): Template => {
  let contents: any = {
    __type: "Template",
    Arn: undefined,
    CreatedTime: undefined,
    LastUpdatedTime: undefined,
    Name: undefined,
    TemplateId: undefined,
    Version: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.LastUpdatedTime !== undefined && output.LastUpdatedTime !== null) {
    contents.LastUpdatedTime = new Date(
      Math.round(output.LastUpdatedTime * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.TemplateId !== undefined && output.TemplateId !== null) {
    contents.TemplateId = output.TemplateId;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = deserializeAws_restJson1_1TemplateVersion(
      output.Version,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1TemplateAlias = (
  output: any,
  context: __SerdeContext
): TemplateAlias => {
  let contents: any = {
    __type: "TemplateAlias",
    AliasName: undefined,
    Arn: undefined,
    TemplateVersionNumber: undefined
  };
  if (output.AliasName !== undefined && output.AliasName !== null) {
    contents.AliasName = output.AliasName;
  }
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (
    output.TemplateVersionNumber !== undefined &&
    output.TemplateVersionNumber !== null
  ) {
    contents.TemplateVersionNumber = output.TemplateVersionNumber;
  }
  return contents;
};

const deserializeAws_restJson1_1TemplateAliasList = (
  output: any,
  context: __SerdeContext
): TemplateAlias[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1TemplateAlias(entry, context)
  );
};

const deserializeAws_restJson1_1TemplateError = (
  output: any,
  context: __SerdeContext
): TemplateError => {
  let contents: any = {
    __type: "TemplateError",
    Message: undefined,
    Type: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1TemplateErrorList = (
  output: any,
  context: __SerdeContext
): TemplateError[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1TemplateError(entry, context)
  );
};

const deserializeAws_restJson1_1TemplateSummary = (
  output: any,
  context: __SerdeContext
): TemplateSummary => {
  let contents: any = {
    __type: "TemplateSummary",
    Arn: undefined,
    CreatedTime: undefined,
    LastUpdatedTime: undefined,
    LatestVersionNumber: undefined,
    Name: undefined,
    TemplateId: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.LastUpdatedTime !== undefined && output.LastUpdatedTime !== null) {
    contents.LastUpdatedTime = new Date(
      Math.round(output.LastUpdatedTime * 1000)
    );
  }
  if (
    output.LatestVersionNumber !== undefined &&
    output.LatestVersionNumber !== null
  ) {
    contents.LatestVersionNumber = output.LatestVersionNumber;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.TemplateId !== undefined && output.TemplateId !== null) {
    contents.TemplateId = output.TemplateId;
  }
  return contents;
};

const deserializeAws_restJson1_1TemplateSummaryList = (
  output: any,
  context: __SerdeContext
): TemplateSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1TemplateSummary(entry, context)
  );
};

const deserializeAws_restJson1_1TemplateVersion = (
  output: any,
  context: __SerdeContext
): TemplateVersion => {
  let contents: any = {
    __type: "TemplateVersion",
    CreatedTime: undefined,
    DataSetConfigurations: undefined,
    Description: undefined,
    Errors: undefined,
    SourceEntityArn: undefined,
    Status: undefined,
    VersionNumber: undefined
  };
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (
    output.DataSetConfigurations !== undefined &&
    output.DataSetConfigurations !== null
  ) {
    contents.DataSetConfigurations = deserializeAws_restJson1_1DataSetConfigurationList(
      output.DataSetConfigurations,
      context
    );
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Errors !== undefined && output.Errors !== null) {
    contents.Errors = deserializeAws_restJson1_1TemplateErrorList(
      output.Errors,
      context
    );
  }
  if (output.SourceEntityArn !== undefined && output.SourceEntityArn !== null) {
    contents.SourceEntityArn = output.SourceEntityArn;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.VersionNumber !== undefined && output.VersionNumber !== null) {
    contents.VersionNumber = output.VersionNumber;
  }
  return contents;
};

const deserializeAws_restJson1_1TemplateVersionSummary = (
  output: any,
  context: __SerdeContext
): TemplateVersionSummary => {
  let contents: any = {
    __type: "TemplateVersionSummary",
    Arn: undefined,
    CreatedTime: undefined,
    Description: undefined,
    Status: undefined,
    VersionNumber: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.CreatedTime !== undefined && output.CreatedTime !== null) {
    contents.CreatedTime = new Date(Math.round(output.CreatedTime * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.VersionNumber !== undefined && output.VersionNumber !== null) {
    contents.VersionNumber = output.VersionNumber;
  }
  return contents;
};

const deserializeAws_restJson1_1TemplateVersionSummaryList = (
  output: any,
  context: __SerdeContext
): TemplateVersionSummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1TemplateVersionSummary(entry, context)
  );
};

const deserializeAws_restJson1_1TeradataParameters = (
  output: any,
  context: __SerdeContext
): TeradataParameters => {
  let contents: any = {
    __type: "TeradataParameters",
    Database: undefined,
    Host: undefined,
    Port: undefined
  };
  if (output.Database !== undefined && output.Database !== null) {
    contents.Database = output.Database;
  }
  if (output.Host !== undefined && output.Host !== null) {
    contents.Host = output.Host;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_restJson1_1TransformOperation = (
  output: any,
  context: __SerdeContext
): TransformOperation => {
  let contents: any = {
    __type: "TransformOperation",
    CastColumnTypeOperation: undefined,
    CreateColumnsOperation: undefined,
    FilterOperation: undefined,
    ProjectOperation: undefined,
    RenameColumnOperation: undefined,
    TagColumnOperation: undefined
  };
  if (
    output.CastColumnTypeOperation !== undefined &&
    output.CastColumnTypeOperation !== null
  ) {
    contents.CastColumnTypeOperation = deserializeAws_restJson1_1CastColumnTypeOperation(
      output.CastColumnTypeOperation,
      context
    );
  }
  if (
    output.CreateColumnsOperation !== undefined &&
    output.CreateColumnsOperation !== null
  ) {
    contents.CreateColumnsOperation = deserializeAws_restJson1_1CreateColumnsOperation(
      output.CreateColumnsOperation,
      context
    );
  }
  if (output.FilterOperation !== undefined && output.FilterOperation !== null) {
    contents.FilterOperation = deserializeAws_restJson1_1FilterOperation(
      output.FilterOperation,
      context
    );
  }
  if (
    output.ProjectOperation !== undefined &&
    output.ProjectOperation !== null
  ) {
    contents.ProjectOperation = deserializeAws_restJson1_1ProjectOperation(
      output.ProjectOperation,
      context
    );
  }
  if (
    output.RenameColumnOperation !== undefined &&
    output.RenameColumnOperation !== null
  ) {
    contents.RenameColumnOperation = deserializeAws_restJson1_1RenameColumnOperation(
      output.RenameColumnOperation,
      context
    );
  }
  if (
    output.TagColumnOperation !== undefined &&
    output.TagColumnOperation !== null
  ) {
    contents.TagColumnOperation = deserializeAws_restJson1_1TagColumnOperation(
      output.TagColumnOperation,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1TransformOperationList = (
  output: any,
  context: __SerdeContext
): TransformOperation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1TransformOperation(entry, context)
  );
};

const deserializeAws_restJson1_1TwitterParameters = (
  output: any,
  context: __SerdeContext
): TwitterParameters => {
  let contents: any = {
    __type: "TwitterParameters",
    MaxRows: undefined,
    Query: undefined
  };
  if (output.MaxRows !== undefined && output.MaxRows !== null) {
    contents.MaxRows = output.MaxRows;
  }
  if (output.Query !== undefined && output.Query !== null) {
    contents.Query = output.Query;
  }
  return contents;
};

const deserializeAws_restJson1_1UploadSettings = (
  output: any,
  context: __SerdeContext
): UploadSettings => {
  let contents: any = {
    __type: "UploadSettings",
    ContainsHeader: undefined,
    Delimiter: undefined,
    Format: undefined,
    StartFromRow: undefined,
    TextQualifier: undefined
  };
  if (output.ContainsHeader !== undefined && output.ContainsHeader !== null) {
    contents.ContainsHeader = output.ContainsHeader;
  }
  if (output.Delimiter !== undefined && output.Delimiter !== null) {
    contents.Delimiter = output.Delimiter;
  }
  if (output.Format !== undefined && output.Format !== null) {
    contents.Format = output.Format;
  }
  if (output.StartFromRow !== undefined && output.StartFromRow !== null) {
    contents.StartFromRow = output.StartFromRow;
  }
  if (output.TextQualifier !== undefined && output.TextQualifier !== null) {
    contents.TextQualifier = output.TextQualifier;
  }
  return contents;
};

const deserializeAws_restJson1_1User = (
  output: any,
  context: __SerdeContext
): User => {
  let contents: any = {
    __type: "User",
    Active: undefined,
    Arn: undefined,
    Email: undefined,
    IdentityType: undefined,
    PrincipalId: undefined,
    Role: undefined,
    UserName: undefined
  };
  if (output.Active !== undefined && output.Active !== null) {
    contents.Active = output.Active;
  }
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (output.Email !== undefined && output.Email !== null) {
    contents.Email = output.Email;
  }
  if (output.IdentityType !== undefined && output.IdentityType !== null) {
    contents.IdentityType = output.IdentityType;
  }
  if (output.PrincipalId !== undefined && output.PrincipalId !== null) {
    contents.PrincipalId = output.PrincipalId;
  }
  if (output.Role !== undefined && output.Role !== null) {
    contents.Role = output.Role;
  }
  if (output.UserName !== undefined && output.UserName !== null) {
    contents.UserName = output.UserName;
  }
  return contents;
};

const deserializeAws_restJson1_1UserList = (
  output: any,
  context: __SerdeContext
): User[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1User(entry, context)
  );
};

const deserializeAws_restJson1_1VpcConnectionProperties = (
  output: any,
  context: __SerdeContext
): VpcConnectionProperties => {
  let contents: any = {
    __type: "VpcConnectionProperties",
    VpcConnectionArn: undefined
  };
  if (
    output.VpcConnectionArn !== undefined &&
    output.VpcConnectionArn !== null
  ) {
    contents.VpcConnectionArn = output.VpcConnectionArn;
  }
  return contents;
};

const deserializeAws_restJson1_1ActionList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1ResourcePermission = (
  output: any,
  context: __SerdeContext
): ResourcePermission => {
  let contents: any = {
    __type: "ResourcePermission",
    Actions: undefined,
    Principal: undefined
  };
  if (output.Actions !== undefined && output.Actions !== null) {
    contents.Actions = deserializeAws_restJson1_1ActionList(
      output.Actions,
      context
    );
  }
  if (output.Principal !== undefined && output.Principal !== null) {
    contents.Principal = output.Principal;
  }
  return contents;
};

const deserializeAws_restJson1_1ResourcePermissionList = (
  output: any,
  context: __SerdeContext
): ResourcePermission[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ResourcePermission(entry, context)
  );
};

const deserializeAws_restJson1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_restJson1_1TagList = (
  output: any,
  context: __SerdeContext
): Tag[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Tag(entry, context)
  );
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any = new Uint8Array(),
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

function isSerializableHeaderValue(value: any): boolean {
  return (
    value !== undefined &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") ||
      value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0)
  );
}

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });

/**
 * Load an error code for the aws.rest-json-1.1 protocol.
 */
const loadRestJsonErrorCode = (output: __HttpResponse, data: any): string => {
  const findKey = (object: any, key: string) =>
    Object.keys(object).find(k => k.toLowerCase() === key.toLowerCase());

  const sanitizeErrorCode = (rawValue: string): string => {
    let cleanValue = rawValue;
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };

  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== undefined) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }

  if (data.code !== undefined) {
    return sanitizeErrorCode(data.code);
  }

  if (data["__type"] !== undefined) {
    return sanitizeErrorCode(data["__type"]);
  }

  return "";
};
