import {
  AssociateRoleToGroupCommandInput,
  AssociateRoleToGroupCommandOutput
} from "../commands/AssociateRoleToGroupCommand";
import {
  AssociateServiceRoleToAccountCommandInput,
  AssociateServiceRoleToAccountCommandOutput
} from "../commands/AssociateServiceRoleToAccountCommand";
import {
  CreateConnectorDefinitionCommandInput,
  CreateConnectorDefinitionCommandOutput
} from "../commands/CreateConnectorDefinitionCommand";
import {
  CreateConnectorDefinitionVersionCommandInput,
  CreateConnectorDefinitionVersionCommandOutput
} from "../commands/CreateConnectorDefinitionVersionCommand";
import {
  CreateCoreDefinitionCommandInput,
  CreateCoreDefinitionCommandOutput
} from "../commands/CreateCoreDefinitionCommand";
import {
  CreateCoreDefinitionVersionCommandInput,
  CreateCoreDefinitionVersionCommandOutput
} from "../commands/CreateCoreDefinitionVersionCommand";
import {
  CreateDeploymentCommandInput,
  CreateDeploymentCommandOutput
} from "../commands/CreateDeploymentCommand";
import {
  CreateDeviceDefinitionCommandInput,
  CreateDeviceDefinitionCommandOutput
} from "../commands/CreateDeviceDefinitionCommand";
import {
  CreateDeviceDefinitionVersionCommandInput,
  CreateDeviceDefinitionVersionCommandOutput
} from "../commands/CreateDeviceDefinitionVersionCommand";
import {
  CreateFunctionDefinitionCommandInput,
  CreateFunctionDefinitionCommandOutput
} from "../commands/CreateFunctionDefinitionCommand";
import {
  CreateFunctionDefinitionVersionCommandInput,
  CreateFunctionDefinitionVersionCommandOutput
} from "../commands/CreateFunctionDefinitionVersionCommand";
import {
  CreateGroupCertificateAuthorityCommandInput,
  CreateGroupCertificateAuthorityCommandOutput
} from "../commands/CreateGroupCertificateAuthorityCommand";
import {
  CreateGroupCommandInput,
  CreateGroupCommandOutput
} from "../commands/CreateGroupCommand";
import {
  CreateGroupVersionCommandInput,
  CreateGroupVersionCommandOutput
} from "../commands/CreateGroupVersionCommand";
import {
  CreateLoggerDefinitionCommandInput,
  CreateLoggerDefinitionCommandOutput
} from "../commands/CreateLoggerDefinitionCommand";
import {
  CreateLoggerDefinitionVersionCommandInput,
  CreateLoggerDefinitionVersionCommandOutput
} from "../commands/CreateLoggerDefinitionVersionCommand";
import {
  CreateResourceDefinitionCommandInput,
  CreateResourceDefinitionCommandOutput
} from "../commands/CreateResourceDefinitionCommand";
import {
  CreateResourceDefinitionVersionCommandInput,
  CreateResourceDefinitionVersionCommandOutput
} from "../commands/CreateResourceDefinitionVersionCommand";
import {
  CreateSoftwareUpdateJobCommandInput,
  CreateSoftwareUpdateJobCommandOutput
} from "../commands/CreateSoftwareUpdateJobCommand";
import {
  CreateSubscriptionDefinitionCommandInput,
  CreateSubscriptionDefinitionCommandOutput
} from "../commands/CreateSubscriptionDefinitionCommand";
import {
  CreateSubscriptionDefinitionVersionCommandInput,
  CreateSubscriptionDefinitionVersionCommandOutput
} from "../commands/CreateSubscriptionDefinitionVersionCommand";
import {
  DeleteConnectorDefinitionCommandInput,
  DeleteConnectorDefinitionCommandOutput
} from "../commands/DeleteConnectorDefinitionCommand";
import {
  DeleteCoreDefinitionCommandInput,
  DeleteCoreDefinitionCommandOutput
} from "../commands/DeleteCoreDefinitionCommand";
import {
  DeleteDeviceDefinitionCommandInput,
  DeleteDeviceDefinitionCommandOutput
} from "../commands/DeleteDeviceDefinitionCommand";
import {
  DeleteFunctionDefinitionCommandInput,
  DeleteFunctionDefinitionCommandOutput
} from "../commands/DeleteFunctionDefinitionCommand";
import {
  DeleteGroupCommandInput,
  DeleteGroupCommandOutput
} from "../commands/DeleteGroupCommand";
import {
  DeleteLoggerDefinitionCommandInput,
  DeleteLoggerDefinitionCommandOutput
} from "../commands/DeleteLoggerDefinitionCommand";
import {
  DeleteResourceDefinitionCommandInput,
  DeleteResourceDefinitionCommandOutput
} from "../commands/DeleteResourceDefinitionCommand";
import {
  DeleteSubscriptionDefinitionCommandInput,
  DeleteSubscriptionDefinitionCommandOutput
} from "../commands/DeleteSubscriptionDefinitionCommand";
import {
  DisassociateRoleFromGroupCommandInput,
  DisassociateRoleFromGroupCommandOutput
} from "../commands/DisassociateRoleFromGroupCommand";
import {
  DisassociateServiceRoleFromAccountCommandInput,
  DisassociateServiceRoleFromAccountCommandOutput
} from "../commands/DisassociateServiceRoleFromAccountCommand";
import {
  GetAssociatedRoleCommandInput,
  GetAssociatedRoleCommandOutput
} from "../commands/GetAssociatedRoleCommand";
import {
  GetBulkDeploymentStatusCommandInput,
  GetBulkDeploymentStatusCommandOutput
} from "../commands/GetBulkDeploymentStatusCommand";
import {
  GetConnectivityInfoCommandInput,
  GetConnectivityInfoCommandOutput
} from "../commands/GetConnectivityInfoCommand";
import {
  GetConnectorDefinitionCommandInput,
  GetConnectorDefinitionCommandOutput
} from "../commands/GetConnectorDefinitionCommand";
import {
  GetConnectorDefinitionVersionCommandInput,
  GetConnectorDefinitionVersionCommandOutput
} from "../commands/GetConnectorDefinitionVersionCommand";
import {
  GetCoreDefinitionCommandInput,
  GetCoreDefinitionCommandOutput
} from "../commands/GetCoreDefinitionCommand";
import {
  GetCoreDefinitionVersionCommandInput,
  GetCoreDefinitionVersionCommandOutput
} from "../commands/GetCoreDefinitionVersionCommand";
import {
  GetDeploymentStatusCommandInput,
  GetDeploymentStatusCommandOutput
} from "../commands/GetDeploymentStatusCommand";
import {
  GetDeviceDefinitionCommandInput,
  GetDeviceDefinitionCommandOutput
} from "../commands/GetDeviceDefinitionCommand";
import {
  GetDeviceDefinitionVersionCommandInput,
  GetDeviceDefinitionVersionCommandOutput
} from "../commands/GetDeviceDefinitionVersionCommand";
import {
  GetFunctionDefinitionCommandInput,
  GetFunctionDefinitionCommandOutput
} from "../commands/GetFunctionDefinitionCommand";
import {
  GetFunctionDefinitionVersionCommandInput,
  GetFunctionDefinitionVersionCommandOutput
} from "../commands/GetFunctionDefinitionVersionCommand";
import {
  GetGroupCertificateAuthorityCommandInput,
  GetGroupCertificateAuthorityCommandOutput
} from "../commands/GetGroupCertificateAuthorityCommand";
import {
  GetGroupCertificateConfigurationCommandInput,
  GetGroupCertificateConfigurationCommandOutput
} from "../commands/GetGroupCertificateConfigurationCommand";
import {
  GetGroupCommandInput,
  GetGroupCommandOutput
} from "../commands/GetGroupCommand";
import {
  GetGroupVersionCommandInput,
  GetGroupVersionCommandOutput
} from "../commands/GetGroupVersionCommand";
import {
  GetLoggerDefinitionCommandInput,
  GetLoggerDefinitionCommandOutput
} from "../commands/GetLoggerDefinitionCommand";
import {
  GetLoggerDefinitionVersionCommandInput,
  GetLoggerDefinitionVersionCommandOutput
} from "../commands/GetLoggerDefinitionVersionCommand";
import {
  GetResourceDefinitionCommandInput,
  GetResourceDefinitionCommandOutput
} from "../commands/GetResourceDefinitionCommand";
import {
  GetResourceDefinitionVersionCommandInput,
  GetResourceDefinitionVersionCommandOutput
} from "../commands/GetResourceDefinitionVersionCommand";
import {
  GetServiceRoleForAccountCommandInput,
  GetServiceRoleForAccountCommandOutput
} from "../commands/GetServiceRoleForAccountCommand";
import {
  GetSubscriptionDefinitionCommandInput,
  GetSubscriptionDefinitionCommandOutput
} from "../commands/GetSubscriptionDefinitionCommand";
import {
  GetSubscriptionDefinitionVersionCommandInput,
  GetSubscriptionDefinitionVersionCommandOutput
} from "../commands/GetSubscriptionDefinitionVersionCommand";
import {
  ListBulkDeploymentDetailedReportsCommandInput,
  ListBulkDeploymentDetailedReportsCommandOutput
} from "../commands/ListBulkDeploymentDetailedReportsCommand";
import {
  ListBulkDeploymentsCommandInput,
  ListBulkDeploymentsCommandOutput
} from "../commands/ListBulkDeploymentsCommand";
import {
  ListConnectorDefinitionVersionsCommandInput,
  ListConnectorDefinitionVersionsCommandOutput
} from "../commands/ListConnectorDefinitionVersionsCommand";
import {
  ListConnectorDefinitionsCommandInput,
  ListConnectorDefinitionsCommandOutput
} from "../commands/ListConnectorDefinitionsCommand";
import {
  ListCoreDefinitionVersionsCommandInput,
  ListCoreDefinitionVersionsCommandOutput
} from "../commands/ListCoreDefinitionVersionsCommand";
import {
  ListCoreDefinitionsCommandInput,
  ListCoreDefinitionsCommandOutput
} from "../commands/ListCoreDefinitionsCommand";
import {
  ListDeploymentsCommandInput,
  ListDeploymentsCommandOutput
} from "../commands/ListDeploymentsCommand";
import {
  ListDeviceDefinitionVersionsCommandInput,
  ListDeviceDefinitionVersionsCommandOutput
} from "../commands/ListDeviceDefinitionVersionsCommand";
import {
  ListDeviceDefinitionsCommandInput,
  ListDeviceDefinitionsCommandOutput
} from "../commands/ListDeviceDefinitionsCommand";
import {
  ListFunctionDefinitionVersionsCommandInput,
  ListFunctionDefinitionVersionsCommandOutput
} from "../commands/ListFunctionDefinitionVersionsCommand";
import {
  ListFunctionDefinitionsCommandInput,
  ListFunctionDefinitionsCommandOutput
} from "../commands/ListFunctionDefinitionsCommand";
import {
  ListGroupCertificateAuthoritiesCommandInput,
  ListGroupCertificateAuthoritiesCommandOutput
} from "../commands/ListGroupCertificateAuthoritiesCommand";
import {
  ListGroupVersionsCommandInput,
  ListGroupVersionsCommandOutput
} from "../commands/ListGroupVersionsCommand";
import {
  ListGroupsCommandInput,
  ListGroupsCommandOutput
} from "../commands/ListGroupsCommand";
import {
  ListLoggerDefinitionVersionsCommandInput,
  ListLoggerDefinitionVersionsCommandOutput
} from "../commands/ListLoggerDefinitionVersionsCommand";
import {
  ListLoggerDefinitionsCommandInput,
  ListLoggerDefinitionsCommandOutput
} from "../commands/ListLoggerDefinitionsCommand";
import {
  ListResourceDefinitionVersionsCommandInput,
  ListResourceDefinitionVersionsCommandOutput
} from "../commands/ListResourceDefinitionVersionsCommand";
import {
  ListResourceDefinitionsCommandInput,
  ListResourceDefinitionsCommandOutput
} from "../commands/ListResourceDefinitionsCommand";
import {
  ListSubscriptionDefinitionVersionsCommandInput,
  ListSubscriptionDefinitionVersionsCommandOutput
} from "../commands/ListSubscriptionDefinitionVersionsCommand";
import {
  ListSubscriptionDefinitionsCommandInput,
  ListSubscriptionDefinitionsCommandOutput
} from "../commands/ListSubscriptionDefinitionsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ResetDeploymentsCommandInput,
  ResetDeploymentsCommandOutput
} from "../commands/ResetDeploymentsCommand";
import {
  StartBulkDeploymentCommandInput,
  StartBulkDeploymentCommandOutput
} from "../commands/StartBulkDeploymentCommand";
import {
  StopBulkDeploymentCommandInput,
  StopBulkDeploymentCommandOutput
} from "../commands/StopBulkDeploymentCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateConnectivityInfoCommandInput,
  UpdateConnectivityInfoCommandOutput
} from "../commands/UpdateConnectivityInfoCommand";
import {
  UpdateConnectorDefinitionCommandInput,
  UpdateConnectorDefinitionCommandOutput
} from "../commands/UpdateConnectorDefinitionCommand";
import {
  UpdateCoreDefinitionCommandInput,
  UpdateCoreDefinitionCommandOutput
} from "../commands/UpdateCoreDefinitionCommand";
import {
  UpdateDeviceDefinitionCommandInput,
  UpdateDeviceDefinitionCommandOutput
} from "../commands/UpdateDeviceDefinitionCommand";
import {
  UpdateFunctionDefinitionCommandInput,
  UpdateFunctionDefinitionCommandOutput
} from "../commands/UpdateFunctionDefinitionCommand";
import {
  UpdateGroupCertificateConfigurationCommandInput,
  UpdateGroupCertificateConfigurationCommandOutput
} from "../commands/UpdateGroupCertificateConfigurationCommand";
import {
  UpdateGroupCommandInput,
  UpdateGroupCommandOutput
} from "../commands/UpdateGroupCommand";
import {
  UpdateLoggerDefinitionCommandInput,
  UpdateLoggerDefinitionCommandOutput
} from "../commands/UpdateLoggerDefinitionCommand";
import {
  UpdateResourceDefinitionCommandInput,
  UpdateResourceDefinitionCommandOutput
} from "../commands/UpdateResourceDefinitionCommand";
import {
  UpdateSubscriptionDefinitionCommandInput,
  UpdateSubscriptionDefinitionCommandOutput
} from "../commands/UpdateSubscriptionDefinitionCommand";
import {
  BadRequestException,
  BulkDeployment,
  BulkDeploymentMetrics,
  BulkDeploymentResult,
  ConnectivityInfo,
  Connector,
  ConnectorDefinitionVersion,
  Core,
  CoreDefinitionVersion,
  DefinitionInformation,
  Deployment,
  Device,
  DeviceDefinitionVersion,
  ErrorDetail,
  Function,
  FunctionConfiguration,
  FunctionConfigurationEnvironment,
  FunctionDefaultConfig,
  FunctionDefaultExecutionConfig,
  FunctionDefinitionVersion,
  FunctionExecutionConfig,
  FunctionRunAsConfig,
  GroupCertificateAuthorityProperties,
  GroupInformation,
  GroupOwnerSetting,
  GroupVersion,
  InternalServerErrorException,
  LocalDeviceResourceData,
  LocalVolumeResourceData,
  Logger,
  LoggerDefinitionVersion,
  Resource,
  ResourceAccessPolicy,
  ResourceDataContainer,
  ResourceDefinitionVersion,
  ResourceDownloadOwnerSetting,
  S3MachineLearningModelResourceData,
  SageMakerMachineLearningModelResourceData,
  SecretsManagerSecretResourceData,
  Subscription,
  SubscriptionDefinitionVersion,
  VersionInformation
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_restJson1_1AssociateRoleToGroupCommand(
  input: AssociateRoleToGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/greengrass/groups/{GroupId}/role";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1AssociateServiceRoleToAccountCommand(
  input: AssociateServiceRoleToAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/greengrass/servicerole";
  let body: any;
  const bodyParams: any = {};
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateConnectorDefinitionCommand(
  input: CreateConnectorDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/definition/connectors";
  let body: any;
  const bodyParams: any = {};
  if (input.InitialVersion !== undefined) {
    bodyParams[
      "InitialVersion"
    ] = serializeAws_restJson1_1ConnectorDefinitionVersion(
      input.InitialVersion,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1Tags(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateConnectorDefinitionVersionCommand(
  input: CreateConnectorDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath =
    "/greengrass/definition/connectors/{ConnectorDefinitionId}/versions";
  if (input.ConnectorDefinitionId !== undefined) {
    const labelValue: string = input.ConnectorDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ConnectorDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ConnectorDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ConnectorDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Connectors !== undefined) {
    bodyParams["Connectors"] = serializeAws_restJson1_1__listOfConnector(
      input.Connectors,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateCoreDefinitionCommand(
  input: CreateCoreDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/definition/cores";
  let body: any;
  const bodyParams: any = {};
  if (input.InitialVersion !== undefined) {
    bodyParams[
      "InitialVersion"
    ] = serializeAws_restJson1_1CoreDefinitionVersion(
      input.InitialVersion,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1Tags(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateCoreDefinitionVersionCommand(
  input: CreateCoreDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/definition/cores/{CoreDefinitionId}/versions";
  if (input.CoreDefinitionId !== undefined) {
    const labelValue: string = input.CoreDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: CoreDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{CoreDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: CoreDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Cores !== undefined) {
    bodyParams["Cores"] = serializeAws_restJson1_1__listOfCore(
      input.Cores,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateDeploymentCommand(
  input: CreateDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/groups/{GroupId}/deployments";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.DeploymentId !== undefined) {
    bodyParams["DeploymentId"] = input.DeploymentId;
  }
  if (input.DeploymentType !== undefined) {
    bodyParams["DeploymentType"] = input.DeploymentType;
  }
  if (input.GroupVersionId !== undefined) {
    bodyParams["GroupVersionId"] = input.GroupVersionId;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateDeviceDefinitionCommand(
  input: CreateDeviceDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/definition/devices";
  let body: any;
  const bodyParams: any = {};
  if (input.InitialVersion !== undefined) {
    bodyParams[
      "InitialVersion"
    ] = serializeAws_restJson1_1DeviceDefinitionVersion(
      input.InitialVersion,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1Tags(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateDeviceDefinitionVersionCommand(
  input: CreateDeviceDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath =
    "/greengrass/definition/devices/{DeviceDefinitionId}/versions";
  if (input.DeviceDefinitionId !== undefined) {
    const labelValue: string = input.DeviceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DeviceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DeviceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: DeviceDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Devices !== undefined) {
    bodyParams["Devices"] = serializeAws_restJson1_1__listOfDevice(
      input.Devices,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateFunctionDefinitionCommand(
  input: CreateFunctionDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/definition/functions";
  let body: any;
  const bodyParams: any = {};
  if (input.InitialVersion !== undefined) {
    bodyParams[
      "InitialVersion"
    ] = serializeAws_restJson1_1FunctionDefinitionVersion(
      input.InitialVersion,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1Tags(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateFunctionDefinitionVersionCommand(
  input: CreateFunctionDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath =
    "/greengrass/definition/functions/{FunctionDefinitionId}/versions";
  if (input.FunctionDefinitionId !== undefined) {
    const labelValue: string = input.FunctionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: FunctionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{FunctionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: FunctionDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.DefaultConfig !== undefined) {
    bodyParams["DefaultConfig"] = serializeAws_restJson1_1FunctionDefaultConfig(
      input.DefaultConfig,
      context
    );
  }
  if (input.Functions !== undefined) {
    bodyParams["Functions"] = serializeAws_restJson1_1__listOfFunction(
      input.Functions,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateGroupCommand(
  input: CreateGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/groups";
  let body: any;
  const bodyParams: any = {};
  if (input.InitialVersion !== undefined) {
    bodyParams["InitialVersion"] = serializeAws_restJson1_1GroupVersion(
      input.InitialVersion,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1Tags(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateGroupCertificateAuthorityCommand(
  input: CreateGroupCertificateAuthorityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/groups/{GroupId}/certificateauthorities";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1CreateGroupVersionCommand(
  input: CreateGroupVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/groups/{GroupId}/versions";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.ConnectorDefinitionVersionArn !== undefined) {
    bodyParams["ConnectorDefinitionVersionArn"] =
      input.ConnectorDefinitionVersionArn;
  }
  if (input.CoreDefinitionVersionArn !== undefined) {
    bodyParams["CoreDefinitionVersionArn"] = input.CoreDefinitionVersionArn;
  }
  if (input.DeviceDefinitionVersionArn !== undefined) {
    bodyParams["DeviceDefinitionVersionArn"] = input.DeviceDefinitionVersionArn;
  }
  if (input.FunctionDefinitionVersionArn !== undefined) {
    bodyParams["FunctionDefinitionVersionArn"] =
      input.FunctionDefinitionVersionArn;
  }
  if (input.LoggerDefinitionVersionArn !== undefined) {
    bodyParams["LoggerDefinitionVersionArn"] = input.LoggerDefinitionVersionArn;
  }
  if (input.ResourceDefinitionVersionArn !== undefined) {
    bodyParams["ResourceDefinitionVersionArn"] =
      input.ResourceDefinitionVersionArn;
  }
  if (input.SubscriptionDefinitionVersionArn !== undefined) {
    bodyParams["SubscriptionDefinitionVersionArn"] =
      input.SubscriptionDefinitionVersionArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateLoggerDefinitionCommand(
  input: CreateLoggerDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/definition/loggers";
  let body: any;
  const bodyParams: any = {};
  if (input.InitialVersion !== undefined) {
    bodyParams[
      "InitialVersion"
    ] = serializeAws_restJson1_1LoggerDefinitionVersion(
      input.InitialVersion,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1Tags(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateLoggerDefinitionVersionCommand(
  input: CreateLoggerDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath =
    "/greengrass/definition/loggers/{LoggerDefinitionId}/versions";
  if (input.LoggerDefinitionId !== undefined) {
    const labelValue: string = input.LoggerDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: LoggerDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{LoggerDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: LoggerDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Loggers !== undefined) {
    bodyParams["Loggers"] = serializeAws_restJson1_1__listOfLogger(
      input.Loggers,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateResourceDefinitionCommand(
  input: CreateResourceDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/definition/resources";
  let body: any;
  const bodyParams: any = {};
  if (input.InitialVersion !== undefined) {
    bodyParams[
      "InitialVersion"
    ] = serializeAws_restJson1_1ResourceDefinitionVersion(
      input.InitialVersion,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1Tags(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateResourceDefinitionVersionCommand(
  input: CreateResourceDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath =
    "/greengrass/definition/resources/{ResourceDefinitionId}/versions";
  if (input.ResourceDefinitionId !== undefined) {
    const labelValue: string = input.ResourceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ResourceDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Resources !== undefined) {
    bodyParams["Resources"] = serializeAws_restJson1_1__listOfResource(
      input.Resources,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateSoftwareUpdateJobCommand(
  input: CreateSoftwareUpdateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/updates";
  let body: any;
  const bodyParams: any = {};
  if (input.S3UrlSignerRole !== undefined) {
    bodyParams["S3UrlSignerRole"] = input.S3UrlSignerRole;
  }
  if (input.SoftwareToUpdate !== undefined) {
    bodyParams["SoftwareToUpdate"] = input.SoftwareToUpdate;
  }
  if (input.UpdateAgentLogLevel !== undefined) {
    bodyParams["UpdateAgentLogLevel"] = input.UpdateAgentLogLevel;
  }
  if (input.UpdateTargets !== undefined) {
    bodyParams["UpdateTargets"] = serializeAws_restJson1_1UpdateTargets(
      input.UpdateTargets,
      context
    );
  }
  if (input.UpdateTargetsArchitecture !== undefined) {
    bodyParams["UpdateTargetsArchitecture"] = input.UpdateTargetsArchitecture;
  }
  if (input.UpdateTargetsOperatingSystem !== undefined) {
    bodyParams["UpdateTargetsOperatingSystem"] =
      input.UpdateTargetsOperatingSystem;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateSubscriptionDefinitionCommand(
  input: CreateSubscriptionDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/definition/subscriptions";
  let body: any;
  const bodyParams: any = {};
  if (input.InitialVersion !== undefined) {
    bodyParams[
      "InitialVersion"
    ] = serializeAws_restJson1_1SubscriptionDefinitionVersion(
      input.InitialVersion,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1Tags(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateSubscriptionDefinitionVersionCommand(
  input: CreateSubscriptionDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath =
    "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions";
  if (input.SubscriptionDefinitionId !== undefined) {
    const labelValue: string = input.SubscriptionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: SubscriptionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{SubscriptionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: SubscriptionDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Subscriptions !== undefined) {
    bodyParams["Subscriptions"] = serializeAws_restJson1_1__listOfSubscription(
      input.Subscriptions,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteConnectorDefinitionCommand(
  input: DeleteConnectorDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/connectors/{ConnectorDefinitionId}";
  if (input.ConnectorDefinitionId !== undefined) {
    const labelValue: string = input.ConnectorDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ConnectorDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ConnectorDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ConnectorDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteCoreDefinitionCommand(
  input: DeleteCoreDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/cores/{CoreDefinitionId}";
  if (input.CoreDefinitionId !== undefined) {
    const labelValue: string = input.CoreDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: CoreDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{CoreDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: CoreDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteDeviceDefinitionCommand(
  input: DeleteDeviceDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/devices/{DeviceDefinitionId}";
  if (input.DeviceDefinitionId !== undefined) {
    const labelValue: string = input.DeviceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DeviceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DeviceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: DeviceDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteFunctionDefinitionCommand(
  input: DeleteFunctionDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/functions/{FunctionDefinitionId}";
  if (input.FunctionDefinitionId !== undefined) {
    const labelValue: string = input.FunctionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: FunctionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{FunctionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: FunctionDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteGroupCommand(
  input: DeleteGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/groups/{GroupId}";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteLoggerDefinitionCommand(
  input: DeleteLoggerDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/loggers/{LoggerDefinitionId}";
  if (input.LoggerDefinitionId !== undefined) {
    const labelValue: string = input.LoggerDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: LoggerDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{LoggerDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: LoggerDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteResourceDefinitionCommand(
  input: DeleteResourceDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/resources/{ResourceDefinitionId}";
  if (input.ResourceDefinitionId !== undefined) {
    const labelValue: string = input.ResourceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ResourceDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteSubscriptionDefinitionCommand(
  input: DeleteSubscriptionDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}";
  if (input.SubscriptionDefinitionId !== undefined) {
    const labelValue: string = input.SubscriptionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: SubscriptionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{SubscriptionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: SubscriptionDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DisassociateRoleFromGroupCommand(
  input: DisassociateRoleFromGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/groups/{GroupId}/role";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DisassociateServiceRoleFromAccountCommand(
  input: DisassociateServiceRoleFromAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/servicerole";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetAssociatedRoleCommand(
  input: GetAssociatedRoleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/groups/{GroupId}/role";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetBulkDeploymentStatusCommand(
  input: GetBulkDeploymentStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/bulk/deployments/{BulkDeploymentId}/status";
  if (input.BulkDeploymentId !== undefined) {
    const labelValue: string = input.BulkDeploymentId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: BulkDeploymentId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{BulkDeploymentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: BulkDeploymentId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetConnectivityInfoCommand(
  input: GetConnectivityInfoCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/things/{ThingName}/connectivityInfo";
  if (input.ThingName !== undefined) {
    const labelValue: string = input.ThingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ThingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{ThingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ThingName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetConnectorDefinitionCommand(
  input: GetConnectorDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/connectors/{ConnectorDefinitionId}";
  if (input.ConnectorDefinitionId !== undefined) {
    const labelValue: string = input.ConnectorDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ConnectorDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ConnectorDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ConnectorDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetConnectorDefinitionVersionCommand(
  input: GetConnectorDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/connectors/{ConnectorDefinitionId}/versions/{ConnectorDefinitionVersionId}";
  if (input.ConnectorDefinitionId !== undefined) {
    const labelValue: string = input.ConnectorDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ConnectorDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ConnectorDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ConnectorDefinitionId."
    );
  }
  if (input.ConnectorDefinitionVersionId !== undefined) {
    const labelValue: string = input.ConnectorDefinitionVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ConnectorDefinitionVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ConnectorDefinitionVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ConnectorDefinitionVersionId."
    );
  }
  const query: any = {};
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1GetCoreDefinitionCommand(
  input: GetCoreDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/cores/{CoreDefinitionId}";
  if (input.CoreDefinitionId !== undefined) {
    const labelValue: string = input.CoreDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: CoreDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{CoreDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: CoreDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetCoreDefinitionVersionCommand(
  input: GetCoreDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/cores/{CoreDefinitionId}/versions/{CoreDefinitionVersionId}";
  if (input.CoreDefinitionId !== undefined) {
    const labelValue: string = input.CoreDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: CoreDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{CoreDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: CoreDefinitionId."
    );
  }
  if (input.CoreDefinitionVersionId !== undefined) {
    const labelValue: string = input.CoreDefinitionVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: CoreDefinitionVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{CoreDefinitionVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: CoreDefinitionVersionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetDeploymentStatusCommand(
  input: GetDeploymentStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/groups/{GroupId}/deployments/{DeploymentId}/status";
  if (input.DeploymentId !== undefined) {
    const labelValue: string = input.DeploymentId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DeploymentId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DeploymentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DeploymentId.");
  }
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetDeviceDefinitionCommand(
  input: GetDeviceDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/devices/{DeviceDefinitionId}";
  if (input.DeviceDefinitionId !== undefined) {
    const labelValue: string = input.DeviceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DeviceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DeviceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: DeviceDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetDeviceDefinitionVersionCommand(
  input: GetDeviceDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/devices/{DeviceDefinitionId}/versions/{DeviceDefinitionVersionId}";
  if (input.DeviceDefinitionId !== undefined) {
    const labelValue: string = input.DeviceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DeviceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DeviceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: DeviceDefinitionId."
    );
  }
  if (input.DeviceDefinitionVersionId !== undefined) {
    const labelValue: string = input.DeviceDefinitionVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DeviceDefinitionVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DeviceDefinitionVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: DeviceDefinitionVersionId."
    );
  }
  const query: any = {};
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1GetFunctionDefinitionCommand(
  input: GetFunctionDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/functions/{FunctionDefinitionId}";
  if (input.FunctionDefinitionId !== undefined) {
    const labelValue: string = input.FunctionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: FunctionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{FunctionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: FunctionDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetFunctionDefinitionVersionCommand(
  input: GetFunctionDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/functions/{FunctionDefinitionId}/versions/{FunctionDefinitionVersionId}";
  if (input.FunctionDefinitionId !== undefined) {
    const labelValue: string = input.FunctionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: FunctionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{FunctionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: FunctionDefinitionId."
    );
  }
  if (input.FunctionDefinitionVersionId !== undefined) {
    const labelValue: string = input.FunctionDefinitionVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: FunctionDefinitionVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{FunctionDefinitionVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: FunctionDefinitionVersionId."
    );
  }
  const query: any = {};
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1GetGroupCommand(
  input: GetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/groups/{GroupId}";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetGroupCertificateAuthorityCommand(
  input: GetGroupCertificateAuthorityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/groups/{GroupId}/certificateauthorities/{CertificateAuthorityId}";
  if (input.CertificateAuthorityId !== undefined) {
    const labelValue: string = input.CertificateAuthorityId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: CertificateAuthorityId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{CertificateAuthorityId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: CertificateAuthorityId."
    );
  }
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetGroupCertificateConfigurationCommand(
  input: GetGroupCertificateConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/groups/{GroupId}/certificateauthorities/configuration/expiry";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetGroupVersionCommand(
  input: GetGroupVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/groups/{GroupId}/versions/{GroupVersionId}";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  if (input.GroupVersionId !== undefined) {
    const labelValue: string = input.GroupVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: GroupVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{GroupVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupVersionId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetLoggerDefinitionCommand(
  input: GetLoggerDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/loggers/{LoggerDefinitionId}";
  if (input.LoggerDefinitionId !== undefined) {
    const labelValue: string = input.LoggerDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: LoggerDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{LoggerDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: LoggerDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetLoggerDefinitionVersionCommand(
  input: GetLoggerDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/loggers/{LoggerDefinitionId}/versions/{LoggerDefinitionVersionId}";
  if (input.LoggerDefinitionId !== undefined) {
    const labelValue: string = input.LoggerDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: LoggerDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{LoggerDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: LoggerDefinitionId."
    );
  }
  if (input.LoggerDefinitionVersionId !== undefined) {
    const labelValue: string = input.LoggerDefinitionVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: LoggerDefinitionVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{LoggerDefinitionVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: LoggerDefinitionVersionId."
    );
  }
  const query: any = {};
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1GetResourceDefinitionCommand(
  input: GetResourceDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/resources/{ResourceDefinitionId}";
  if (input.ResourceDefinitionId !== undefined) {
    const labelValue: string = input.ResourceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ResourceDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetResourceDefinitionVersionCommand(
  input: GetResourceDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/resources/{ResourceDefinitionId}/versions/{ResourceDefinitionVersionId}";
  if (input.ResourceDefinitionId !== undefined) {
    const labelValue: string = input.ResourceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ResourceDefinitionId."
    );
  }
  if (input.ResourceDefinitionVersionId !== undefined) {
    const labelValue: string = input.ResourceDefinitionVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceDefinitionVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceDefinitionVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ResourceDefinitionVersionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetServiceRoleForAccountCommand(
  input: GetServiceRoleForAccountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/servicerole";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetSubscriptionDefinitionCommand(
  input: GetSubscriptionDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}";
  if (input.SubscriptionDefinitionId !== undefined) {
    const labelValue: string = input.SubscriptionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: SubscriptionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{SubscriptionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: SubscriptionDefinitionId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetSubscriptionDefinitionVersionCommand(
  input: GetSubscriptionDefinitionVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions/{SubscriptionDefinitionVersionId}";
  if (input.SubscriptionDefinitionId !== undefined) {
    const labelValue: string = input.SubscriptionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: SubscriptionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{SubscriptionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: SubscriptionDefinitionId."
    );
  }
  if (input.SubscriptionDefinitionVersionId !== undefined) {
    const labelValue: string = input.SubscriptionDefinitionVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: SubscriptionDefinitionVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{SubscriptionDefinitionVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: SubscriptionDefinitionVersionId."
    );
  }
  const query: any = {};
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListBulkDeploymentDetailedReportsCommand(
  input: ListBulkDeploymentDetailedReportsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/bulk/deployments/{BulkDeploymentId}/detailed-reports";
  if (input.BulkDeploymentId !== undefined) {
    const labelValue: string = input.BulkDeploymentId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: BulkDeploymentId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{BulkDeploymentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: BulkDeploymentId."
    );
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListBulkDeploymentsCommand(
  input: ListBulkDeploymentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/bulk/deployments";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListConnectorDefinitionVersionsCommand(
  input: ListConnectorDefinitionVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/connectors/{ConnectorDefinitionId}/versions";
  if (input.ConnectorDefinitionId !== undefined) {
    const labelValue: string = input.ConnectorDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ConnectorDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ConnectorDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ConnectorDefinitionId."
    );
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListConnectorDefinitionsCommand(
  input: ListConnectorDefinitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/connectors";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListCoreDefinitionVersionsCommand(
  input: ListCoreDefinitionVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/cores/{CoreDefinitionId}/versions";
  if (input.CoreDefinitionId !== undefined) {
    const labelValue: string = input.CoreDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: CoreDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{CoreDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: CoreDefinitionId."
    );
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListCoreDefinitionsCommand(
  input: ListCoreDefinitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/cores";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListDeploymentsCommand(
  input: ListDeploymentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/groups/{GroupId}/deployments";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListDeviceDefinitionVersionsCommand(
  input: ListDeviceDefinitionVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/devices/{DeviceDefinitionId}/versions";
  if (input.DeviceDefinitionId !== undefined) {
    const labelValue: string = input.DeviceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DeviceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DeviceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: DeviceDefinitionId."
    );
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListDeviceDefinitionsCommand(
  input: ListDeviceDefinitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/devices";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListFunctionDefinitionVersionsCommand(
  input: ListFunctionDefinitionVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/functions/{FunctionDefinitionId}/versions";
  if (input.FunctionDefinitionId !== undefined) {
    const labelValue: string = input.FunctionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: FunctionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{FunctionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: FunctionDefinitionId."
    );
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListFunctionDefinitionsCommand(
  input: ListFunctionDefinitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/functions";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListGroupCertificateAuthoritiesCommand(
  input: ListGroupCertificateAuthoritiesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/groups/{GroupId}/certificateauthorities";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ListGroupVersionsCommand(
  input: ListGroupVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/groups/{GroupId}/versions";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListGroupsCommand(
  input: ListGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/groups";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListLoggerDefinitionVersionsCommand(
  input: ListLoggerDefinitionVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/loggers/{LoggerDefinitionId}/versions";
  if (input.LoggerDefinitionId !== undefined) {
    const labelValue: string = input.LoggerDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: LoggerDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{LoggerDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: LoggerDefinitionId."
    );
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListLoggerDefinitionsCommand(
  input: ListLoggerDefinitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/loggers";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListResourceDefinitionVersionsCommand(
  input: ListResourceDefinitionVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/resources/{ResourceDefinitionId}/versions";
  if (input.ResourceDefinitionId !== undefined) {
    const labelValue: string = input.ResourceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ResourceDefinitionId."
    );
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListResourceDefinitionsCommand(
  input: ListResourceDefinitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/resources";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListSubscriptionDefinitionVersionsCommand(
  input: ListSubscriptionDefinitionVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions";
  if (input.SubscriptionDefinitionId !== undefined) {
    const labelValue: string = input.SubscriptionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: SubscriptionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{SubscriptionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: SubscriptionDefinitionId."
    );
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListSubscriptionDefinitionsCommand(
  input: ListSubscriptionDefinitionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/definition/subscriptions";
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query[
      __extendedEncodeURIComponent("MaxResults")
    ] = __extendedEncodeURIComponent(input.MaxResults);
  }
  if (input.NextToken !== undefined) {
    query[
      __extendedEncodeURIComponent("NextToken")
    ] = __extendedEncodeURIComponent(input.NextToken);
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/tags/{ResourceArn}";
  if (input.ResourceArn !== undefined) {
    const labelValue: string = input.ResourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceArn.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ResetDeploymentsCommand(
  input: ResetDeploymentsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/groups/{GroupId}/deployments/$reset";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Force !== undefined) {
    bodyParams["Force"] = input.Force;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1StartBulkDeploymentCommand(
  input: StartBulkDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.AmznClientToken !== undefined) {
    headers["X-Amzn-Client-Token"] = input.AmznClientToken;
  }
  let resolvedPath = "/greengrass/bulk/deployments";
  let body: any;
  const bodyParams: any = {};
  if (input.ExecutionRoleArn !== undefined) {
    bodyParams["ExecutionRoleArn"] = input.ExecutionRoleArn;
  }
  if (input.InputFileUri !== undefined) {
    bodyParams["InputFileUri"] = input.InputFileUri;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1Tags(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1StopBulkDeploymentCommand(
  input: StopBulkDeploymentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/greengrass/bulk/deployments/{BulkDeploymentId}/$stop";
  if (input.BulkDeploymentId !== undefined) {
    const labelValue: string = input.BulkDeploymentId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: BulkDeploymentId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{BulkDeploymentId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: BulkDeploymentId."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/tags/{ResourceArn}";
  if (input.ResourceArn !== undefined) {
    const labelValue: string = input.ResourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceArn.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1Tags(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/tags/{ResourceArn}";
  if (input.ResourceArn !== undefined) {
    const labelValue: string = input.ResourceArn;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceArn."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceArn}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceArn.");
  }
  const query: any = {};
  if (input.TagKeys !== undefined) {
    query[__extendedEncodeURIComponent("tagKeys")] = input.TagKeys.map(entry =>
      __extendedEncodeURIComponent(entry)
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1UpdateConnectivityInfoCommand(
  input: UpdateConnectivityInfoCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/greengrass/things/{ThingName}/connectivityInfo";
  if (input.ThingName !== undefined) {
    const labelValue: string = input.ThingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ThingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{ThingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ThingName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.ConnectivityInfo !== undefined) {
    bodyParams[
      "ConnectivityInfo"
    ] = serializeAws_restJson1_1__listOfConnectivityInfo(
      input.ConnectivityInfo,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateConnectorDefinitionCommand(
  input: UpdateConnectorDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/greengrass/definition/connectors/{ConnectorDefinitionId}";
  if (input.ConnectorDefinitionId !== undefined) {
    const labelValue: string = input.ConnectorDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ConnectorDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ConnectorDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ConnectorDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateCoreDefinitionCommand(
  input: UpdateCoreDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/greengrass/definition/cores/{CoreDefinitionId}";
  if (input.CoreDefinitionId !== undefined) {
    const labelValue: string = input.CoreDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: CoreDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{CoreDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: CoreDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateDeviceDefinitionCommand(
  input: UpdateDeviceDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/greengrass/definition/devices/{DeviceDefinitionId}";
  if (input.DeviceDefinitionId !== undefined) {
    const labelValue: string = input.DeviceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DeviceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DeviceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: DeviceDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateFunctionDefinitionCommand(
  input: UpdateFunctionDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/greengrass/definition/functions/{FunctionDefinitionId}";
  if (input.FunctionDefinitionId !== undefined) {
    const labelValue: string = input.FunctionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: FunctionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{FunctionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: FunctionDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateGroupCommand(
  input: UpdateGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/greengrass/groups/{GroupId}";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateGroupCertificateConfigurationCommand(
  input: UpdateGroupCertificateConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/greengrass/groups/{GroupId}/certificateauthorities/configuration/expiry";
  if (input.GroupId !== undefined) {
    const labelValue: string = input.GroupId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: GroupId.");
    }
    resolvedPath = resolvedPath.replace(
      "{GroupId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: GroupId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.CertificateExpiryInMilliseconds !== undefined) {
    bodyParams["CertificateExpiryInMilliseconds"] =
      input.CertificateExpiryInMilliseconds;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateLoggerDefinitionCommand(
  input: UpdateLoggerDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/greengrass/definition/loggers/{LoggerDefinitionId}";
  if (input.LoggerDefinitionId !== undefined) {
    const labelValue: string = input.LoggerDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: LoggerDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{LoggerDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: LoggerDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateResourceDefinitionCommand(
  input: UpdateResourceDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/greengrass/definition/resources/{ResourceDefinitionId}";
  if (input.ResourceDefinitionId !== undefined) {
    const labelValue: string = input.ResourceDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: ResourceDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateSubscriptionDefinitionCommand(
  input: UpdateSubscriptionDefinitionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath =
    "/greengrass/definition/subscriptions/{SubscriptionDefinitionId}";
  if (input.SubscriptionDefinitionId !== undefined) {
    const labelValue: string = input.SubscriptionDefinitionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: SubscriptionDefinitionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{SubscriptionDefinitionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: SubscriptionDefinitionId."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function deserializeAws_restJson1_1AssociateRoleToGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateRoleToGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AssociateRoleToGroupCommandError(
      output,
      context
    );
  }
  const contents: AssociateRoleToGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateRoleToGroupResponse",
    AssociatedAt: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AssociatedAt !== undefined && data.AssociatedAt !== null) {
    contents.AssociatedAt = data.AssociatedAt;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AssociateRoleToGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateRoleToGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AssociateServiceRoleToAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateServiceRoleToAccountCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AssociateServiceRoleToAccountCommandError(
      output,
      context
    );
  }
  const contents: AssociateServiceRoleToAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateServiceRoleToAccountResponse",
    AssociatedAt: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AssociatedAt !== undefined && data.AssociatedAt !== null) {
    contents.AssociatedAt = data.AssociatedAt;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AssociateServiceRoleToAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateServiceRoleToAccountCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateConnectorDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectorDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateConnectorDefinitionCommandError(
      output,
      context
    );
  }
  const contents: CreateConnectorDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateConnectorDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateConnectorDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectorDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateConnectorDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectorDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateConnectorDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateConnectorDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateConnectorDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateConnectorDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateConnectorDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateCoreDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCoreDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateCoreDefinitionCommandError(
      output,
      context
    );
  }
  const contents: CreateCoreDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCoreDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateCoreDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCoreDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateCoreDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCoreDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateCoreDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateCoreDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCoreDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateCoreDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCoreDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateDeploymentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeploymentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateDeploymentCommandError(
      output,
      context
    );
  }
  const contents: CreateDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDeploymentResponse",
    DeploymentArn: undefined,
    DeploymentId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DeploymentArn !== undefined && data.DeploymentArn !== null) {
    contents.DeploymentArn = data.DeploymentArn;
  }
  if (data.DeploymentId !== undefined && data.DeploymentId !== null) {
    contents.DeploymentId = data.DeploymentId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateDeploymentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeploymentCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateDeviceDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeviceDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateDeviceDefinitionCommandError(
      output,
      context
    );
  }
  const contents: CreateDeviceDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDeviceDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateDeviceDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeviceDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateDeviceDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeviceDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateDeviceDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateDeviceDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDeviceDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateDeviceDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDeviceDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateFunctionDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFunctionDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateFunctionDefinitionCommandError(
      output,
      context
    );
  }
  const contents: CreateFunctionDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFunctionDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateFunctionDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFunctionDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateFunctionDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFunctionDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateFunctionDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateFunctionDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFunctionDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateFunctionDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFunctionDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateGroupCommandError(output, context);
  }
  const contents: CreateGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGroupResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateGroupCertificateAuthorityCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGroupCertificateAuthorityCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateGroupCertificateAuthorityCommandError(
      output,
      context
    );
  }
  const contents: CreateGroupCertificateAuthorityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGroupCertificateAuthorityResponse",
    GroupCertificateAuthorityArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.GroupCertificateAuthorityArn !== undefined &&
    data.GroupCertificateAuthorityArn !== null
  ) {
    contents.GroupCertificateAuthorityArn = data.GroupCertificateAuthorityArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateGroupCertificateAuthorityCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGroupCertificateAuthorityCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateGroupVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGroupVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateGroupVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateGroupVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGroupVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateGroupVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGroupVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateLoggerDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLoggerDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateLoggerDefinitionCommandError(
      output,
      context
    );
  }
  const contents: CreateLoggerDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateLoggerDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateLoggerDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLoggerDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateLoggerDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLoggerDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateLoggerDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateLoggerDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateLoggerDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateLoggerDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateLoggerDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateResourceDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateResourceDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateResourceDefinitionCommandError(
      output,
      context
    );
  }
  const contents: CreateResourceDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateResourceDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateResourceDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateResourceDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateResourceDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateResourceDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateResourceDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateResourceDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateResourceDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateResourceDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateResourceDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateSoftwareUpdateJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSoftwareUpdateJobCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateSoftwareUpdateJobCommandError(
      output,
      context
    );
  }
  const contents: CreateSoftwareUpdateJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSoftwareUpdateJobResponse",
    IotJobArn: undefined,
    IotJobId: undefined,
    PlatformSoftwareVersion: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.IotJobArn !== undefined && data.IotJobArn !== null) {
    contents.IotJobArn = data.IotJobArn;
  }
  if (data.IotJobId !== undefined && data.IotJobId !== null) {
    contents.IotJobId = data.IotJobId;
  }
  if (
    data.PlatformSoftwareVersion !== undefined &&
    data.PlatformSoftwareVersion !== null
  ) {
    contents.PlatformSoftwareVersion = data.PlatformSoftwareVersion;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateSoftwareUpdateJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSoftwareUpdateJobCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateSubscriptionDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSubscriptionDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateSubscriptionDefinitionCommandError(
      output,
      context
    );
  }
  const contents: CreateSubscriptionDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSubscriptionDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateSubscriptionDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSubscriptionDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateSubscriptionDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSubscriptionDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateSubscriptionDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateSubscriptionDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSubscriptionDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateSubscriptionDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSubscriptionDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteConnectorDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectorDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteConnectorDefinitionCommandError(
      output,
      context
    );
  }
  const contents: DeleteConnectorDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteConnectorDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteConnectorDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectorDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteCoreDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCoreDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteCoreDefinitionCommandError(
      output,
      context
    );
  }
  const contents: DeleteCoreDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteCoreDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteCoreDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCoreDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteDeviceDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDeviceDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteDeviceDefinitionCommandError(
      output,
      context
    );
  }
  const contents: DeleteDeviceDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDeviceDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteDeviceDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDeviceDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteFunctionDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFunctionDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteFunctionDefinitionCommandError(
      output,
      context
    );
  }
  const contents: DeleteFunctionDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteFunctionDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteFunctionDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFunctionDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteGroupCommandError(output, context);
  }
  const contents: DeleteGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteGroupResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteLoggerDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLoggerDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteLoggerDefinitionCommandError(
      output,
      context
    );
  }
  const contents: DeleteLoggerDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteLoggerDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteLoggerDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteLoggerDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteResourceDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourceDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteResourceDefinitionCommandError(
      output,
      context
    );
  }
  const contents: DeleteResourceDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteResourceDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteResourceDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteResourceDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteSubscriptionDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSubscriptionDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteSubscriptionDefinitionCommandError(
      output,
      context
    );
  }
  const contents: DeleteSubscriptionDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSubscriptionDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteSubscriptionDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSubscriptionDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DisassociateRoleFromGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateRoleFromGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DisassociateRoleFromGroupCommandError(
      output,
      context
    );
  }
  const contents: DisassociateRoleFromGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateRoleFromGroupResponse",
    DisassociatedAt: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DisassociatedAt !== undefined && data.DisassociatedAt !== null) {
    contents.DisassociatedAt = data.DisassociatedAt;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DisassociateRoleFromGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateRoleFromGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DisassociateServiceRoleFromAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateServiceRoleFromAccountCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DisassociateServiceRoleFromAccountCommandError(
      output,
      context
    );
  }
  const contents: DisassociateServiceRoleFromAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateServiceRoleFromAccountResponse",
    DisassociatedAt: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DisassociatedAt !== undefined && data.DisassociatedAt !== null) {
    contents.DisassociatedAt = data.DisassociatedAt;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DisassociateServiceRoleFromAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateServiceRoleFromAccountCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetAssociatedRoleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAssociatedRoleCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetAssociatedRoleCommandError(
      output,
      context
    );
  }
  const contents: GetAssociatedRoleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAssociatedRoleResponse",
    AssociatedAt: undefined,
    RoleArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AssociatedAt !== undefined && data.AssociatedAt !== null) {
    contents.AssociatedAt = data.AssociatedAt;
  }
  if (data.RoleArn !== undefined && data.RoleArn !== null) {
    contents.RoleArn = data.RoleArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetAssociatedRoleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAssociatedRoleCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetBulkDeploymentStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBulkDeploymentStatusCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetBulkDeploymentStatusCommandError(
      output,
      context
    );
  }
  const contents: GetBulkDeploymentStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetBulkDeploymentStatusResponse",
    BulkDeploymentMetrics: undefined,
    BulkDeploymentStatus: undefined,
    CreatedAt: undefined,
    ErrorDetails: undefined,
    ErrorMessage: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.BulkDeploymentMetrics !== undefined &&
    data.BulkDeploymentMetrics !== null
  ) {
    contents.BulkDeploymentMetrics = deserializeAws_restJson1_1BulkDeploymentMetrics(
      data.BulkDeploymentMetrics,
      context
    );
  }
  if (
    data.BulkDeploymentStatus !== undefined &&
    data.BulkDeploymentStatus !== null
  ) {
    contents.BulkDeploymentStatus = data.BulkDeploymentStatus;
  }
  if (data.CreatedAt !== undefined && data.CreatedAt !== null) {
    contents.CreatedAt = data.CreatedAt;
  }
  if (data.ErrorDetails !== undefined && data.ErrorDetails !== null) {
    contents.ErrorDetails = deserializeAws_restJson1_1ErrorDetails(
      data.ErrorDetails,
      context
    );
  }
  if (data.ErrorMessage !== undefined && data.ErrorMessage !== null) {
    contents.ErrorMessage = data.ErrorMessage;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1Tags(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetBulkDeploymentStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBulkDeploymentStatusCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetConnectivityInfoCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectivityInfoCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetConnectivityInfoCommandError(
      output,
      context
    );
  }
  const contents: GetConnectivityInfoCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConnectivityInfoResponse",
    ConnectivityInfo: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.ConnectivityInfo !== undefined && data.ConnectivityInfo !== null) {
    contents.ConnectivityInfo = deserializeAws_restJson1_1__listOfConnectivityInfo(
      data.ConnectivityInfo,
      context
    );
  }
  if (data.message !== undefined && data.message !== null) {
    contents.Message = data.message;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetConnectivityInfoCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectivityInfoCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetConnectorDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectorDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetConnectorDefinitionCommandError(
      output,
      context
    );
  }
  const contents: GetConnectorDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConnectorDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1Tags(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetConnectorDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectorDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetConnectorDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectorDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetConnectorDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: GetConnectorDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetConnectorDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Definition: undefined,
    Id: undefined,
    NextToken: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Definition !== undefined && data.Definition !== null) {
    contents.Definition = deserializeAws_restJson1_1ConnectorDefinitionVersion(
      data.Definition,
      context
    );
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetConnectorDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetConnectorDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetCoreDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCoreDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetCoreDefinitionCommandError(
      output,
      context
    );
  }
  const contents: GetCoreDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCoreDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1Tags(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetCoreDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCoreDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetCoreDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCoreDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetCoreDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: GetCoreDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCoreDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Definition: undefined,
    Id: undefined,
    NextToken: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Definition !== undefined && data.Definition !== null) {
    contents.Definition = deserializeAws_restJson1_1CoreDefinitionVersion(
      data.Definition,
      context
    );
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetCoreDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCoreDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetDeploymentStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeploymentStatusCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetDeploymentStatusCommandError(
      output,
      context
    );
  }
  const contents: GetDeploymentStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDeploymentStatusResponse",
    DeploymentStatus: undefined,
    DeploymentType: undefined,
    ErrorDetails: undefined,
    ErrorMessage: undefined,
    UpdatedAt: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DeploymentStatus !== undefined && data.DeploymentStatus !== null) {
    contents.DeploymentStatus = data.DeploymentStatus;
  }
  if (data.DeploymentType !== undefined && data.DeploymentType !== null) {
    contents.DeploymentType = data.DeploymentType;
  }
  if (data.ErrorDetails !== undefined && data.ErrorDetails !== null) {
    contents.ErrorDetails = deserializeAws_restJson1_1ErrorDetails(
      data.ErrorDetails,
      context
    );
  }
  if (data.ErrorMessage !== undefined && data.ErrorMessage !== null) {
    contents.ErrorMessage = data.ErrorMessage;
  }
  if (data.UpdatedAt !== undefined && data.UpdatedAt !== null) {
    contents.UpdatedAt = data.UpdatedAt;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDeploymentStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeploymentStatusCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetDeviceDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeviceDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetDeviceDefinitionCommandError(
      output,
      context
    );
  }
  const contents: GetDeviceDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDeviceDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1Tags(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDeviceDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeviceDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetDeviceDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeviceDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetDeviceDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: GetDeviceDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetDeviceDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Definition: undefined,
    Id: undefined,
    NextToken: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Definition !== undefined && data.Definition !== null) {
    contents.Definition = deserializeAws_restJson1_1DeviceDefinitionVersion(
      data.Definition,
      context
    );
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetDeviceDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetDeviceDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetFunctionDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFunctionDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetFunctionDefinitionCommandError(
      output,
      context
    );
  }
  const contents: GetFunctionDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFunctionDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1Tags(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetFunctionDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFunctionDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetFunctionDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFunctionDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetFunctionDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: GetFunctionDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetFunctionDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Definition: undefined,
    Id: undefined,
    NextToken: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Definition !== undefined && data.Definition !== null) {
    contents.Definition = deserializeAws_restJson1_1FunctionDefinitionVersion(
      data.Definition,
      context
    );
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetFunctionDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetFunctionDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetGroupCommandError(output, context);
  }
  const contents: GetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGroupResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1Tags(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetGroupCertificateAuthorityCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGroupCertificateAuthorityCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetGroupCertificateAuthorityCommandError(
      output,
      context
    );
  }
  const contents: GetGroupCertificateAuthorityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGroupCertificateAuthorityResponse",
    GroupCertificateAuthorityArn: undefined,
    GroupCertificateAuthorityId: undefined,
    PemEncodedCertificate: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.GroupCertificateAuthorityArn !== undefined &&
    data.GroupCertificateAuthorityArn !== null
  ) {
    contents.GroupCertificateAuthorityArn = data.GroupCertificateAuthorityArn;
  }
  if (
    data.GroupCertificateAuthorityId !== undefined &&
    data.GroupCertificateAuthorityId !== null
  ) {
    contents.GroupCertificateAuthorityId = data.GroupCertificateAuthorityId;
  }
  if (
    data.PemEncodedCertificate !== undefined &&
    data.PemEncodedCertificate !== null
  ) {
    contents.PemEncodedCertificate = data.PemEncodedCertificate;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetGroupCertificateAuthorityCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGroupCertificateAuthorityCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetGroupCertificateConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGroupCertificateConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetGroupCertificateConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetGroupCertificateConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGroupCertificateConfigurationResponse",
    CertificateAuthorityExpiryInMilliseconds: undefined,
    CertificateExpiryInMilliseconds: undefined,
    GroupId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.CertificateAuthorityExpiryInMilliseconds !== undefined &&
    data.CertificateAuthorityExpiryInMilliseconds !== null
  ) {
    contents.CertificateAuthorityExpiryInMilliseconds =
      data.CertificateAuthorityExpiryInMilliseconds;
  }
  if (
    data.CertificateExpiryInMilliseconds !== undefined &&
    data.CertificateExpiryInMilliseconds !== null
  ) {
    contents.CertificateExpiryInMilliseconds =
      data.CertificateExpiryInMilliseconds;
  }
  if (data.GroupId !== undefined && data.GroupId !== null) {
    contents.GroupId = data.GroupId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetGroupCertificateConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGroupCertificateConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetGroupVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGroupVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetGroupVersionCommandError(
      output,
      context
    );
  }
  const contents: GetGroupVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGroupVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Definition: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Definition !== undefined && data.Definition !== null) {
    contents.Definition = deserializeAws_restJson1_1GroupVersion(
      data.Definition,
      context
    );
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetGroupVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGroupVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetLoggerDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggerDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetLoggerDefinitionCommandError(
      output,
      context
    );
  }
  const contents: GetLoggerDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetLoggerDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1Tags(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetLoggerDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggerDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetLoggerDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggerDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetLoggerDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: GetLoggerDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetLoggerDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Definition: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Definition !== undefined && data.Definition !== null) {
    contents.Definition = deserializeAws_restJson1_1LoggerDefinitionVersion(
      data.Definition,
      context
    );
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetLoggerDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggerDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetResourceDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourceDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetResourceDefinitionCommandError(
      output,
      context
    );
  }
  const contents: GetResourceDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetResourceDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1Tags(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetResourceDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourceDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetResourceDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourceDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetResourceDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: GetResourceDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetResourceDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Definition: undefined,
    Id: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Definition !== undefined && data.Definition !== null) {
    contents.Definition = deserializeAws_restJson1_1ResourceDefinitionVersion(
      data.Definition,
      context
    );
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetResourceDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetResourceDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetServiceRoleForAccountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetServiceRoleForAccountCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetServiceRoleForAccountCommandError(
      output,
      context
    );
  }
  const contents: GetServiceRoleForAccountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetServiceRoleForAccountResponse",
    AssociatedAt: undefined,
    RoleArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.AssociatedAt !== undefined && data.AssociatedAt !== null) {
    contents.AssociatedAt = data.AssociatedAt;
  }
  if (data.RoleArn !== undefined && data.RoleArn !== null) {
    contents.RoleArn = data.RoleArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetServiceRoleForAccountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetServiceRoleForAccountCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetSubscriptionDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSubscriptionDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetSubscriptionDefinitionCommandError(
      output,
      context
    );
  }
  const contents: GetSubscriptionDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSubscriptionDefinitionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (
    data.LastUpdatedTimestamp !== undefined &&
    data.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = data.LastUpdatedTimestamp;
  }
  if (data.LatestVersion !== undefined && data.LatestVersion !== null) {
    contents.LatestVersion = data.LatestVersion;
  }
  if (data.LatestVersionArn !== undefined && data.LatestVersionArn !== null) {
    contents.LatestVersionArn = data.LatestVersionArn;
  }
  if (data.Name !== undefined && data.Name !== null) {
    contents.Name = data.Name;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1Tags(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSubscriptionDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSubscriptionDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetSubscriptionDefinitionVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSubscriptionDefinitionVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetSubscriptionDefinitionVersionCommandError(
      output,
      context
    );
  }
  const contents: GetSubscriptionDefinitionVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetSubscriptionDefinitionVersionResponse",
    Arn: undefined,
    CreationTimestamp: undefined,
    Definition: undefined,
    Id: undefined,
    NextToken: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Arn !== undefined && data.Arn !== null) {
    contents.Arn = data.Arn;
  }
  if (data.CreationTimestamp !== undefined && data.CreationTimestamp !== null) {
    contents.CreationTimestamp = data.CreationTimestamp;
  }
  if (data.Definition !== undefined && data.Definition !== null) {
    contents.Definition = deserializeAws_restJson1_1SubscriptionDefinitionVersion(
      data.Definition,
      context
    );
  }
  if (data.Id !== undefined && data.Id !== null) {
    contents.Id = data.Id;
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetSubscriptionDefinitionVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetSubscriptionDefinitionVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListBulkDeploymentDetailedReportsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBulkDeploymentDetailedReportsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListBulkDeploymentDetailedReportsCommandError(
      output,
      context
    );
  }
  const contents: ListBulkDeploymentDetailedReportsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBulkDeploymentDetailedReportsResponse",
    Deployments: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Deployments !== undefined && data.Deployments !== null) {
    contents.Deployments = deserializeAws_restJson1_1BulkDeploymentResults(
      data.Deployments,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListBulkDeploymentDetailedReportsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBulkDeploymentDetailedReportsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListBulkDeploymentsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBulkDeploymentsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListBulkDeploymentsCommandError(
      output,
      context
    );
  }
  const contents: ListBulkDeploymentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBulkDeploymentsResponse",
    BulkDeployments: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.BulkDeployments !== undefined && data.BulkDeployments !== null) {
    contents.BulkDeployments = deserializeAws_restJson1_1BulkDeployments(
      data.BulkDeployments,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListBulkDeploymentsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBulkDeploymentsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListConnectorDefinitionVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListConnectorDefinitionVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListConnectorDefinitionVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListConnectorDefinitionVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListConnectorDefinitionVersionsResponse",
    NextToken: undefined,
    Versions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Versions !== undefined && data.Versions !== null) {
    contents.Versions = deserializeAws_restJson1_1__listOfVersionInformation(
      data.Versions,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListConnectorDefinitionVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListConnectorDefinitionVersionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListConnectorDefinitionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListConnectorDefinitionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListConnectorDefinitionsCommandError(
      output,
      context
    );
  }
  const contents: ListConnectorDefinitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListConnectorDefinitionsResponse",
    Definitions: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Definitions !== undefined && data.Definitions !== null) {
    contents.Definitions = deserializeAws_restJson1_1__listOfDefinitionInformation(
      data.Definitions,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListConnectorDefinitionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListConnectorDefinitionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListCoreDefinitionVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCoreDefinitionVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListCoreDefinitionVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListCoreDefinitionVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCoreDefinitionVersionsResponse",
    NextToken: undefined,
    Versions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Versions !== undefined && data.Versions !== null) {
    contents.Versions = deserializeAws_restJson1_1__listOfVersionInformation(
      data.Versions,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListCoreDefinitionVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCoreDefinitionVersionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListCoreDefinitionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCoreDefinitionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListCoreDefinitionsCommandError(
      output,
      context
    );
  }
  const contents: ListCoreDefinitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCoreDefinitionsResponse",
    Definitions: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Definitions !== undefined && data.Definitions !== null) {
    contents.Definitions = deserializeAws_restJson1_1__listOfDefinitionInformation(
      data.Definitions,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListCoreDefinitionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCoreDefinitionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListDeploymentsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDeploymentsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListDeploymentsCommandError(
      output,
      context
    );
  }
  const contents: ListDeploymentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDeploymentsResponse",
    Deployments: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Deployments !== undefined && data.Deployments !== null) {
    contents.Deployments = deserializeAws_restJson1_1Deployments(
      data.Deployments,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListDeploymentsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDeploymentsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListDeviceDefinitionVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDeviceDefinitionVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListDeviceDefinitionVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListDeviceDefinitionVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDeviceDefinitionVersionsResponse",
    NextToken: undefined,
    Versions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Versions !== undefined && data.Versions !== null) {
    contents.Versions = deserializeAws_restJson1_1__listOfVersionInformation(
      data.Versions,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListDeviceDefinitionVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDeviceDefinitionVersionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListDeviceDefinitionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDeviceDefinitionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListDeviceDefinitionsCommandError(
      output,
      context
    );
  }
  const contents: ListDeviceDefinitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDeviceDefinitionsResponse",
    Definitions: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Definitions !== undefined && data.Definitions !== null) {
    contents.Definitions = deserializeAws_restJson1_1__listOfDefinitionInformation(
      data.Definitions,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListDeviceDefinitionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDeviceDefinitionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListFunctionDefinitionVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFunctionDefinitionVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListFunctionDefinitionVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListFunctionDefinitionVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListFunctionDefinitionVersionsResponse",
    NextToken: undefined,
    Versions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Versions !== undefined && data.Versions !== null) {
    contents.Versions = deserializeAws_restJson1_1__listOfVersionInformation(
      data.Versions,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListFunctionDefinitionVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFunctionDefinitionVersionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListFunctionDefinitionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFunctionDefinitionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListFunctionDefinitionsCommandError(
      output,
      context
    );
  }
  const contents: ListFunctionDefinitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListFunctionDefinitionsResponse",
    Definitions: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Definitions !== undefined && data.Definitions !== null) {
    contents.Definitions = deserializeAws_restJson1_1__listOfDefinitionInformation(
      data.Definitions,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListFunctionDefinitionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFunctionDefinitionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListGroupCertificateAuthoritiesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGroupCertificateAuthoritiesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListGroupCertificateAuthoritiesCommandError(
      output,
      context
    );
  }
  const contents: ListGroupCertificateAuthoritiesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGroupCertificateAuthoritiesResponse",
    GroupCertificateAuthorities: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.GroupCertificateAuthorities !== undefined &&
    data.GroupCertificateAuthorities !== null
  ) {
    contents.GroupCertificateAuthorities = deserializeAws_restJson1_1__listOfGroupCertificateAuthorityProperties(
      data.GroupCertificateAuthorities,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListGroupCertificateAuthoritiesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGroupCertificateAuthoritiesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListGroupVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGroupVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListGroupVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListGroupVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGroupVersionsResponse",
    NextToken: undefined,
    Versions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Versions !== undefined && data.Versions !== null) {
    contents.Versions = deserializeAws_restJson1_1__listOfVersionInformation(
      data.Versions,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListGroupVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGroupVersionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGroupsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListGroupsCommandError(output, context);
  }
  const contents: ListGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGroupsResponse",
    Groups: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Groups !== undefined && data.Groups !== null) {
    contents.Groups = deserializeAws_restJson1_1__listOfGroupInformation(
      data.Groups,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGroupsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListLoggerDefinitionVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLoggerDefinitionVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListLoggerDefinitionVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListLoggerDefinitionVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListLoggerDefinitionVersionsResponse",
    NextToken: undefined,
    Versions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Versions !== undefined && data.Versions !== null) {
    contents.Versions = deserializeAws_restJson1_1__listOfVersionInformation(
      data.Versions,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListLoggerDefinitionVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLoggerDefinitionVersionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListLoggerDefinitionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLoggerDefinitionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListLoggerDefinitionsCommandError(
      output,
      context
    );
  }
  const contents: ListLoggerDefinitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListLoggerDefinitionsResponse",
    Definitions: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Definitions !== undefined && data.Definitions !== null) {
    contents.Definitions = deserializeAws_restJson1_1__listOfDefinitionInformation(
      data.Definitions,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListLoggerDefinitionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListLoggerDefinitionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListResourceDefinitionVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceDefinitionVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListResourceDefinitionVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListResourceDefinitionVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListResourceDefinitionVersionsResponse",
    NextToken: undefined,
    Versions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Versions !== undefined && data.Versions !== null) {
    contents.Versions = deserializeAws_restJson1_1__listOfVersionInformation(
      data.Versions,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListResourceDefinitionVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceDefinitionVersionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListResourceDefinitionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceDefinitionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListResourceDefinitionsCommandError(
      output,
      context
    );
  }
  const contents: ListResourceDefinitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListResourceDefinitionsResponse",
    Definitions: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Definitions !== undefined && data.Definitions !== null) {
    contents.Definitions = deserializeAws_restJson1_1__listOfDefinitionInformation(
      data.Definitions,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListResourceDefinitionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceDefinitionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListSubscriptionDefinitionVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSubscriptionDefinitionVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListSubscriptionDefinitionVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListSubscriptionDefinitionVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSubscriptionDefinitionVersionsResponse",
    NextToken: undefined,
    Versions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  if (data.Versions !== undefined && data.Versions !== null) {
    contents.Versions = deserializeAws_restJson1_1__listOfVersionInformation(
      data.Versions,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListSubscriptionDefinitionVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSubscriptionDefinitionVersionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListSubscriptionDefinitionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSubscriptionDefinitionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListSubscriptionDefinitionsCommandError(
      output,
      context
    );
  }
  const contents: ListSubscriptionDefinitionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSubscriptionDefinitionsResponse",
    Definitions: undefined,
    NextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.Definitions !== undefined && data.Definitions !== null) {
    contents.Definitions = deserializeAws_restJson1_1__listOfDefinitionInformation(
      data.Definitions,
      context
    );
  }
  if (data.NextToken !== undefined && data.NextToken !== null) {
    contents.NextToken = data.NextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListSubscriptionDefinitionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSubscriptionDefinitionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const contents: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1Tags(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ResetDeploymentsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetDeploymentsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ResetDeploymentsCommandError(
      output,
      context
    );
  }
  const contents: ResetDeploymentsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResetDeploymentsResponse",
    DeploymentArn: undefined,
    DeploymentId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DeploymentArn !== undefined && data.DeploymentArn !== null) {
    contents.DeploymentArn = data.DeploymentArn;
  }
  if (data.DeploymentId !== undefined && data.DeploymentId !== null) {
    contents.DeploymentId = data.DeploymentId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ResetDeploymentsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResetDeploymentsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1StartBulkDeploymentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartBulkDeploymentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1StartBulkDeploymentCommandError(
      output,
      context
    );
  }
  const contents: StartBulkDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartBulkDeploymentResponse",
    BulkDeploymentArn: undefined,
    BulkDeploymentId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.BulkDeploymentArn !== undefined && data.BulkDeploymentArn !== null) {
    contents.BulkDeploymentArn = data.BulkDeploymentArn;
  }
  if (data.BulkDeploymentId !== undefined && data.BulkDeploymentId !== null) {
    contents.BulkDeploymentId = data.BulkDeploymentId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1StartBulkDeploymentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartBulkDeploymentCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1StopBulkDeploymentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopBulkDeploymentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1StopBulkDeploymentCommandError(
      output,
      context
    );
  }
  const contents: StopBulkDeploymentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopBulkDeploymentResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1StopBulkDeploymentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopBulkDeploymentCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1TagResourceCommandError(output, context);
  }
  const contents: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode !== 204 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UntagResourceCommandError(output, context);
  }
  const contents: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateConnectivityInfoCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectivityInfoCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateConnectivityInfoCommandError(
      output,
      context
    );
  }
  const contents: UpdateConnectivityInfoCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateConnectivityInfoResponse",
    Message: undefined,
    Version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.Message = data.message;
  }
  if (data.Version !== undefined && data.Version !== null) {
    contents.Version = data.Version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateConnectivityInfoCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectivityInfoCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateConnectorDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectorDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateConnectorDefinitionCommandError(
      output,
      context
    );
  }
  const contents: UpdateConnectorDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateConnectorDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateConnectorDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateConnectorDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateCoreDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCoreDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateCoreDefinitionCommandError(
      output,
      context
    );
  }
  const contents: UpdateCoreDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateCoreDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateCoreDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCoreDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateDeviceDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDeviceDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateDeviceDefinitionCommandError(
      output,
      context
    );
  }
  const contents: UpdateDeviceDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDeviceDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateDeviceDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDeviceDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateFunctionDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFunctionDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateFunctionDefinitionCommandError(
      output,
      context
    );
  }
  const contents: UpdateFunctionDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateFunctionDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateFunctionDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFunctionDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateGroupCommandError(output, context);
  }
  const contents: UpdateGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateGroupResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateGroupCertificateConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGroupCertificateConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateGroupCertificateConfigurationCommandError(
      output,
      context
    );
  }
  const contents: UpdateGroupCertificateConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateGroupCertificateConfigurationResponse",
    CertificateAuthorityExpiryInMilliseconds: undefined,
    CertificateExpiryInMilliseconds: undefined,
    GroupId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.CertificateAuthorityExpiryInMilliseconds !== undefined &&
    data.CertificateAuthorityExpiryInMilliseconds !== null
  ) {
    contents.CertificateAuthorityExpiryInMilliseconds =
      data.CertificateAuthorityExpiryInMilliseconds;
  }
  if (
    data.CertificateExpiryInMilliseconds !== undefined &&
    data.CertificateExpiryInMilliseconds !== null
  ) {
    contents.CertificateExpiryInMilliseconds =
      data.CertificateExpiryInMilliseconds;
  }
  if (data.GroupId !== undefined && data.GroupId !== null) {
    contents.GroupId = data.GroupId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateGroupCertificateConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGroupCertificateConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    case "InternalServerErrorException":
    case "com.amazonaws.greengrass#InternalServerErrorException":
      response = await deserializeAws_restJson1_1InternalServerErrorExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateLoggerDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateLoggerDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateLoggerDefinitionCommandError(
      output,
      context
    );
  }
  const contents: UpdateLoggerDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateLoggerDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateLoggerDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateLoggerDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateResourceDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateResourceDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateResourceDefinitionCommandError(
      output,
      context
    );
  }
  const contents: UpdateResourceDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateResourceDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateResourceDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateResourceDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateSubscriptionDefinitionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSubscriptionDefinitionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateSubscriptionDefinitionCommandError(
      output,
      context
    );
  }
  const contents: UpdateSubscriptionDefinitionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSubscriptionDefinitionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateSubscriptionDefinitionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSubscriptionDefinitionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "BadRequestException":
    case "com.amazonaws.greengrass#BadRequestException":
      response = await deserializeAws_restJson1_1BadRequestExceptionResponse(
        output,
        context
      );
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_restJson1_1BadRequestExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<BadRequestException> => {
  const contents: BadRequestException = {
    name: "BadRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ErrorDetails: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.ErrorDetails !== undefined && data.ErrorDetails !== null) {
    contents.ErrorDetails = deserializeAws_restJson1_1ErrorDetails(
      data.ErrorDetails,
      context
    );
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const deserializeAws_restJson1_1InternalServerErrorExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InternalServerErrorException> => {
  const contents: InternalServerErrorException = {
    name: "InternalServerErrorException",
    $fault: "server",
    $metadata: deserializeMetadata(output),
    ErrorDetails: undefined,
    Message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.ErrorDetails !== undefined && data.ErrorDetails !== null) {
    contents.ErrorDetails = deserializeAws_restJson1_1ErrorDetails(
      data.ErrorDetails,
      context
    );
  }
  if (data.Message !== undefined && data.Message !== null) {
    contents.Message = data.Message;
  }
  return contents;
};

const serializeAws_restJson1_1ConnectivityInfo = (
  input: ConnectivityInfo,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.HostAddress !== undefined) {
    bodyParams["HostAddress"] = input.HostAddress;
  }
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.Metadata !== undefined) {
    bodyParams["Metadata"] = input.Metadata;
  }
  if (input.PortNumber !== undefined) {
    bodyParams["PortNumber"] = input.PortNumber;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Connector = (
  input: Connector,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConnectorArn !== undefined) {
    bodyParams["ConnectorArn"] = input.ConnectorArn;
  }
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = serializeAws_restJson1_1__mapOf__string(
      input.Parameters,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1ConnectorDefinitionVersion = (
  input: ConnectorDefinitionVersion,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Connectors !== undefined) {
    bodyParams["Connectors"] = serializeAws_restJson1_1__listOfConnector(
      input.Connectors,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1Core = (
  input: Core,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateArn !== undefined) {
    bodyParams["CertificateArn"] = input.CertificateArn;
  }
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.SyncShadow !== undefined) {
    bodyParams["SyncShadow"] = input.SyncShadow;
  }
  if (input.ThingArn !== undefined) {
    bodyParams["ThingArn"] = input.ThingArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CoreDefinitionVersion = (
  input: CoreDefinitionVersion,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Cores !== undefined) {
    bodyParams["Cores"] = serializeAws_restJson1_1__listOfCore(
      input.Cores,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1Device = (
  input: Device,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateArn !== undefined) {
    bodyParams["CertificateArn"] = input.CertificateArn;
  }
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.SyncShadow !== undefined) {
    bodyParams["SyncShadow"] = input.SyncShadow;
  }
  if (input.ThingArn !== undefined) {
    bodyParams["ThingArn"] = input.ThingArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1DeviceDefinitionVersion = (
  input: DeviceDefinitionVersion,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Devices !== undefined) {
    bodyParams["Devices"] = serializeAws_restJson1_1__listOfDevice(
      input.Devices,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1Function = (
  input: Function,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FunctionArn !== undefined) {
    bodyParams["FunctionArn"] = input.FunctionArn;
  }
  if (input.FunctionConfiguration !== undefined) {
    bodyParams[
      "FunctionConfiguration"
    ] = serializeAws_restJson1_1FunctionConfiguration(
      input.FunctionConfiguration,
      context
    );
  }
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  return bodyParams;
};

const serializeAws_restJson1_1FunctionConfiguration = (
  input: FunctionConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EncodingType !== undefined) {
    bodyParams["EncodingType"] = input.EncodingType;
  }
  if (input.Environment !== undefined) {
    bodyParams[
      "Environment"
    ] = serializeAws_restJson1_1FunctionConfigurationEnvironment(
      input.Environment,
      context
    );
  }
  if (input.ExecArgs !== undefined) {
    bodyParams["ExecArgs"] = input.ExecArgs;
  }
  if (input.Executable !== undefined) {
    bodyParams["Executable"] = input.Executable;
  }
  if (input.MemorySize !== undefined) {
    bodyParams["MemorySize"] = input.MemorySize;
  }
  if (input.Pinned !== undefined) {
    bodyParams["Pinned"] = input.Pinned;
  }
  if (input.Timeout !== undefined) {
    bodyParams["Timeout"] = input.Timeout;
  }
  return bodyParams;
};

const serializeAws_restJson1_1FunctionConfigurationEnvironment = (
  input: FunctionConfigurationEnvironment,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AccessSysfs !== undefined) {
    bodyParams["AccessSysfs"] = input.AccessSysfs;
  }
  if (input.Execution !== undefined) {
    bodyParams["Execution"] = serializeAws_restJson1_1FunctionExecutionConfig(
      input.Execution,
      context
    );
  }
  if (input.ResourceAccessPolicies !== undefined) {
    bodyParams[
      "ResourceAccessPolicies"
    ] = serializeAws_restJson1_1__listOfResourceAccessPolicy(
      input.ResourceAccessPolicies,
      context
    );
  }
  if (input.Variables !== undefined) {
    bodyParams["Variables"] = serializeAws_restJson1_1__mapOf__string(
      input.Variables,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1FunctionDefaultConfig = (
  input: FunctionDefaultConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Execution !== undefined) {
    bodyParams[
      "Execution"
    ] = serializeAws_restJson1_1FunctionDefaultExecutionConfig(
      input.Execution,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1FunctionDefaultExecutionConfig = (
  input: FunctionDefaultExecutionConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.IsolationMode !== undefined) {
    bodyParams["IsolationMode"] = input.IsolationMode;
  }
  if (input.RunAs !== undefined) {
    bodyParams["RunAs"] = serializeAws_restJson1_1FunctionRunAsConfig(
      input.RunAs,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1FunctionDefinitionVersion = (
  input: FunctionDefinitionVersion,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DefaultConfig !== undefined) {
    bodyParams["DefaultConfig"] = serializeAws_restJson1_1FunctionDefaultConfig(
      input.DefaultConfig,
      context
    );
  }
  if (input.Functions !== undefined) {
    bodyParams["Functions"] = serializeAws_restJson1_1__listOfFunction(
      input.Functions,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1FunctionExecutionConfig = (
  input: FunctionExecutionConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.IsolationMode !== undefined) {
    bodyParams["IsolationMode"] = input.IsolationMode;
  }
  if (input.RunAs !== undefined) {
    bodyParams["RunAs"] = serializeAws_restJson1_1FunctionRunAsConfig(
      input.RunAs,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1FunctionRunAsConfig = (
  input: FunctionRunAsConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Gid !== undefined) {
    bodyParams["Gid"] = input.Gid;
  }
  if (input.Uid !== undefined) {
    bodyParams["Uid"] = input.Uid;
  }
  return bodyParams;
};

const serializeAws_restJson1_1GroupOwnerSetting = (
  input: GroupOwnerSetting,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AutoAddGroupOwner !== undefined) {
    bodyParams["AutoAddGroupOwner"] = input.AutoAddGroupOwner;
  }
  if (input.GroupOwner !== undefined) {
    bodyParams["GroupOwner"] = input.GroupOwner;
  }
  return bodyParams;
};

const serializeAws_restJson1_1GroupVersion = (
  input: GroupVersion,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConnectorDefinitionVersionArn !== undefined) {
    bodyParams["ConnectorDefinitionVersionArn"] =
      input.ConnectorDefinitionVersionArn;
  }
  if (input.CoreDefinitionVersionArn !== undefined) {
    bodyParams["CoreDefinitionVersionArn"] = input.CoreDefinitionVersionArn;
  }
  if (input.DeviceDefinitionVersionArn !== undefined) {
    bodyParams["DeviceDefinitionVersionArn"] = input.DeviceDefinitionVersionArn;
  }
  if (input.FunctionDefinitionVersionArn !== undefined) {
    bodyParams["FunctionDefinitionVersionArn"] =
      input.FunctionDefinitionVersionArn;
  }
  if (input.LoggerDefinitionVersionArn !== undefined) {
    bodyParams["LoggerDefinitionVersionArn"] = input.LoggerDefinitionVersionArn;
  }
  if (input.ResourceDefinitionVersionArn !== undefined) {
    bodyParams["ResourceDefinitionVersionArn"] =
      input.ResourceDefinitionVersionArn;
  }
  if (input.SubscriptionDefinitionVersionArn !== undefined) {
    bodyParams["SubscriptionDefinitionVersionArn"] =
      input.SubscriptionDefinitionVersionArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1LocalDeviceResourceData = (
  input: LocalDeviceResourceData,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GroupOwnerSetting !== undefined) {
    bodyParams["GroupOwnerSetting"] = serializeAws_restJson1_1GroupOwnerSetting(
      input.GroupOwnerSetting,
      context
    );
  }
  if (input.SourcePath !== undefined) {
    bodyParams["SourcePath"] = input.SourcePath;
  }
  return bodyParams;
};

const serializeAws_restJson1_1LocalVolumeResourceData = (
  input: LocalVolumeResourceData,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DestinationPath !== undefined) {
    bodyParams["DestinationPath"] = input.DestinationPath;
  }
  if (input.GroupOwnerSetting !== undefined) {
    bodyParams["GroupOwnerSetting"] = serializeAws_restJson1_1GroupOwnerSetting(
      input.GroupOwnerSetting,
      context
    );
  }
  if (input.SourcePath !== undefined) {
    bodyParams["SourcePath"] = input.SourcePath;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Logger = (
  input: Logger,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Component !== undefined) {
    bodyParams["Component"] = input.Component;
  }
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.Level !== undefined) {
    bodyParams["Level"] = input.Level;
  }
  if (input.Space !== undefined) {
    bodyParams["Space"] = input.Space;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_restJson1_1LoggerDefinitionVersion = (
  input: LoggerDefinitionVersion,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Loggers !== undefined) {
    bodyParams["Loggers"] = serializeAws_restJson1_1__listOfLogger(
      input.Loggers,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1Resource = (
  input: Resource,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.ResourceDataContainer !== undefined) {
    bodyParams[
      "ResourceDataContainer"
    ] = serializeAws_restJson1_1ResourceDataContainer(
      input.ResourceDataContainer,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1ResourceAccessPolicy = (
  input: ResourceAccessPolicy,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Permission !== undefined) {
    bodyParams["Permission"] = input.Permission;
  }
  if (input.ResourceId !== undefined) {
    bodyParams["ResourceId"] = input.ResourceId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ResourceDataContainer = (
  input: ResourceDataContainer,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LocalDeviceResourceData !== undefined) {
    bodyParams[
      "LocalDeviceResourceData"
    ] = serializeAws_restJson1_1LocalDeviceResourceData(
      input.LocalDeviceResourceData,
      context
    );
  }
  if (input.LocalVolumeResourceData !== undefined) {
    bodyParams[
      "LocalVolumeResourceData"
    ] = serializeAws_restJson1_1LocalVolumeResourceData(
      input.LocalVolumeResourceData,
      context
    );
  }
  if (input.S3MachineLearningModelResourceData !== undefined) {
    bodyParams[
      "S3MachineLearningModelResourceData"
    ] = serializeAws_restJson1_1S3MachineLearningModelResourceData(
      input.S3MachineLearningModelResourceData,
      context
    );
  }
  if (input.SageMakerMachineLearningModelResourceData !== undefined) {
    bodyParams[
      "SageMakerMachineLearningModelResourceData"
    ] = serializeAws_restJson1_1SageMakerMachineLearningModelResourceData(
      input.SageMakerMachineLearningModelResourceData,
      context
    );
  }
  if (input.SecretsManagerSecretResourceData !== undefined) {
    bodyParams[
      "SecretsManagerSecretResourceData"
    ] = serializeAws_restJson1_1SecretsManagerSecretResourceData(
      input.SecretsManagerSecretResourceData,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1ResourceDefinitionVersion = (
  input: ResourceDefinitionVersion,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Resources !== undefined) {
    bodyParams["Resources"] = serializeAws_restJson1_1__listOfResource(
      input.Resources,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1ResourceDownloadOwnerSetting = (
  input: ResourceDownloadOwnerSetting,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GroupOwner !== undefined) {
    bodyParams["GroupOwner"] = input.GroupOwner;
  }
  if (input.GroupPermission !== undefined) {
    bodyParams["GroupPermission"] = input.GroupPermission;
  }
  return bodyParams;
};

const serializeAws_restJson1_1S3MachineLearningModelResourceData = (
  input: S3MachineLearningModelResourceData,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DestinationPath !== undefined) {
    bodyParams["DestinationPath"] = input.DestinationPath;
  }
  if (input.OwnerSetting !== undefined) {
    bodyParams[
      "OwnerSetting"
    ] = serializeAws_restJson1_1ResourceDownloadOwnerSetting(
      input.OwnerSetting,
      context
    );
  }
  if (input.S3Uri !== undefined) {
    bodyParams["S3Uri"] = input.S3Uri;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SageMakerMachineLearningModelResourceData = (
  input: SageMakerMachineLearningModelResourceData,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DestinationPath !== undefined) {
    bodyParams["DestinationPath"] = input.DestinationPath;
  }
  if (input.OwnerSetting !== undefined) {
    bodyParams[
      "OwnerSetting"
    ] = serializeAws_restJson1_1ResourceDownloadOwnerSetting(
      input.OwnerSetting,
      context
    );
  }
  if (input.SageMakerJobArn !== undefined) {
    bodyParams["SageMakerJobArn"] = input.SageMakerJobArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SecretsManagerSecretResourceData = (
  input: SecretsManagerSecretResourceData,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ARN !== undefined) {
    bodyParams["ARN"] = input.ARN;
  }
  if (input.AdditionalStagingLabelsToDownload !== undefined) {
    bodyParams[
      "AdditionalStagingLabelsToDownload"
    ] = serializeAws_restJson1_1__listOf__string(
      input.AdditionalStagingLabelsToDownload,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1Subscription = (
  input: Subscription,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Id !== undefined) {
    bodyParams["Id"] = input.Id;
  }
  if (input.Source !== undefined) {
    bodyParams["Source"] = input.Source;
  }
  if (input.Subject !== undefined) {
    bodyParams["Subject"] = input.Subject;
  }
  if (input.Target !== undefined) {
    bodyParams["Target"] = input.Target;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SubscriptionDefinitionVersion = (
  input: SubscriptionDefinitionVersion,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Subscriptions !== undefined) {
    bodyParams["Subscriptions"] = serializeAws_restJson1_1__listOfSubscription(
      input.Subscriptions,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1Tags = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_restJson1_1UpdateTargets = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_restJson1_1__listOfConnectivityInfo = (
  input: Array<ConnectivityInfo>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1ConnectivityInfo(entry, context)
  );
};

const serializeAws_restJson1_1__listOfConnector = (
  input: Array<Connector>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1Connector(entry, context)
  );
};

const serializeAws_restJson1_1__listOfCore = (
  input: Array<Core>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1Core(entry, context)
  );
};

const serializeAws_restJson1_1__listOfDevice = (
  input: Array<Device>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1Device(entry, context)
  );
};

const serializeAws_restJson1_1__listOfFunction = (
  input: Array<Function>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1Function(entry, context)
  );
};

const serializeAws_restJson1_1__listOfLogger = (
  input: Array<Logger>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1Logger(entry, context)
  );
};

const serializeAws_restJson1_1__listOfResource = (
  input: Array<Resource>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1Resource(entry, context)
  );
};

const serializeAws_restJson1_1__listOfResourceAccessPolicy = (
  input: Array<ResourceAccessPolicy>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1ResourceAccessPolicy(entry, context)
  );
};

const serializeAws_restJson1_1__listOfSubscription = (
  input: Array<Subscription>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_restJson1_1Subscription(entry, context)
  );
};

const serializeAws_restJson1_1__listOf__string = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_restJson1_1__mapOf__string = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1BulkDeployment = (
  output: any,
  context: __SerdeContext
): BulkDeployment => {
  let contents: any = {
    __type: "BulkDeployment",
    BulkDeploymentArn: undefined,
    BulkDeploymentId: undefined,
    CreatedAt: undefined
  };
  if (
    output.BulkDeploymentArn !== undefined &&
    output.BulkDeploymentArn !== null
  ) {
    contents.BulkDeploymentArn = output.BulkDeploymentArn;
  }
  if (
    output.BulkDeploymentId !== undefined &&
    output.BulkDeploymentId !== null
  ) {
    contents.BulkDeploymentId = output.BulkDeploymentId;
  }
  if (output.CreatedAt !== undefined && output.CreatedAt !== null) {
    contents.CreatedAt = output.CreatedAt;
  }
  return contents;
};

const deserializeAws_restJson1_1BulkDeploymentMetrics = (
  output: any,
  context: __SerdeContext
): BulkDeploymentMetrics => {
  let contents: any = {
    __type: "BulkDeploymentMetrics",
    InvalidInputRecords: undefined,
    RecordsProcessed: undefined,
    RetryAttempts: undefined
  };
  if (
    output.InvalidInputRecords !== undefined &&
    output.InvalidInputRecords !== null
  ) {
    contents.InvalidInputRecords = output.InvalidInputRecords;
  }
  if (
    output.RecordsProcessed !== undefined &&
    output.RecordsProcessed !== null
  ) {
    contents.RecordsProcessed = output.RecordsProcessed;
  }
  if (output.RetryAttempts !== undefined && output.RetryAttempts !== null) {
    contents.RetryAttempts = output.RetryAttempts;
  }
  return contents;
};

const deserializeAws_restJson1_1BulkDeploymentResult = (
  output: any,
  context: __SerdeContext
): BulkDeploymentResult => {
  let contents: any = {
    __type: "BulkDeploymentResult",
    CreatedAt: undefined,
    DeploymentArn: undefined,
    DeploymentId: undefined,
    DeploymentStatus: undefined,
    DeploymentType: undefined,
    ErrorDetails: undefined,
    ErrorMessage: undefined,
    GroupArn: undefined
  };
  if (output.CreatedAt !== undefined && output.CreatedAt !== null) {
    contents.CreatedAt = output.CreatedAt;
  }
  if (output.DeploymentArn !== undefined && output.DeploymentArn !== null) {
    contents.DeploymentArn = output.DeploymentArn;
  }
  if (output.DeploymentId !== undefined && output.DeploymentId !== null) {
    contents.DeploymentId = output.DeploymentId;
  }
  if (
    output.DeploymentStatus !== undefined &&
    output.DeploymentStatus !== null
  ) {
    contents.DeploymentStatus = output.DeploymentStatus;
  }
  if (output.DeploymentType !== undefined && output.DeploymentType !== null) {
    contents.DeploymentType = output.DeploymentType;
  }
  if (output.ErrorDetails !== undefined && output.ErrorDetails !== null) {
    contents.ErrorDetails = deserializeAws_restJson1_1ErrorDetails(
      output.ErrorDetails,
      context
    );
  }
  if (output.ErrorMessage !== undefined && output.ErrorMessage !== null) {
    contents.ErrorMessage = output.ErrorMessage;
  }
  if (output.GroupArn !== undefined && output.GroupArn !== null) {
    contents.GroupArn = output.GroupArn;
  }
  return contents;
};

const deserializeAws_restJson1_1BulkDeploymentResults = (
  output: any,
  context: __SerdeContext
): Array<BulkDeploymentResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1BulkDeploymentResult(entry, context)
  );
};

const deserializeAws_restJson1_1BulkDeployments = (
  output: any,
  context: __SerdeContext
): Array<BulkDeployment> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1BulkDeployment(entry, context)
  );
};

const deserializeAws_restJson1_1ConnectivityInfo = (
  output: any,
  context: __SerdeContext
): ConnectivityInfo => {
  let contents: any = {
    __type: "ConnectivityInfo",
    HostAddress: undefined,
    Id: undefined,
    Metadata: undefined,
    PortNumber: undefined
  };
  if (output.HostAddress !== undefined && output.HostAddress !== null) {
    contents.HostAddress = output.HostAddress;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Metadata !== undefined && output.Metadata !== null) {
    contents.Metadata = output.Metadata;
  }
  if (output.PortNumber !== undefined && output.PortNumber !== null) {
    contents.PortNumber = output.PortNumber;
  }
  return contents;
};

const deserializeAws_restJson1_1Connector = (
  output: any,
  context: __SerdeContext
): Connector => {
  let contents: any = {
    __type: "Connector",
    ConnectorArn: undefined,
    Id: undefined,
    Parameters: undefined
  };
  if (output.ConnectorArn !== undefined && output.ConnectorArn !== null) {
    contents.ConnectorArn = output.ConnectorArn;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = deserializeAws_restJson1_1__mapOf__string(
      output.Parameters,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ConnectorDefinitionVersion = (
  output: any,
  context: __SerdeContext
): ConnectorDefinitionVersion => {
  let contents: any = {
    __type: "ConnectorDefinitionVersion",
    Connectors: undefined
  };
  if (output.Connectors !== undefined && output.Connectors !== null) {
    contents.Connectors = deserializeAws_restJson1_1__listOfConnector(
      output.Connectors,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Core = (
  output: any,
  context: __SerdeContext
): Core => {
  let contents: any = {
    __type: "Core",
    CertificateArn: undefined,
    Id: undefined,
    SyncShadow: undefined,
    ThingArn: undefined
  };
  if (output.CertificateArn !== undefined && output.CertificateArn !== null) {
    contents.CertificateArn = output.CertificateArn;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.SyncShadow !== undefined && output.SyncShadow !== null) {
    contents.SyncShadow = output.SyncShadow;
  }
  if (output.ThingArn !== undefined && output.ThingArn !== null) {
    contents.ThingArn = output.ThingArn;
  }
  return contents;
};

const deserializeAws_restJson1_1CoreDefinitionVersion = (
  output: any,
  context: __SerdeContext
): CoreDefinitionVersion => {
  let contents: any = {
    __type: "CoreDefinitionVersion",
    Cores: undefined
  };
  if (output.Cores !== undefined && output.Cores !== null) {
    contents.Cores = deserializeAws_restJson1_1__listOfCore(
      output.Cores,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1DefinitionInformation = (
  output: any,
  context: __SerdeContext
): DefinitionInformation => {
  let contents: any = {
    __type: "DefinitionInformation",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined,
    Tags: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (
    output.CreationTimestamp !== undefined &&
    output.CreationTimestamp !== null
  ) {
    contents.CreationTimestamp = output.CreationTimestamp;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (
    output.LastUpdatedTimestamp !== undefined &&
    output.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = output.LastUpdatedTimestamp;
  }
  if (output.LatestVersion !== undefined && output.LatestVersion !== null) {
    contents.LatestVersion = output.LatestVersion;
  }
  if (
    output.LatestVersionArn !== undefined &&
    output.LatestVersionArn !== null
  ) {
    contents.LatestVersionArn = output.LatestVersionArn;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.tags !== undefined && output.tags !== null) {
    contents.Tags = deserializeAws_restJson1_1Tags(output.tags, context);
  }
  return contents;
};

const deserializeAws_restJson1_1Deployment = (
  output: any,
  context: __SerdeContext
): Deployment => {
  let contents: any = {
    __type: "Deployment",
    CreatedAt: undefined,
    DeploymentArn: undefined,
    DeploymentId: undefined,
    DeploymentType: undefined,
    GroupArn: undefined
  };
  if (output.CreatedAt !== undefined && output.CreatedAt !== null) {
    contents.CreatedAt = output.CreatedAt;
  }
  if (output.DeploymentArn !== undefined && output.DeploymentArn !== null) {
    contents.DeploymentArn = output.DeploymentArn;
  }
  if (output.DeploymentId !== undefined && output.DeploymentId !== null) {
    contents.DeploymentId = output.DeploymentId;
  }
  if (output.DeploymentType !== undefined && output.DeploymentType !== null) {
    contents.DeploymentType = output.DeploymentType;
  }
  if (output.GroupArn !== undefined && output.GroupArn !== null) {
    contents.GroupArn = output.GroupArn;
  }
  return contents;
};

const deserializeAws_restJson1_1Deployments = (
  output: any,
  context: __SerdeContext
): Array<Deployment> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Deployment(entry, context)
  );
};

const deserializeAws_restJson1_1Device = (
  output: any,
  context: __SerdeContext
): Device => {
  let contents: any = {
    __type: "Device",
    CertificateArn: undefined,
    Id: undefined,
    SyncShadow: undefined,
    ThingArn: undefined
  };
  if (output.CertificateArn !== undefined && output.CertificateArn !== null) {
    contents.CertificateArn = output.CertificateArn;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.SyncShadow !== undefined && output.SyncShadow !== null) {
    contents.SyncShadow = output.SyncShadow;
  }
  if (output.ThingArn !== undefined && output.ThingArn !== null) {
    contents.ThingArn = output.ThingArn;
  }
  return contents;
};

const deserializeAws_restJson1_1DeviceDefinitionVersion = (
  output: any,
  context: __SerdeContext
): DeviceDefinitionVersion => {
  let contents: any = {
    __type: "DeviceDefinitionVersion",
    Devices: undefined
  };
  if (output.Devices !== undefined && output.Devices !== null) {
    contents.Devices = deserializeAws_restJson1_1__listOfDevice(
      output.Devices,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ErrorDetail = (
  output: any,
  context: __SerdeContext
): ErrorDetail => {
  let contents: any = {
    __type: "ErrorDetail",
    DetailedErrorCode: undefined,
    DetailedErrorMessage: undefined
  };
  if (
    output.DetailedErrorCode !== undefined &&
    output.DetailedErrorCode !== null
  ) {
    contents.DetailedErrorCode = output.DetailedErrorCode;
  }
  if (
    output.DetailedErrorMessage !== undefined &&
    output.DetailedErrorMessage !== null
  ) {
    contents.DetailedErrorMessage = output.DetailedErrorMessage;
  }
  return contents;
};

const deserializeAws_restJson1_1ErrorDetails = (
  output: any,
  context: __SerdeContext
): Array<ErrorDetail> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ErrorDetail(entry, context)
  );
};

const deserializeAws_restJson1_1Function = (
  output: any,
  context: __SerdeContext
): Function => {
  let contents: any = {
    __type: "Function",
    FunctionArn: undefined,
    FunctionConfiguration: undefined,
    Id: undefined
  };
  if (output.FunctionArn !== undefined && output.FunctionArn !== null) {
    contents.FunctionArn = output.FunctionArn;
  }
  if (
    output.FunctionConfiguration !== undefined &&
    output.FunctionConfiguration !== null
  ) {
    contents.FunctionConfiguration = deserializeAws_restJson1_1FunctionConfiguration(
      output.FunctionConfiguration,
      context
    );
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  return contents;
};

const deserializeAws_restJson1_1FunctionConfiguration = (
  output: any,
  context: __SerdeContext
): FunctionConfiguration => {
  let contents: any = {
    __type: "FunctionConfiguration",
    EncodingType: undefined,
    Environment: undefined,
    ExecArgs: undefined,
    Executable: undefined,
    MemorySize: undefined,
    Pinned: undefined,
    Timeout: undefined
  };
  if (output.EncodingType !== undefined && output.EncodingType !== null) {
    contents.EncodingType = output.EncodingType;
  }
  if (output.Environment !== undefined && output.Environment !== null) {
    contents.Environment = deserializeAws_restJson1_1FunctionConfigurationEnvironment(
      output.Environment,
      context
    );
  }
  if (output.ExecArgs !== undefined && output.ExecArgs !== null) {
    contents.ExecArgs = output.ExecArgs;
  }
  if (output.Executable !== undefined && output.Executable !== null) {
    contents.Executable = output.Executable;
  }
  if (output.MemorySize !== undefined && output.MemorySize !== null) {
    contents.MemorySize = output.MemorySize;
  }
  if (output.Pinned !== undefined && output.Pinned !== null) {
    contents.Pinned = output.Pinned;
  }
  if (output.Timeout !== undefined && output.Timeout !== null) {
    contents.Timeout = output.Timeout;
  }
  return contents;
};

const deserializeAws_restJson1_1FunctionConfigurationEnvironment = (
  output: any,
  context: __SerdeContext
): FunctionConfigurationEnvironment => {
  let contents: any = {
    __type: "FunctionConfigurationEnvironment",
    AccessSysfs: undefined,
    Execution: undefined,
    ResourceAccessPolicies: undefined,
    Variables: undefined
  };
  if (output.AccessSysfs !== undefined && output.AccessSysfs !== null) {
    contents.AccessSysfs = output.AccessSysfs;
  }
  if (output.Execution !== undefined && output.Execution !== null) {
    contents.Execution = deserializeAws_restJson1_1FunctionExecutionConfig(
      output.Execution,
      context
    );
  }
  if (
    output.ResourceAccessPolicies !== undefined &&
    output.ResourceAccessPolicies !== null
  ) {
    contents.ResourceAccessPolicies = deserializeAws_restJson1_1__listOfResourceAccessPolicy(
      output.ResourceAccessPolicies,
      context
    );
  }
  if (output.Variables !== undefined && output.Variables !== null) {
    contents.Variables = deserializeAws_restJson1_1__mapOf__string(
      output.Variables,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1FunctionDefaultConfig = (
  output: any,
  context: __SerdeContext
): FunctionDefaultConfig => {
  let contents: any = {
    __type: "FunctionDefaultConfig",
    Execution: undefined
  };
  if (output.Execution !== undefined && output.Execution !== null) {
    contents.Execution = deserializeAws_restJson1_1FunctionDefaultExecutionConfig(
      output.Execution,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1FunctionDefaultExecutionConfig = (
  output: any,
  context: __SerdeContext
): FunctionDefaultExecutionConfig => {
  let contents: any = {
    __type: "FunctionDefaultExecutionConfig",
    IsolationMode: undefined,
    RunAs: undefined
  };
  if (output.IsolationMode !== undefined && output.IsolationMode !== null) {
    contents.IsolationMode = output.IsolationMode;
  }
  if (output.RunAs !== undefined && output.RunAs !== null) {
    contents.RunAs = deserializeAws_restJson1_1FunctionRunAsConfig(
      output.RunAs,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1FunctionDefinitionVersion = (
  output: any,
  context: __SerdeContext
): FunctionDefinitionVersion => {
  let contents: any = {
    __type: "FunctionDefinitionVersion",
    DefaultConfig: undefined,
    Functions: undefined
  };
  if (output.DefaultConfig !== undefined && output.DefaultConfig !== null) {
    contents.DefaultConfig = deserializeAws_restJson1_1FunctionDefaultConfig(
      output.DefaultConfig,
      context
    );
  }
  if (output.Functions !== undefined && output.Functions !== null) {
    contents.Functions = deserializeAws_restJson1_1__listOfFunction(
      output.Functions,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1FunctionExecutionConfig = (
  output: any,
  context: __SerdeContext
): FunctionExecutionConfig => {
  let contents: any = {
    __type: "FunctionExecutionConfig",
    IsolationMode: undefined,
    RunAs: undefined
  };
  if (output.IsolationMode !== undefined && output.IsolationMode !== null) {
    contents.IsolationMode = output.IsolationMode;
  }
  if (output.RunAs !== undefined && output.RunAs !== null) {
    contents.RunAs = deserializeAws_restJson1_1FunctionRunAsConfig(
      output.RunAs,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1FunctionRunAsConfig = (
  output: any,
  context: __SerdeContext
): FunctionRunAsConfig => {
  let contents: any = {
    __type: "FunctionRunAsConfig",
    Gid: undefined,
    Uid: undefined
  };
  if (output.Gid !== undefined && output.Gid !== null) {
    contents.Gid = output.Gid;
  }
  if (output.Uid !== undefined && output.Uid !== null) {
    contents.Uid = output.Uid;
  }
  return contents;
};

const deserializeAws_restJson1_1GroupCertificateAuthorityProperties = (
  output: any,
  context: __SerdeContext
): GroupCertificateAuthorityProperties => {
  let contents: any = {
    __type: "GroupCertificateAuthorityProperties",
    GroupCertificateAuthorityArn: undefined,
    GroupCertificateAuthorityId: undefined
  };
  if (
    output.GroupCertificateAuthorityArn !== undefined &&
    output.GroupCertificateAuthorityArn !== null
  ) {
    contents.GroupCertificateAuthorityArn = output.GroupCertificateAuthorityArn;
  }
  if (
    output.GroupCertificateAuthorityId !== undefined &&
    output.GroupCertificateAuthorityId !== null
  ) {
    contents.GroupCertificateAuthorityId = output.GroupCertificateAuthorityId;
  }
  return contents;
};

const deserializeAws_restJson1_1GroupInformation = (
  output: any,
  context: __SerdeContext
): GroupInformation => {
  let contents: any = {
    __type: "GroupInformation",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    LastUpdatedTimestamp: undefined,
    LatestVersion: undefined,
    LatestVersionArn: undefined,
    Name: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (
    output.CreationTimestamp !== undefined &&
    output.CreationTimestamp !== null
  ) {
    contents.CreationTimestamp = output.CreationTimestamp;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (
    output.LastUpdatedTimestamp !== undefined &&
    output.LastUpdatedTimestamp !== null
  ) {
    contents.LastUpdatedTimestamp = output.LastUpdatedTimestamp;
  }
  if (output.LatestVersion !== undefined && output.LatestVersion !== null) {
    contents.LatestVersion = output.LatestVersion;
  }
  if (
    output.LatestVersionArn !== undefined &&
    output.LatestVersionArn !== null
  ) {
    contents.LatestVersionArn = output.LatestVersionArn;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_restJson1_1GroupOwnerSetting = (
  output: any,
  context: __SerdeContext
): GroupOwnerSetting => {
  let contents: any = {
    __type: "GroupOwnerSetting",
    AutoAddGroupOwner: undefined,
    GroupOwner: undefined
  };
  if (
    output.AutoAddGroupOwner !== undefined &&
    output.AutoAddGroupOwner !== null
  ) {
    contents.AutoAddGroupOwner = output.AutoAddGroupOwner;
  }
  if (output.GroupOwner !== undefined && output.GroupOwner !== null) {
    contents.GroupOwner = output.GroupOwner;
  }
  return contents;
};

const deserializeAws_restJson1_1GroupVersion = (
  output: any,
  context: __SerdeContext
): GroupVersion => {
  let contents: any = {
    __type: "GroupVersion",
    ConnectorDefinitionVersionArn: undefined,
    CoreDefinitionVersionArn: undefined,
    DeviceDefinitionVersionArn: undefined,
    FunctionDefinitionVersionArn: undefined,
    LoggerDefinitionVersionArn: undefined,
    ResourceDefinitionVersionArn: undefined,
    SubscriptionDefinitionVersionArn: undefined
  };
  if (
    output.ConnectorDefinitionVersionArn !== undefined &&
    output.ConnectorDefinitionVersionArn !== null
  ) {
    contents.ConnectorDefinitionVersionArn =
      output.ConnectorDefinitionVersionArn;
  }
  if (
    output.CoreDefinitionVersionArn !== undefined &&
    output.CoreDefinitionVersionArn !== null
  ) {
    contents.CoreDefinitionVersionArn = output.CoreDefinitionVersionArn;
  }
  if (
    output.DeviceDefinitionVersionArn !== undefined &&
    output.DeviceDefinitionVersionArn !== null
  ) {
    contents.DeviceDefinitionVersionArn = output.DeviceDefinitionVersionArn;
  }
  if (
    output.FunctionDefinitionVersionArn !== undefined &&
    output.FunctionDefinitionVersionArn !== null
  ) {
    contents.FunctionDefinitionVersionArn = output.FunctionDefinitionVersionArn;
  }
  if (
    output.LoggerDefinitionVersionArn !== undefined &&
    output.LoggerDefinitionVersionArn !== null
  ) {
    contents.LoggerDefinitionVersionArn = output.LoggerDefinitionVersionArn;
  }
  if (
    output.ResourceDefinitionVersionArn !== undefined &&
    output.ResourceDefinitionVersionArn !== null
  ) {
    contents.ResourceDefinitionVersionArn = output.ResourceDefinitionVersionArn;
  }
  if (
    output.SubscriptionDefinitionVersionArn !== undefined &&
    output.SubscriptionDefinitionVersionArn !== null
  ) {
    contents.SubscriptionDefinitionVersionArn =
      output.SubscriptionDefinitionVersionArn;
  }
  return contents;
};

const deserializeAws_restJson1_1LocalDeviceResourceData = (
  output: any,
  context: __SerdeContext
): LocalDeviceResourceData => {
  let contents: any = {
    __type: "LocalDeviceResourceData",
    GroupOwnerSetting: undefined,
    SourcePath: undefined
  };
  if (
    output.GroupOwnerSetting !== undefined &&
    output.GroupOwnerSetting !== null
  ) {
    contents.GroupOwnerSetting = deserializeAws_restJson1_1GroupOwnerSetting(
      output.GroupOwnerSetting,
      context
    );
  }
  if (output.SourcePath !== undefined && output.SourcePath !== null) {
    contents.SourcePath = output.SourcePath;
  }
  return contents;
};

const deserializeAws_restJson1_1LocalVolumeResourceData = (
  output: any,
  context: __SerdeContext
): LocalVolumeResourceData => {
  let contents: any = {
    __type: "LocalVolumeResourceData",
    DestinationPath: undefined,
    GroupOwnerSetting: undefined,
    SourcePath: undefined
  };
  if (output.DestinationPath !== undefined && output.DestinationPath !== null) {
    contents.DestinationPath = output.DestinationPath;
  }
  if (
    output.GroupOwnerSetting !== undefined &&
    output.GroupOwnerSetting !== null
  ) {
    contents.GroupOwnerSetting = deserializeAws_restJson1_1GroupOwnerSetting(
      output.GroupOwnerSetting,
      context
    );
  }
  if (output.SourcePath !== undefined && output.SourcePath !== null) {
    contents.SourcePath = output.SourcePath;
  }
  return contents;
};

const deserializeAws_restJson1_1Logger = (
  output: any,
  context: __SerdeContext
): Logger => {
  let contents: any = {
    __type: "Logger",
    Component: undefined,
    Id: undefined,
    Level: undefined,
    Space: undefined,
    Type: undefined
  };
  if (output.Component !== undefined && output.Component !== null) {
    contents.Component = output.Component;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Level !== undefined && output.Level !== null) {
    contents.Level = output.Level;
  }
  if (output.Space !== undefined && output.Space !== null) {
    contents.Space = output.Space;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_restJson1_1LoggerDefinitionVersion = (
  output: any,
  context: __SerdeContext
): LoggerDefinitionVersion => {
  let contents: any = {
    __type: "LoggerDefinitionVersion",
    Loggers: undefined
  };
  if (output.Loggers !== undefined && output.Loggers !== null) {
    contents.Loggers = deserializeAws_restJson1_1__listOfLogger(
      output.Loggers,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Resource = (
  output: any,
  context: __SerdeContext
): Resource => {
  let contents: any = {
    __type: "Resource",
    Id: undefined,
    Name: undefined,
    ResourceDataContainer: undefined
  };
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.ResourceDataContainer !== undefined &&
    output.ResourceDataContainer !== null
  ) {
    contents.ResourceDataContainer = deserializeAws_restJson1_1ResourceDataContainer(
      output.ResourceDataContainer,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceAccessPolicy = (
  output: any,
  context: __SerdeContext
): ResourceAccessPolicy => {
  let contents: any = {
    __type: "ResourceAccessPolicy",
    Permission: undefined,
    ResourceId: undefined
  };
  if (output.Permission !== undefined && output.Permission !== null) {
    contents.Permission = output.Permission;
  }
  if (output.ResourceId !== undefined && output.ResourceId !== null) {
    contents.ResourceId = output.ResourceId;
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceDataContainer = (
  output: any,
  context: __SerdeContext
): ResourceDataContainer => {
  let contents: any = {
    __type: "ResourceDataContainer",
    LocalDeviceResourceData: undefined,
    LocalVolumeResourceData: undefined,
    S3MachineLearningModelResourceData: undefined,
    SageMakerMachineLearningModelResourceData: undefined,
    SecretsManagerSecretResourceData: undefined
  };
  if (
    output.LocalDeviceResourceData !== undefined &&
    output.LocalDeviceResourceData !== null
  ) {
    contents.LocalDeviceResourceData = deserializeAws_restJson1_1LocalDeviceResourceData(
      output.LocalDeviceResourceData,
      context
    );
  }
  if (
    output.LocalVolumeResourceData !== undefined &&
    output.LocalVolumeResourceData !== null
  ) {
    contents.LocalVolumeResourceData = deserializeAws_restJson1_1LocalVolumeResourceData(
      output.LocalVolumeResourceData,
      context
    );
  }
  if (
    output.S3MachineLearningModelResourceData !== undefined &&
    output.S3MachineLearningModelResourceData !== null
  ) {
    contents.S3MachineLearningModelResourceData = deserializeAws_restJson1_1S3MachineLearningModelResourceData(
      output.S3MachineLearningModelResourceData,
      context
    );
  }
  if (
    output.SageMakerMachineLearningModelResourceData !== undefined &&
    output.SageMakerMachineLearningModelResourceData !== null
  ) {
    contents.SageMakerMachineLearningModelResourceData = deserializeAws_restJson1_1SageMakerMachineLearningModelResourceData(
      output.SageMakerMachineLearningModelResourceData,
      context
    );
  }
  if (
    output.SecretsManagerSecretResourceData !== undefined &&
    output.SecretsManagerSecretResourceData !== null
  ) {
    contents.SecretsManagerSecretResourceData = deserializeAws_restJson1_1SecretsManagerSecretResourceData(
      output.SecretsManagerSecretResourceData,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceDefinitionVersion = (
  output: any,
  context: __SerdeContext
): ResourceDefinitionVersion => {
  let contents: any = {
    __type: "ResourceDefinitionVersion",
    Resources: undefined
  };
  if (output.Resources !== undefined && output.Resources !== null) {
    contents.Resources = deserializeAws_restJson1_1__listOfResource(
      output.Resources,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceDownloadOwnerSetting = (
  output: any,
  context: __SerdeContext
): ResourceDownloadOwnerSetting => {
  let contents: any = {
    __type: "ResourceDownloadOwnerSetting",
    GroupOwner: undefined,
    GroupPermission: undefined
  };
  if (output.GroupOwner !== undefined && output.GroupOwner !== null) {
    contents.GroupOwner = output.GroupOwner;
  }
  if (output.GroupPermission !== undefined && output.GroupPermission !== null) {
    contents.GroupPermission = output.GroupPermission;
  }
  return contents;
};

const deserializeAws_restJson1_1S3MachineLearningModelResourceData = (
  output: any,
  context: __SerdeContext
): S3MachineLearningModelResourceData => {
  let contents: any = {
    __type: "S3MachineLearningModelResourceData",
    DestinationPath: undefined,
    OwnerSetting: undefined,
    S3Uri: undefined
  };
  if (output.DestinationPath !== undefined && output.DestinationPath !== null) {
    contents.DestinationPath = output.DestinationPath;
  }
  if (output.OwnerSetting !== undefined && output.OwnerSetting !== null) {
    contents.OwnerSetting = deserializeAws_restJson1_1ResourceDownloadOwnerSetting(
      output.OwnerSetting,
      context
    );
  }
  if (output.S3Uri !== undefined && output.S3Uri !== null) {
    contents.S3Uri = output.S3Uri;
  }
  return contents;
};

const deserializeAws_restJson1_1SageMakerMachineLearningModelResourceData = (
  output: any,
  context: __SerdeContext
): SageMakerMachineLearningModelResourceData => {
  let contents: any = {
    __type: "SageMakerMachineLearningModelResourceData",
    DestinationPath: undefined,
    OwnerSetting: undefined,
    SageMakerJobArn: undefined
  };
  if (output.DestinationPath !== undefined && output.DestinationPath !== null) {
    contents.DestinationPath = output.DestinationPath;
  }
  if (output.OwnerSetting !== undefined && output.OwnerSetting !== null) {
    contents.OwnerSetting = deserializeAws_restJson1_1ResourceDownloadOwnerSetting(
      output.OwnerSetting,
      context
    );
  }
  if (output.SageMakerJobArn !== undefined && output.SageMakerJobArn !== null) {
    contents.SageMakerJobArn = output.SageMakerJobArn;
  }
  return contents;
};

const deserializeAws_restJson1_1SecretsManagerSecretResourceData = (
  output: any,
  context: __SerdeContext
): SecretsManagerSecretResourceData => {
  let contents: any = {
    __type: "SecretsManagerSecretResourceData",
    ARN: undefined,
    AdditionalStagingLabelsToDownload: undefined
  };
  if (output.ARN !== undefined && output.ARN !== null) {
    contents.ARN = output.ARN;
  }
  if (
    output.AdditionalStagingLabelsToDownload !== undefined &&
    output.AdditionalStagingLabelsToDownload !== null
  ) {
    contents.AdditionalStagingLabelsToDownload = deserializeAws_restJson1_1__listOf__string(
      output.AdditionalStagingLabelsToDownload,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Subscription = (
  output: any,
  context: __SerdeContext
): Subscription => {
  let contents: any = {
    __type: "Subscription",
    Id: undefined,
    Source: undefined,
    Subject: undefined,
    Target: undefined
  };
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Source !== undefined && output.Source !== null) {
    contents.Source = output.Source;
  }
  if (output.Subject !== undefined && output.Subject !== null) {
    contents.Subject = output.Subject;
  }
  if (output.Target !== undefined && output.Target !== null) {
    contents.Target = output.Target;
  }
  return contents;
};

const deserializeAws_restJson1_1SubscriptionDefinitionVersion = (
  output: any,
  context: __SerdeContext
): SubscriptionDefinitionVersion => {
  let contents: any = {
    __type: "SubscriptionDefinitionVersion",
    Subscriptions: undefined
  };
  if (output.Subscriptions !== undefined && output.Subscriptions !== null) {
    contents.Subscriptions = deserializeAws_restJson1_1__listOfSubscription(
      output.Subscriptions,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Tags = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1VersionInformation = (
  output: any,
  context: __SerdeContext
): VersionInformation => {
  let contents: any = {
    __type: "VersionInformation",
    Arn: undefined,
    CreationTimestamp: undefined,
    Id: undefined,
    Version: undefined
  };
  if (output.Arn !== undefined && output.Arn !== null) {
    contents.Arn = output.Arn;
  }
  if (
    output.CreationTimestamp !== undefined &&
    output.CreationTimestamp !== null
  ) {
    contents.CreationTimestamp = output.CreationTimestamp;
  }
  if (output.Id !== undefined && output.Id !== null) {
    contents.Id = output.Id;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_restJson1_1__listOfConnectivityInfo = (
  output: any,
  context: __SerdeContext
): Array<ConnectivityInfo> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ConnectivityInfo(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfConnector = (
  output: any,
  context: __SerdeContext
): Array<Connector> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Connector(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfCore = (
  output: any,
  context: __SerdeContext
): Array<Core> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Core(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfDefinitionInformation = (
  output: any,
  context: __SerdeContext
): Array<DefinitionInformation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DefinitionInformation(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfDevice = (
  output: any,
  context: __SerdeContext
): Array<Device> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Device(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfFunction = (
  output: any,
  context: __SerdeContext
): Array<Function> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Function(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfGroupCertificateAuthorityProperties = (
  output: any,
  context: __SerdeContext
): Array<GroupCertificateAuthorityProperties> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1GroupCertificateAuthorityProperties(
      entry,
      context
    )
  );
};

const deserializeAws_restJson1_1__listOfGroupInformation = (
  output: any,
  context: __SerdeContext
): Array<GroupInformation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1GroupInformation(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfLogger = (
  output: any,
  context: __SerdeContext
): Array<Logger> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Logger(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfResource = (
  output: any,
  context: __SerdeContext
): Array<Resource> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Resource(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfResourceAccessPolicy = (
  output: any,
  context: __SerdeContext
): Array<ResourceAccessPolicy> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ResourceAccessPolicy(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfSubscription = (
  output: any,
  context: __SerdeContext
): Array<Subscription> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Subscription(entry, context)
  );
};

const deserializeAws_restJson1_1__listOfVersionInformation = (
  output: any,
  context: __SerdeContext
): Array<VersionInformation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1VersionInformation(entry, context)
  );
};

const deserializeAws_restJson1_1__listOf__string = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1__mapOf__string = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
