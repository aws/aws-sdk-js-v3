// smithy-typescript generated code
import { ExceptionOptionType as __ExceptionOptionType, SENSITIVE_STRING } from "@smithy/smithy-client";

import { PaymentCryptographyDataServiceException as __BaseException } from "./PaymentCryptographyDataServiceException";

/**
 * <p>You do not have sufficient access to perform this action.</p>
 * @public
 */
export class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException" = "AccessDeniedException";
  readonly $fault: "client" = "client";
  Message?: string | undefined;
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>) {
    super({
      name: "AccessDeniedException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, AccessDeniedException.prototype);
    this.Message = opts.Message;
  }
}

/**
 * <p>The parameter values of the current PIN to be changed on the EMV chip card.</p>
 * @public
 */
export interface CurrentPinAttributes {
  /**
   * <p>The <code>keyArn</code> of the current PIN PEK.</p>
   * @public
   */
  CurrentPinPekIdentifier: string | undefined;

  /**
   * <p>The encrypted pinblock of the current pin stored on the chip card.</p>
   * @public
   */
  CurrentEncryptedPinBlock: string | undefined;
}

/**
 * @public
 * @enum
 */
export const MajorKeyDerivationMode = {
  EMV_OPTION_A: "EMV_OPTION_A",
  EMV_OPTION_B: "EMV_OPTION_B",
} as const;

/**
 * @public
 */
export type MajorKeyDerivationMode = (typeof MajorKeyDerivationMode)[keyof typeof MajorKeyDerivationMode];

/**
 * <p>Parameters to derive the confidentiality and integrity keys for a payment card using Amex derivation method.</p>
 * @public
 */
export interface AmexAttributes {
  /**
   * <p>The method to use when deriving the master key for a payment card using Amex derivation.</p>
   * @public
   */
  MajorKeyDerivationMode: MajorKeyDerivationMode | undefined;

  /**
   * <p>The Primary Account Number (PAN) of the cardholder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN). Typically 00 is used, if no value is provided by the terminal.</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The transaction counter of the current transaction that is provided by the terminal during transaction processing.</p>
   * @public
   */
  ApplicationTransactionCounter: string | undefined;

  /**
   * <p>The <code>keyArn</code> of the issuer master key for cryptogram (IMK-AC) for the payment card.</p>
   * @public
   */
  AuthorizationRequestKeyIdentifier: string | undefined;

  /**
   * <p>The encrypted pinblock of the old pin stored on the chip card.</p>
   * @public
   */
  CurrentPinAttributes?: CurrentPinAttributes | undefined;
}

/**
 * <p>Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.</p>
 * @public
 */
export interface AmexCardSecurityCodeVersion1 {
  /**
   * <p>The expiry date of a payment card.</p>
   * @public
   */
  CardExpiryDate: string | undefined;
}

/**
 * <p>Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.</p>
 * @public
 */
export interface AmexCardSecurityCodeVersion2 {
  /**
   * <p>The expiry date of a payment card.</p>
   * @public
   */
  CardExpiryDate: string | undefined;

  /**
   * <p>The service code of the AMEX payment card. This is different from the Card Security Code (CSC).</p>
   * @public
   */
  ServiceCode: string | undefined;
}

/**
 * @public
 * @enum
 */
export const PaddingType = {
  OAEP_SHA1: "OAEP_SHA1",
  OAEP_SHA256: "OAEP_SHA256",
  OAEP_SHA512: "OAEP_SHA512",
  PKCS1: "PKCS1",
} as const;

/**
 * @public
 */
export type PaddingType = (typeof PaddingType)[keyof typeof PaddingType];

/**
 * <p>Parameters for plaintext encryption using asymmetric keys.</p>
 * @public
 */
export interface AsymmetricEncryptionAttributes {
  /**
   * <p>The padding to be included with the data.</p>
   * @public
   */
  PaddingType?: PaddingType | undefined;
}

/**
 * <p>Card data parameters that are required to generate a cardholder verification value for the payment card.</p>
 * @public
 */
export interface CardHolderVerificationValue {
  /**
   * <p>A random number generated by the issuer.</p>
   * @public
   */
  UnpredictableNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The transaction counter value that comes from a point of sale terminal.</p>
   * @public
   */
  ApplicationTransactionCounter: string | undefined;
}

/**
 * <p>Card data parameters that are required to verify CVV (Card Verification Value) for the payment card.</p>
 * @public
 */
export interface CardVerificationValue1 {
  /**
   * <p>The expiry date of a payment card.</p>
   * @public
   */
  CardExpiryDate: string | undefined;

  /**
   * <p>The service code of the payment card. This is different from Card Security Code (CSC).</p>
   * @public
   */
  ServiceCode: string | undefined;
}

/**
 * <p>Card data parameters that are required to verify Card Verification Value (CVV2) for the payment card.</p>
 * @public
 */
export interface CardVerificationValue2 {
  /**
   * <p>The expiry date of a payment card.</p>
   * @public
   */
  CardExpiryDate: string | undefined;
}

/**
 * <p>Parameters that are required to generate or verify Dynamic Card Verification Value (dCVV).</p>
 * @public
 */
export interface DynamicCardVerificationCode {
  /**
   * <p>A random number generated by the issuer.</p>
   * @public
   */
  UnpredictableNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The transaction counter value that comes from the terminal.</p>
   * @public
   */
  ApplicationTransactionCounter: string | undefined;

  /**
   * <p>The data on the two tracks of magnetic cards used for financial transactions. This includes the cardholder name, PAN, expiration date, bank ID (BIN) and several other numbers the issuing bank uses to validate the data received.</p>
   * @public
   */
  TrackData: string | undefined;
}

/**
 * <p>Parameters that are required to generate or verify Dynamic Card Verification Value (dCVV).</p>
 * @public
 */
export interface DynamicCardVerificationValue {
  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The expiry date of a payment card.</p>
   * @public
   */
  CardExpiryDate: string | undefined;

  /**
   * <p>The service code of the payment card. This is different from Card Security Code (CSC).</p>
   * @public
   */
  ServiceCode: string | undefined;

  /**
   * <p>The transaction counter value that comes from the terminal.</p>
   * @public
   */
  ApplicationTransactionCounter: string | undefined;
}

/**
 * <p>Card data parameters that are required to generate Card Verification Values (CVV/CVV2), Dynamic Card Verification Values (dCVV/dCVV2), or Card Security Codes (CSC).</p>
 * @public
 */
export type CardGenerationAttributes =
  | CardGenerationAttributes.AmexCardSecurityCodeVersion1Member
  | CardGenerationAttributes.AmexCardSecurityCodeVersion2Member
  | CardGenerationAttributes.CardHolderVerificationValueMember
  | CardGenerationAttributes.CardVerificationValue1Member
  | CardGenerationAttributes.CardVerificationValue2Member
  | CardGenerationAttributes.DynamicCardVerificationCodeMember
  | CardGenerationAttributes.DynamicCardVerificationValueMember
  | CardGenerationAttributes.$UnknownMember;

/**
 * @public
 */
export namespace CardGenerationAttributes {
  /**
   * <p>Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.</p>
   * @public
   */
  export interface AmexCardSecurityCodeVersion1Member {
    AmexCardSecurityCodeVersion1: AmexCardSecurityCodeVersion1;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.</p>
   * @public
   */
  export interface AmexCardSecurityCodeVersion2Member {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2: AmexCardSecurityCodeVersion2;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to generate Card Verification Value (CVV) for the payment card.</p>
   * @public
   */
  export interface CardVerificationValue1Member {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1: CardVerificationValue1;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to generate Card Verification Value (CVV2) for the payment card.</p>
   * @public
   */
  export interface CardVerificationValue2Member {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2: CardVerificationValue2;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to generate a cardholder verification value for the payment card.</p>
   * @public
   */
  export interface CardHolderVerificationValueMember {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue: CardHolderVerificationValue;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to generate CDynamic Card Verification Code (dCVC) for the payment card.</p>
   * @public
   */
  export interface DynamicCardVerificationCodeMember {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode: DynamicCardVerificationCode;
    DynamicCardVerificationValue?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to generate CDynamic Card Verification Value (dCVV) for the payment card.</p>
   * @public
   */
  export interface DynamicCardVerificationValueMember {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue: DynamicCardVerificationValue;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    AmexCardSecurityCodeVersion1: (value: AmexCardSecurityCodeVersion1) => T;
    AmexCardSecurityCodeVersion2: (value: AmexCardSecurityCodeVersion2) => T;
    CardVerificationValue1: (value: CardVerificationValue1) => T;
    CardVerificationValue2: (value: CardVerificationValue2) => T;
    CardHolderVerificationValue: (value: CardHolderVerificationValue) => T;
    DynamicCardVerificationCode: (value: DynamicCardVerificationCode) => T;
    DynamicCardVerificationValue: (value: DynamicCardVerificationValue) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: CardGenerationAttributes, visitor: Visitor<T>): T => {
    if (value.AmexCardSecurityCodeVersion1 !== undefined)
      return visitor.AmexCardSecurityCodeVersion1(value.AmexCardSecurityCodeVersion1);
    if (value.AmexCardSecurityCodeVersion2 !== undefined)
      return visitor.AmexCardSecurityCodeVersion2(value.AmexCardSecurityCodeVersion2);
    if (value.CardVerificationValue1 !== undefined) return visitor.CardVerificationValue1(value.CardVerificationValue1);
    if (value.CardVerificationValue2 !== undefined) return visitor.CardVerificationValue2(value.CardVerificationValue2);
    if (value.CardHolderVerificationValue !== undefined)
      return visitor.CardHolderVerificationValue(value.CardHolderVerificationValue);
    if (value.DynamicCardVerificationCode !== undefined)
      return visitor.DynamicCardVerificationCode(value.DynamicCardVerificationCode);
    if (value.DynamicCardVerificationValue !== undefined)
      return visitor.DynamicCardVerificationValue(value.DynamicCardVerificationValue);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * <p>Parameters that are required to generate or verify dCVC (Dynamic Card Verification Code).</p>
 * @public
 */
export interface DiscoverDynamicCardVerificationCode {
  /**
   * <p>The expiry date of a payment card.</p>
   * @public
   */
  CardExpiryDate: string | undefined;

  /**
   * <p>A random number that is generated by the issuer.</p>
   * @public
   */
  UnpredictableNumber: string | undefined;

  /**
   * <p>The transaction counter value that comes from the terminal.</p>
   * @public
   */
  ApplicationTransactionCounter: string | undefined;
}

/**
 * <p>Card data parameters that are requried to verify Card Verification Values (CVV/CVV2), Dynamic Card Verification Values (dCVV/dCVV2), or Card Security Codes (CSC).</p>
 * @public
 */
export type CardVerificationAttributes =
  | CardVerificationAttributes.AmexCardSecurityCodeVersion1Member
  | CardVerificationAttributes.AmexCardSecurityCodeVersion2Member
  | CardVerificationAttributes.CardHolderVerificationValueMember
  | CardVerificationAttributes.CardVerificationValue1Member
  | CardVerificationAttributes.CardVerificationValue2Member
  | CardVerificationAttributes.DiscoverDynamicCardVerificationCodeMember
  | CardVerificationAttributes.DynamicCardVerificationCodeMember
  | CardVerificationAttributes.DynamicCardVerificationValueMember
  | CardVerificationAttributes.$UnknownMember;

/**
 * @public
 */
export namespace CardVerificationAttributes {
  /**
   * <p>Card data parameters that are required to generate a Card Security Code (CSC2) for an AMEX payment card.</p>
   * @public
   */
  export interface AmexCardSecurityCodeVersion1Member {
    AmexCardSecurityCodeVersion1: AmexCardSecurityCodeVersion1;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    DiscoverDynamicCardVerificationCode?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to verify a Card Security Code (CSC2) for an AMEX payment card.</p>
   * @public
   */
  export interface AmexCardSecurityCodeVersion2Member {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2: AmexCardSecurityCodeVersion2;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    DiscoverDynamicCardVerificationCode?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to verify Card Verification Value (CVV) for the payment card.</p>
   * @public
   */
  export interface CardVerificationValue1Member {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1: CardVerificationValue1;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    DiscoverDynamicCardVerificationCode?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to verify Card Verification Value (CVV2) for the payment card.</p>
   * @public
   */
  export interface CardVerificationValue2Member {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2: CardVerificationValue2;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    DiscoverDynamicCardVerificationCode?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to verify a cardholder verification value for the payment card.</p>
   * @public
   */
  export interface CardHolderVerificationValueMember {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue: CardHolderVerificationValue;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    DiscoverDynamicCardVerificationCode?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to verify CDynamic Card Verification Code (dCVC) for the payment card.</p>
   * @public
   */
  export interface DynamicCardVerificationCodeMember {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode: DynamicCardVerificationCode;
    DynamicCardVerificationValue?: never;
    DiscoverDynamicCardVerificationCode?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to verify CDynamic Card Verification Value (dCVV) for the payment card.</p>
   * @public
   */
  export interface DynamicCardVerificationValueMember {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue: DynamicCardVerificationValue;
    DiscoverDynamicCardVerificationCode?: never;
    $unknown?: never;
  }

  /**
   * <p>Card data parameters that are required to verify CDynamic Card Verification Code (dCVC) for the payment card.</p>
   * @public
   */
  export interface DiscoverDynamicCardVerificationCodeMember {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    DiscoverDynamicCardVerificationCode: DiscoverDynamicCardVerificationCode;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    AmexCardSecurityCodeVersion1?: never;
    AmexCardSecurityCodeVersion2?: never;
    CardVerificationValue1?: never;
    CardVerificationValue2?: never;
    CardHolderVerificationValue?: never;
    DynamicCardVerificationCode?: never;
    DynamicCardVerificationValue?: never;
    DiscoverDynamicCardVerificationCode?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    AmexCardSecurityCodeVersion1: (value: AmexCardSecurityCodeVersion1) => T;
    AmexCardSecurityCodeVersion2: (value: AmexCardSecurityCodeVersion2) => T;
    CardVerificationValue1: (value: CardVerificationValue1) => T;
    CardVerificationValue2: (value: CardVerificationValue2) => T;
    CardHolderVerificationValue: (value: CardHolderVerificationValue) => T;
    DynamicCardVerificationCode: (value: DynamicCardVerificationCode) => T;
    DynamicCardVerificationValue: (value: DynamicCardVerificationValue) => T;
    DiscoverDynamicCardVerificationCode: (value: DiscoverDynamicCardVerificationCode) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: CardVerificationAttributes, visitor: Visitor<T>): T => {
    if (value.AmexCardSecurityCodeVersion1 !== undefined)
      return visitor.AmexCardSecurityCodeVersion1(value.AmexCardSecurityCodeVersion1);
    if (value.AmexCardSecurityCodeVersion2 !== undefined)
      return visitor.AmexCardSecurityCodeVersion2(value.AmexCardSecurityCodeVersion2);
    if (value.CardVerificationValue1 !== undefined) return visitor.CardVerificationValue1(value.CardVerificationValue1);
    if (value.CardVerificationValue2 !== undefined) return visitor.CardVerificationValue2(value.CardVerificationValue2);
    if (value.CardHolderVerificationValue !== undefined)
      return visitor.CardHolderVerificationValue(value.CardHolderVerificationValue);
    if (value.DynamicCardVerificationCode !== undefined)
      return visitor.DynamicCardVerificationCode(value.DynamicCardVerificationCode);
    if (value.DynamicCardVerificationValue !== undefined)
      return visitor.DynamicCardVerificationValue(value.DynamicCardVerificationValue);
    if (value.DiscoverDynamicCardVerificationCode !== undefined)
      return visitor.DiscoverDynamicCardVerificationCode(value.DiscoverDynamicCardVerificationCode);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * <p>Parameters that are required for ARPC response generation using method1 after ARQC verification is successful.</p>
 * @public
 */
export interface CryptogramVerificationArpcMethod1 {
  /**
   * <p>The auth code used to calculate APRC after ARQC verification is successful. This is the same auth code used for ARQC generation outside of Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  AuthResponseCode: string | undefined;
}

/**
 * <p>Parameters that are required for ARPC response generation using method2 after ARQC verification is successful.</p>
 * @public
 */
export interface CryptogramVerificationArpcMethod2 {
  /**
   * <p>The data indicating whether the issuer approves or declines an online transaction using an EMV chip card.</p>
   * @public
   */
  CardStatusUpdate: string | undefined;

  /**
   * <p>The proprietary authentication data used by issuer for communication during online transaction using an EMV chip card.</p>
   * @public
   */
  ProprietaryAuthenticationData?: string | undefined;
}

/**
 * <p>Parameters that are required for Authorization Response Cryptogram (ARPC) generation after Authorization Request Cryptogram (ARQC) verification is successful.</p>
 * @public
 */
export type CryptogramAuthResponse =
  | CryptogramAuthResponse.ArpcMethod1Member
  | CryptogramAuthResponse.ArpcMethod2Member
  | CryptogramAuthResponse.$UnknownMember;

/**
 * @public
 */
export namespace CryptogramAuthResponse {
  /**
   * <p>Parameters that are required for ARPC response generation using method1 after ARQC verification is successful.</p>
   * @public
   */
  export interface ArpcMethod1Member {
    ArpcMethod1: CryptogramVerificationArpcMethod1;
    ArpcMethod2?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required for ARPC response generation using method2 after ARQC verification is successful.</p>
   * @public
   */
  export interface ArpcMethod2Member {
    ArpcMethod1?: never;
    ArpcMethod2: CryptogramVerificationArpcMethod2;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    ArpcMethod1?: never;
    ArpcMethod2?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    ArpcMethod1: (value: CryptogramVerificationArpcMethod1) => T;
    ArpcMethod2: (value: CryptogramVerificationArpcMethod2) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: CryptogramAuthResponse, visitor: Visitor<T>): T => {
    if (value.ArpcMethod1 !== undefined) return visitor.ArpcMethod1(value.ArpcMethod1);
    if (value.ArpcMethod2 !== undefined) return visitor.ArpcMethod2(value.ArpcMethod2);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * @public
 * @enum
 */
export const DukptDerivationType = {
  AES_128: "AES_128",
  AES_192: "AES_192",
  AES_256: "AES_256",
  TDES_2KEY: "TDES_2KEY",
  TDES_3KEY: "TDES_3KEY",
} as const;

/**
 * @public
 */
export type DukptDerivationType = (typeof DukptDerivationType)[keyof typeof DukptDerivationType];

/**
 * @public
 * @enum
 */
export const DukptKeyVariant = {
  BIDIRECTIONAL: "BIDIRECTIONAL",
  REQUEST: "REQUEST",
  RESPONSE: "RESPONSE",
} as const;

/**
 * @public
 */
export type DukptKeyVariant = (typeof DukptKeyVariant)[keyof typeof DukptKeyVariant];

/**
 * @public
 * @enum
 */
export const DukptEncryptionMode = {
  CBC: "CBC",
  ECB: "ECB",
} as const;

/**
 * @public
 */
export type DukptEncryptionMode = (typeof DukptEncryptionMode)[keyof typeof DukptEncryptionMode];

/**
 * <p>Parameters that are required to encrypt plaintext data using DUKPT.</p>
 * @public
 */
export interface DukptEncryptionAttributes {
  /**
   * <p>The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.</p>
   * @public
   */
  KeySerialNumber: string | undefined;

  /**
   * <p>The block cipher method to use for encryption.</p>
   *          <p>The default is CBC.</p>
   * @public
   */
  Mode?: DukptEncryptionMode | undefined;

  /**
   * <p>The key type encrypted using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use <code>AES_128</code> as a derivation type for a BDK of <code>AES_128</code> or <code>TDES_2KEY</code>
   *          </p>
   * @public
   */
  DukptKeyDerivationType?: DukptDerivationType | undefined;

  /**
   * <p>The type of use of DUKPT, which can be incoming data decryption, outgoing data encryption, or both.</p>
   * @public
   */
  DukptKeyVariant?: DukptKeyVariant | undefined;

  /**
   * <p>An input used to provide the intial state. If no value is provided, Amazon Web Services Payment Cryptography defaults it to zero.</p>
   * @public
   */
  InitializationVector?: string | undefined;
}

/**
 * @public
 * @enum
 */
export const EmvMajorKeyDerivationMode = {
  EMV_OPTION_A: "EMV_OPTION_A",
  EMV_OPTION_B: "EMV_OPTION_B",
} as const;

/**
 * @public
 */
export type EmvMajorKeyDerivationMode = (typeof EmvMajorKeyDerivationMode)[keyof typeof EmvMajorKeyDerivationMode];

/**
 * @public
 * @enum
 */
export const EmvEncryptionMode = {
  CBC: "CBC",
  ECB: "ECB",
} as const;

/**
 * @public
 */
export type EmvEncryptionMode = (typeof EmvEncryptionMode)[keyof typeof EmvEncryptionMode];

/**
 * <p>Parameters for plaintext encryption using EMV keys.</p>
 * @public
 */
export interface EmvEncryptionAttributes {
  /**
   * <p>The EMV derivation mode to use for ICC master key derivation as per EMV version 4.3 book 2.</p>
   * @public
   */
  MajorKeyDerivationMode: EmvMajorKeyDerivationMode | undefined;

  /**
   * <p>The Primary Account Number (PAN), a unique identifier for a payment credit or debit card and associates the card to a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN). Typically 00 is used, if no value is provided by the terminal.</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The derivation value used to derive the ICC session key. It is typically the application transaction counter value padded with zeros or previous ARQC value padded with zeros as per EMV version 4.3 book 2.</p>
   * @public
   */
  SessionDerivationData: string | undefined;

  /**
   * <p>The block cipher method to use for encryption.</p>
   * @public
   */
  Mode?: EmvEncryptionMode | undefined;

  /**
   * <p>An input used to provide the intial state. If no value is provided, Amazon Web Services Payment Cryptography defaults it to zero.</p>
   * @public
   */
  InitializationVector?: string | undefined;
}

/**
 * @public
 * @enum
 */
export const EncryptionMode = {
  CBC: "CBC",
  CFB: "CFB",
  CFB1: "CFB1",
  CFB128: "CFB128",
  CFB64: "CFB64",
  CFB8: "CFB8",
  ECB: "ECB",
  OFB: "OFB",
} as const;

/**
 * @public
 */
export type EncryptionMode = (typeof EncryptionMode)[keyof typeof EncryptionMode];

/**
 * <p>Parameters requried to encrypt plaintext data using symmetric keys.</p>
 * @public
 */
export interface SymmetricEncryptionAttributes {
  /**
   * <p>The block cipher method to use for encryption.</p>
   * @public
   */
  Mode: EncryptionMode | undefined;

  /**
   * <p>An input used to provide the intial state. If no value is provided, Amazon Web Services Payment Cryptography defaults it to zero.</p>
   * @public
   */
  InitializationVector?: string | undefined;

  /**
   * <p>The padding to be included with the data.</p>
   * @public
   */
  PaddingType?: PaddingType | undefined;
}

/**
 * <p>Parameters that are required to perform encryption and decryption operations.</p>
 * @public
 */
export type EncryptionDecryptionAttributes =
  | EncryptionDecryptionAttributes.AsymmetricMember
  | EncryptionDecryptionAttributes.DukptMember
  | EncryptionDecryptionAttributes.EmvMember
  | EncryptionDecryptionAttributes.SymmetricMember
  | EncryptionDecryptionAttributes.$UnknownMember;

/**
 * @public
 */
export namespace EncryptionDecryptionAttributes {
  /**
   * <p>Parameters that are required to perform encryption and decryption using symmetric keys.</p>
   * @public
   */
  export interface SymmetricMember {
    Symmetric: SymmetricEncryptionAttributes;
    Asymmetric?: never;
    Dukpt?: never;
    Emv?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters for plaintext encryption using asymmetric keys.</p>
   * @public
   */
  export interface AsymmetricMember {
    Symmetric?: never;
    Asymmetric: AsymmetricEncryptionAttributes;
    Dukpt?: never;
    Emv?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required to encrypt plaintext data using DUKPT.</p>
   * @public
   */
  export interface DukptMember {
    Symmetric?: never;
    Asymmetric?: never;
    Dukpt: DukptEncryptionAttributes;
    Emv?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters for plaintext encryption using EMV keys.</p>
   * @public
   */
  export interface EmvMember {
    Symmetric?: never;
    Asymmetric?: never;
    Dukpt?: never;
    Emv: EmvEncryptionAttributes;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    Symmetric?: never;
    Asymmetric?: never;
    Dukpt?: never;
    Emv?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    Symmetric: (value: SymmetricEncryptionAttributes) => T;
    Asymmetric: (value: AsymmetricEncryptionAttributes) => T;
    Dukpt: (value: DukptEncryptionAttributes) => T;
    Emv: (value: EmvEncryptionAttributes) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: EncryptionDecryptionAttributes, visitor: Visitor<T>): T => {
    if (value.Symmetric !== undefined) return visitor.Symmetric(value.Symmetric);
    if (value.Asymmetric !== undefined) return visitor.Asymmetric(value.Asymmetric);
    if (value.Dukpt !== undefined) return visitor.Dukpt(value.Dukpt);
    if (value.Emv !== undefined) return visitor.Emv(value.Emv);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * @public
 * @enum
 */
export const KeyCheckValueAlgorithm = {
  ANSI_X9_24: "ANSI_X9_24",
  CMAC: "CMAC",
} as const;

/**
 * @public
 */
export type KeyCheckValueAlgorithm = (typeof KeyCheckValueAlgorithm)[keyof typeof KeyCheckValueAlgorithm];

/**
 * @public
 * @enum
 */
export const SymmetricKeyAlgorithm = {
  AES_128: "AES_128",
  AES_192: "AES_192",
  AES_256: "AES_256",
  TDES_2KEY: "TDES_2KEY",
  TDES_3KEY: "TDES_3KEY",
} as const;

/**
 * @public
 */
export type SymmetricKeyAlgorithm = (typeof SymmetricKeyAlgorithm)[keyof typeof SymmetricKeyAlgorithm];

/**
 * @public
 * @enum
 */
export const KeyDerivationFunction = {
  ANSI_X963: "ANSI_X963",
  NIST_SP800: "NIST_SP800",
} as const;

/**
 * @public
 */
export type KeyDerivationFunction = (typeof KeyDerivationFunction)[keyof typeof KeyDerivationFunction];

/**
 * @public
 * @enum
 */
export const KeyDerivationHashAlgorithm = {
  SHA_256: "SHA_256",
  SHA_384: "SHA_384",
  SHA_512: "SHA_512",
} as const;

/**
 * @public
 */
export type KeyDerivationHashAlgorithm = (typeof KeyDerivationHashAlgorithm)[keyof typeof KeyDerivationHashAlgorithm];

/**
 * <p>Parameters required to establish ECDH based key exchange.</p>
 * @public
 */
export interface EcdhDerivationAttributes {
  /**
   * <p>The <code>keyArn</code> of the certificate that signed the client's <code>PublicKeyCertificate</code>.</p>
   * @public
   */
  CertificateAuthorityPublicKeyIdentifier: string | undefined;

  /**
   * <p>The client's public key certificate in PEM format (base64 encoded) to use for ECDH key derivation.</p>
   * @public
   */
  PublicKeyCertificate: string | undefined;

  /**
   * <p>The key algorithm of the derived ECDH key.</p>
   * @public
   */
  KeyAlgorithm: SymmetricKeyAlgorithm | undefined;

  /**
   * <p>The key derivation function to use for deriving a key using ECDH.</p>
   * @public
   */
  KeyDerivationFunction: KeyDerivationFunction | undefined;

  /**
   * <p>The hash type to use for deriving a key using ECDH.</p>
   * @public
   */
  KeyDerivationHashAlgorithm: KeyDerivationHashAlgorithm | undefined;

  /**
   * <p>A byte string containing information that binds the ECDH derived key to the two parties involved or to the context of the key.</p>
   *          <p>It may include details like identities of the two parties deriving the key, context of the operation, session IDs, and optionally a nonce. It must not contain zero bytes, and re-using shared information for multiple ECDH key derivations is not recommended.</p>
   * @public
   */
  SharedInformation: string | undefined;
}

/**
 * <p>Parameter information of a WrappedKeyBlock for encryption key exchange.</p>
 * @public
 */
export type WrappedKeyMaterial =
  | WrappedKeyMaterial.DiffieHellmanSymmetricKeyMember
  | WrappedKeyMaterial.Tr31KeyBlockMember
  | WrappedKeyMaterial.$UnknownMember;

/**
 * @public
 */
export namespace WrappedKeyMaterial {
  /**
   * <p>The TR-31 wrapped key block.</p>
   * @public
   */
  export interface Tr31KeyBlockMember {
    Tr31KeyBlock: string;
    DiffieHellmanSymmetricKey?: never;
    $unknown?: never;
  }

  /**
   * <p>The parameter information for deriving a ECDH shared key.</p>
   * @public
   */
  export interface DiffieHellmanSymmetricKeyMember {
    Tr31KeyBlock?: never;
    DiffieHellmanSymmetricKey: EcdhDerivationAttributes;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    Tr31KeyBlock?: never;
    DiffieHellmanSymmetricKey?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    Tr31KeyBlock: (value: string) => T;
    DiffieHellmanSymmetricKey: (value: EcdhDerivationAttributes) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: WrappedKeyMaterial, visitor: Visitor<T>): T => {
    if (value.Tr31KeyBlock !== undefined) return visitor.Tr31KeyBlock(value.Tr31KeyBlock);
    if (value.DiffieHellmanSymmetricKey !== undefined)
      return visitor.DiffieHellmanSymmetricKey(value.DiffieHellmanSymmetricKey);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * <p>Parameter information of a WrappedKeyBlock for encryption key exchange.</p>
 * @public
 */
export interface WrappedKey {
  /**
   * <p>Parameter information of a WrappedKeyBlock for encryption key exchange.</p>
   * @public
   */
  WrappedKeyMaterial: WrappedKeyMaterial | undefined;

  /**
   * <p>The algorithm that Amazon Web Services Payment Cryptography uses to calculate the key check value (KCV). It is used to validate the key integrity.</p>
   *          <p>For TDES keys, the KCV is computed by encrypting 8 bytes, each with value of zero, with the key to be checked and retaining the 3 highest order bytes of the encrypted result. For AES keys, the KCV is computed using a CMAC algorithm where the input data is 16 bytes of zero and retaining the 3 highest order bytes of the encrypted result.</p>
   * @public
   */
  KeyCheckValueAlgorithm?: KeyCheckValueAlgorithm | undefined;
}

/**
 * @public
 */
export interface DecryptDataInput {
  /**
   * <p>The <code>keyARN</code> of the encryption key that Amazon Web Services Payment Cryptography uses for ciphertext decryption.</p>
   *          <p>When a WrappedKeyBlock is provided, this value will be the identifier to the key wrapping key. Otherwise, it is the key identifier used to perform the operation.</p>
   * @public
   */
  KeyIdentifier: string | undefined;

  /**
   * <p>The ciphertext to decrypt.</p>
   * @public
   */
  CipherText: string | undefined;

  /**
   * <p>The encryption key type and attributes for ciphertext decryption.</p>
   * @public
   */
  DecryptionAttributes: EncryptionDecryptionAttributes | undefined;

  /**
   * <p>The WrappedKeyBlock containing the encryption key for ciphertext decryption.</p>
   * @public
   */
  WrappedKey?: WrappedKey | undefined;
}

/**
 * @public
 */
export interface DecryptDataOutput {
  /**
   * <p>The <code>keyARN</code> of the encryption key that Amazon Web Services Payment Cryptography uses for ciphertext decryption.</p>
   * @public
   */
  KeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  KeyCheckValue: string | undefined;

  /**
   * <p>The decrypted plaintext data in hexBinary format.</p>
   * @public
   */
  PlainText: string | undefined;
}

/**
 * <p>The request processing has failed because of an unknown error, exception, or failure.</p>
 * @public
 */
export class InternalServerException extends __BaseException {
  readonly name: "InternalServerException" = "InternalServerException";
  readonly $fault: "server" = "server";
  Message?: string | undefined;
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>) {
    super({
      name: "InternalServerException",
      $fault: "server",
      ...opts,
    });
    Object.setPrototypeOf(this, InternalServerException.prototype);
    this.Message = opts.Message;
  }
}

/**
 * <p>The request was denied due to an invalid resource error.</p>
 * @public
 */
export class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException" = "ResourceNotFoundException";
  readonly $fault: "client" = "client";
  /**
   * <p>The resource that is missing.</p>
   * @public
   */
  ResourceId?: string | undefined;
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    this.ResourceId = opts.ResourceId;
  }
}

/**
 * <p>The request was denied due to request throttling.</p>
 * @public
 */
export class ThrottlingException extends __BaseException {
  readonly name: "ThrottlingException" = "ThrottlingException";
  readonly $fault: "client" = "client";
  Message?: string | undefined;
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>) {
    super({
      name: "ThrottlingException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, ThrottlingException.prototype);
    this.Message = opts.Message;
  }
}

/**
 * <p>The request was denied due to an invalid request error.</p>
 * @public
 */
export interface ValidationExceptionField {
  /**
   * <p>The request was denied due to an invalid request error.</p>
   * @public
   */
  path: string | undefined;

  /**
   * <p>The request was denied due to an invalid request error.</p>
   * @public
   */
  message: string | undefined;
}

/**
 * <p>The request was denied due to an invalid request error.</p>
 * @public
 */
export class ValidationException extends __BaseException {
  readonly name: "ValidationException" = "ValidationException";
  readonly $fault: "client" = "client";
  /**
   * <p>The request was denied due to an invalid request error.</p>
   * @public
   */
  fieldList?: ValidationExceptionField[] | undefined;

  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>) {
    super({
      name: "ValidationException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, ValidationException.prototype);
    this.fieldList = opts.fieldList;
  }
}

/**
 * <p>Parameters to derive the confidentiality and integrity keys for a payment card using EMV2000 deruv.</p>
 * @public
 */
export interface Emv2000Attributes {
  /**
   * <p>The method to use when deriving the master key for the payment card.</p>
   * @public
   */
  MajorKeyDerivationMode: MajorKeyDerivationMode | undefined;

  /**
   * <p>The Primary Account Number (PAN) of the cardholder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN). Typically 00 is used, if no value is provided by the terminal.</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The transaction counter of the current transaction that is provided by the terminal during transaction processing.</p>
   * @public
   */
  ApplicationTransactionCounter: string | undefined;
}

/**
 * @public
 * @enum
 */
export const PinBlockLengthPosition = {
  FRONT_OF_PIN_BLOCK: "FRONT_OF_PIN_BLOCK",
  NONE: "NONE",
} as const;

/**
 * @public
 */
export type PinBlockLengthPosition = (typeof PinBlockLengthPosition)[keyof typeof PinBlockLengthPosition];

/**
 * @public
 * @enum
 */
export const PinBlockPaddingType = {
  ISO_IEC_7816_4: "ISO_IEC_7816_4",
  NO_PADDING: "NO_PADDING",
} as const;

/**
 * @public
 */
export type PinBlockPaddingType = (typeof PinBlockPaddingType)[keyof typeof PinBlockPaddingType];

/**
 * <p>Parameters to derive the confidentiality and integrity keys for an Emv common payment card.</p>
 * @public
 */
export interface EmvCommonAttributes {
  /**
   * <p>The method to use when deriving the master key for the payment card.</p>
   * @public
   */
  MajorKeyDerivationMode: MajorKeyDerivationMode | undefined;

  /**
   * <p>The Primary Account Number (PAN) of the cardholder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN). Typically 00 is used, if no value is provided by the terminal.</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The application cryptogram for the current transaction that is provided by the terminal during transaction processing.</p>
   * @public
   */
  ApplicationCryptogram: string | undefined;

  /**
   * <p>The block cipher method to use for encryption.</p>
   * @public
   */
  Mode: EmvEncryptionMode | undefined;

  /**
   * <p>The padding to be added to the PIN block prior to encryption.</p>
   *          <p>Padding type should be <code>ISO_IEC_7816_4</code>, if <code>PinBlockLengthPosition</code> is set to <code>FRONT_OF_PIN_BLOCK</code>. No padding is required, if <code>PinBlockLengthPosition</code> is set to <code>NONE</code>.</p>
   * @public
   */
  PinBlockPaddingType: PinBlockPaddingType | undefined;

  /**
   * <p>Specifies if PIN block length should be added to front of the pin block. </p>
   *          <p>If value is set to <code>FRONT_OF_PIN_BLOCK</code>, then PIN block padding type should be <code>ISO_IEC_7816_4</code>.</p>
   * @public
   */
  PinBlockLengthPosition: PinBlockLengthPosition | undefined;
}

/**
 * <p>Parameters to derive the confidentiality and integrity keys for a Mastercard payment card.</p>
 * @public
 */
export interface MasterCardAttributes {
  /**
   * <p>The method to use when deriving the master key for the payment card.</p>
   * @public
   */
  MajorKeyDerivationMode: MajorKeyDerivationMode | undefined;

  /**
   * <p>The Primary Account Number (PAN) of the cardholder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN). Typically 00 is used, if no value is provided by the terminal.</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The application cryptogram for the current transaction that is provided by the terminal during transaction processing.</p>
   * @public
   */
  ApplicationCryptogram: string | undefined;
}

/**
 * <p>Parameters to derive the confidentiality and integrity keys for a Visa payment card.</p>
 * @public
 */
export interface VisaAttributes {
  /**
   * <p>The method to use when deriving the master key for the payment card.</p>
   * @public
   */
  MajorKeyDerivationMode: MajorKeyDerivationMode | undefined;

  /**
   * <p>The Primary Account Number (PAN) of the cardholder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN). Typically 00 is used, if no value is provided by the terminal.</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The transaction counter of the current transaction that is provided by the terminal during transaction processing.</p>
   * @public
   */
  ApplicationTransactionCounter: string | undefined;

  /**
   * <p>The <code>keyArn</code> of the issuer master key for cryptogram (IMK-AC) for the payment card.</p>
   * @public
   */
  AuthorizationRequestKeyIdentifier: string | undefined;

  /**
   * <p>The encrypted pinblock of the old pin stored on the chip card.</p>
   * @public
   */
  CurrentPinAttributes?: CurrentPinAttributes | undefined;
}

/**
 * <p>Parameters to derive the payment card specific confidentiality and integrity keys.</p>
 * @public
 */
export type DerivationMethodAttributes =
  | DerivationMethodAttributes.AmexMember
  | DerivationMethodAttributes.Emv2000Member
  | DerivationMethodAttributes.EmvCommonMember
  | DerivationMethodAttributes.MastercardMember
  | DerivationMethodAttributes.VisaMember
  | DerivationMethodAttributes.$UnknownMember;

/**
 * @public
 */
export namespace DerivationMethodAttributes {
  /**
   * <p>Parameters to derive the confidentiality and integrity keys for a payment card using Emv common derivation method.</p>
   * @public
   */
  export interface EmvCommonMember {
    EmvCommon: EmvCommonAttributes;
    Amex?: never;
    Visa?: never;
    Emv2000?: never;
    Mastercard?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters to derive the confidentiality and integrity keys for a payment card using Amex derivation method.</p>
   * @public
   */
  export interface AmexMember {
    EmvCommon?: never;
    Amex: AmexAttributes;
    Visa?: never;
    Emv2000?: never;
    Mastercard?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters to derive the confidentiality and integrity keys for a a payment card using Visa derivation method.</p>
   * @public
   */
  export interface VisaMember {
    EmvCommon?: never;
    Amex?: never;
    Visa: VisaAttributes;
    Emv2000?: never;
    Mastercard?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters to derive the confidentiality and integrity keys for a payment card using Emv2000 derivation method.</p>
   * @public
   */
  export interface Emv2000Member {
    EmvCommon?: never;
    Amex?: never;
    Visa?: never;
    Emv2000: Emv2000Attributes;
    Mastercard?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters to derive the confidentiality and integrity keys for a payment card using Mastercard derivation method.</p>
   * @public
   */
  export interface MastercardMember {
    EmvCommon?: never;
    Amex?: never;
    Visa?: never;
    Emv2000?: never;
    Mastercard: MasterCardAttributes;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    EmvCommon?: never;
    Amex?: never;
    Visa?: never;
    Emv2000?: never;
    Mastercard?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    EmvCommon: (value: EmvCommonAttributes) => T;
    Amex: (value: AmexAttributes) => T;
    Visa: (value: VisaAttributes) => T;
    Emv2000: (value: Emv2000Attributes) => T;
    Mastercard: (value: MasterCardAttributes) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: DerivationMethodAttributes, visitor: Visitor<T>): T => {
    if (value.EmvCommon !== undefined) return visitor.EmvCommon(value.EmvCommon);
    if (value.Amex !== undefined) return visitor.Amex(value.Amex);
    if (value.Visa !== undefined) return visitor.Visa(value.Visa);
    if (value.Emv2000 !== undefined) return visitor.Emv2000(value.Emv2000);
    if (value.Mastercard !== undefined) return visitor.Mastercard(value.Mastercard);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * <p>Parameters that are used for Derived Unique Key Per Transaction (DUKPT) derivation algorithm.</p>
 * @public
 */
export interface DukptAttributes {
  /**
   * <p>The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.</p>
   * @public
   */
  KeySerialNumber: string | undefined;

  /**
   * <p>The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use <code>AES_128</code> as a derivation type for a BDK of <code>AES_128</code> or <code>TDES_2KEY</code>.</p>
   * @public
   */
  DukptDerivationType: DukptDerivationType | undefined;
}

/**
 * <p>Parameters required for encryption or decryption of data using DUKPT.</p>
 * @public
 */
export interface DukptDerivationAttributes {
  /**
   * <p>The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.</p>
   * @public
   */
  KeySerialNumber: string | undefined;

  /**
   * <p>The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use <code>AES_128</code> as a derivation type for a BDK of <code>AES_128</code> or <code>TDES_2KEY</code>
   *          </p>
   * @public
   */
  DukptKeyDerivationType?: DukptDerivationType | undefined;

  /**
   * <p>The type of use of DUKPT, which can be for incoming data decryption, outgoing data encryption, or both.</p>
   * @public
   */
  DukptKeyVariant?: DukptKeyVariant | undefined;
}

/**
 * @public
 */
export interface EncryptDataInput {
  /**
   * <p>The <code>keyARN</code> of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.</p>
   *          <p>When a WrappedKeyBlock is provided, this value will be the identifier to the key wrapping key. Otherwise, it is the key identifier used to perform the operation.</p>
   * @public
   */
  KeyIdentifier: string | undefined;

  /**
   * <p>The plaintext to be encrypted.</p>
   *          <note>
   *             <p>For encryption using asymmetric keys, plaintext data length is constrained by encryption key strength that you define in <code>KeyAlgorithm</code> and padding type that you define in <code>AsymmetricEncryptionAttributes</code>. For more information, see <a href="https://docs.aws.amazon.com/payment-cryptography/latest/userguide/encrypt-data.html">Encrypt data</a> in the <i>Amazon Web Services Payment Cryptography User Guide</i>.</p>
   *          </note>
   * @public
   */
  PlainText: string | undefined;

  /**
   * <p>The encryption key type and attributes for plaintext encryption.</p>
   * @public
   */
  EncryptionAttributes: EncryptionDecryptionAttributes | undefined;

  /**
   * <p>The WrappedKeyBlock containing the encryption key for plaintext encryption.</p>
   * @public
   */
  WrappedKey?: WrappedKey | undefined;
}

/**
 * @public
 */
export interface EncryptDataOutput {
  /**
   * <p>The <code>keyARN</code> of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.</p>
   * @public
   */
  KeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  KeyCheckValue?: string | undefined;

  /**
   * <p>The encrypted ciphertext.</p>
   * @public
   */
  CipherText: string | undefined;
}

/**
 * @public
 */
export interface GenerateCardValidationDataInput {
  /**
   * <p>The <code>keyARN</code> of the CVK encryption key that Amazon Web Services Payment Cryptography uses to generate card data.</p>
   * @public
   */
  KeyIdentifier: string | undefined;

  /**
   * <p>The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>The algorithm for generating CVV or CSC values for the card within Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  GenerationAttributes: CardGenerationAttributes | undefined;

  /**
   * <p>The length of the CVV or CSC to be generated. The default value is 3.</p>
   * @public
   */
  ValidationDataLength?: number | undefined;
}

/**
 * @public
 */
export interface GenerateCardValidationDataOutput {
  /**
   * <p>The <code>keyARN</code> of the CVK encryption key that Amazon Web Services Payment Cryptography uses to generate CVV or CSC.</p>
   * @public
   */
  KeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  KeyCheckValue: string | undefined;

  /**
   * <p>The CVV or CSC value that Amazon Web Services Payment Cryptography generates for the card.</p>
   * @public
   */
  ValidationData: string | undefined;
}

/**
 * @public
 * @enum
 */
export const MacAlgorithm = {
  CMAC: "CMAC",
  HMAC_SHA224: "HMAC_SHA224",
  HMAC_SHA256: "HMAC_SHA256",
  HMAC_SHA384: "HMAC_SHA384",
  HMAC_SHA512: "HMAC_SHA512",
  ISO9797_ALGORITHM1: "ISO9797_ALGORITHM1",
  ISO9797_ALGORITHM3: "ISO9797_ALGORITHM3",
} as const;

/**
 * @public
 */
export type MacAlgorithm = (typeof MacAlgorithm)[keyof typeof MacAlgorithm];

/**
 * <p>Parameters required for DUKPT MAC generation and verification.</p>
 * @public
 */
export interface MacAlgorithmDukpt {
  /**
   * <p>The unique identifier known as Key Serial Number (KSN) that comes from an encrypting device using DUKPT encryption method. The KSN is derived from the encrypting device unique identifier and an internal transaction counter.</p>
   * @public
   */
  KeySerialNumber: string | undefined;

  /**
   * <p>The type of use of DUKPT, which can be MAC generation, MAC verification, or both.</p>
   * @public
   */
  DukptKeyVariant: DukptKeyVariant | undefined;

  /**
   * <p>The key type derived using DUKPT from a Base Derivation Key (BDK) and Key Serial Number (KSN). This must be less than or equal to the strength of the BDK. For example, you can't use <code>AES_128</code> as a derivation type for a BDK of <code>AES_128</code> or <code>TDES_2KEY</code>.</p>
   * @public
   */
  DukptDerivationType?: DukptDerivationType | undefined;
}

/**
 * @public
 * @enum
 */
export const SessionKeyDerivationMode = {
  AMEX: "AMEX",
  EMV2000: "EMV2000",
  EMV_COMMON_SESSION_KEY: "EMV_COMMON_SESSION_KEY",
  MASTERCARD_SESSION_KEY: "MASTERCARD_SESSION_KEY",
  VISA: "VISA",
} as const;

/**
 * @public
 */
export type SessionKeyDerivationMode = (typeof SessionKeyDerivationMode)[keyof typeof SessionKeyDerivationMode];

/**
 * <p>Parameters to derive session key value using a MAC EMV algorithm.</p>
 * @public
 */
export type SessionKeyDerivationValue =
  | SessionKeyDerivationValue.ApplicationCryptogramMember
  | SessionKeyDerivationValue.ApplicationTransactionCounterMember
  | SessionKeyDerivationValue.$UnknownMember;

/**
 * @public
 */
export namespace SessionKeyDerivationValue {
  /**
   * <p>The cryptogram provided by the terminal during transaction processing.</p>
   * @public
   */
  export interface ApplicationCryptogramMember {
    ApplicationCryptogram: string;
    ApplicationTransactionCounter?: never;
    $unknown?: never;
  }

  /**
   * <p>The transaction counter that is provided by the terminal during transaction processing.</p>
   * @public
   */
  export interface ApplicationTransactionCounterMember {
    ApplicationCryptogram?: never;
    ApplicationTransactionCounter: string;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    ApplicationCryptogram?: never;
    ApplicationTransactionCounter?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    ApplicationCryptogram: (value: string) => T;
    ApplicationTransactionCounter: (value: string) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: SessionKeyDerivationValue, visitor: Visitor<T>): T => {
    if (value.ApplicationCryptogram !== undefined) return visitor.ApplicationCryptogram(value.ApplicationCryptogram);
    if (value.ApplicationTransactionCounter !== undefined)
      return visitor.ApplicationTransactionCounter(value.ApplicationTransactionCounter);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * <p>Parameters that are required for EMV MAC generation and verification.</p>
 * @public
 */
export interface MacAlgorithmEmv {
  /**
   * <p>The method to use when deriving the master key for EMV MAC generation or verification.</p>
   * @public
   */
  MajorKeyDerivationMode: MajorKeyDerivationMode | undefined;

  /**
   * <p>The Primary Account Number (PAN), a unique identifier for a payment credit or debit card and associates the card to a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The method of deriving a session key for EMV MAC generation or verification.</p>
   * @public
   */
  SessionKeyDerivationMode: SessionKeyDerivationMode | undefined;

  /**
   * <p>Parameters that are required to generate session key for EMV generation and verification.</p>
   * @public
   */
  SessionKeyDerivationValue: SessionKeyDerivationValue | undefined;
}

/**
 * <p>Parameters that are required for DUKPT, HMAC, or EMV MAC generation or verification.</p>
 * @public
 */
export type MacAttributes =
  | MacAttributes.AlgorithmMember
  | MacAttributes.DukptCmacMember
  | MacAttributes.DukptIso9797Algorithm1Member
  | MacAttributes.DukptIso9797Algorithm3Member
  | MacAttributes.EmvMacMember
  | MacAttributes.$UnknownMember;

/**
 * @public
 */
export namespace MacAttributes {
  /**
   * <p>The encryption algorithm for MAC generation or verification.</p>
   * @public
   */
  export interface AlgorithmMember {
    Algorithm: MacAlgorithm;
    EmvMac?: never;
    DukptIso9797Algorithm1?: never;
    DukptIso9797Algorithm3?: never;
    DukptCmac?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required for MAC generation or verification using EMV MAC algorithm.</p>
   * @public
   */
  export interface EmvMacMember {
    Algorithm?: never;
    EmvMac: MacAlgorithmEmv;
    DukptIso9797Algorithm1?: never;
    DukptIso9797Algorithm3?: never;
    DukptCmac?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required for MAC generation or verification using DUKPT ISO 9797 algorithm1.</p>
   * @public
   */
  export interface DukptIso9797Algorithm1Member {
    Algorithm?: never;
    EmvMac?: never;
    DukptIso9797Algorithm1: MacAlgorithmDukpt;
    DukptIso9797Algorithm3?: never;
    DukptCmac?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required for MAC generation or verification using DUKPT ISO 9797 algorithm3.</p>
   * @public
   */
  export interface DukptIso9797Algorithm3Member {
    Algorithm?: never;
    EmvMac?: never;
    DukptIso9797Algorithm1?: never;
    DukptIso9797Algorithm3: MacAlgorithmDukpt;
    DukptCmac?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required for MAC generation or verification using DUKPT CMAC algorithm.</p>
   * @public
   */
  export interface DukptCmacMember {
    Algorithm?: never;
    EmvMac?: never;
    DukptIso9797Algorithm1?: never;
    DukptIso9797Algorithm3?: never;
    DukptCmac: MacAlgorithmDukpt;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    Algorithm?: never;
    EmvMac?: never;
    DukptIso9797Algorithm1?: never;
    DukptIso9797Algorithm3?: never;
    DukptCmac?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    Algorithm: (value: MacAlgorithm) => T;
    EmvMac: (value: MacAlgorithmEmv) => T;
    DukptIso9797Algorithm1: (value: MacAlgorithmDukpt) => T;
    DukptIso9797Algorithm3: (value: MacAlgorithmDukpt) => T;
    DukptCmac: (value: MacAlgorithmDukpt) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: MacAttributes, visitor: Visitor<T>): T => {
    if (value.Algorithm !== undefined) return visitor.Algorithm(value.Algorithm);
    if (value.EmvMac !== undefined) return visitor.EmvMac(value.EmvMac);
    if (value.DukptIso9797Algorithm1 !== undefined) return visitor.DukptIso9797Algorithm1(value.DukptIso9797Algorithm1);
    if (value.DukptIso9797Algorithm3 !== undefined) return visitor.DukptIso9797Algorithm3(value.DukptIso9797Algorithm3);
    if (value.DukptCmac !== undefined) return visitor.DukptCmac(value.DukptCmac);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * @public
 */
export interface GenerateMacInput {
  /**
   * <p>The <code>keyARN</code> of the MAC generation encryption key.</p>
   * @public
   */
  KeyIdentifier: string | undefined;

  /**
   * <p>The data for which a MAC is under generation. This value must be hexBinary.</p>
   * @public
   */
  MessageData: string | undefined;

  /**
   * <p>The attributes and data values to use for MAC generation within Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  GenerationAttributes: MacAttributes | undefined;

  /**
   * <p>The length of a MAC under generation.</p>
   * @public
   */
  MacLength?: number | undefined;
}

/**
 * @public
 */
export interface GenerateMacOutput {
  /**
   * <p>The <code>keyARN</code> of the encryption key that Amazon Web Services Payment Cryptography uses for MAC generation.</p>
   * @public
   */
  KeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  KeyCheckValue: string | undefined;

  /**
   * <p>The MAC cryptogram generated within Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  Mac: string | undefined;
}

/**
 * @public
 * @enum
 */
export const PinBlockFormatForEmvPinChange = {
  ISO_FORMAT_0: "ISO_FORMAT_0",
  ISO_FORMAT_1: "ISO_FORMAT_1",
  ISO_FORMAT_3: "ISO_FORMAT_3",
} as const;

/**
 * @public
 */
export type PinBlockFormatForEmvPinChange =
  (typeof PinBlockFormatForEmvPinChange)[keyof typeof PinBlockFormatForEmvPinChange];

/**
 * @public
 */
export interface GenerateMacEmvPinChangeInput {
  /**
   * <p>The <code>keyARN</code> of the PEK protecting the incoming new encrypted PIN block.</p>
   * @public
   */
  NewPinPekIdentifier: string | undefined;

  /**
   * <p>The incoming new encrypted PIN block data for offline pin change on an EMV card.</p>
   * @public
   */
  NewEncryptedPinBlock: string | undefined;

  /**
   * <p>The PIN encoding format of the incoming new encrypted PIN block as specified in ISO 9564.</p>
   * @public
   */
  PinBlockFormat: PinBlockFormatForEmvPinChange | undefined;

  /**
   * <p>The <code>keyARN</code> of the issuer master key (IMK-SMI) used to authenticate the issuer script response.</p>
   * @public
   */
  SecureMessagingIntegrityKeyIdentifier: string | undefined;

  /**
   * <p>The <code>keyARN</code> of the issuer master key (IMK-SMC) used to protect the PIN block data in the issuer script response.</p>
   * @public
   */
  SecureMessagingConfidentialityKeyIdentifier: string | undefined;

  /**
   * <p>The message data is the APDU command from the card reader or terminal. The target encrypted PIN block, after translation to ISO2 format, is appended to this message data to generate an issuer script response.</p>
   * @public
   */
  MessageData: string | undefined;

  /**
   * <p>The attributes and data values to derive payment card specific confidentiality and integrity keys.</p>
   * @public
   */
  DerivationMethodAttributes: DerivationMethodAttributes | undefined;
}

/**
 * <p>The attributes values used for Amex and Visa derivation methods.</p>
 * @public
 */
export interface VisaAmexDerivationOutputs {
  /**
   * <p>The <code>keyArn</code> of the issuer master key for cryptogram (IMK-AC) used by the operation.</p>
   * @public
   */
  AuthorizationRequestKeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the issuer master key for cryptogram (IMK-AC) used by the operation.</p>
   * @public
   */
  AuthorizationRequestKeyCheckValue: string | undefined;

  /**
   * <p>The <code>keyArn</code> of the current PIN PEK.</p>
   * @public
   */
  CurrentPinPekArn?: string | undefined;

  /**
   * <p>The key check value (KCV) of the current PIN PEK.</p>
   * @public
   */
  CurrentPinPekKeyCheckValue?: string | undefined;
}

/**
 * @public
 */
export interface GenerateMacEmvPinChangeOutput {
  /**
   * <p>Returns the <code>keyArn</code> of the PEK protecting the incoming new encrypted PIN block.</p>
   * @public
   */
  NewPinPekArn: string | undefined;

  /**
   * <p>Returns the <code>keyArn</code> of the IMK-SMI used by the operation.</p>
   * @public
   */
  SecureMessagingIntegrityKeyArn: string | undefined;

  /**
   * <p>Returns the <code>keyArn</code> of the IMK-SMC used by the operation.</p>
   * @public
   */
  SecureMessagingConfidentialityKeyArn: string | undefined;

  /**
   * <p>Returns the mac of the issuer script containing message data and appended target encrypted pin block in ISO2 format.</p>
   * @public
   */
  Mac: string | undefined;

  /**
   * <p>Returns the incoming new encrpted PIN block.</p>
   * @public
   */
  EncryptedPinBlock: string | undefined;

  /**
   * <p>The key check value (KCV) of the PEK uprotecting the incoming new encrypted PIN block.</p>
   * @public
   */
  NewPinPekKeyCheckValue: string | undefined;

  /**
   * <p>The key check value (KCV) of the SMI issuer master key used by the operation.</p>
   * @public
   */
  SecureMessagingIntegrityKeyCheckValue: string | undefined;

  /**
   * <p>The key check value (KCV) of the SMC issuer master key used by the operation.</p>
   * @public
   */
  SecureMessagingConfidentialityKeyCheckValue: string | undefined;

  /**
   * <p>The attribute values used for Amex and Visa derivation methods.</p>
   * @public
   */
  VisaAmexDerivationOutputs?: VisaAmexDerivationOutputs | undefined;
}

/**
 * <p>Parameters that are required to generate or verify Ibm3624 natural PIN.</p>
 * @public
 */
export interface Ibm3624NaturalPin {
  /**
   * <p>The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.</p>
   * @public
   */
  DecimalizationTable: string | undefined;

  /**
   * <p>The padding character for validation data.</p>
   * @public
   */
  PinValidationDataPadCharacter: string | undefined;

  /**
   * <p>The unique data for cardholder identification.</p>
   * @public
   */
  PinValidationData: string | undefined;
}

/**
 * <p>Parameters that are required to generate or verify Ibm3624 PIN from offset PIN.</p>
 * @public
 */
export interface Ibm3624PinFromOffset {
  /**
   * <p>The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.</p>
   * @public
   */
  DecimalizationTable: string | undefined;

  /**
   * <p>The padding character for validation data.</p>
   * @public
   */
  PinValidationDataPadCharacter: string | undefined;

  /**
   * <p>The unique data for cardholder identification.</p>
   * @public
   */
  PinValidationData: string | undefined;

  /**
   * <p>The PIN offset value.</p>
   * @public
   */
  PinOffset: string | undefined;
}

/**
 * <p>Pparameters that are required to generate or verify Ibm3624 PIN offset PIN.</p>
 * @public
 */
export interface Ibm3624PinOffset {
  /**
   * <p>The encrypted PIN block data. According to ISO 9564 standard, a PIN Block is an encoded representation of a payment card Personal Account Number (PAN) and the cardholder Personal Identification Number (PIN).</p>
   * @public
   */
  EncryptedPinBlock: string | undefined;

  /**
   * <p>The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.</p>
   * @public
   */
  DecimalizationTable: string | undefined;

  /**
   * <p>The padding character for validation data.</p>
   * @public
   */
  PinValidationDataPadCharacter: string | undefined;

  /**
   * <p>The unique data for cardholder identification.</p>
   * @public
   */
  PinValidationData: string | undefined;
}

/**
 * <p>Parameters that are required to generate or verify Ibm3624 random PIN.</p>
 * @public
 */
export interface Ibm3624RandomPin {
  /**
   * <p>The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.</p>
   * @public
   */
  DecimalizationTable: string | undefined;

  /**
   * <p>The padding character for validation data.</p>
   * @public
   */
  PinValidationDataPadCharacter: string | undefined;

  /**
   * <p>The unique data for cardholder identification.</p>
   * @public
   */
  PinValidationData: string | undefined;
}

/**
 * <p>Parameters that are required to generate or verify Visa PIN.</p>
 * @public
 */
export interface VisaPin {
  /**
   * <p>The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).</p>
   * @public
   */
  PinVerificationKeyIndex: number | undefined;
}

/**
 * <p>Parameters that are required to generate or verify Visa PVV (PIN Verification Value).</p>
 * @public
 */
export interface VisaPinVerificationValue {
  /**
   * <p>The encrypted PIN block data to verify.</p>
   * @public
   */
  EncryptedPinBlock: string | undefined;

  /**
   * <p>The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).</p>
   * @public
   */
  PinVerificationKeyIndex: number | undefined;
}

/**
 * <p>Parameters that are required for PIN data generation.</p>
 * @public
 */
export type PinGenerationAttributes =
  | PinGenerationAttributes.Ibm3624NaturalPinMember
  | PinGenerationAttributes.Ibm3624PinFromOffsetMember
  | PinGenerationAttributes.Ibm3624PinOffsetMember
  | PinGenerationAttributes.Ibm3624RandomPinMember
  | PinGenerationAttributes.VisaPinMember
  | PinGenerationAttributes.VisaPinVerificationValueMember
  | PinGenerationAttributes.$UnknownMember;

/**
 * @public
 */
export namespace PinGenerationAttributes {
  /**
   * <p>Parameters that are required to generate or verify Visa PIN.</p>
   * @public
   */
  export interface VisaPinMember {
    VisaPin: VisaPin;
    VisaPinVerificationValue?: never;
    Ibm3624PinOffset?: never;
    Ibm3624NaturalPin?: never;
    Ibm3624RandomPin?: never;
    Ibm3624PinFromOffset?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required to generate or verify Visa PIN Verification Value (PVV).</p>
   * @public
   */
  export interface VisaPinVerificationValueMember {
    VisaPin?: never;
    VisaPinVerificationValue: VisaPinVerificationValue;
    Ibm3624PinOffset?: never;
    Ibm3624NaturalPin?: never;
    Ibm3624RandomPin?: never;
    Ibm3624PinFromOffset?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required to generate or verify Ibm3624 PIN offset PIN.</p>
   * @public
   */
  export interface Ibm3624PinOffsetMember {
    VisaPin?: never;
    VisaPinVerificationValue?: never;
    Ibm3624PinOffset: Ibm3624PinOffset;
    Ibm3624NaturalPin?: never;
    Ibm3624RandomPin?: never;
    Ibm3624PinFromOffset?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required to generate or verify Ibm3624 natural PIN.</p>
   * @public
   */
  export interface Ibm3624NaturalPinMember {
    VisaPin?: never;
    VisaPinVerificationValue?: never;
    Ibm3624PinOffset?: never;
    Ibm3624NaturalPin: Ibm3624NaturalPin;
    Ibm3624RandomPin?: never;
    Ibm3624PinFromOffset?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required to generate or verify Ibm3624 random PIN.</p>
   * @public
   */
  export interface Ibm3624RandomPinMember {
    VisaPin?: never;
    VisaPinVerificationValue?: never;
    Ibm3624PinOffset?: never;
    Ibm3624NaturalPin?: never;
    Ibm3624RandomPin: Ibm3624RandomPin;
    Ibm3624PinFromOffset?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required to generate or verify Ibm3624 PIN from offset PIN.</p>
   * @public
   */
  export interface Ibm3624PinFromOffsetMember {
    VisaPin?: never;
    VisaPinVerificationValue?: never;
    Ibm3624PinOffset?: never;
    Ibm3624NaturalPin?: never;
    Ibm3624RandomPin?: never;
    Ibm3624PinFromOffset: Ibm3624PinFromOffset;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    VisaPin?: never;
    VisaPinVerificationValue?: never;
    Ibm3624PinOffset?: never;
    Ibm3624NaturalPin?: never;
    Ibm3624RandomPin?: never;
    Ibm3624PinFromOffset?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    VisaPin: (value: VisaPin) => T;
    VisaPinVerificationValue: (value: VisaPinVerificationValue) => T;
    Ibm3624PinOffset: (value: Ibm3624PinOffset) => T;
    Ibm3624NaturalPin: (value: Ibm3624NaturalPin) => T;
    Ibm3624RandomPin: (value: Ibm3624RandomPin) => T;
    Ibm3624PinFromOffset: (value: Ibm3624PinFromOffset) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: PinGenerationAttributes, visitor: Visitor<T>): T => {
    if (value.VisaPin !== undefined) return visitor.VisaPin(value.VisaPin);
    if (value.VisaPinVerificationValue !== undefined)
      return visitor.VisaPinVerificationValue(value.VisaPinVerificationValue);
    if (value.Ibm3624PinOffset !== undefined) return visitor.Ibm3624PinOffset(value.Ibm3624PinOffset);
    if (value.Ibm3624NaturalPin !== undefined) return visitor.Ibm3624NaturalPin(value.Ibm3624NaturalPin);
    if (value.Ibm3624RandomPin !== undefined) return visitor.Ibm3624RandomPin(value.Ibm3624RandomPin);
    if (value.Ibm3624PinFromOffset !== undefined) return visitor.Ibm3624PinFromOffset(value.Ibm3624PinFromOffset);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * @public
 * @enum
 */
export const PinBlockFormatForPinData = {
  ISO_FORMAT_0: "ISO_FORMAT_0",
  ISO_FORMAT_3: "ISO_FORMAT_3",
  ISO_FORMAT_4: "ISO_FORMAT_4",
} as const;

/**
 * @public
 */
export type PinBlockFormatForPinData = (typeof PinBlockFormatForPinData)[keyof typeof PinBlockFormatForPinData];

/**
 * @public
 */
export interface GeneratePinDataInput {
  /**
   * <p>The <code>keyARN</code> of the PEK that Amazon Web Services Payment Cryptography uses for pin data generation.</p>
   * @public
   */
  GenerationKeyIdentifier: string | undefined;

  /**
   * <p>The <code>keyARN</code> of the PEK that Amazon Web Services Payment Cryptography uses to encrypt the PIN Block. For ECDH, it is the <code>keyARN</code> of the asymmetric ECC key.</p>
   * @public
   */
  EncryptionKeyIdentifier: string | undefined;

  /**
   * <p>The attributes and values to use for PIN, PVV, or PIN Offset generation.</p>
   * @public
   */
  GenerationAttributes: PinGenerationAttributes | undefined;

  /**
   * <p>The length of PIN under generation.</p>
   * @public
   */
  PinDataLength?: number | undefined;

  /**
   * <p>The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>The PIN encoding format for pin data generation as specified in ISO 9564. Amazon Web Services Payment Cryptography supports <code>ISO_Format_0</code> and <code>ISO_Format_3</code>.</p>
   *          <p>The <code>ISO_Format_0</code> PIN block format is equivalent to the ANSI X9.8, VISA-1, and ECI-1 PIN block formats. It is similar to a VISA-4 PIN block format. It supports a PIN from 4 to 12 digits in length.</p>
   *          <p>The <code>ISO_Format_3</code> PIN block format is the same as <code>ISO_Format_0</code> except that the fill digits are random values from 10 to 15.</p>
   * @public
   */
  PinBlockFormat: PinBlockFormatForPinData | undefined;

  /**
   * <p>Parameter information of a WrappedKeyBlock for encryption key exchange.</p>
   * @public
   */
  EncryptionWrappedKey?: WrappedKey | undefined;
}

/**
 * <p>Parameters that are required to generate, translate, or verify PIN data.</p>
 * @public
 */
export type PinData = PinData.PinOffsetMember | PinData.VerificationValueMember | PinData.$UnknownMember;

/**
 * @public
 */
export namespace PinData {
  /**
   * <p>The PIN offset value.</p>
   * @public
   */
  export interface PinOffsetMember {
    PinOffset: string;
    VerificationValue?: never;
    $unknown?: never;
  }

  /**
   * <p>The unique data to identify a cardholder. In most cases, this is the same as cardholder's Primary Account Number (PAN). If a value is not provided, it defaults to PAN.</p>
   * @public
   */
  export interface VerificationValueMember {
    PinOffset?: never;
    VerificationValue: string;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    PinOffset?: never;
    VerificationValue?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    PinOffset: (value: string) => T;
    VerificationValue: (value: string) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: PinData, visitor: Visitor<T>): T => {
    if (value.PinOffset !== undefined) return visitor.PinOffset(value.PinOffset);
    if (value.VerificationValue !== undefined) return visitor.VerificationValue(value.VerificationValue);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * @public
 */
export interface GeneratePinDataOutput {
  /**
   * <p>The <code>keyARN</code> of the pin data generation key that Amazon Web Services Payment Cryptography uses for PIN, PVV or PIN Offset generation.</p>
   * @public
   */
  GenerationKeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  GenerationKeyCheckValue: string | undefined;

  /**
   * <p>The <code>keyARN</code> of the PEK that Amazon Web Services Payment Cryptography uses for encrypted pin block generation. For ECDH, it is the <code>keyARN</code> of the asymmetric ECC key.</p>
   * @public
   */
  EncryptionKeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  EncryptionKeyCheckValue: string | undefined;

  /**
   * <p>The PIN block encrypted under PEK from Amazon Web Services Payment Cryptography. The encrypted PIN block is a composite of PAN (Primary Account Number) and PIN (Personal Identification Number), generated in accordance with ISO 9564 standard.</p>
   * @public
   */
  EncryptedPinBlock: string | undefined;

  /**
   * <p>The attributes and values Amazon Web Services Payment Cryptography uses for pin data generation.</p>
   * @public
   */
  PinData: PinData | undefined;
}

/**
 * <p>Parameters that are required to generate or verify Ibm3624 PIN verification PIN.</p>
 * @public
 */
export interface Ibm3624PinVerification {
  /**
   * <p>The decimalization table to use for IBM 3624 PIN algorithm. The table is used to convert the algorithm intermediate result from hexadecimal characters to decimal.</p>
   * @public
   */
  DecimalizationTable: string | undefined;

  /**
   * <p>The padding character for validation data.</p>
   * @public
   */
  PinValidationDataPadCharacter: string | undefined;

  /**
   * <p>The unique data for cardholder identification.</p>
   * @public
   */
  PinValidationData: string | undefined;

  /**
   * <p>The PIN offset value.</p>
   * @public
   */
  PinOffset: string | undefined;
}

/**
 * <p>Parameters that are required to perform reencryption operation.</p>
 * @public
 */
export type ReEncryptionAttributes =
  | ReEncryptionAttributes.DukptMember
  | ReEncryptionAttributes.SymmetricMember
  | ReEncryptionAttributes.$UnknownMember;

/**
 * @public
 */
export namespace ReEncryptionAttributes {
  /**
   * <p>Parameters that are required to encrypt data using symmetric keys.</p>
   * @public
   */
  export interface SymmetricMember {
    Symmetric: SymmetricEncryptionAttributes;
    Dukpt?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required to encrypt plaintext data using DUKPT.</p>
   * @public
   */
  export interface DukptMember {
    Symmetric?: never;
    Dukpt: DukptEncryptionAttributes;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    Symmetric?: never;
    Dukpt?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    Symmetric: (value: SymmetricEncryptionAttributes) => T;
    Dukpt: (value: DukptEncryptionAttributes) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: ReEncryptionAttributes, visitor: Visitor<T>): T => {
    if (value.Symmetric !== undefined) return visitor.Symmetric(value.Symmetric);
    if (value.Dukpt !== undefined) return visitor.Dukpt(value.Dukpt);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * @public
 */
export interface ReEncryptDataInput {
  /**
   * <p>The <code>keyARN</code> of the encryption key of incoming ciphertext data.</p>
   *          <p>When a WrappedKeyBlock is provided, this value will be the identifier to the key wrapping key. Otherwise, it is the key identifier used to perform the operation.</p>
   * @public
   */
  IncomingKeyIdentifier: string | undefined;

  /**
   * <p>The <code>keyARN</code> of the encryption key of outgoing ciphertext data after encryption by Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  OutgoingKeyIdentifier: string | undefined;

  /**
   * <p>Ciphertext to be encrypted. The minimum allowed length is 16 bytes and maximum allowed length is 4096 bytes.</p>
   * @public
   */
  CipherText: string | undefined;

  /**
   * <p>The attributes and values for incoming ciphertext.</p>
   * @public
   */
  IncomingEncryptionAttributes: ReEncryptionAttributes | undefined;

  /**
   * <p>The attributes and values for outgoing ciphertext data after encryption by Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  OutgoingEncryptionAttributes: ReEncryptionAttributes | undefined;

  /**
   * <p>The WrappedKeyBlock containing the encryption key of incoming ciphertext data.</p>
   * @public
   */
  IncomingWrappedKey?: WrappedKey | undefined;

  /**
   * <p>The WrappedKeyBlock containing the encryption key of outgoing ciphertext data after encryption by Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  OutgoingWrappedKey?: WrappedKey | undefined;
}

/**
 * @public
 */
export interface ReEncryptDataOutput {
  /**
   * <p>The keyARN (Amazon Resource Name) of the encryption key that Amazon Web Services Payment Cryptography uses for plaintext encryption.</p>
   * @public
   */
  KeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  KeyCheckValue: string | undefined;

  /**
   * <p>The encrypted ciphertext.</p>
   * @public
   */
  CipherText: string | undefined;
}

/**
 * <p>Parameters that are required for tranlation between ISO9564 PIN format 0,3,4 tranlation.</p>
 * @public
 */
export interface TranslationPinDataIsoFormat034 {
  /**
   * <p>The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;
}

/**
 * <p>Parameters that are required for ISO9564 PIN format 1 tranlation.</p>
 * @public
 */
export interface TranslationPinDataIsoFormat1 {}

/**
 * <p>Parameters that are required for translation between ISO9564 PIN block formats 0,1,3,4.</p>
 * @public
 */
export type TranslationIsoFormats =
  | TranslationIsoFormats.IsoFormat0Member
  | TranslationIsoFormats.IsoFormat1Member
  | TranslationIsoFormats.IsoFormat3Member
  | TranslationIsoFormats.IsoFormat4Member
  | TranslationIsoFormats.$UnknownMember;

/**
 * @public
 */
export namespace TranslationIsoFormats {
  /**
   * <p>Parameters that are required for ISO9564 PIN format 0 tranlation.</p>
   * @public
   */
  export interface IsoFormat0Member {
    IsoFormat0: TranslationPinDataIsoFormat034;
    IsoFormat1?: never;
    IsoFormat3?: never;
    IsoFormat4?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required for ISO9564 PIN format 1 tranlation.</p>
   * @public
   */
  export interface IsoFormat1Member {
    IsoFormat0?: never;
    IsoFormat1: TranslationPinDataIsoFormat1;
    IsoFormat3?: never;
    IsoFormat4?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required for ISO9564 PIN format 3 tranlation.</p>
   * @public
   */
  export interface IsoFormat3Member {
    IsoFormat0?: never;
    IsoFormat1?: never;
    IsoFormat3: TranslationPinDataIsoFormat034;
    IsoFormat4?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required for ISO9564 PIN format 4 tranlation.</p>
   * @public
   */
  export interface IsoFormat4Member {
    IsoFormat0?: never;
    IsoFormat1?: never;
    IsoFormat3?: never;
    IsoFormat4: TranslationPinDataIsoFormat034;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    IsoFormat0?: never;
    IsoFormat1?: never;
    IsoFormat3?: never;
    IsoFormat4?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    IsoFormat0: (value: TranslationPinDataIsoFormat034) => T;
    IsoFormat1: (value: TranslationPinDataIsoFormat1) => T;
    IsoFormat3: (value: TranslationPinDataIsoFormat034) => T;
    IsoFormat4: (value: TranslationPinDataIsoFormat034) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: TranslationIsoFormats, visitor: Visitor<T>): T => {
    if (value.IsoFormat0 !== undefined) return visitor.IsoFormat0(value.IsoFormat0);
    if (value.IsoFormat1 !== undefined) return visitor.IsoFormat1(value.IsoFormat1);
    if (value.IsoFormat3 !== undefined) return visitor.IsoFormat3(value.IsoFormat3);
    if (value.IsoFormat4 !== undefined) return visitor.IsoFormat4(value.IsoFormat4);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * @public
 */
export interface TranslatePinDataInput {
  /**
   * <p>The <code>keyARN</code> of the encryption key under which incoming PIN block data is encrypted. This key type can be PEK or BDK.</p>
   *          <p>For dynamic keys, it is the <code>keyARN</code> of KEK of the TR-31 wrapped PEK. For ECDH, it is the <code>keyARN</code> of the asymmetric ECC key.</p>
   * @public
   */
  IncomingKeyIdentifier: string | undefined;

  /**
   * <p>The <code>keyARN</code> of the encryption key for encrypting outgoing PIN block data. This key type can be PEK or BDK.</p>
   *          <p>For ECDH, it is the <code>keyARN</code> of the asymmetric ECC key.</p>
   * @public
   */
  OutgoingKeyIdentifier: string | undefined;

  /**
   * <p>The format of the incoming PIN block data for translation within Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  IncomingTranslationAttributes: TranslationIsoFormats | undefined;

  /**
   * <p>The format of the outgoing PIN block data after translation by Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  OutgoingTranslationAttributes: TranslationIsoFormats | undefined;

  /**
   * <p>The encrypted PIN block data that Amazon Web Services Payment Cryptography translates.</p>
   * @public
   */
  EncryptedPinBlock: string | undefined;

  /**
   * <p>The attributes and values to use for incoming DUKPT encryption key for PIN block translation.</p>
   * @public
   */
  IncomingDukptAttributes?: DukptDerivationAttributes | undefined;

  /**
   * <p>The attributes and values to use for outgoing DUKPT encryption key after PIN block translation.</p>
   * @public
   */
  OutgoingDukptAttributes?: DukptDerivationAttributes | undefined;

  /**
   * <p>The WrappedKeyBlock containing the encryption key under which incoming PIN block data is encrypted.</p>
   * @public
   */
  IncomingWrappedKey?: WrappedKey | undefined;

  /**
   * <p>The WrappedKeyBlock containing the encryption key for encrypting outgoing PIN block data.</p>
   * @public
   */
  OutgoingWrappedKey?: WrappedKey | undefined;
}

/**
 * @public
 */
export interface TranslatePinDataOutput {
  /**
   * <p>The outgoing encrypted PIN block data after translation.</p>
   * @public
   */
  PinBlock: string | undefined;

  /**
   * <p>The <code>keyARN</code> of the encryption key that Amazon Web Services Payment Cryptography uses to encrypt outgoing PIN block data after translation.</p>
   * @public
   */
  KeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  KeyCheckValue: string | undefined;
}

/**
 * @public
 * @enum
 */
export const VerificationFailedReason = {
  INVALID_AUTH_REQUEST_CRYPTOGRAM: "INVALID_AUTH_REQUEST_CRYPTOGRAM",
  INVALID_MAC: "INVALID_MAC",
  INVALID_PIN: "INVALID_PIN",
  INVALID_VALIDATION_DATA: "INVALID_VALIDATION_DATA",
} as const;

/**
 * @public
 */
export type VerificationFailedReason = (typeof VerificationFailedReason)[keyof typeof VerificationFailedReason];

/**
 * <p>This request failed verification.</p>
 * @public
 */
export class VerificationFailedException extends __BaseException {
  readonly name: "VerificationFailedException" = "VerificationFailedException";
  readonly $fault: "client" = "client";
  /**
   * <p>The reason for the exception.</p>
   * @public
   */
  Reason: VerificationFailedReason | undefined;

  Message: string | undefined;
  /**
   * @internal
   */
  constructor(opts: __ExceptionOptionType<VerificationFailedException, __BaseException>) {
    super({
      name: "VerificationFailedException",
      $fault: "client",
      ...opts,
    });
    Object.setPrototypeOf(this, VerificationFailedException.prototype);
    this.Reason = opts.Reason;
    this.Message = opts.Message;
  }
}

/**
 * <p>Parameters to derive session key for an Amex payment card.</p>
 * @public
 */
export interface SessionKeyAmex {
  /**
   * <p>The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).</p>
   * @public
   */
  PanSequenceNumber: string | undefined;
}

/**
 * <p>Parameters to derive session key for an Emv2000 payment card for ARQC verification.</p>
 * @public
 */
export interface SessionKeyEmv2000 {
  /**
   * <p>The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The transaction counter that is provided by the terminal during transaction processing.</p>
   * @public
   */
  ApplicationTransactionCounter: string | undefined;
}

/**
 * <p>Parameters to derive session key for an Emv common payment card for ARQC verification.</p>
 * @public
 */
export interface SessionKeyEmvCommon {
  /**
   * <p>The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The transaction counter that is provided by the terminal during transaction processing.</p>
   * @public
   */
  ApplicationTransactionCounter: string | undefined;
}

/**
 * <p>Parameters to derive session key for Mastercard payment card for ARQC verification.</p>
 * @public
 */
export interface SessionKeyMastercard {
  /**
   * <p>The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).</p>
   * @public
   */
  PanSequenceNumber: string | undefined;

  /**
   * <p>The transaction counter that is provided by the terminal during transaction processing.</p>
   * @public
   */
  ApplicationTransactionCounter: string | undefined;

  /**
   * <p>A random number generated by the issuer.</p>
   * @public
   */
  UnpredictableNumber: string | undefined;
}

/**
 * <p>Parameters to derive session key for Visa payment card for ARQC verification.</p>
 * @public
 */
export interface SessionKeyVisa {
  /**
   * <p>The Primary Account Number (PAN) of the cardholder. A PAN is a unique identifier for a payment credit or debit card and associates the card to a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>A number that identifies and differentiates payment cards with the same Primary Account Number (PAN).</p>
   * @public
   */
  PanSequenceNumber: string | undefined;
}

/**
 * <p>Parameters to derive a session key for Authorization Response Cryptogram (ARQC) verification.</p>
 * @public
 */
export type SessionKeyDerivation =
  | SessionKeyDerivation.AmexMember
  | SessionKeyDerivation.Emv2000Member
  | SessionKeyDerivation.EmvCommonMember
  | SessionKeyDerivation.MastercardMember
  | SessionKeyDerivation.VisaMember
  | SessionKeyDerivation.$UnknownMember;

/**
 * @public
 */
export namespace SessionKeyDerivation {
  /**
   * <p>Parameters to derive session key for an Emv common payment card for ARQC verification.</p>
   * @public
   */
  export interface EmvCommonMember {
    EmvCommon: SessionKeyEmvCommon;
    Mastercard?: never;
    Emv2000?: never;
    Amex?: never;
    Visa?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters to derive session key for a Mastercard payment card for ARQC verification.</p>
   * @public
   */
  export interface MastercardMember {
    EmvCommon?: never;
    Mastercard: SessionKeyMastercard;
    Emv2000?: never;
    Amex?: never;
    Visa?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters to derive session key for an Emv2000 payment card for ARQC verification.</p>
   * @public
   */
  export interface Emv2000Member {
    EmvCommon?: never;
    Mastercard?: never;
    Emv2000: SessionKeyEmv2000;
    Amex?: never;
    Visa?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters to derive session key for an Amex payment card for ARQC verification.</p>
   * @public
   */
  export interface AmexMember {
    EmvCommon?: never;
    Mastercard?: never;
    Emv2000?: never;
    Amex: SessionKeyAmex;
    Visa?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters to derive session key for a Visa payment cardfor ARQC verification.</p>
   * @public
   */
  export interface VisaMember {
    EmvCommon?: never;
    Mastercard?: never;
    Emv2000?: never;
    Amex?: never;
    Visa: SessionKeyVisa;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    EmvCommon?: never;
    Mastercard?: never;
    Emv2000?: never;
    Amex?: never;
    Visa?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    EmvCommon: (value: SessionKeyEmvCommon) => T;
    Mastercard: (value: SessionKeyMastercard) => T;
    Emv2000: (value: SessionKeyEmv2000) => T;
    Amex: (value: SessionKeyAmex) => T;
    Visa: (value: SessionKeyVisa) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: SessionKeyDerivation, visitor: Visitor<T>): T => {
    if (value.EmvCommon !== undefined) return visitor.EmvCommon(value.EmvCommon);
    if (value.Mastercard !== undefined) return visitor.Mastercard(value.Mastercard);
    if (value.Emv2000 !== undefined) return visitor.Emv2000(value.Emv2000);
    if (value.Amex !== undefined) return visitor.Amex(value.Amex);
    if (value.Visa !== undefined) return visitor.Visa(value.Visa);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * @public
 */
export interface VerifyAuthRequestCryptogramInput {
  /**
   * <p>The <code>keyARN</code> of the major encryption key that Amazon Web Services Payment Cryptography uses for ARQC verification.</p>
   * @public
   */
  KeyIdentifier: string | undefined;

  /**
   * <p>The transaction data that Amazon Web Services Payment Cryptography uses for ARQC verification. The same transaction is used for ARQC generation outside of Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  TransactionData: string | undefined;

  /**
   * <p>The auth request cryptogram imported into Amazon Web Services Payment Cryptography for ARQC verification using a major encryption key and transaction data.</p>
   * @public
   */
  AuthRequestCryptogram: string | undefined;

  /**
   * <p>The method to use when deriving the major encryption key for ARQC verification within Amazon Web Services Payment Cryptography. The same key derivation mode was used for ARQC generation outside of Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  MajorKeyDerivationMode: MajorKeyDerivationMode | undefined;

  /**
   * <p>The attributes and values to use for deriving a session key for ARQC verification within Amazon Web Services Payment Cryptography. The same attributes were used for ARQC generation outside of Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  SessionKeyDerivationAttributes: SessionKeyDerivation | undefined;

  /**
   * <p>The attributes and values for auth request cryptogram verification. These parameters are required in case using ARPC Method 1 or Method 2 for ARQC verification.</p>
   * @public
   */
  AuthResponseAttributes?: CryptogramAuthResponse | undefined;
}

/**
 * @public
 */
export interface VerifyAuthRequestCryptogramOutput {
  /**
   * <p>The <code>keyARN</code> of the major encryption key that Amazon Web Services Payment Cryptography uses for ARQC verification.</p>
   * @public
   */
  KeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  KeyCheckValue: string | undefined;

  /**
   * <p>The result for ARQC verification or ARPC generation within Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  AuthResponseValue?: string | undefined;
}

/**
 * @public
 */
export interface VerifyCardValidationDataInput {
  /**
   * <p>The <code>keyARN</code> of the CVK encryption key that Amazon Web Services Payment Cryptography uses to verify card data.</p>
   * @public
   */
  KeyIdentifier: string | undefined;

  /**
   * <p>The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>The algorithm to use for verification of card data within Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  VerificationAttributes: CardVerificationAttributes | undefined;

  /**
   * <p>The CVV or CSC value for use for card data verification within Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  ValidationData: string | undefined;
}

/**
 * @public
 */
export interface VerifyCardValidationDataOutput {
  /**
   * <p>The <code>keyARN</code> of the CVK encryption key that Amazon Web Services Payment Cryptography uses to verify CVV or CSC.</p>
   * @public
   */
  KeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  KeyCheckValue: string | undefined;
}

/**
 * @public
 */
export interface VerifyMacInput {
  /**
   * <p>The <code>keyARN</code> of the encryption key that Amazon Web Services Payment Cryptography uses to verify MAC data.</p>
   * @public
   */
  KeyIdentifier: string | undefined;

  /**
   * <p>The data on for which MAC is under verification. This value must be hexBinary.</p>
   * @public
   */
  MessageData: string | undefined;

  /**
   * <p>The MAC being verified.</p>
   * @public
   */
  Mac: string | undefined;

  /**
   * <p>The attributes and data values to use for MAC verification within Amazon Web Services Payment Cryptography.</p>
   * @public
   */
  VerificationAttributes: MacAttributes | undefined;

  /**
   * <p>The length of the MAC.</p>
   * @public
   */
  MacLength?: number | undefined;
}

/**
 * @public
 */
export interface VerifyMacOutput {
  /**
   * <p>The <code>keyARN</code> of the encryption key that Amazon Web Services Payment Cryptography uses for MAC verification.</p>
   * @public
   */
  KeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  KeyCheckValue: string | undefined;
}

/**
 * <p>Parameters that are required to generate or verify Visa PIN.</p>
 * @public
 */
export interface VisaPinVerification {
  /**
   * <p>The value for PIN verification index. It is used in the Visa PIN algorithm to calculate the PVV (PIN Verification Value).</p>
   * @public
   */
  PinVerificationKeyIndex: number | undefined;

  /**
   * <p>Parameters that are required to generate or verify Visa PVV (PIN Verification Value).</p>
   * @public
   */
  VerificationValue: string | undefined;
}

/**
 * <p>Parameters that are required for PIN data verification.</p>
 * @public
 */
export type PinVerificationAttributes =
  | PinVerificationAttributes.Ibm3624PinMember
  | PinVerificationAttributes.VisaPinMember
  | PinVerificationAttributes.$UnknownMember;

/**
 * @public
 */
export namespace PinVerificationAttributes {
  /**
   * <p>Parameters that are required to generate or verify Visa PIN.</p>
   * @public
   */
  export interface VisaPinMember {
    VisaPin: VisaPinVerification;
    Ibm3624Pin?: never;
    $unknown?: never;
  }

  /**
   * <p>Parameters that are required to generate or verify Ibm3624 PIN.</p>
   * @public
   */
  export interface Ibm3624PinMember {
    VisaPin?: never;
    Ibm3624Pin: Ibm3624PinVerification;
    $unknown?: never;
  }

  /**
   * @public
   */
  export interface $UnknownMember {
    VisaPin?: never;
    Ibm3624Pin?: never;
    $unknown: [string, any];
  }

  export interface Visitor<T> {
    VisaPin: (value: VisaPinVerification) => T;
    Ibm3624Pin: (value: Ibm3624PinVerification) => T;
    _: (name: string, value: any) => T;
  }

  export const visit = <T>(value: PinVerificationAttributes, visitor: Visitor<T>): T => {
    if (value.VisaPin !== undefined) return visitor.VisaPin(value.VisaPin);
    if (value.Ibm3624Pin !== undefined) return visitor.Ibm3624Pin(value.Ibm3624Pin);
    return visitor._(value.$unknown[0], value.$unknown[1]);
  };
}

/**
 * @public
 */
export interface VerifyPinDataInput {
  /**
   * <p>The <code>keyARN</code> of the PIN verification key.</p>
   * @public
   */
  VerificationKeyIdentifier: string | undefined;

  /**
   * <p>The <code>keyARN</code> of the encryption key under which the PIN block data is encrypted. This key type can be PEK or BDK.</p>
   * @public
   */
  EncryptionKeyIdentifier: string | undefined;

  /**
   * <p>The attributes and values for PIN data verification.</p>
   * @public
   */
  VerificationAttributes: PinVerificationAttributes | undefined;

  /**
   * <p>The encrypted PIN block data that Amazon Web Services Payment Cryptography verifies.</p>
   * @public
   */
  EncryptedPinBlock: string | undefined;

  /**
   * <p>The Primary Account Number (PAN), a unique identifier for a payment credit or debit card that associates the card with a specific account holder.</p>
   * @public
   */
  PrimaryAccountNumber: string | undefined;

  /**
   * <p>The PIN encoding format for pin data generation as specified in ISO 9564. Amazon Web Services Payment Cryptography supports <code>ISO_Format_0</code> and <code>ISO_Format_3</code>.</p>
   *          <p>The <code>ISO_Format_0</code> PIN block format is equivalent to the ANSI X9.8, VISA-1, and ECI-1 PIN block formats. It is similar to a VISA-4 PIN block format. It supports a PIN from 4 to 12 digits in length.</p>
   *          <p>The <code>ISO_Format_3</code> PIN block format is the same as <code>ISO_Format_0</code> except that the fill digits are random values from 10 to 15.</p>
   * @public
   */
  PinBlockFormat: PinBlockFormatForPinData | undefined;

  /**
   * <p>The length of PIN being verified.</p>
   * @public
   */
  PinDataLength?: number | undefined;

  /**
   * <p>The attributes and values for the DUKPT encrypted PIN block data.</p>
   * @public
   */
  DukptAttributes?: DukptAttributes | undefined;

  /**
   * <p>Parameter information of a WrappedKeyBlock for encryption key exchange.</p>
   * @public
   */
  EncryptionWrappedKey?: WrappedKey | undefined;
}

/**
 * @public
 */
export interface VerifyPinDataOutput {
  /**
   * <p>The <code>keyARN</code> of the PIN encryption key that Amazon Web Services Payment Cryptography uses for PIN or PIN Offset verification.</p>
   * @public
   */
  VerificationKeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  VerificationKeyCheckValue: string | undefined;

  /**
   * <p>The <code>keyARN</code> of the PEK that Amazon Web Services Payment Cryptography uses for encrypted pin block generation.</p>
   * @public
   */
  EncryptionKeyArn: string | undefined;

  /**
   * <p>The key check value (KCV) of the encryption key. The KCV is used to check if all parties holding a given key have the same key or to detect that a key has changed.</p>
   *          <p>Amazon Web Services Payment Cryptography computes the KCV according to the CMAC specification.</p>
   * @public
   */
  EncryptionKeyCheckValue: string | undefined;
}

/**
 * @internal
 */
export const CurrentPinAttributesFilterSensitiveLog = (obj: CurrentPinAttributes): any => ({
  ...obj,
  ...(obj.CurrentEncryptedPinBlock && { CurrentEncryptedPinBlock: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const AmexAttributesFilterSensitiveLog = (obj: AmexAttributes): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
  ...(obj.CurrentPinAttributes && {
    CurrentPinAttributes: CurrentPinAttributesFilterSensitiveLog(obj.CurrentPinAttributes),
  }),
});

/**
 * @internal
 */
export const AmexCardSecurityCodeVersion1FilterSensitiveLog = (obj: AmexCardSecurityCodeVersion1): any => ({
  ...obj,
  ...(obj.CardExpiryDate && { CardExpiryDate: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const AmexCardSecurityCodeVersion2FilterSensitiveLog = (obj: AmexCardSecurityCodeVersion2): any => ({
  ...obj,
  ...(obj.CardExpiryDate && { CardExpiryDate: SENSITIVE_STRING }),
  ...(obj.ServiceCode && { ServiceCode: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const CardVerificationValue1FilterSensitiveLog = (obj: CardVerificationValue1): any => ({
  ...obj,
  ...(obj.CardExpiryDate && { CardExpiryDate: SENSITIVE_STRING }),
  ...(obj.ServiceCode && { ServiceCode: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const CardVerificationValue2FilterSensitiveLog = (obj: CardVerificationValue2): any => ({
  ...obj,
  ...(obj.CardExpiryDate && { CardExpiryDate: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const DynamicCardVerificationCodeFilterSensitiveLog = (obj: DynamicCardVerificationCode): any => ({
  ...obj,
  ...(obj.TrackData && { TrackData: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const DynamicCardVerificationValueFilterSensitiveLog = (obj: DynamicCardVerificationValue): any => ({
  ...obj,
  ...(obj.CardExpiryDate && { CardExpiryDate: SENSITIVE_STRING }),
  ...(obj.ServiceCode && { ServiceCode: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const CardGenerationAttributesFilterSensitiveLog = (obj: CardGenerationAttributes): any => {
  if (obj.AmexCardSecurityCodeVersion1 !== undefined)
    return {
      AmexCardSecurityCodeVersion1: AmexCardSecurityCodeVersion1FilterSensitiveLog(obj.AmexCardSecurityCodeVersion1),
    };
  if (obj.AmexCardSecurityCodeVersion2 !== undefined)
    return {
      AmexCardSecurityCodeVersion2: AmexCardSecurityCodeVersion2FilterSensitiveLog(obj.AmexCardSecurityCodeVersion2),
    };
  if (obj.CardVerificationValue1 !== undefined)
    return { CardVerificationValue1: CardVerificationValue1FilterSensitiveLog(obj.CardVerificationValue1) };
  if (obj.CardVerificationValue2 !== undefined)
    return { CardVerificationValue2: CardVerificationValue2FilterSensitiveLog(obj.CardVerificationValue2) };
  if (obj.CardHolderVerificationValue !== undefined)
    return { CardHolderVerificationValue: obj.CardHolderVerificationValue };
  if (obj.DynamicCardVerificationCode !== undefined)
    return {
      DynamicCardVerificationCode: DynamicCardVerificationCodeFilterSensitiveLog(obj.DynamicCardVerificationCode),
    };
  if (obj.DynamicCardVerificationValue !== undefined)
    return {
      DynamicCardVerificationValue: DynamicCardVerificationValueFilterSensitiveLog(obj.DynamicCardVerificationValue),
    };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const DiscoverDynamicCardVerificationCodeFilterSensitiveLog = (
  obj: DiscoverDynamicCardVerificationCode
): any => ({
  ...obj,
  ...(obj.CardExpiryDate && { CardExpiryDate: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const CardVerificationAttributesFilterSensitiveLog = (obj: CardVerificationAttributes): any => {
  if (obj.AmexCardSecurityCodeVersion1 !== undefined)
    return {
      AmexCardSecurityCodeVersion1: AmexCardSecurityCodeVersion1FilterSensitiveLog(obj.AmexCardSecurityCodeVersion1),
    };
  if (obj.AmexCardSecurityCodeVersion2 !== undefined)
    return {
      AmexCardSecurityCodeVersion2: AmexCardSecurityCodeVersion2FilterSensitiveLog(obj.AmexCardSecurityCodeVersion2),
    };
  if (obj.CardVerificationValue1 !== undefined)
    return { CardVerificationValue1: CardVerificationValue1FilterSensitiveLog(obj.CardVerificationValue1) };
  if (obj.CardVerificationValue2 !== undefined)
    return { CardVerificationValue2: CardVerificationValue2FilterSensitiveLog(obj.CardVerificationValue2) };
  if (obj.CardHolderVerificationValue !== undefined)
    return { CardHolderVerificationValue: obj.CardHolderVerificationValue };
  if (obj.DynamicCardVerificationCode !== undefined)
    return {
      DynamicCardVerificationCode: DynamicCardVerificationCodeFilterSensitiveLog(obj.DynamicCardVerificationCode),
    };
  if (obj.DynamicCardVerificationValue !== undefined)
    return {
      DynamicCardVerificationValue: DynamicCardVerificationValueFilterSensitiveLog(obj.DynamicCardVerificationValue),
    };
  if (obj.DiscoverDynamicCardVerificationCode !== undefined)
    return {
      DiscoverDynamicCardVerificationCode: DiscoverDynamicCardVerificationCodeFilterSensitiveLog(
        obj.DiscoverDynamicCardVerificationCode
      ),
    };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const CryptogramVerificationArpcMethod2FilterSensitiveLog = (obj: CryptogramVerificationArpcMethod2): any => ({
  ...obj,
  ...(obj.ProprietaryAuthenticationData && { ProprietaryAuthenticationData: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const CryptogramAuthResponseFilterSensitiveLog = (obj: CryptogramAuthResponse): any => {
  if (obj.ArpcMethod1 !== undefined) return { ArpcMethod1: obj.ArpcMethod1 };
  if (obj.ArpcMethod2 !== undefined)
    return { ArpcMethod2: CryptogramVerificationArpcMethod2FilterSensitiveLog(obj.ArpcMethod2) };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const DukptEncryptionAttributesFilterSensitiveLog = (obj: DukptEncryptionAttributes): any => ({
  ...obj,
  ...(obj.InitializationVector && { InitializationVector: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const EmvEncryptionAttributesFilterSensitiveLog = (obj: EmvEncryptionAttributes): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
  ...(obj.SessionDerivationData && { SessionDerivationData: SENSITIVE_STRING }),
  ...(obj.InitializationVector && { InitializationVector: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const SymmetricEncryptionAttributesFilterSensitiveLog = (obj: SymmetricEncryptionAttributes): any => ({
  ...obj,
  ...(obj.InitializationVector && { InitializationVector: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const EncryptionDecryptionAttributesFilterSensitiveLog = (obj: EncryptionDecryptionAttributes): any => {
  if (obj.Symmetric !== undefined) return { Symmetric: SymmetricEncryptionAttributesFilterSensitiveLog(obj.Symmetric) };
  if (obj.Asymmetric !== undefined) return { Asymmetric: obj.Asymmetric };
  if (obj.Dukpt !== undefined) return { Dukpt: DukptEncryptionAttributesFilterSensitiveLog(obj.Dukpt) };
  if (obj.Emv !== undefined) return { Emv: EmvEncryptionAttributesFilterSensitiveLog(obj.Emv) };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const EcdhDerivationAttributesFilterSensitiveLog = (obj: EcdhDerivationAttributes): any => ({
  ...obj,
  ...(obj.PublicKeyCertificate && { PublicKeyCertificate: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const WrappedKeyMaterialFilterSensitiveLog = (obj: WrappedKeyMaterial): any => {
  if (obj.Tr31KeyBlock !== undefined) return { Tr31KeyBlock: SENSITIVE_STRING };
  if (obj.DiffieHellmanSymmetricKey !== undefined)
    return { DiffieHellmanSymmetricKey: EcdhDerivationAttributesFilterSensitiveLog(obj.DiffieHellmanSymmetricKey) };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const WrappedKeyFilterSensitiveLog = (obj: WrappedKey): any => ({
  ...obj,
  ...(obj.WrappedKeyMaterial && { WrappedKeyMaterial: WrappedKeyMaterialFilterSensitiveLog(obj.WrappedKeyMaterial) }),
});

/**
 * @internal
 */
export const DecryptDataInputFilterSensitiveLog = (obj: DecryptDataInput): any => ({
  ...obj,
  ...(obj.CipherText && { CipherText: SENSITIVE_STRING }),
  ...(obj.DecryptionAttributes && {
    DecryptionAttributes: EncryptionDecryptionAttributesFilterSensitiveLog(obj.DecryptionAttributes),
  }),
  ...(obj.WrappedKey && { WrappedKey: WrappedKeyFilterSensitiveLog(obj.WrappedKey) }),
});

/**
 * @internal
 */
export const DecryptDataOutputFilterSensitiveLog = (obj: DecryptDataOutput): any => ({
  ...obj,
  ...(obj.PlainText && { PlainText: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const Emv2000AttributesFilterSensitiveLog = (obj: Emv2000Attributes): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const EmvCommonAttributesFilterSensitiveLog = (obj: EmvCommonAttributes): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
  ...(obj.ApplicationCryptogram && { ApplicationCryptogram: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const MasterCardAttributesFilterSensitiveLog = (obj: MasterCardAttributes): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
  ...(obj.ApplicationCryptogram && { ApplicationCryptogram: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const VisaAttributesFilterSensitiveLog = (obj: VisaAttributes): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
  ...(obj.CurrentPinAttributes && {
    CurrentPinAttributes: CurrentPinAttributesFilterSensitiveLog(obj.CurrentPinAttributes),
  }),
});

/**
 * @internal
 */
export const DerivationMethodAttributesFilterSensitiveLog = (obj: DerivationMethodAttributes): any => {
  if (obj.EmvCommon !== undefined) return { EmvCommon: EmvCommonAttributesFilterSensitiveLog(obj.EmvCommon) };
  if (obj.Amex !== undefined) return { Amex: AmexAttributesFilterSensitiveLog(obj.Amex) };
  if (obj.Visa !== undefined) return { Visa: VisaAttributesFilterSensitiveLog(obj.Visa) };
  if (obj.Emv2000 !== undefined) return { Emv2000: Emv2000AttributesFilterSensitiveLog(obj.Emv2000) };
  if (obj.Mastercard !== undefined) return { Mastercard: MasterCardAttributesFilterSensitiveLog(obj.Mastercard) };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const EncryptDataInputFilterSensitiveLog = (obj: EncryptDataInput): any => ({
  ...obj,
  ...(obj.PlainText && { PlainText: SENSITIVE_STRING }),
  ...(obj.EncryptionAttributes && {
    EncryptionAttributes: EncryptionDecryptionAttributesFilterSensitiveLog(obj.EncryptionAttributes),
  }),
  ...(obj.WrappedKey && { WrappedKey: WrappedKeyFilterSensitiveLog(obj.WrappedKey) }),
});

/**
 * @internal
 */
export const EncryptDataOutputFilterSensitiveLog = (obj: EncryptDataOutput): any => ({
  ...obj,
  ...(obj.CipherText && { CipherText: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const GenerateCardValidationDataInputFilterSensitiveLog = (obj: GenerateCardValidationDataInput): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
  ...(obj.GenerationAttributes && {
    GenerationAttributes: CardGenerationAttributesFilterSensitiveLog(obj.GenerationAttributes),
  }),
});

/**
 * @internal
 */
export const GenerateCardValidationDataOutputFilterSensitiveLog = (obj: GenerateCardValidationDataOutput): any => ({
  ...obj,
  ...(obj.ValidationData && { ValidationData: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const SessionKeyDerivationValueFilterSensitiveLog = (obj: SessionKeyDerivationValue): any => {
  if (obj.ApplicationCryptogram !== undefined) return { ApplicationCryptogram: SENSITIVE_STRING };
  if (obj.ApplicationTransactionCounter !== undefined)
    return { ApplicationTransactionCounter: obj.ApplicationTransactionCounter };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const MacAlgorithmEmvFilterSensitiveLog = (obj: MacAlgorithmEmv): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
  ...(obj.SessionKeyDerivationValue && {
    SessionKeyDerivationValue: SessionKeyDerivationValueFilterSensitiveLog(obj.SessionKeyDerivationValue),
  }),
});

/**
 * @internal
 */
export const MacAttributesFilterSensitiveLog = (obj: MacAttributes): any => {
  if (obj.Algorithm !== undefined) return { Algorithm: obj.Algorithm };
  if (obj.EmvMac !== undefined) return { EmvMac: MacAlgorithmEmvFilterSensitiveLog(obj.EmvMac) };
  if (obj.DukptIso9797Algorithm1 !== undefined) return { DukptIso9797Algorithm1: obj.DukptIso9797Algorithm1 };
  if (obj.DukptIso9797Algorithm3 !== undefined) return { DukptIso9797Algorithm3: obj.DukptIso9797Algorithm3 };
  if (obj.DukptCmac !== undefined) return { DukptCmac: obj.DukptCmac };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const GenerateMacInputFilterSensitiveLog = (obj: GenerateMacInput): any => ({
  ...obj,
  ...(obj.MessageData && { MessageData: SENSITIVE_STRING }),
  ...(obj.GenerationAttributes && { GenerationAttributes: MacAttributesFilterSensitiveLog(obj.GenerationAttributes) }),
});

/**
 * @internal
 */
export const GenerateMacOutputFilterSensitiveLog = (obj: GenerateMacOutput): any => ({
  ...obj,
  ...(obj.Mac && { Mac: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const GenerateMacEmvPinChangeInputFilterSensitiveLog = (obj: GenerateMacEmvPinChangeInput): any => ({
  ...obj,
  ...(obj.NewEncryptedPinBlock && { NewEncryptedPinBlock: SENSITIVE_STRING }),
  ...(obj.MessageData && { MessageData: SENSITIVE_STRING }),
  ...(obj.DerivationMethodAttributes && {
    DerivationMethodAttributes: DerivationMethodAttributesFilterSensitiveLog(obj.DerivationMethodAttributes),
  }),
});

/**
 * @internal
 */
export const GenerateMacEmvPinChangeOutputFilterSensitiveLog = (obj: GenerateMacEmvPinChangeOutput): any => ({
  ...obj,
  ...(obj.Mac && { Mac: SENSITIVE_STRING }),
  ...(obj.EncryptedPinBlock && { EncryptedPinBlock: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const Ibm3624NaturalPinFilterSensitiveLog = (obj: Ibm3624NaturalPin): any => ({
  ...obj,
  ...(obj.DecimalizationTable && { DecimalizationTable: SENSITIVE_STRING }),
  ...(obj.PinValidationData && { PinValidationData: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const Ibm3624PinFromOffsetFilterSensitiveLog = (obj: Ibm3624PinFromOffset): any => ({
  ...obj,
  ...(obj.DecimalizationTable && { DecimalizationTable: SENSITIVE_STRING }),
  ...(obj.PinValidationData && { PinValidationData: SENSITIVE_STRING }),
  ...(obj.PinOffset && { PinOffset: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const Ibm3624PinOffsetFilterSensitiveLog = (obj: Ibm3624PinOffset): any => ({
  ...obj,
  ...(obj.EncryptedPinBlock && { EncryptedPinBlock: SENSITIVE_STRING }),
  ...(obj.DecimalizationTable && { DecimalizationTable: SENSITIVE_STRING }),
  ...(obj.PinValidationData && { PinValidationData: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const Ibm3624RandomPinFilterSensitiveLog = (obj: Ibm3624RandomPin): any => ({
  ...obj,
  ...(obj.DecimalizationTable && { DecimalizationTable: SENSITIVE_STRING }),
  ...(obj.PinValidationData && { PinValidationData: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const VisaPinVerificationValueFilterSensitiveLog = (obj: VisaPinVerificationValue): any => ({
  ...obj,
  ...(obj.EncryptedPinBlock && { EncryptedPinBlock: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const PinGenerationAttributesFilterSensitiveLog = (obj: PinGenerationAttributes): any => {
  if (obj.VisaPin !== undefined) return { VisaPin: obj.VisaPin };
  if (obj.VisaPinVerificationValue !== undefined)
    return { VisaPinVerificationValue: VisaPinVerificationValueFilterSensitiveLog(obj.VisaPinVerificationValue) };
  if (obj.Ibm3624PinOffset !== undefined)
    return { Ibm3624PinOffset: Ibm3624PinOffsetFilterSensitiveLog(obj.Ibm3624PinOffset) };
  if (obj.Ibm3624NaturalPin !== undefined)
    return { Ibm3624NaturalPin: Ibm3624NaturalPinFilterSensitiveLog(obj.Ibm3624NaturalPin) };
  if (obj.Ibm3624RandomPin !== undefined)
    return { Ibm3624RandomPin: Ibm3624RandomPinFilterSensitiveLog(obj.Ibm3624RandomPin) };
  if (obj.Ibm3624PinFromOffset !== undefined)
    return { Ibm3624PinFromOffset: Ibm3624PinFromOffsetFilterSensitiveLog(obj.Ibm3624PinFromOffset) };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const GeneratePinDataInputFilterSensitiveLog = (obj: GeneratePinDataInput): any => ({
  ...obj,
  ...(obj.GenerationAttributes && {
    GenerationAttributes: PinGenerationAttributesFilterSensitiveLog(obj.GenerationAttributes),
  }),
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
  ...(obj.EncryptionWrappedKey && { EncryptionWrappedKey: WrappedKeyFilterSensitiveLog(obj.EncryptionWrappedKey) }),
});

/**
 * @internal
 */
export const PinDataFilterSensitiveLog = (obj: PinData): any => {
  if (obj.PinOffset !== undefined) return { PinOffset: SENSITIVE_STRING };
  if (obj.VerificationValue !== undefined) return { VerificationValue: SENSITIVE_STRING };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const GeneratePinDataOutputFilterSensitiveLog = (obj: GeneratePinDataOutput): any => ({
  ...obj,
  ...(obj.EncryptedPinBlock && { EncryptedPinBlock: SENSITIVE_STRING }),
  ...(obj.PinData && { PinData: PinDataFilterSensitiveLog(obj.PinData) }),
});

/**
 * @internal
 */
export const Ibm3624PinVerificationFilterSensitiveLog = (obj: Ibm3624PinVerification): any => ({
  ...obj,
  ...(obj.DecimalizationTable && { DecimalizationTable: SENSITIVE_STRING }),
  ...(obj.PinValidationData && { PinValidationData: SENSITIVE_STRING }),
  ...(obj.PinOffset && { PinOffset: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const ReEncryptionAttributesFilterSensitiveLog = (obj: ReEncryptionAttributes): any => {
  if (obj.Symmetric !== undefined) return { Symmetric: SymmetricEncryptionAttributesFilterSensitiveLog(obj.Symmetric) };
  if (obj.Dukpt !== undefined) return { Dukpt: DukptEncryptionAttributesFilterSensitiveLog(obj.Dukpt) };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const ReEncryptDataInputFilterSensitiveLog = (obj: ReEncryptDataInput): any => ({
  ...obj,
  ...(obj.CipherText && { CipherText: SENSITIVE_STRING }),
  ...(obj.IncomingEncryptionAttributes && {
    IncomingEncryptionAttributes: ReEncryptionAttributesFilterSensitiveLog(obj.IncomingEncryptionAttributes),
  }),
  ...(obj.OutgoingEncryptionAttributes && {
    OutgoingEncryptionAttributes: ReEncryptionAttributesFilterSensitiveLog(obj.OutgoingEncryptionAttributes),
  }),
  ...(obj.IncomingWrappedKey && { IncomingWrappedKey: WrappedKeyFilterSensitiveLog(obj.IncomingWrappedKey) }),
  ...(obj.OutgoingWrappedKey && { OutgoingWrappedKey: WrappedKeyFilterSensitiveLog(obj.OutgoingWrappedKey) }),
});

/**
 * @internal
 */
export const ReEncryptDataOutputFilterSensitiveLog = (obj: ReEncryptDataOutput): any => ({
  ...obj,
  ...(obj.CipherText && { CipherText: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const TranslationPinDataIsoFormat034FilterSensitiveLog = (obj: TranslationPinDataIsoFormat034): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const TranslationIsoFormatsFilterSensitiveLog = (obj: TranslationIsoFormats): any => {
  if (obj.IsoFormat0 !== undefined)
    return { IsoFormat0: TranslationPinDataIsoFormat034FilterSensitiveLog(obj.IsoFormat0) };
  if (obj.IsoFormat1 !== undefined) return { IsoFormat1: obj.IsoFormat1 };
  if (obj.IsoFormat3 !== undefined)
    return { IsoFormat3: TranslationPinDataIsoFormat034FilterSensitiveLog(obj.IsoFormat3) };
  if (obj.IsoFormat4 !== undefined)
    return { IsoFormat4: TranslationPinDataIsoFormat034FilterSensitiveLog(obj.IsoFormat4) };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const TranslatePinDataInputFilterSensitiveLog = (obj: TranslatePinDataInput): any => ({
  ...obj,
  ...(obj.IncomingTranslationAttributes && {
    IncomingTranslationAttributes: TranslationIsoFormatsFilterSensitiveLog(obj.IncomingTranslationAttributes),
  }),
  ...(obj.OutgoingTranslationAttributes && {
    OutgoingTranslationAttributes: TranslationIsoFormatsFilterSensitiveLog(obj.OutgoingTranslationAttributes),
  }),
  ...(obj.EncryptedPinBlock && { EncryptedPinBlock: SENSITIVE_STRING }),
  ...(obj.IncomingWrappedKey && { IncomingWrappedKey: WrappedKeyFilterSensitiveLog(obj.IncomingWrappedKey) }),
  ...(obj.OutgoingWrappedKey && { OutgoingWrappedKey: WrappedKeyFilterSensitiveLog(obj.OutgoingWrappedKey) }),
});

/**
 * @internal
 */
export const TranslatePinDataOutputFilterSensitiveLog = (obj: TranslatePinDataOutput): any => ({
  ...obj,
  ...(obj.PinBlock && { PinBlock: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const SessionKeyAmexFilterSensitiveLog = (obj: SessionKeyAmex): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const SessionKeyEmv2000FilterSensitiveLog = (obj: SessionKeyEmv2000): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const SessionKeyEmvCommonFilterSensitiveLog = (obj: SessionKeyEmvCommon): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const SessionKeyMastercardFilterSensitiveLog = (obj: SessionKeyMastercard): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const SessionKeyVisaFilterSensitiveLog = (obj: SessionKeyVisa): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const SessionKeyDerivationFilterSensitiveLog = (obj: SessionKeyDerivation): any => {
  if (obj.EmvCommon !== undefined) return { EmvCommon: SessionKeyEmvCommonFilterSensitiveLog(obj.EmvCommon) };
  if (obj.Mastercard !== undefined) return { Mastercard: SessionKeyMastercardFilterSensitiveLog(obj.Mastercard) };
  if (obj.Emv2000 !== undefined) return { Emv2000: SessionKeyEmv2000FilterSensitiveLog(obj.Emv2000) };
  if (obj.Amex !== undefined) return { Amex: SessionKeyAmexFilterSensitiveLog(obj.Amex) };
  if (obj.Visa !== undefined) return { Visa: SessionKeyVisaFilterSensitiveLog(obj.Visa) };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const VerifyAuthRequestCryptogramInputFilterSensitiveLog = (obj: VerifyAuthRequestCryptogramInput): any => ({
  ...obj,
  ...(obj.TransactionData && { TransactionData: SENSITIVE_STRING }),
  ...(obj.AuthRequestCryptogram && { AuthRequestCryptogram: SENSITIVE_STRING }),
  ...(obj.SessionKeyDerivationAttributes && {
    SessionKeyDerivationAttributes: SessionKeyDerivationFilterSensitiveLog(obj.SessionKeyDerivationAttributes),
  }),
  ...(obj.AuthResponseAttributes && {
    AuthResponseAttributes: CryptogramAuthResponseFilterSensitiveLog(obj.AuthResponseAttributes),
  }),
});

/**
 * @internal
 */
export const VerifyAuthRequestCryptogramOutputFilterSensitiveLog = (obj: VerifyAuthRequestCryptogramOutput): any => ({
  ...obj,
  ...(obj.AuthResponseValue && { AuthResponseValue: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const VerifyCardValidationDataInputFilterSensitiveLog = (obj: VerifyCardValidationDataInput): any => ({
  ...obj,
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
  ...(obj.VerificationAttributes && {
    VerificationAttributes: CardVerificationAttributesFilterSensitiveLog(obj.VerificationAttributes),
  }),
  ...(obj.ValidationData && { ValidationData: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const VerifyMacInputFilterSensitiveLog = (obj: VerifyMacInput): any => ({
  ...obj,
  ...(obj.MessageData && { MessageData: SENSITIVE_STRING }),
  ...(obj.Mac && { Mac: SENSITIVE_STRING }),
  ...(obj.VerificationAttributes && {
    VerificationAttributes: MacAttributesFilterSensitiveLog(obj.VerificationAttributes),
  }),
});

/**
 * @internal
 */
export const VisaPinVerificationFilterSensitiveLog = (obj: VisaPinVerification): any => ({
  ...obj,
  ...(obj.VerificationValue && { VerificationValue: SENSITIVE_STRING }),
});

/**
 * @internal
 */
export const PinVerificationAttributesFilterSensitiveLog = (obj: PinVerificationAttributes): any => {
  if (obj.VisaPin !== undefined) return { VisaPin: VisaPinVerificationFilterSensitiveLog(obj.VisaPin) };
  if (obj.Ibm3624Pin !== undefined) return { Ibm3624Pin: Ibm3624PinVerificationFilterSensitiveLog(obj.Ibm3624Pin) };
  if (obj.$unknown !== undefined) return { [obj.$unknown[0]]: "UNKNOWN" };
};

/**
 * @internal
 */
export const VerifyPinDataInputFilterSensitiveLog = (obj: VerifyPinDataInput): any => ({
  ...obj,
  ...(obj.VerificationAttributes && {
    VerificationAttributes: PinVerificationAttributesFilterSensitiveLog(obj.VerificationAttributes),
  }),
  ...(obj.EncryptedPinBlock && { EncryptedPinBlock: SENSITIVE_STRING }),
  ...(obj.PrimaryAccountNumber && { PrimaryAccountNumber: SENSITIVE_STRING }),
  ...(obj.EncryptionWrappedKey && { EncryptionWrappedKey: WrappedKeyFilterSensitiveLog(obj.EncryptionWrappedKey) }),
});
