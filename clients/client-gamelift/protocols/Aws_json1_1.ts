import {
  AcceptMatchCommandInput,
  AcceptMatchCommandOutput
} from "../commands/AcceptMatchCommand";
import {
  CreateAliasCommandInput,
  CreateAliasCommandOutput
} from "../commands/CreateAliasCommand";
import {
  CreateBuildCommandInput,
  CreateBuildCommandOutput
} from "../commands/CreateBuildCommand";
import {
  CreateFleetCommandInput,
  CreateFleetCommandOutput
} from "../commands/CreateFleetCommand";
import {
  CreateGameSessionCommandInput,
  CreateGameSessionCommandOutput
} from "../commands/CreateGameSessionCommand";
import {
  CreateGameSessionQueueCommandInput,
  CreateGameSessionQueueCommandOutput
} from "../commands/CreateGameSessionQueueCommand";
import {
  CreateMatchmakingConfigurationCommandInput,
  CreateMatchmakingConfigurationCommandOutput
} from "../commands/CreateMatchmakingConfigurationCommand";
import {
  CreateMatchmakingRuleSetCommandInput,
  CreateMatchmakingRuleSetCommandOutput
} from "../commands/CreateMatchmakingRuleSetCommand";
import {
  CreatePlayerSessionCommandInput,
  CreatePlayerSessionCommandOutput
} from "../commands/CreatePlayerSessionCommand";
import {
  CreatePlayerSessionsCommandInput,
  CreatePlayerSessionsCommandOutput
} from "../commands/CreatePlayerSessionsCommand";
import {
  CreateScriptCommandInput,
  CreateScriptCommandOutput
} from "../commands/CreateScriptCommand";
import {
  CreateVpcPeeringAuthorizationCommandInput,
  CreateVpcPeeringAuthorizationCommandOutput
} from "../commands/CreateVpcPeeringAuthorizationCommand";
import {
  CreateVpcPeeringConnectionCommandInput,
  CreateVpcPeeringConnectionCommandOutput
} from "../commands/CreateVpcPeeringConnectionCommand";
import {
  DeleteAliasCommandInput,
  DeleteAliasCommandOutput
} from "../commands/DeleteAliasCommand";
import {
  DeleteBuildCommandInput,
  DeleteBuildCommandOutput
} from "../commands/DeleteBuildCommand";
import {
  DeleteFleetCommandInput,
  DeleteFleetCommandOutput
} from "../commands/DeleteFleetCommand";
import {
  DeleteGameSessionQueueCommandInput,
  DeleteGameSessionQueueCommandOutput
} from "../commands/DeleteGameSessionQueueCommand";
import {
  DeleteMatchmakingConfigurationCommandInput,
  DeleteMatchmakingConfigurationCommandOutput
} from "../commands/DeleteMatchmakingConfigurationCommand";
import {
  DeleteMatchmakingRuleSetCommandInput,
  DeleteMatchmakingRuleSetCommandOutput
} from "../commands/DeleteMatchmakingRuleSetCommand";
import {
  DeleteScalingPolicyCommandInput,
  DeleteScalingPolicyCommandOutput
} from "../commands/DeleteScalingPolicyCommand";
import {
  DeleteScriptCommandInput,
  DeleteScriptCommandOutput
} from "../commands/DeleteScriptCommand";
import {
  DeleteVpcPeeringAuthorizationCommandInput,
  DeleteVpcPeeringAuthorizationCommandOutput
} from "../commands/DeleteVpcPeeringAuthorizationCommand";
import {
  DeleteVpcPeeringConnectionCommandInput,
  DeleteVpcPeeringConnectionCommandOutput
} from "../commands/DeleteVpcPeeringConnectionCommand";
import {
  DescribeAliasCommandInput,
  DescribeAliasCommandOutput
} from "../commands/DescribeAliasCommand";
import {
  DescribeBuildCommandInput,
  DescribeBuildCommandOutput
} from "../commands/DescribeBuildCommand";
import {
  DescribeEC2InstanceLimitsCommandInput,
  DescribeEC2InstanceLimitsCommandOutput
} from "../commands/DescribeEC2InstanceLimitsCommand";
import {
  DescribeFleetAttributesCommandInput,
  DescribeFleetAttributesCommandOutput
} from "../commands/DescribeFleetAttributesCommand";
import {
  DescribeFleetCapacityCommandInput,
  DescribeFleetCapacityCommandOutput
} from "../commands/DescribeFleetCapacityCommand";
import {
  DescribeFleetEventsCommandInput,
  DescribeFleetEventsCommandOutput
} from "../commands/DescribeFleetEventsCommand";
import {
  DescribeFleetPortSettingsCommandInput,
  DescribeFleetPortSettingsCommandOutput
} from "../commands/DescribeFleetPortSettingsCommand";
import {
  DescribeFleetUtilizationCommandInput,
  DescribeFleetUtilizationCommandOutput
} from "../commands/DescribeFleetUtilizationCommand";
import {
  DescribeGameSessionDetailsCommandInput,
  DescribeGameSessionDetailsCommandOutput
} from "../commands/DescribeGameSessionDetailsCommand";
import {
  DescribeGameSessionPlacementCommandInput,
  DescribeGameSessionPlacementCommandOutput
} from "../commands/DescribeGameSessionPlacementCommand";
import {
  DescribeGameSessionQueuesCommandInput,
  DescribeGameSessionQueuesCommandOutput
} from "../commands/DescribeGameSessionQueuesCommand";
import {
  DescribeGameSessionsCommandInput,
  DescribeGameSessionsCommandOutput
} from "../commands/DescribeGameSessionsCommand";
import {
  DescribeInstancesCommandInput,
  DescribeInstancesCommandOutput
} from "../commands/DescribeInstancesCommand";
import {
  DescribeMatchmakingCommandInput,
  DescribeMatchmakingCommandOutput
} from "../commands/DescribeMatchmakingCommand";
import {
  DescribeMatchmakingConfigurationsCommandInput,
  DescribeMatchmakingConfigurationsCommandOutput
} from "../commands/DescribeMatchmakingConfigurationsCommand";
import {
  DescribeMatchmakingRuleSetsCommandInput,
  DescribeMatchmakingRuleSetsCommandOutput
} from "../commands/DescribeMatchmakingRuleSetsCommand";
import {
  DescribePlayerSessionsCommandInput,
  DescribePlayerSessionsCommandOutput
} from "../commands/DescribePlayerSessionsCommand";
import {
  DescribeRuntimeConfigurationCommandInput,
  DescribeRuntimeConfigurationCommandOutput
} from "../commands/DescribeRuntimeConfigurationCommand";
import {
  DescribeScalingPoliciesCommandInput,
  DescribeScalingPoliciesCommandOutput
} from "../commands/DescribeScalingPoliciesCommand";
import {
  DescribeScriptCommandInput,
  DescribeScriptCommandOutput
} from "../commands/DescribeScriptCommand";
import {
  DescribeVpcPeeringAuthorizationsCommandInput,
  DescribeVpcPeeringAuthorizationsCommandOutput
} from "../commands/DescribeVpcPeeringAuthorizationsCommand";
import {
  DescribeVpcPeeringConnectionsCommandInput,
  DescribeVpcPeeringConnectionsCommandOutput
} from "../commands/DescribeVpcPeeringConnectionsCommand";
import {
  GetGameSessionLogUrlCommandInput,
  GetGameSessionLogUrlCommandOutput
} from "../commands/GetGameSessionLogUrlCommand";
import {
  GetInstanceAccessCommandInput,
  GetInstanceAccessCommandOutput
} from "../commands/GetInstanceAccessCommand";
import {
  ListAliasesCommandInput,
  ListAliasesCommandOutput
} from "../commands/ListAliasesCommand";
import {
  ListBuildsCommandInput,
  ListBuildsCommandOutput
} from "../commands/ListBuildsCommand";
import {
  ListFleetsCommandInput,
  ListFleetsCommandOutput
} from "../commands/ListFleetsCommand";
import {
  ListScriptsCommandInput,
  ListScriptsCommandOutput
} from "../commands/ListScriptsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  PutScalingPolicyCommandInput,
  PutScalingPolicyCommandOutput
} from "../commands/PutScalingPolicyCommand";
import {
  RequestUploadCredentialsCommandInput,
  RequestUploadCredentialsCommandOutput
} from "../commands/RequestUploadCredentialsCommand";
import {
  ResolveAliasCommandInput,
  ResolveAliasCommandOutput
} from "../commands/ResolveAliasCommand";
import {
  SearchGameSessionsCommandInput,
  SearchGameSessionsCommandOutput
} from "../commands/SearchGameSessionsCommand";
import {
  StartFleetActionsCommandInput,
  StartFleetActionsCommandOutput
} from "../commands/StartFleetActionsCommand";
import {
  StartGameSessionPlacementCommandInput,
  StartGameSessionPlacementCommandOutput
} from "../commands/StartGameSessionPlacementCommand";
import {
  StartMatchBackfillCommandInput,
  StartMatchBackfillCommandOutput
} from "../commands/StartMatchBackfillCommand";
import {
  StartMatchmakingCommandInput,
  StartMatchmakingCommandOutput
} from "../commands/StartMatchmakingCommand";
import {
  StopFleetActionsCommandInput,
  StopFleetActionsCommandOutput
} from "../commands/StopFleetActionsCommand";
import {
  StopGameSessionPlacementCommandInput,
  StopGameSessionPlacementCommandOutput
} from "../commands/StopGameSessionPlacementCommand";
import {
  StopMatchmakingCommandInput,
  StopMatchmakingCommandOutput
} from "../commands/StopMatchmakingCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateAliasCommandInput,
  UpdateAliasCommandOutput
} from "../commands/UpdateAliasCommand";
import {
  UpdateBuildCommandInput,
  UpdateBuildCommandOutput
} from "../commands/UpdateBuildCommand";
import {
  UpdateFleetAttributesCommandInput,
  UpdateFleetAttributesCommandOutput
} from "../commands/UpdateFleetAttributesCommand";
import {
  UpdateFleetCapacityCommandInput,
  UpdateFleetCapacityCommandOutput
} from "../commands/UpdateFleetCapacityCommand";
import {
  UpdateFleetPortSettingsCommandInput,
  UpdateFleetPortSettingsCommandOutput
} from "../commands/UpdateFleetPortSettingsCommand";
import {
  UpdateGameSessionCommandInput,
  UpdateGameSessionCommandOutput
} from "../commands/UpdateGameSessionCommand";
import {
  UpdateGameSessionQueueCommandInput,
  UpdateGameSessionQueueCommandOutput
} from "../commands/UpdateGameSessionQueueCommand";
import {
  UpdateMatchmakingConfigurationCommandInput,
  UpdateMatchmakingConfigurationCommandOutput
} from "../commands/UpdateMatchmakingConfigurationCommand";
import {
  UpdateRuntimeConfigurationCommandInput,
  UpdateRuntimeConfigurationCommandOutput
} from "../commands/UpdateRuntimeConfigurationCommand";
import {
  UpdateScriptCommandInput,
  UpdateScriptCommandOutput
} from "../commands/UpdateScriptCommand";
import {
  ValidateMatchmakingRuleSetCommandInput,
  ValidateMatchmakingRuleSetCommandOutput
} from "../commands/ValidateMatchmakingRuleSetCommand";
import {
  AcceptMatchInput,
  AcceptMatchOutput,
  Alias,
  AttributeValue,
  AwsCredentials,
  Build,
  CertificateConfiguration,
  ConflictException,
  CreateAliasInput,
  CreateAliasOutput,
  CreateBuildInput,
  CreateBuildOutput,
  CreateFleetInput,
  CreateFleetOutput,
  CreateGameSessionInput,
  CreateGameSessionOutput,
  CreateGameSessionQueueInput,
  CreateGameSessionQueueOutput,
  CreateMatchmakingConfigurationInput,
  CreateMatchmakingConfigurationOutput,
  CreateMatchmakingRuleSetInput,
  CreateMatchmakingRuleSetOutput,
  CreatePlayerSessionInput,
  CreatePlayerSessionOutput,
  CreatePlayerSessionsInput,
  CreatePlayerSessionsOutput,
  CreateScriptInput,
  CreateScriptOutput,
  CreateVpcPeeringAuthorizationInput,
  CreateVpcPeeringAuthorizationOutput,
  CreateVpcPeeringConnectionInput,
  CreateVpcPeeringConnectionOutput,
  DeleteAliasInput,
  DeleteBuildInput,
  DeleteFleetInput,
  DeleteGameSessionQueueInput,
  DeleteGameSessionQueueOutput,
  DeleteMatchmakingConfigurationInput,
  DeleteMatchmakingConfigurationOutput,
  DeleteMatchmakingRuleSetInput,
  DeleteMatchmakingRuleSetOutput,
  DeleteScalingPolicyInput,
  DeleteScriptInput,
  DeleteVpcPeeringAuthorizationInput,
  DeleteVpcPeeringAuthorizationOutput,
  DeleteVpcPeeringConnectionInput,
  DeleteVpcPeeringConnectionOutput,
  DescribeAliasInput,
  DescribeAliasOutput,
  DescribeBuildInput,
  DescribeBuildOutput,
  DescribeEC2InstanceLimitsInput,
  DescribeEC2InstanceLimitsOutput,
  DescribeFleetAttributesInput,
  DescribeFleetAttributesOutput,
  DescribeFleetCapacityInput,
  DescribeFleetCapacityOutput,
  DescribeFleetEventsInput,
  DescribeFleetEventsOutput,
  DescribeFleetPortSettingsInput,
  DescribeFleetPortSettingsOutput,
  DescribeFleetUtilizationInput,
  DescribeFleetUtilizationOutput,
  DescribeGameSessionDetailsInput,
  DescribeGameSessionDetailsOutput,
  DescribeGameSessionPlacementInput,
  DescribeGameSessionPlacementOutput,
  DescribeGameSessionQueuesInput,
  DescribeGameSessionQueuesOutput,
  DescribeGameSessionsInput,
  DescribeGameSessionsOutput,
  DescribeInstancesInput,
  DescribeInstancesOutput,
  DescribeMatchmakingConfigurationsInput,
  DescribeMatchmakingConfigurationsOutput,
  DescribeMatchmakingInput,
  DescribeMatchmakingOutput,
  DescribeMatchmakingRuleSetsInput,
  DescribeMatchmakingRuleSetsOutput,
  DescribePlayerSessionsInput,
  DescribePlayerSessionsOutput,
  DescribeRuntimeConfigurationInput,
  DescribeRuntimeConfigurationOutput,
  DescribeScalingPoliciesInput,
  DescribeScalingPoliciesOutput,
  DescribeScriptInput,
  DescribeScriptOutput,
  DescribeVpcPeeringAuthorizationsInput,
  DescribeVpcPeeringAuthorizationsOutput,
  DescribeVpcPeeringConnectionsInput,
  DescribeVpcPeeringConnectionsOutput,
  DesiredPlayerSession,
  EC2InstanceCounts,
  EC2InstanceLimit,
  Event,
  FleetAction,
  FleetAttributes,
  FleetCapacity,
  FleetCapacityExceededException,
  FleetUtilization,
  GameProperty,
  GameSession,
  GameSessionConnectionInfo,
  GameSessionDetail,
  GameSessionFullException,
  GameSessionPlacement,
  GameSessionQueue,
  GameSessionQueueDestination,
  GetGameSessionLogUrlInput,
  GetGameSessionLogUrlOutput,
  GetInstanceAccessInput,
  GetInstanceAccessOutput,
  IdempotentParameterMismatchException,
  Instance,
  InstanceAccess,
  InstanceCredentials,
  InternalServiceException,
  InvalidFleetStatusException,
  InvalidGameSessionStatusException,
  InvalidRequestException,
  IpPermission,
  LimitExceededException,
  ListAliasesInput,
  ListAliasesOutput,
  ListBuildsInput,
  ListBuildsOutput,
  ListFleetsInput,
  ListFleetsOutput,
  ListScriptsInput,
  ListScriptsOutput,
  ListTagsForResourceRequest,
  ListTagsForResourceResponse,
  MatchedPlayerSession,
  MatchmakingConfiguration,
  MatchmakingRuleSet,
  MatchmakingTicket,
  NotFoundException,
  PlacedPlayerSession,
  Player,
  PlayerLatency,
  PlayerLatencyPolicy,
  PlayerSession,
  PutScalingPolicyInput,
  PutScalingPolicyOutput,
  RequestUploadCredentialsInput,
  RequestUploadCredentialsOutput,
  ResolveAliasInput,
  ResolveAliasOutput,
  ResourceCreationLimitPolicy,
  RoutingStrategy,
  RuntimeConfiguration,
  S3Location,
  ScalingPolicy,
  Script,
  SearchGameSessionsInput,
  SearchGameSessionsOutput,
  ServerProcess,
  StartFleetActionsInput,
  StartFleetActionsOutput,
  StartGameSessionPlacementInput,
  StartGameSessionPlacementOutput,
  StartMatchBackfillInput,
  StartMatchBackfillOutput,
  StartMatchmakingInput,
  StartMatchmakingOutput,
  StopFleetActionsInput,
  StopFleetActionsOutput,
  StopGameSessionPlacementInput,
  StopGameSessionPlacementOutput,
  StopMatchmakingInput,
  StopMatchmakingOutput,
  Tag,
  TagResourceRequest,
  TagResourceResponse,
  TaggingFailedException,
  TargetConfiguration,
  TerminalRoutingStrategyException,
  UnauthorizedException,
  UnsupportedRegionException,
  UntagResourceRequest,
  UntagResourceResponse,
  UpdateAliasInput,
  UpdateAliasOutput,
  UpdateBuildInput,
  UpdateBuildOutput,
  UpdateFleetAttributesInput,
  UpdateFleetAttributesOutput,
  UpdateFleetCapacityInput,
  UpdateFleetCapacityOutput,
  UpdateFleetPortSettingsInput,
  UpdateFleetPortSettingsOutput,
  UpdateGameSessionInput,
  UpdateGameSessionOutput,
  UpdateGameSessionQueueInput,
  UpdateGameSessionQueueOutput,
  UpdateMatchmakingConfigurationInput,
  UpdateMatchmakingConfigurationOutput,
  UpdateRuntimeConfigurationInput,
  UpdateRuntimeConfigurationOutput,
  UpdateScriptInput,
  UpdateScriptOutput,
  ValidateMatchmakingRuleSetInput,
  ValidateMatchmakingRuleSetOutput,
  VpcPeeringAuthorization,
  VpcPeeringConnection,
  VpcPeeringConnectionStatus
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_json1_1AcceptMatchCommand(
  input: AcceptMatchCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.AcceptMatch";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1AcceptMatchInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateAliasCommand(
  input: CreateAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreateAlias";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateAliasInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateBuildCommand(
  input: CreateBuildCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreateBuild";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateBuildInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateFleetCommand(
  input: CreateFleetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreateFleet";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateFleetInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateGameSessionCommand(
  input: CreateGameSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreateGameSession";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateGameSessionInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateGameSessionQueueCommand(
  input: CreateGameSessionQueueCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreateGameSessionQueue";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateGameSessionQueueInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateMatchmakingConfigurationCommand(
  input: CreateMatchmakingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreateMatchmakingConfiguration";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateMatchmakingConfigurationInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateMatchmakingRuleSetCommand(
  input: CreateMatchmakingRuleSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreateMatchmakingRuleSet";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateMatchmakingRuleSetInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreatePlayerSessionCommand(
  input: CreatePlayerSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreatePlayerSession";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreatePlayerSessionInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreatePlayerSessionsCommand(
  input: CreatePlayerSessionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreatePlayerSessions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreatePlayerSessionsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateScriptCommand(
  input: CreateScriptCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreateScript";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1CreateScriptInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateVpcPeeringAuthorizationCommand(
  input: CreateVpcPeeringAuthorizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreateVpcPeeringAuthorization";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateVpcPeeringAuthorizationInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateVpcPeeringConnectionCommand(
  input: CreateVpcPeeringConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.CreateVpcPeeringConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateVpcPeeringConnectionInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteAliasCommand(
  input: DeleteAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DeleteAlias";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteAliasInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteBuildCommand(
  input: DeleteBuildCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DeleteBuild";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteBuildInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteFleetCommand(
  input: DeleteFleetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DeleteFleet";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteFleetInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteGameSessionQueueCommand(
  input: DeleteGameSessionQueueCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DeleteGameSessionQueue";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteGameSessionQueueInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteMatchmakingConfigurationCommand(
  input: DeleteMatchmakingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DeleteMatchmakingConfiguration";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteMatchmakingConfigurationInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteMatchmakingRuleSetCommand(
  input: DeleteMatchmakingRuleSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DeleteMatchmakingRuleSet";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteMatchmakingRuleSetInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteScalingPolicyCommand(
  input: DeleteScalingPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DeleteScalingPolicy";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteScalingPolicyInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteScriptCommand(
  input: DeleteScriptCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DeleteScript";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DeleteScriptInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteVpcPeeringAuthorizationCommand(
  input: DeleteVpcPeeringAuthorizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DeleteVpcPeeringAuthorization";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteVpcPeeringAuthorizationInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteVpcPeeringConnectionCommand(
  input: DeleteVpcPeeringConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DeleteVpcPeeringConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteVpcPeeringConnectionInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeAliasCommand(
  input: DescribeAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeAlias";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeAliasInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeBuildCommand(
  input: DescribeBuildCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeBuild";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1DescribeBuildInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEC2InstanceLimitsCommand(
  input: DescribeEC2InstanceLimitsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeEC2InstanceLimits";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEC2InstanceLimitsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeFleetAttributesCommand(
  input: DescribeFleetAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeFleetAttributes";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeFleetAttributesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeFleetCapacityCommand(
  input: DescribeFleetCapacityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeFleetCapacity";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeFleetCapacityInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeFleetEventsCommand(
  input: DescribeFleetEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeFleetEvents";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeFleetEventsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeFleetPortSettingsCommand(
  input: DescribeFleetPortSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeFleetPortSettings";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeFleetPortSettingsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeFleetUtilizationCommand(
  input: DescribeFleetUtilizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeFleetUtilization";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeFleetUtilizationInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeGameSessionDetailsCommand(
  input: DescribeGameSessionDetailsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeGameSessionDetails";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeGameSessionDetailsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeGameSessionPlacementCommand(
  input: DescribeGameSessionPlacementCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeGameSessionPlacement";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeGameSessionPlacementInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeGameSessionQueuesCommand(
  input: DescribeGameSessionQueuesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeGameSessionQueues";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeGameSessionQueuesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeGameSessionsCommand(
  input: DescribeGameSessionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeGameSessions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeGameSessionsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeInstancesCommand(
  input: DescribeInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeInstances";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeInstancesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMatchmakingCommand(
  input: DescribeMatchmakingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeMatchmaking";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMatchmakingInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMatchmakingConfigurationsCommand(
  input: DescribeMatchmakingConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeMatchmakingConfigurations";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMatchmakingConfigurationsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeMatchmakingRuleSetsCommand(
  input: DescribeMatchmakingRuleSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeMatchmakingRuleSets";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeMatchmakingRuleSetsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribePlayerSessionsCommand(
  input: DescribePlayerSessionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribePlayerSessions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribePlayerSessionsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeRuntimeConfigurationCommand(
  input: DescribeRuntimeConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeRuntimeConfiguration";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeRuntimeConfigurationInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeScalingPoliciesCommand(
  input: DescribeScalingPoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeScalingPolicies";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeScalingPoliciesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeScriptCommand(
  input: DescribeScriptCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeScript";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeScriptInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeVpcPeeringAuthorizationsCommand(
  input: DescribeVpcPeeringAuthorizationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeVpcPeeringAuthorizations";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeVpcPeeringAuthorizationsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeVpcPeeringConnectionsCommand(
  input: DescribeVpcPeeringConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.DescribeVpcPeeringConnections";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeVpcPeeringConnectionsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetGameSessionLogUrlCommand(
  input: GetGameSessionLogUrlCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.GetGameSessionLogUrl";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetGameSessionLogUrlInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1GetInstanceAccessCommand(
  input: GetInstanceAccessCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.GetInstanceAccess";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1GetInstanceAccessInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListAliasesCommand(
  input: ListAliasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.ListAliases";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListAliasesInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListBuildsCommand(
  input: ListBuildsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.ListBuilds";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListBuildsInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListFleetsCommand(
  input: ListFleetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.ListFleets";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListFleetsInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListScriptsCommand(
  input: ListScriptsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.ListScripts";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ListScriptsInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.ListTagsForResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListTagsForResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1PutScalingPolicyCommand(
  input: PutScalingPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.PutScalingPolicy";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1PutScalingPolicyInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RequestUploadCredentialsCommand(
  input: RequestUploadCredentialsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.RequestUploadCredentials";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RequestUploadCredentialsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ResolveAliasCommand(
  input: ResolveAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.ResolveAlias";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1ResolveAliasInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1SearchGameSessionsCommand(
  input: SearchGameSessionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.SearchGameSessions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1SearchGameSessionsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartFleetActionsCommand(
  input: StartFleetActionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.StartFleetActions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartFleetActionsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartGameSessionPlacementCommand(
  input: StartGameSessionPlacementCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.StartGameSessionPlacement";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartGameSessionPlacementInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartMatchBackfillCommand(
  input: StartMatchBackfillCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.StartMatchBackfill";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartMatchBackfillInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartMatchmakingCommand(
  input: StartMatchmakingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.StartMatchmaking";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartMatchmakingInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopFleetActionsCommand(
  input: StopFleetActionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.StopFleetActions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopFleetActionsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopGameSessionPlacementCommand(
  input: StopGameSessionPlacementCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.StopGameSessionPlacement";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopGameSessionPlacementInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopMatchmakingCommand(
  input: StopMatchmakingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.StopMatchmaking";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopMatchmakingInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.TagResource";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UntagResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UntagResourceRequest(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateAliasCommand(
  input: UpdateAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UpdateAlias";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateAliasInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateBuildCommand(
  input: UpdateBuildCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UpdateBuild";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateBuildInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateFleetAttributesCommand(
  input: UpdateFleetAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UpdateFleetAttributes";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateFleetAttributesInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateFleetCapacityCommand(
  input: UpdateFleetCapacityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UpdateFleetCapacity";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateFleetCapacityInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateFleetPortSettingsCommand(
  input: UpdateFleetPortSettingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UpdateFleetPortSettings";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateFleetPortSettingsInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateGameSessionCommand(
  input: UpdateGameSessionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UpdateGameSession";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateGameSessionInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateGameSessionQueueCommand(
  input: UpdateGameSessionQueueCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UpdateGameSessionQueue";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateGameSessionQueueInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateMatchmakingConfigurationCommand(
  input: UpdateMatchmakingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UpdateMatchmakingConfiguration";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateMatchmakingConfigurationInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateRuntimeConfigurationCommand(
  input: UpdateRuntimeConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UpdateRuntimeConfiguration";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1UpdateRuntimeConfigurationInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1UpdateScriptCommand(
  input: UpdateScriptCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.UpdateScript";
  let body: any;
  body = JSON.stringify(serializeAws_json1_1UpdateScriptInput(input, context));
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ValidateMatchmakingRuleSetCommand(
  input: ValidateMatchmakingRuleSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "GameLift.ValidateMatchmakingRuleSet";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ValidateMatchmakingRuleSetInput(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function deserializeAws_json1_1AcceptMatchCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptMatchCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AcceptMatchCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AcceptMatchOutput(data, context);
  const response: AcceptMatchCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AcceptMatchOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AcceptMatchCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptMatchCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateAliasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAliasCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateAliasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateAliasOutput(data, context);
  const response: CreateAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAliasOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateAliasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAliasCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.gameliftapi.v20151001#ConflictException":
      response = {
        ...(await deserializeAws_json1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.gameliftapi.v20151001#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateBuildCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBuildCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateBuildCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateBuildOutput(data, context);
  const response: CreateBuildCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateBuildOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateBuildCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBuildCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.gameliftapi.v20151001#ConflictException":
      response = {
        ...(await deserializeAws_json1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateFleetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFleetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateFleetCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateFleetOutput(data, context);
  const response: CreateFleetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateFleetOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateFleetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFleetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.gameliftapi.v20151001#ConflictException":
      response = {
        ...(await deserializeAws_json1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.gameliftapi.v20151001#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateGameSessionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGameSessionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateGameSessionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateGameSessionOutput(data, context);
  const response: CreateGameSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGameSessionOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateGameSessionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGameSessionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.gameliftapi.v20151001#ConflictException":
      response = {
        ...(await deserializeAws_json1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "FleetCapacityExceededException":
    case "com.amazonaws.gameliftapi.v20151001#FleetCapacityExceededException":
      response = {
        ...(await deserializeAws_json1_1FleetCapacityExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IdempotentParameterMismatchException":
    case "com.amazonaws.gameliftapi.v20151001#IdempotentParameterMismatchException":
      response = {
        ...(await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFleetStatusException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidFleetStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidFleetStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.gameliftapi.v20151001#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TerminalRoutingStrategyException":
    case "com.amazonaws.gameliftapi.v20151001#TerminalRoutingStrategyException":
      response = {
        ...(await deserializeAws_json1_1TerminalRoutingStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateGameSessionQueueCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGameSessionQueueCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateGameSessionQueueCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateGameSessionQueueOutput(data, context);
  const response: CreateGameSessionQueueCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateGameSessionQueueOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateGameSessionQueueCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateGameSessionQueueCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.gameliftapi.v20151001#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateMatchmakingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMatchmakingConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateMatchmakingConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateMatchmakingConfigurationOutput(
    data,
    context
  );
  const response: CreateMatchmakingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateMatchmakingConfigurationOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateMatchmakingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMatchmakingConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.gameliftapi.v20151001#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateMatchmakingRuleSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMatchmakingRuleSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateMatchmakingRuleSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateMatchmakingRuleSetOutput(
    data,
    context
  );
  const response: CreateMatchmakingRuleSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateMatchmakingRuleSetOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateMatchmakingRuleSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMatchmakingRuleSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreatePlayerSessionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePlayerSessionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePlayerSessionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreatePlayerSessionOutput(data, context);
  const response: CreatePlayerSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePlayerSessionOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreatePlayerSessionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePlayerSessionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "GameSessionFullException":
    case "com.amazonaws.gameliftapi.v20151001#GameSessionFullException":
      response = {
        ...(await deserializeAws_json1_1GameSessionFullExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidGameSessionStatusException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidGameSessionStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidGameSessionStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TerminalRoutingStrategyException":
    case "com.amazonaws.gameliftapi.v20151001#TerminalRoutingStrategyException":
      response = {
        ...(await deserializeAws_json1_1TerminalRoutingStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreatePlayerSessionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePlayerSessionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreatePlayerSessionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreatePlayerSessionsOutput(data, context);
  const response: CreatePlayerSessionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePlayerSessionsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreatePlayerSessionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePlayerSessionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "GameSessionFullException":
    case "com.amazonaws.gameliftapi.v20151001#GameSessionFullException":
      response = {
        ...(await deserializeAws_json1_1GameSessionFullExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidGameSessionStatusException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidGameSessionStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidGameSessionStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TerminalRoutingStrategyException":
    case "com.amazonaws.gameliftapi.v20151001#TerminalRoutingStrategyException":
      response = {
        ...(await deserializeAws_json1_1TerminalRoutingStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateScriptCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScriptCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateScriptCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateScriptOutput(data, context);
  const response: CreateScriptCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateScriptOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateScriptCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScriptCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.gameliftapi.v20151001#ConflictException":
      response = {
        ...(await deserializeAws_json1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateVpcPeeringAuthorizationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcPeeringAuthorizationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateVpcPeeringAuthorizationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateVpcPeeringAuthorizationOutput(
    data,
    context
  );
  const response: CreateVpcPeeringAuthorizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVpcPeeringAuthorizationOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateVpcPeeringAuthorizationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcPeeringAuthorizationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateVpcPeeringConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcPeeringConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateVpcPeeringConnectionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateVpcPeeringConnectionOutput(
    data,
    context
  );
  const response: CreateVpcPeeringConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVpcPeeringConnectionOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateVpcPeeringConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVpcPeeringConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteAliasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAliasCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteAliasCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteAliasCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteAliasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAliasCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteBuildCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBuildCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteBuildCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteBuildCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteBuildCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBuildCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteFleetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFleetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteFleetCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteFleetCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteFleetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFleetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFleetStatusException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidFleetStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidFleetStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteGameSessionQueueCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGameSessionQueueCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteGameSessionQueueCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteGameSessionQueueOutput(data, context);
  const response: DeleteGameSessionQueueCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteGameSessionQueueOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteGameSessionQueueCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteGameSessionQueueCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteMatchmakingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMatchmakingConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteMatchmakingConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteMatchmakingConfigurationOutput(
    data,
    context
  );
  const response: DeleteMatchmakingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteMatchmakingConfigurationOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteMatchmakingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMatchmakingConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteMatchmakingRuleSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMatchmakingRuleSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteMatchmakingRuleSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteMatchmakingRuleSetOutput(
    data,
    context
  );
  const response: DeleteMatchmakingRuleSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteMatchmakingRuleSetOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteMatchmakingRuleSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMatchmakingRuleSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteScalingPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteScalingPolicyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteScalingPolicyCommandError(
      output,
      context
    );
  }
  await collectBody(output.body, context);
  const response: DeleteScalingPolicyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteScalingPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteScalingPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteScriptCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteScriptCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteScriptCommandError(output, context);
  }
  await collectBody(output.body, context);
  const response: DeleteScriptCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteScriptCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteScriptCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteVpcPeeringAuthorizationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcPeeringAuthorizationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteVpcPeeringAuthorizationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteVpcPeeringAuthorizationOutput(
    data,
    context
  );
  const response: DeleteVpcPeeringAuthorizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVpcPeeringAuthorizationOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteVpcPeeringAuthorizationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcPeeringAuthorizationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteVpcPeeringConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcPeeringConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteVpcPeeringConnectionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteVpcPeeringConnectionOutput(
    data,
    context
  );
  const response: DeleteVpcPeeringConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVpcPeeringConnectionOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteVpcPeeringConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVpcPeeringConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAliasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAliasCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAliasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAliasOutput(data, context);
  const response: DescribeAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAliasOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAliasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAliasCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeBuildCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeBuildCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeBuildCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeBuildOutput(data, context);
  const response: DescribeBuildCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeBuildOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeBuildCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeBuildCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEC2InstanceLimitsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEC2InstanceLimitsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEC2InstanceLimitsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEC2InstanceLimitsOutput(
    data,
    context
  );
  const response: DescribeEC2InstanceLimitsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEC2InstanceLimitsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEC2InstanceLimitsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEC2InstanceLimitsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeFleetAttributesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetAttributesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeFleetAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeFleetAttributesOutput(data, context);
  const response: DescribeFleetAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFleetAttributesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeFleetAttributesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetAttributesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeFleetCapacityCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetCapacityCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeFleetCapacityCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeFleetCapacityOutput(data, context);
  const response: DescribeFleetCapacityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFleetCapacityOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeFleetCapacityCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetCapacityCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeFleetEventsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetEventsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeFleetEventsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeFleetEventsOutput(data, context);
  const response: DescribeFleetEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFleetEventsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeFleetEventsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetEventsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeFleetPortSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetPortSettingsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeFleetPortSettingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeFleetPortSettingsOutput(
    data,
    context
  );
  const response: DescribeFleetPortSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFleetPortSettingsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeFleetPortSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetPortSettingsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeFleetUtilizationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetUtilizationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeFleetUtilizationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeFleetUtilizationOutput(
    data,
    context
  );
  const response: DescribeFleetUtilizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeFleetUtilizationOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeFleetUtilizationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetUtilizationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeGameSessionDetailsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGameSessionDetailsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeGameSessionDetailsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeGameSessionDetailsOutput(
    data,
    context
  );
  const response: DescribeGameSessionDetailsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeGameSessionDetailsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeGameSessionDetailsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGameSessionDetailsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TerminalRoutingStrategyException":
    case "com.amazonaws.gameliftapi.v20151001#TerminalRoutingStrategyException":
      response = {
        ...(await deserializeAws_json1_1TerminalRoutingStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeGameSessionPlacementCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGameSessionPlacementCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeGameSessionPlacementCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeGameSessionPlacementOutput(
    data,
    context
  );
  const response: DescribeGameSessionPlacementCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeGameSessionPlacementOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeGameSessionPlacementCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGameSessionPlacementCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeGameSessionQueuesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGameSessionQueuesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeGameSessionQueuesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeGameSessionQueuesOutput(
    data,
    context
  );
  const response: DescribeGameSessionQueuesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeGameSessionQueuesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeGameSessionQueuesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGameSessionQueuesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeGameSessionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGameSessionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeGameSessionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeGameSessionsOutput(data, context);
  const response: DescribeGameSessionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeGameSessionsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeGameSessionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeGameSessionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TerminalRoutingStrategyException":
    case "com.amazonaws.gameliftapi.v20151001#TerminalRoutingStrategyException":
      response = {
        ...(await deserializeAws_json1_1TerminalRoutingStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeInstancesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeInstancesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeInstancesOutput(data, context);
  const response: DescribeInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeInstancesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeInstancesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeInstancesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMatchmakingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMatchmakingCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMatchmakingCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMatchmakingOutput(data, context);
  const response: DescribeMatchmakingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMatchmakingOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMatchmakingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMatchmakingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMatchmakingConfigurationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMatchmakingConfigurationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMatchmakingConfigurationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMatchmakingConfigurationsOutput(
    data,
    context
  );
  const response: DescribeMatchmakingConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMatchmakingConfigurationsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMatchmakingConfigurationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMatchmakingConfigurationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeMatchmakingRuleSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMatchmakingRuleSetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeMatchmakingRuleSetsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeMatchmakingRuleSetsOutput(
    data,
    context
  );
  const response: DescribeMatchmakingRuleSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMatchmakingRuleSetsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeMatchmakingRuleSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMatchmakingRuleSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribePlayerSessionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePlayerSessionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribePlayerSessionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribePlayerSessionsOutput(data, context);
  const response: DescribePlayerSessionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePlayerSessionsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribePlayerSessionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePlayerSessionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeRuntimeConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRuntimeConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeRuntimeConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeRuntimeConfigurationOutput(
    data,
    context
  );
  const response: DescribeRuntimeConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeRuntimeConfigurationOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeRuntimeConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRuntimeConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeScalingPoliciesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScalingPoliciesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeScalingPoliciesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeScalingPoliciesOutput(data, context);
  const response: DescribeScalingPoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeScalingPoliciesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeScalingPoliciesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScalingPoliciesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeScriptCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScriptCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeScriptCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeScriptOutput(data, context);
  const response: DescribeScriptCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeScriptOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeScriptCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScriptCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeVpcPeeringAuthorizationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcPeeringAuthorizationsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeVpcPeeringAuthorizationsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeVpcPeeringAuthorizationsOutput(
    data,
    context
  );
  const response: DescribeVpcPeeringAuthorizationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcPeeringAuthorizationsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeVpcPeeringAuthorizationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcPeeringAuthorizationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeVpcPeeringConnectionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcPeeringConnectionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeVpcPeeringConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeVpcPeeringConnectionsOutput(
    data,
    context
  );
  const response: DescribeVpcPeeringConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeVpcPeeringConnectionsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeVpcPeeringConnectionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeVpcPeeringConnectionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetGameSessionLogUrlCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGameSessionLogUrlCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetGameSessionLogUrlCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetGameSessionLogUrlOutput(data, context);
  const response: GetGameSessionLogUrlCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGameSessionLogUrlOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetGameSessionLogUrlCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGameSessionLogUrlCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1GetInstanceAccessCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInstanceAccessCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1GetInstanceAccessCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1GetInstanceAccessOutput(data, context);
  const response: GetInstanceAccessCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetInstanceAccessOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1GetInstanceAccessCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetInstanceAccessCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListAliasesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAliasesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListAliasesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListAliasesOutput(data, context);
  const response: ListAliasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAliasesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListAliasesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAliasesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListBuildsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBuildsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListBuildsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListBuildsOutput(data, context);
  const response: ListBuildsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBuildsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListBuildsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBuildsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListFleetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFleetsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListFleetsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListFleetsOutput(data, context);
  const response: ListFleetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListFleetsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListFleetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFleetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListScriptsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListScriptsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListScriptsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListScriptsOutput(data, context);
  const response: ListScriptsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListScriptsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListScriptsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListScriptsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceResponse(data, context);
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1PutScalingPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutScalingPolicyCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1PutScalingPolicyCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1PutScalingPolicyOutput(data, context);
  const response: PutScalingPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "PutScalingPolicyOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1PutScalingPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<PutScalingPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RequestUploadCredentialsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RequestUploadCredentialsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RequestUploadCredentialsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RequestUploadCredentialsOutput(
    data,
    context
  );
  const response: RequestUploadCredentialsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RequestUploadCredentialsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RequestUploadCredentialsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RequestUploadCredentialsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ResolveAliasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResolveAliasCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ResolveAliasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ResolveAliasOutput(data, context);
  const response: ResolveAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ResolveAliasOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ResolveAliasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ResolveAliasCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TerminalRoutingStrategyException":
    case "com.amazonaws.gameliftapi.v20151001#TerminalRoutingStrategyException":
      response = {
        ...(await deserializeAws_json1_1TerminalRoutingStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1SearchGameSessionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchGameSessionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1SearchGameSessionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1SearchGameSessionsOutput(data, context);
  const response: SearchGameSessionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchGameSessionsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1SearchGameSessionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchGameSessionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TerminalRoutingStrategyException":
    case "com.amazonaws.gameliftapi.v20151001#TerminalRoutingStrategyException":
      response = {
        ...(await deserializeAws_json1_1TerminalRoutingStrategyExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartFleetActionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartFleetActionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartFleetActionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartFleetActionsOutput(data, context);
  const response: StartFleetActionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartFleetActionsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartFleetActionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartFleetActionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartGameSessionPlacementCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartGameSessionPlacementCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartGameSessionPlacementCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartGameSessionPlacementOutput(
    data,
    context
  );
  const response: StartGameSessionPlacementCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartGameSessionPlacementOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartGameSessionPlacementCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartGameSessionPlacementCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartMatchBackfillCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMatchBackfillCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartMatchBackfillCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartMatchBackfillOutput(data, context);
  const response: StartMatchBackfillCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartMatchBackfillOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartMatchBackfillCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMatchBackfillCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartMatchmakingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMatchmakingCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartMatchmakingCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartMatchmakingOutput(data, context);
  const response: StartMatchmakingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartMatchmakingOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartMatchmakingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartMatchmakingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopFleetActionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopFleetActionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopFleetActionsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopFleetActionsOutput(data, context);
  const response: StopFleetActionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopFleetActionsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopFleetActionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopFleetActionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopGameSessionPlacementCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopGameSessionPlacementCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopGameSessionPlacementCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopGameSessionPlacementOutput(
    data,
    context
  );
  const response: StopGameSessionPlacementCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopGameSessionPlacementOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopGameSessionPlacementCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopGameSessionPlacementCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopMatchmakingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopMatchmakingCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopMatchmakingCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopMatchmakingOutput(data, context);
  const response: StopMatchmakingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopMatchmakingOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopMatchmakingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopMatchmakingCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TagResourceResponse(data, context);
  const response: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UntagResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UntagResourceResponse(data, context);
  const response: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaggingFailedException":
    case "com.amazonaws.gameliftapi.v20151001#TaggingFailedException":
      response = {
        ...(await deserializeAws_json1_1TaggingFailedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateAliasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAliasCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateAliasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateAliasOutput(data, context);
  const response: UpdateAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateAliasOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateAliasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAliasCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateBuildCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBuildCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateBuildCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateBuildOutput(data, context);
  const response: UpdateBuildCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateBuildOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateBuildCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBuildCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateFleetAttributesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFleetAttributesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateFleetAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateFleetAttributesOutput(data, context);
  const response: UpdateFleetAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateFleetAttributesOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateFleetAttributesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFleetAttributesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.gameliftapi.v20151001#ConflictException":
      response = {
        ...(await deserializeAws_json1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFleetStatusException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidFleetStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidFleetStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.gameliftapi.v20151001#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateFleetCapacityCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFleetCapacityCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateFleetCapacityCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateFleetCapacityOutput(data, context);
  const response: UpdateFleetCapacityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateFleetCapacityOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateFleetCapacityCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFleetCapacityCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.gameliftapi.v20151001#ConflictException":
      response = {
        ...(await deserializeAws_json1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFleetStatusException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidFleetStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidFleetStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.gameliftapi.v20151001#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateFleetPortSettingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFleetPortSettingsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateFleetPortSettingsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateFleetPortSettingsOutput(data, context);
  const response: UpdateFleetPortSettingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateFleetPortSettingsOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateFleetPortSettingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFleetPortSettingsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.gameliftapi.v20151001#ConflictException":
      response = {
        ...(await deserializeAws_json1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFleetStatusException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidFleetStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidFleetStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.gameliftapi.v20151001#LimitExceededException":
      response = {
        ...(await deserializeAws_json1_1LimitExceededExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateGameSessionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGameSessionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateGameSessionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateGameSessionOutput(data, context);
  const response: UpdateGameSessionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateGameSessionOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateGameSessionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGameSessionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.gameliftapi.v20151001#ConflictException":
      response = {
        ...(await deserializeAws_json1_1ConflictExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidGameSessionStatusException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidGameSessionStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidGameSessionStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateGameSessionQueueCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGameSessionQueueCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateGameSessionQueueCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateGameSessionQueueOutput(data, context);
  const response: UpdateGameSessionQueueCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateGameSessionQueueOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateGameSessionQueueCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateGameSessionQueueCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateMatchmakingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMatchmakingConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateMatchmakingConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateMatchmakingConfigurationOutput(
    data,
    context
  );
  const response: UpdateMatchmakingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateMatchmakingConfigurationOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateMatchmakingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMatchmakingConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateRuntimeConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRuntimeConfigurationCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateRuntimeConfigurationCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateRuntimeConfigurationOutput(
    data,
    context
  );
  const response: UpdateRuntimeConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRuntimeConfigurationOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateRuntimeConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRuntimeConfigurationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidFleetStatusException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidFleetStatusException":
      response = {
        ...(await deserializeAws_json1_1InvalidFleetStatusExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1UpdateScriptCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateScriptCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1UpdateScriptCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1UpdateScriptOutput(data, context);
  const response: UpdateScriptCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateScriptOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1UpdateScriptCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateScriptCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotFoundException":
    case "com.amazonaws.gameliftapi.v20151001#NotFoundException":
      response = {
        ...(await deserializeAws_json1_1NotFoundExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.gameliftapi.v20151001#UnauthorizedException":
      response = {
        ...(await deserializeAws_json1_1UnauthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ValidateMatchmakingRuleSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ValidateMatchmakingRuleSetCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ValidateMatchmakingRuleSetCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ValidateMatchmakingRuleSetOutput(
    data,
    context
  );
  const response: ValidateMatchmakingRuleSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ValidateMatchmakingRuleSetOutput",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ValidateMatchmakingRuleSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ValidateMatchmakingRuleSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InternalServiceException":
    case "com.amazonaws.gameliftapi.v20151001#InternalServiceException":
      response = {
        ...(await deserializeAws_json1_1InternalServiceExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.gameliftapi.v20151001#InvalidRequestException":
      response = {
        ...(await deserializeAws_json1_1InvalidRequestExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnsupportedRegionException":
    case "com.amazonaws.gameliftapi.v20151001#UnsupportedRegionException":
      response = {
        ...(await deserializeAws_json1_1UnsupportedRegionExceptionResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1ConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConflictException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ConflictException(
    body,
    context
  );
  const contents: ConflictException = {
    name: "ConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1FleetCapacityExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<FleetCapacityExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1FleetCapacityExceededException(
    body,
    context
  );
  const contents: FleetCapacityExceededException = {
    name: "FleetCapacityExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1GameSessionFullExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<GameSessionFullException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1GameSessionFullException(
    body,
    context
  );
  const contents: GameSessionFullException = {
    name: "GameSessionFullException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IdempotentParameterMismatchException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1IdempotentParameterMismatchException(
    body,
    context
  );
  const contents: IdempotentParameterMismatchException = {
    name: "IdempotentParameterMismatchException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InternalServiceExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InternalServiceException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InternalServiceException(
    body,
    context
  );
  const contents: InternalServiceException = {
    name: "InternalServiceException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidFleetStatusExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidFleetStatusException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidFleetStatusException(
    body,
    context
  );
  const contents: InvalidFleetStatusException = {
    name: "InvalidFleetStatusException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidGameSessionStatusExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidGameSessionStatusException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidGameSessionStatusException(
    body,
    context
  );
  const contents: InvalidGameSessionStatusException = {
    name: "InvalidGameSessionStatusException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRequestException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidRequestException(
    body,
    context
  );
  const contents: InvalidRequestException = {
    name: "InvalidRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1LimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<LimitExceededException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1LimitExceededException(
    body,
    context
  );
  const contents: LimitExceededException = {
    name: "LimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1NotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NotFoundException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1NotFoundException(
    body,
    context
  );
  const contents: NotFoundException = {
    name: "NotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TaggingFailedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TaggingFailedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TaggingFailedException(
    body,
    context
  );
  const contents: TaggingFailedException = {
    name: "TaggingFailedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1TerminalRoutingStrategyExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TerminalRoutingStrategyException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1TerminalRoutingStrategyException(
    body,
    context
  );
  const contents: TerminalRoutingStrategyException = {
    name: "TerminalRoutingStrategyException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnauthorizedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnauthorizedException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnauthorizedException(
    body,
    context
  );
  const contents: UnauthorizedException = {
    name: "UnauthorizedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UnsupportedRegionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnsupportedRegionException> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UnsupportedRegionException(
    body,
    context
  );
  const contents: UnsupportedRegionException = {
    name: "UnsupportedRegionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1AcceptMatchInput = (
  input: AcceptMatchInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AcceptanceType !== undefined) {
    bodyParams["AcceptanceType"] = input.AcceptanceType;
  }
  if (input.PlayerIds !== undefined) {
    bodyParams["PlayerIds"] = serializeAws_json1_1StringList(
      input.PlayerIds,
      context
    );
  }
  if (input.TicketId !== undefined) {
    bodyParams["TicketId"] = input.TicketId;
  }
  return bodyParams;
};

const serializeAws_json1_1AttributeValue = (
  input: AttributeValue,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.N !== undefined) {
    bodyParams["N"] = input.N;
  }
  if (input.S !== undefined) {
    bodyParams["S"] = input.S;
  }
  if (input.SDM !== undefined) {
    bodyParams["SDM"] = serializeAws_json1_1StringDoubleMap(input.SDM, context);
  }
  if (input.SL !== undefined) {
    bodyParams["SL"] = serializeAws_json1_1StringList(input.SL, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CertificateConfiguration = (
  input: CertificateConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateType !== undefined) {
    bodyParams["CertificateType"] = input.CertificateType;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateAliasInput = (
  input: CreateAliasInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RoutingStrategy !== undefined) {
    bodyParams["RoutingStrategy"] = serializeAws_json1_1RoutingStrategy(
      input.RoutingStrategy,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateBuildInput = (
  input: CreateBuildInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.OperatingSystem !== undefined) {
    bodyParams["OperatingSystem"] = input.OperatingSystem;
  }
  if (input.StorageLocation !== undefined) {
    bodyParams["StorageLocation"] = serializeAws_json1_1S3Location(
      input.StorageLocation,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.Version !== undefined) {
    bodyParams["Version"] = input.Version;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateFleetInput = (
  input: CreateFleetInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BuildId !== undefined) {
    bodyParams["BuildId"] = input.BuildId;
  }
  if (input.CertificateConfiguration !== undefined) {
    bodyParams[
      "CertificateConfiguration"
    ] = serializeAws_json1_1CertificateConfiguration(
      input.CertificateConfiguration,
      context
    );
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.EC2InboundPermissions !== undefined) {
    bodyParams["EC2InboundPermissions"] = serializeAws_json1_1IpPermissionsList(
      input.EC2InboundPermissions,
      context
    );
  }
  if (input.EC2InstanceType !== undefined) {
    bodyParams["EC2InstanceType"] = input.EC2InstanceType;
  }
  if (input.FleetType !== undefined) {
    bodyParams["FleetType"] = input.FleetType;
  }
  if (input.InstanceRoleArn !== undefined) {
    bodyParams["InstanceRoleArn"] = input.InstanceRoleArn;
  }
  if (input.LogPaths !== undefined) {
    bodyParams["LogPaths"] = serializeAws_json1_1StringList(
      input.LogPaths,
      context
    );
  }
  if (input.MetricGroups !== undefined) {
    bodyParams["MetricGroups"] = serializeAws_json1_1MetricGroupList(
      input.MetricGroups,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NewGameSessionProtectionPolicy !== undefined) {
    bodyParams["NewGameSessionProtectionPolicy"] =
      input.NewGameSessionProtectionPolicy;
  }
  if (input.PeerVpcAwsAccountId !== undefined) {
    bodyParams["PeerVpcAwsAccountId"] = input.PeerVpcAwsAccountId;
  }
  if (input.PeerVpcId !== undefined) {
    bodyParams["PeerVpcId"] = input.PeerVpcId;
  }
  if (input.ResourceCreationLimitPolicy !== undefined) {
    bodyParams[
      "ResourceCreationLimitPolicy"
    ] = serializeAws_json1_1ResourceCreationLimitPolicy(
      input.ResourceCreationLimitPolicy,
      context
    );
  }
  if (input.RuntimeConfiguration !== undefined) {
    bodyParams[
      "RuntimeConfiguration"
    ] = serializeAws_json1_1RuntimeConfiguration(
      input.RuntimeConfiguration,
      context
    );
  }
  if (input.ScriptId !== undefined) {
    bodyParams["ScriptId"] = input.ScriptId;
  }
  if (input.ServerLaunchParameters !== undefined) {
    bodyParams["ServerLaunchParameters"] = input.ServerLaunchParameters;
  }
  if (input.ServerLaunchPath !== undefined) {
    bodyParams["ServerLaunchPath"] = input.ServerLaunchPath;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateGameSessionInput = (
  input: CreateGameSessionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AliasId !== undefined) {
    bodyParams["AliasId"] = input.AliasId;
  }
  if (input.CreatorId !== undefined) {
    bodyParams["CreatorId"] = input.CreatorId;
  }
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.GameProperties !== undefined) {
    bodyParams["GameProperties"] = serializeAws_json1_1GamePropertyList(
      input.GameProperties,
      context
    );
  }
  if (input.GameSessionData !== undefined) {
    bodyParams["GameSessionData"] = input.GameSessionData;
  }
  if (input.GameSessionId !== undefined) {
    bodyParams["GameSessionId"] = input.GameSessionId;
  }
  if (input.IdempotencyToken !== undefined) {
    bodyParams["IdempotencyToken"] = input.IdempotencyToken;
  }
  if (input.MaximumPlayerSessionCount !== undefined) {
    bodyParams["MaximumPlayerSessionCount"] = input.MaximumPlayerSessionCount;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateGameSessionQueueInput = (
  input: CreateGameSessionQueueInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Destinations !== undefined) {
    bodyParams[
      "Destinations"
    ] = serializeAws_json1_1GameSessionQueueDestinationList(
      input.Destinations,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.PlayerLatencyPolicies !== undefined) {
    bodyParams[
      "PlayerLatencyPolicies"
    ] = serializeAws_json1_1PlayerLatencyPolicyList(
      input.PlayerLatencyPolicies,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.TimeoutInSeconds !== undefined) {
    bodyParams["TimeoutInSeconds"] = input.TimeoutInSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateMatchmakingConfigurationInput = (
  input: CreateMatchmakingConfigurationInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AcceptanceRequired !== undefined) {
    bodyParams["AcceptanceRequired"] = input.AcceptanceRequired;
  }
  if (input.AcceptanceTimeoutSeconds !== undefined) {
    bodyParams["AcceptanceTimeoutSeconds"] = input.AcceptanceTimeoutSeconds;
  }
  if (input.AdditionalPlayerCount !== undefined) {
    bodyParams["AdditionalPlayerCount"] = input.AdditionalPlayerCount;
  }
  if (input.BackfillMode !== undefined) {
    bodyParams["BackfillMode"] = input.BackfillMode;
  }
  if (input.CustomEventData !== undefined) {
    bodyParams["CustomEventData"] = input.CustomEventData;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.GameProperties !== undefined) {
    bodyParams["GameProperties"] = serializeAws_json1_1GamePropertyList(
      input.GameProperties,
      context
    );
  }
  if (input.GameSessionData !== undefined) {
    bodyParams["GameSessionData"] = input.GameSessionData;
  }
  if (input.GameSessionQueueArns !== undefined) {
    bodyParams["GameSessionQueueArns"] = serializeAws_json1_1QueueArnsList(
      input.GameSessionQueueArns,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NotificationTarget !== undefined) {
    bodyParams["NotificationTarget"] = input.NotificationTarget;
  }
  if (input.RequestTimeoutSeconds !== undefined) {
    bodyParams["RequestTimeoutSeconds"] = input.RequestTimeoutSeconds;
  }
  if (input.RuleSetName !== undefined) {
    bodyParams["RuleSetName"] = input.RuleSetName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateMatchmakingRuleSetInput = (
  input: CreateMatchmakingRuleSetInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RuleSetBody !== undefined) {
    bodyParams["RuleSetBody"] = input.RuleSetBody;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreatePlayerSessionInput = (
  input: CreatePlayerSessionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GameSessionId !== undefined) {
    bodyParams["GameSessionId"] = input.GameSessionId;
  }
  if (input.PlayerData !== undefined) {
    bodyParams["PlayerData"] = input.PlayerData;
  }
  if (input.PlayerId !== undefined) {
    bodyParams["PlayerId"] = input.PlayerId;
  }
  return bodyParams;
};

const serializeAws_json1_1CreatePlayerSessionsInput = (
  input: CreatePlayerSessionsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GameSessionId !== undefined) {
    bodyParams["GameSessionId"] = input.GameSessionId;
  }
  if (input.PlayerDataMap !== undefined) {
    bodyParams["PlayerDataMap"] = serializeAws_json1_1PlayerDataMap(
      input.PlayerDataMap,
      context
    );
  }
  if (input.PlayerIds !== undefined) {
    bodyParams["PlayerIds"] = serializeAws_json1_1PlayerIdList(
      input.PlayerIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateScriptInput = (
  input: CreateScriptInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.StorageLocation !== undefined) {
    bodyParams["StorageLocation"] = serializeAws_json1_1S3Location(
      input.StorageLocation,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.Version !== undefined) {
    bodyParams["Version"] = input.Version;
  }
  if (input.ZipFile !== undefined) {
    bodyParams["ZipFile"] = context.base64Encoder(input.ZipFile);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateVpcPeeringAuthorizationInput = (
  input: CreateVpcPeeringAuthorizationInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GameLiftAwsAccountId !== undefined) {
    bodyParams["GameLiftAwsAccountId"] = input.GameLiftAwsAccountId;
  }
  if (input.PeerVpcId !== undefined) {
    bodyParams["PeerVpcId"] = input.PeerVpcId;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateVpcPeeringConnectionInput = (
  input: CreateVpcPeeringConnectionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.PeerVpcAwsAccountId !== undefined) {
    bodyParams["PeerVpcAwsAccountId"] = input.PeerVpcAwsAccountId;
  }
  if (input.PeerVpcId !== undefined) {
    bodyParams["PeerVpcId"] = input.PeerVpcId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteAliasInput = (
  input: DeleteAliasInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AliasId !== undefined) {
    bodyParams["AliasId"] = input.AliasId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteBuildInput = (
  input: DeleteBuildInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BuildId !== undefined) {
    bodyParams["BuildId"] = input.BuildId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteFleetInput = (
  input: DeleteFleetInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteGameSessionQueueInput = (
  input: DeleteGameSessionQueueInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteMatchmakingConfigurationInput = (
  input: DeleteMatchmakingConfigurationInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteMatchmakingRuleSetInput = (
  input: DeleteMatchmakingRuleSetInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteScalingPolicyInput = (
  input: DeleteScalingPolicyInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteScriptInput = (
  input: DeleteScriptInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ScriptId !== undefined) {
    bodyParams["ScriptId"] = input.ScriptId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteVpcPeeringAuthorizationInput = (
  input: DeleteVpcPeeringAuthorizationInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GameLiftAwsAccountId !== undefined) {
    bodyParams["GameLiftAwsAccountId"] = input.GameLiftAwsAccountId;
  }
  if (input.PeerVpcId !== undefined) {
    bodyParams["PeerVpcId"] = input.PeerVpcId;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteVpcPeeringConnectionInput = (
  input: DeleteVpcPeeringConnectionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.VpcPeeringConnectionId !== undefined) {
    bodyParams["VpcPeeringConnectionId"] = input.VpcPeeringConnectionId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAliasInput = (
  input: DescribeAliasInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AliasId !== undefined) {
    bodyParams["AliasId"] = input.AliasId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeBuildInput = (
  input: DescribeBuildInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BuildId !== undefined) {
    bodyParams["BuildId"] = input.BuildId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEC2InstanceLimitsInput = (
  input: DescribeEC2InstanceLimitsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EC2InstanceType !== undefined) {
    bodyParams["EC2InstanceType"] = input.EC2InstanceType;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeFleetAttributesInput = (
  input: DescribeFleetAttributesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetIds !== undefined) {
    bodyParams["FleetIds"] = serializeAws_json1_1FleetIdList(
      input.FleetIds,
      context
    );
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeFleetCapacityInput = (
  input: DescribeFleetCapacityInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetIds !== undefined) {
    bodyParams["FleetIds"] = serializeAws_json1_1FleetIdList(
      input.FleetIds,
      context
    );
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeFleetEventsInput = (
  input: DescribeFleetEventsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndTime !== undefined) {
    bodyParams["EndTime"] = Math.round(input.EndTime.getTime() / 1000);
  }
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.StartTime !== undefined) {
    bodyParams["StartTime"] = Math.round(input.StartTime.getTime() / 1000);
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeFleetPortSettingsInput = (
  input: DescribeFleetPortSettingsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeFleetUtilizationInput = (
  input: DescribeFleetUtilizationInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetIds !== undefined) {
    bodyParams["FleetIds"] = serializeAws_json1_1FleetIdList(
      input.FleetIds,
      context
    );
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeGameSessionDetailsInput = (
  input: DescribeGameSessionDetailsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AliasId !== undefined) {
    bodyParams["AliasId"] = input.AliasId;
  }
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.GameSessionId !== undefined) {
    bodyParams["GameSessionId"] = input.GameSessionId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.StatusFilter !== undefined) {
    bodyParams["StatusFilter"] = input.StatusFilter;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeGameSessionPlacementInput = (
  input: DescribeGameSessionPlacementInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.PlacementId !== undefined) {
    bodyParams["PlacementId"] = input.PlacementId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeGameSessionQueuesInput = (
  input: DescribeGameSessionQueuesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.Names !== undefined) {
    bodyParams["Names"] = serializeAws_json1_1GameSessionQueueNameList(
      input.Names,
      context
    );
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeGameSessionsInput = (
  input: DescribeGameSessionsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AliasId !== undefined) {
    bodyParams["AliasId"] = input.AliasId;
  }
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.GameSessionId !== undefined) {
    bodyParams["GameSessionId"] = input.GameSessionId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.StatusFilter !== undefined) {
    bodyParams["StatusFilter"] = input.StatusFilter;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeInstancesInput = (
  input: DescribeInstancesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMatchmakingConfigurationsInput = (
  input: DescribeMatchmakingConfigurationsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.Names !== undefined) {
    bodyParams["Names"] = serializeAws_json1_1MatchmakingConfigurationNameList(
      input.Names,
      context
    );
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.RuleSetName !== undefined) {
    bodyParams["RuleSetName"] = input.RuleSetName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMatchmakingInput = (
  input: DescribeMatchmakingInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TicketIds !== undefined) {
    bodyParams["TicketIds"] = serializeAws_json1_1MatchmakingIdList(
      input.TicketIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeMatchmakingRuleSetsInput = (
  input: DescribeMatchmakingRuleSetsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.Names !== undefined) {
    bodyParams["Names"] = serializeAws_json1_1MatchmakingRuleSetNameList(
      input.Names,
      context
    );
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribePlayerSessionsInput = (
  input: DescribePlayerSessionsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GameSessionId !== undefined) {
    bodyParams["GameSessionId"] = input.GameSessionId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.PlayerId !== undefined) {
    bodyParams["PlayerId"] = input.PlayerId;
  }
  if (input.PlayerSessionId !== undefined) {
    bodyParams["PlayerSessionId"] = input.PlayerSessionId;
  }
  if (input.PlayerSessionStatusFilter !== undefined) {
    bodyParams["PlayerSessionStatusFilter"] = input.PlayerSessionStatusFilter;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeRuntimeConfigurationInput = (
  input: DescribeRuntimeConfigurationInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeScalingPoliciesInput = (
  input: DescribeScalingPoliciesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.StatusFilter !== undefined) {
    bodyParams["StatusFilter"] = input.StatusFilter;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeScriptInput = (
  input: DescribeScriptInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ScriptId !== undefined) {
    bodyParams["ScriptId"] = input.ScriptId;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeVpcPeeringAuthorizationsInput = (
  input: DescribeVpcPeeringAuthorizationsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  return bodyParams;
};

const serializeAws_json1_1DescribeVpcPeeringConnectionsInput = (
  input: DescribeVpcPeeringConnectionsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  return bodyParams;
};

const serializeAws_json1_1DesiredPlayerSession = (
  input: DesiredPlayerSession,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.PlayerData !== undefined) {
    bodyParams["PlayerData"] = input.PlayerData;
  }
  if (input.PlayerId !== undefined) {
    bodyParams["PlayerId"] = input.PlayerId;
  }
  return bodyParams;
};

const serializeAws_json1_1DesiredPlayerSessionList = (
  input: Array<DesiredPlayerSession>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1DesiredPlayerSession(entry, context));
  }
  return contents;
};

const serializeAws_json1_1FleetActionList = (
  input: Array<FleetAction | string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1FleetIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1GameProperty = (
  input: GameProperty,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1GamePropertyList = (
  input: Array<GameProperty>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1GameProperty(entry, context));
  }
  return contents;
};

const serializeAws_json1_1GameSessionQueueDestination = (
  input: GameSessionQueueDestination,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DestinationArn !== undefined) {
    bodyParams["DestinationArn"] = input.DestinationArn;
  }
  return bodyParams;
};

const serializeAws_json1_1GameSessionQueueDestinationList = (
  input: Array<GameSessionQueueDestination>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_json1_1GameSessionQueueDestination(entry, context)
    );
  }
  return contents;
};

const serializeAws_json1_1GameSessionQueueNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1GetGameSessionLogUrlInput = (
  input: GetGameSessionLogUrlInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GameSessionId !== undefined) {
    bodyParams["GameSessionId"] = input.GameSessionId;
  }
  return bodyParams;
};

const serializeAws_json1_1GetInstanceAccessInput = (
  input: GetInstanceAccessInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.InstanceId !== undefined) {
    bodyParams["InstanceId"] = input.InstanceId;
  }
  return bodyParams;
};

const serializeAws_json1_1IpPermission = (
  input: IpPermission,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FromPort !== undefined) {
    bodyParams["FromPort"] = input.FromPort;
  }
  if (input.IpRange !== undefined) {
    bodyParams["IpRange"] = input.IpRange;
  }
  if (input.Protocol !== undefined) {
    bodyParams["Protocol"] = input.Protocol;
  }
  if (input.ToPort !== undefined) {
    bodyParams["ToPort"] = input.ToPort;
  }
  return bodyParams;
};

const serializeAws_json1_1IpPermissionsList = (
  input: Array<IpPermission>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1IpPermission(entry, context));
  }
  return contents;
};

const serializeAws_json1_1LatencyMap = (
  input: { [key: string]: number },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1ListAliasesInput = (
  input: ListAliasesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.RoutingStrategyType !== undefined) {
    bodyParams["RoutingStrategyType"] = input.RoutingStrategyType;
  }
  return bodyParams;
};

const serializeAws_json1_1ListBuildsInput = (
  input: ListBuildsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.Status !== undefined) {
    bodyParams["Status"] = input.Status;
  }
  return bodyParams;
};

const serializeAws_json1_1ListFleetsInput = (
  input: ListFleetsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BuildId !== undefined) {
    bodyParams["BuildId"] = input.BuildId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.ScriptId !== undefined) {
    bodyParams["ScriptId"] = input.ScriptId;
  }
  return bodyParams;
};

const serializeAws_json1_1ListScriptsInput = (
  input: ListScriptsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsForResourceRequest = (
  input: ListTagsForResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceARN !== undefined) {
    bodyParams["ResourceARN"] = input.ResourceARN;
  }
  return bodyParams;
};

const serializeAws_json1_1MatchmakingConfigurationNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1MatchmakingIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1MatchmakingRuleSetNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1MetricGroupList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Player = (
  input: Player,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LatencyInMs !== undefined) {
    bodyParams["LatencyInMs"] = serializeAws_json1_1LatencyMap(
      input.LatencyInMs,
      context
    );
  }
  if (input.PlayerAttributes !== undefined) {
    bodyParams["PlayerAttributes"] = serializeAws_json1_1PlayerAttributeMap(
      input.PlayerAttributes,
      context
    );
  }
  if (input.PlayerId !== undefined) {
    bodyParams["PlayerId"] = input.PlayerId;
  }
  if (input.Team !== undefined) {
    bodyParams["Team"] = input.Team;
  }
  return bodyParams;
};

const serializeAws_json1_1PlayerAttributeMap = (
  input: { [key: string]: AttributeValue },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_json1_1AttributeValue(input[key], context);
  });
  return mapParams;
};

const serializeAws_json1_1PlayerDataMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1PlayerIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1PlayerLatency = (
  input: PlayerLatency,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.LatencyInMilliseconds !== undefined) {
    bodyParams["LatencyInMilliseconds"] = input.LatencyInMilliseconds;
  }
  if (input.PlayerId !== undefined) {
    bodyParams["PlayerId"] = input.PlayerId;
  }
  if (input.RegionIdentifier !== undefined) {
    bodyParams["RegionIdentifier"] = input.RegionIdentifier;
  }
  return bodyParams;
};

const serializeAws_json1_1PlayerLatencyList = (
  input: Array<PlayerLatency>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PlayerLatency(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PlayerLatencyPolicy = (
  input: PlayerLatencyPolicy,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MaximumIndividualPlayerLatencyMilliseconds !== undefined) {
    bodyParams["MaximumIndividualPlayerLatencyMilliseconds"] =
      input.MaximumIndividualPlayerLatencyMilliseconds;
  }
  if (input.PolicyDurationSeconds !== undefined) {
    bodyParams["PolicyDurationSeconds"] = input.PolicyDurationSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1PlayerLatencyPolicyList = (
  input: Array<PlayerLatencyPolicy>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1PlayerLatencyPolicy(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PlayerList = (
  input: Array<Player>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Player(entry, context));
  }
  return contents;
};

const serializeAws_json1_1PutScalingPolicyInput = (
  input: PutScalingPolicyInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ComparisonOperator !== undefined) {
    bodyParams["ComparisonOperator"] = input.ComparisonOperator;
  }
  if (input.EvaluationPeriods !== undefined) {
    bodyParams["EvaluationPeriods"] = input.EvaluationPeriods;
  }
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.MetricName !== undefined) {
    bodyParams["MetricName"] = input.MetricName;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.PolicyType !== undefined) {
    bodyParams["PolicyType"] = input.PolicyType;
  }
  if (input.ScalingAdjustment !== undefined) {
    bodyParams["ScalingAdjustment"] = input.ScalingAdjustment;
  }
  if (input.ScalingAdjustmentType !== undefined) {
    bodyParams["ScalingAdjustmentType"] = input.ScalingAdjustmentType;
  }
  if (input.TargetConfiguration !== undefined) {
    bodyParams["TargetConfiguration"] = serializeAws_json1_1TargetConfiguration(
      input.TargetConfiguration,
      context
    );
  }
  if (input.Threshold !== undefined) {
    bodyParams["Threshold"] = input.Threshold;
  }
  return bodyParams;
};

const serializeAws_json1_1QueueArnsList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1RequestUploadCredentialsInput = (
  input: RequestUploadCredentialsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BuildId !== undefined) {
    bodyParams["BuildId"] = input.BuildId;
  }
  return bodyParams;
};

const serializeAws_json1_1ResolveAliasInput = (
  input: ResolveAliasInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AliasId !== undefined) {
    bodyParams["AliasId"] = input.AliasId;
  }
  return bodyParams;
};

const serializeAws_json1_1ResourceCreationLimitPolicy = (
  input: ResourceCreationLimitPolicy,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.NewGameSessionsPerCreator !== undefined) {
    bodyParams["NewGameSessionsPerCreator"] = input.NewGameSessionsPerCreator;
  }
  if (input.PolicyPeriodInMinutes !== undefined) {
    bodyParams["PolicyPeriodInMinutes"] = input.PolicyPeriodInMinutes;
  }
  return bodyParams;
};

const serializeAws_json1_1RoutingStrategy = (
  input: RoutingStrategy,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.Message !== undefined) {
    bodyParams["Message"] = input.Message;
  }
  if (input.Type !== undefined) {
    bodyParams["Type"] = input.Type;
  }
  return bodyParams;
};

const serializeAws_json1_1RuntimeConfiguration = (
  input: RuntimeConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GameSessionActivationTimeoutSeconds !== undefined) {
    bodyParams["GameSessionActivationTimeoutSeconds"] =
      input.GameSessionActivationTimeoutSeconds;
  }
  if (input.MaxConcurrentGameSessionActivations !== undefined) {
    bodyParams["MaxConcurrentGameSessionActivations"] =
      input.MaxConcurrentGameSessionActivations;
  }
  if (input.ServerProcesses !== undefined) {
    bodyParams["ServerProcesses"] = serializeAws_json1_1ServerProcessList(
      input.ServerProcesses,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1S3Location = (
  input: S3Location,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Bucket !== undefined) {
    bodyParams["Bucket"] = input.Bucket;
  }
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.ObjectVersion !== undefined) {
    bodyParams["ObjectVersion"] = input.ObjectVersion;
  }
  if (input.RoleArn !== undefined) {
    bodyParams["RoleArn"] = input.RoleArn;
  }
  return bodyParams;
};

const serializeAws_json1_1SearchGameSessionsInput = (
  input: SearchGameSessionsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AliasId !== undefined) {
    bodyParams["AliasId"] = input.AliasId;
  }
  if (input.FilterExpression !== undefined) {
    bodyParams["FilterExpression"] = input.FilterExpression;
  }
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.Limit !== undefined) {
    bodyParams["Limit"] = input.Limit;
  }
  if (input.NextToken !== undefined) {
    bodyParams["NextToken"] = input.NextToken;
  }
  if (input.SortExpression !== undefined) {
    bodyParams["SortExpression"] = input.SortExpression;
  }
  return bodyParams;
};

const serializeAws_json1_1ServerProcess = (
  input: ServerProcess,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConcurrentExecutions !== undefined) {
    bodyParams["ConcurrentExecutions"] = input.ConcurrentExecutions;
  }
  if (input.LaunchPath !== undefined) {
    bodyParams["LaunchPath"] = input.LaunchPath;
  }
  if (input.Parameters !== undefined) {
    bodyParams["Parameters"] = input.Parameters;
  }
  return bodyParams;
};

const serializeAws_json1_1ServerProcessList = (
  input: Array<ServerProcess>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1ServerProcess(entry, context));
  }
  return contents;
};

const serializeAws_json1_1StartFleetActionsInput = (
  input: StartFleetActionsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Actions !== undefined) {
    bodyParams["Actions"] = serializeAws_json1_1FleetActionList(
      input.Actions,
      context
    );
  }
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  return bodyParams;
};

const serializeAws_json1_1StartGameSessionPlacementInput = (
  input: StartGameSessionPlacementInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DesiredPlayerSessions !== undefined) {
    bodyParams[
      "DesiredPlayerSessions"
    ] = serializeAws_json1_1DesiredPlayerSessionList(
      input.DesiredPlayerSessions,
      context
    );
  }
  if (input.GameProperties !== undefined) {
    bodyParams["GameProperties"] = serializeAws_json1_1GamePropertyList(
      input.GameProperties,
      context
    );
  }
  if (input.GameSessionData !== undefined) {
    bodyParams["GameSessionData"] = input.GameSessionData;
  }
  if (input.GameSessionName !== undefined) {
    bodyParams["GameSessionName"] = input.GameSessionName;
  }
  if (input.GameSessionQueueName !== undefined) {
    bodyParams["GameSessionQueueName"] = input.GameSessionQueueName;
  }
  if (input.MaximumPlayerSessionCount !== undefined) {
    bodyParams["MaximumPlayerSessionCount"] = input.MaximumPlayerSessionCount;
  }
  if (input.PlacementId !== undefined) {
    bodyParams["PlacementId"] = input.PlacementId;
  }
  if (input.PlayerLatencies !== undefined) {
    bodyParams["PlayerLatencies"] = serializeAws_json1_1PlayerLatencyList(
      input.PlayerLatencies,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1StartMatchBackfillInput = (
  input: StartMatchBackfillInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConfigurationName !== undefined) {
    bodyParams["ConfigurationName"] = input.ConfigurationName;
  }
  if (input.GameSessionArn !== undefined) {
    bodyParams["GameSessionArn"] = input.GameSessionArn;
  }
  if (input.Players !== undefined) {
    bodyParams["Players"] = serializeAws_json1_1PlayerList(
      input.Players,
      context
    );
  }
  if (input.TicketId !== undefined) {
    bodyParams["TicketId"] = input.TicketId;
  }
  return bodyParams;
};

const serializeAws_json1_1StartMatchmakingInput = (
  input: StartMatchmakingInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ConfigurationName !== undefined) {
    bodyParams["ConfigurationName"] = input.ConfigurationName;
  }
  if (input.Players !== undefined) {
    bodyParams["Players"] = serializeAws_json1_1PlayerList(
      input.Players,
      context
    );
  }
  if (input.TicketId !== undefined) {
    bodyParams["TicketId"] = input.TicketId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopFleetActionsInput = (
  input: StopFleetActionsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Actions !== undefined) {
    bodyParams["Actions"] = serializeAws_json1_1FleetActionList(
      input.Actions,
      context
    );
  }
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopGameSessionPlacementInput = (
  input: StopGameSessionPlacementInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.PlacementId !== undefined) {
    bodyParams["PlacementId"] = input.PlacementId;
  }
  return bodyParams;
};

const serializeAws_json1_1StopMatchmakingInput = (
  input: StopMatchmakingInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TicketId !== undefined) {
    bodyParams["TicketId"] = input.TicketId;
  }
  return bodyParams;
};

const serializeAws_json1_1StringDoubleMap = (
  input: { [key: string]: number },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_json1_1StringList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagKeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Tag(entry, context));
  }
  return contents;
};

const serializeAws_json1_1TagResourceRequest = (
  input: TagResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceARN !== undefined) {
    bodyParams["ResourceARN"] = input.ResourceARN;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1TargetConfiguration = (
  input: TargetConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.TargetValue !== undefined) {
    bodyParams["TargetValue"] = input.TargetValue;
  }
  return bodyParams;
};

const serializeAws_json1_1UntagResourceRequest = (
  input: UntagResourceRequest,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceARN !== undefined) {
    bodyParams["ResourceARN"] = input.ResourceARN;
  }
  if (input.TagKeys !== undefined) {
    bodyParams["TagKeys"] = serializeAws_json1_1TagKeyList(
      input.TagKeys,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateAliasInput = (
  input: UpdateAliasInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AliasId !== undefined) {
    bodyParams["AliasId"] = input.AliasId;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.RoutingStrategy !== undefined) {
    bodyParams["RoutingStrategy"] = serializeAws_json1_1RoutingStrategy(
      input.RoutingStrategy,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateBuildInput = (
  input: UpdateBuildInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BuildId !== undefined) {
    bodyParams["BuildId"] = input.BuildId;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Version !== undefined) {
    bodyParams["Version"] = input.Version;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateFleetAttributesInput = (
  input: UpdateFleetAttributesInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.MetricGroups !== undefined) {
    bodyParams["MetricGroups"] = serializeAws_json1_1MetricGroupList(
      input.MetricGroups,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NewGameSessionProtectionPolicy !== undefined) {
    bodyParams["NewGameSessionProtectionPolicy"] =
      input.NewGameSessionProtectionPolicy;
  }
  if (input.ResourceCreationLimitPolicy !== undefined) {
    bodyParams[
      "ResourceCreationLimitPolicy"
    ] = serializeAws_json1_1ResourceCreationLimitPolicy(
      input.ResourceCreationLimitPolicy,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateFleetCapacityInput = (
  input: UpdateFleetCapacityInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.DesiredInstances !== undefined) {
    bodyParams["DesiredInstances"] = input.DesiredInstances;
  }
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.MaxSize !== undefined) {
    bodyParams["MaxSize"] = input.MaxSize;
  }
  if (input.MinSize !== undefined) {
    bodyParams["MinSize"] = input.MinSize;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateFleetPortSettingsInput = (
  input: UpdateFleetPortSettingsInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.InboundPermissionAuthorizations !== undefined) {
    bodyParams[
      "InboundPermissionAuthorizations"
    ] = serializeAws_json1_1IpPermissionsList(
      input.InboundPermissionAuthorizations,
      context
    );
  }
  if (input.InboundPermissionRevocations !== undefined) {
    bodyParams[
      "InboundPermissionRevocations"
    ] = serializeAws_json1_1IpPermissionsList(
      input.InboundPermissionRevocations,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateGameSessionInput = (
  input: UpdateGameSessionInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.GameSessionId !== undefined) {
    bodyParams["GameSessionId"] = input.GameSessionId;
  }
  if (input.MaximumPlayerSessionCount !== undefined) {
    bodyParams["MaximumPlayerSessionCount"] = input.MaximumPlayerSessionCount;
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.PlayerSessionCreationPolicy !== undefined) {
    bodyParams["PlayerSessionCreationPolicy"] =
      input.PlayerSessionCreationPolicy;
  }
  if (input.ProtectionPolicy !== undefined) {
    bodyParams["ProtectionPolicy"] = input.ProtectionPolicy;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateGameSessionQueueInput = (
  input: UpdateGameSessionQueueInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Destinations !== undefined) {
    bodyParams[
      "Destinations"
    ] = serializeAws_json1_1GameSessionQueueDestinationList(
      input.Destinations,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.PlayerLatencyPolicies !== undefined) {
    bodyParams[
      "PlayerLatencyPolicies"
    ] = serializeAws_json1_1PlayerLatencyPolicyList(
      input.PlayerLatencyPolicies,
      context
    );
  }
  if (input.TimeoutInSeconds !== undefined) {
    bodyParams["TimeoutInSeconds"] = input.TimeoutInSeconds;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateMatchmakingConfigurationInput = (
  input: UpdateMatchmakingConfigurationInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AcceptanceRequired !== undefined) {
    bodyParams["AcceptanceRequired"] = input.AcceptanceRequired;
  }
  if (input.AcceptanceTimeoutSeconds !== undefined) {
    bodyParams["AcceptanceTimeoutSeconds"] = input.AcceptanceTimeoutSeconds;
  }
  if (input.AdditionalPlayerCount !== undefined) {
    bodyParams["AdditionalPlayerCount"] = input.AdditionalPlayerCount;
  }
  if (input.BackfillMode !== undefined) {
    bodyParams["BackfillMode"] = input.BackfillMode;
  }
  if (input.CustomEventData !== undefined) {
    bodyParams["CustomEventData"] = input.CustomEventData;
  }
  if (input.Description !== undefined) {
    bodyParams["Description"] = input.Description;
  }
  if (input.GameProperties !== undefined) {
    bodyParams["GameProperties"] = serializeAws_json1_1GamePropertyList(
      input.GameProperties,
      context
    );
  }
  if (input.GameSessionData !== undefined) {
    bodyParams["GameSessionData"] = input.GameSessionData;
  }
  if (input.GameSessionQueueArns !== undefined) {
    bodyParams["GameSessionQueueArns"] = serializeAws_json1_1QueueArnsList(
      input.GameSessionQueueArns,
      context
    );
  }
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.NotificationTarget !== undefined) {
    bodyParams["NotificationTarget"] = input.NotificationTarget;
  }
  if (input.RequestTimeoutSeconds !== undefined) {
    bodyParams["RequestTimeoutSeconds"] = input.RequestTimeoutSeconds;
  }
  if (input.RuleSetName !== undefined) {
    bodyParams["RuleSetName"] = input.RuleSetName;
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateRuntimeConfigurationInput = (
  input: UpdateRuntimeConfigurationInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.FleetId !== undefined) {
    bodyParams["FleetId"] = input.FleetId;
  }
  if (input.RuntimeConfiguration !== undefined) {
    bodyParams[
      "RuntimeConfiguration"
    ] = serializeAws_json1_1RuntimeConfiguration(
      input.RuntimeConfiguration,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1UpdateScriptInput = (
  input: UpdateScriptInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.ScriptId !== undefined) {
    bodyParams["ScriptId"] = input.ScriptId;
  }
  if (input.StorageLocation !== undefined) {
    bodyParams["StorageLocation"] = serializeAws_json1_1S3Location(
      input.StorageLocation,
      context
    );
  }
  if (input.Version !== undefined) {
    bodyParams["Version"] = input.Version;
  }
  if (input.ZipFile !== undefined) {
    bodyParams["ZipFile"] = context.base64Encoder(input.ZipFile);
  }
  return bodyParams;
};

const serializeAws_json1_1ValidateMatchmakingRuleSetInput = (
  input: ValidateMatchmakingRuleSetInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.RuleSetBody !== undefined) {
    bodyParams["RuleSetBody"] = input.RuleSetBody;
  }
  return bodyParams;
};

const deserializeAws_json1_1AcceptMatchOutput = (
  output: any,
  context: __SerdeContext
): AcceptMatchOutput => {
  let contents: any = {
    __type: "AcceptMatchOutput"
  };
  return contents;
};

const deserializeAws_json1_1Alias = (
  output: any,
  context: __SerdeContext
): Alias => {
  let contents: any = {
    __type: "Alias",
    AliasArn: undefined,
    AliasId: undefined,
    CreationTime: undefined,
    Description: undefined,
    LastUpdatedTime: undefined,
    Name: undefined,
    RoutingStrategy: undefined
  };
  if (output.AliasArn !== undefined && output.AliasArn !== null) {
    contents.AliasArn = output.AliasArn;
  }
  if (output.AliasId !== undefined && output.AliasId !== null) {
    contents.AliasId = output.AliasId;
  }
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.LastUpdatedTime !== undefined && output.LastUpdatedTime !== null) {
    contents.LastUpdatedTime = new Date(
      Math.round(output.LastUpdatedTime * 1000)
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.RoutingStrategy !== undefined && output.RoutingStrategy !== null) {
    contents.RoutingStrategy = deserializeAws_json1_1RoutingStrategy(
      output.RoutingStrategy,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1AliasList = (
  output: any,
  context: __SerdeContext
): Array<Alias> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Alias(entry, context)
  );
};

const deserializeAws_json1_1AttributeValue = (
  output: any,
  context: __SerdeContext
): AttributeValue => {
  let contents: any = {
    __type: "AttributeValue",
    N: undefined,
    S: undefined,
    SDM: undefined,
    SL: undefined
  };
  if (output.N !== undefined && output.N !== null) {
    contents.N = output.N;
  }
  if (output.S !== undefined && output.S !== null) {
    contents.S = output.S;
  }
  if (output.SDM !== undefined && output.SDM !== null) {
    contents.SDM = deserializeAws_json1_1StringDoubleMap(output.SDM, context);
  }
  if (output.SL !== undefined && output.SL !== null) {
    contents.SL = deserializeAws_json1_1StringList(output.SL, context);
  }
  return contents;
};

const deserializeAws_json1_1AwsCredentials = (
  output: any,
  context: __SerdeContext
): AwsCredentials => {
  let contents: any = {
    __type: "AwsCredentials",
    AccessKeyId: undefined,
    SecretAccessKey: undefined,
    SessionToken: undefined
  };
  if (output.AccessKeyId !== undefined && output.AccessKeyId !== null) {
    contents.AccessKeyId = output.AccessKeyId;
  }
  if (output.SecretAccessKey !== undefined && output.SecretAccessKey !== null) {
    contents.SecretAccessKey = output.SecretAccessKey;
  }
  if (output.SessionToken !== undefined && output.SessionToken !== null) {
    contents.SessionToken = output.SessionToken;
  }
  return contents;
};

const deserializeAws_json1_1Build = (
  output: any,
  context: __SerdeContext
): Build => {
  let contents: any = {
    __type: "Build",
    BuildArn: undefined,
    BuildId: undefined,
    CreationTime: undefined,
    Name: undefined,
    OperatingSystem: undefined,
    SizeOnDisk: undefined,
    Status: undefined,
    Version: undefined
  };
  if (output.BuildArn !== undefined && output.BuildArn !== null) {
    contents.BuildArn = output.BuildArn;
  }
  if (output.BuildId !== undefined && output.BuildId !== null) {
    contents.BuildId = output.BuildId;
  }
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.OperatingSystem !== undefined && output.OperatingSystem !== null) {
    contents.OperatingSystem = output.OperatingSystem;
  }
  if (output.SizeOnDisk !== undefined && output.SizeOnDisk !== null) {
    contents.SizeOnDisk = output.SizeOnDisk;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1BuildList = (
  output: any,
  context: __SerdeContext
): Array<Build> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Build(entry, context)
  );
};

const deserializeAws_json1_1CertificateConfiguration = (
  output: any,
  context: __SerdeContext
): CertificateConfiguration => {
  let contents: any = {
    __type: "CertificateConfiguration",
    CertificateType: undefined
  };
  if (output.CertificateType !== undefined && output.CertificateType !== null) {
    contents.CertificateType = output.CertificateType;
  }
  return contents;
};

const deserializeAws_json1_1ConflictException = (
  output: any,
  context: __SerdeContext
): ConflictException => {
  let contents: any = {
    __type: "ConflictException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1CreateAliasOutput = (
  output: any,
  context: __SerdeContext
): CreateAliasOutput => {
  let contents: any = {
    __type: "CreateAliasOutput",
    Alias: undefined
  };
  if (output.Alias !== undefined && output.Alias !== null) {
    contents.Alias = deserializeAws_json1_1Alias(output.Alias, context);
  }
  return contents;
};

const deserializeAws_json1_1CreateBuildOutput = (
  output: any,
  context: __SerdeContext
): CreateBuildOutput => {
  let contents: any = {
    __type: "CreateBuildOutput",
    Build: undefined,
    StorageLocation: undefined,
    UploadCredentials: undefined
  };
  if (output.Build !== undefined && output.Build !== null) {
    contents.Build = deserializeAws_json1_1Build(output.Build, context);
  }
  if (output.StorageLocation !== undefined && output.StorageLocation !== null) {
    contents.StorageLocation = deserializeAws_json1_1S3Location(
      output.StorageLocation,
      context
    );
  }
  if (
    output.UploadCredentials !== undefined &&
    output.UploadCredentials !== null
  ) {
    contents.UploadCredentials = deserializeAws_json1_1AwsCredentials(
      output.UploadCredentials,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateFleetOutput = (
  output: any,
  context: __SerdeContext
): CreateFleetOutput => {
  let contents: any = {
    __type: "CreateFleetOutput",
    FleetAttributes: undefined
  };
  if (output.FleetAttributes !== undefined && output.FleetAttributes !== null) {
    contents.FleetAttributes = deserializeAws_json1_1FleetAttributes(
      output.FleetAttributes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateGameSessionOutput = (
  output: any,
  context: __SerdeContext
): CreateGameSessionOutput => {
  let contents: any = {
    __type: "CreateGameSessionOutput",
    GameSession: undefined
  };
  if (output.GameSession !== undefined && output.GameSession !== null) {
    contents.GameSession = deserializeAws_json1_1GameSession(
      output.GameSession,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateGameSessionQueueOutput = (
  output: any,
  context: __SerdeContext
): CreateGameSessionQueueOutput => {
  let contents: any = {
    __type: "CreateGameSessionQueueOutput",
    GameSessionQueue: undefined
  };
  if (
    output.GameSessionQueue !== undefined &&
    output.GameSessionQueue !== null
  ) {
    contents.GameSessionQueue = deserializeAws_json1_1GameSessionQueue(
      output.GameSessionQueue,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateMatchmakingConfigurationOutput = (
  output: any,
  context: __SerdeContext
): CreateMatchmakingConfigurationOutput => {
  let contents: any = {
    __type: "CreateMatchmakingConfigurationOutput",
    Configuration: undefined
  };
  if (output.Configuration !== undefined && output.Configuration !== null) {
    contents.Configuration = deserializeAws_json1_1MatchmakingConfiguration(
      output.Configuration,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateMatchmakingRuleSetOutput = (
  output: any,
  context: __SerdeContext
): CreateMatchmakingRuleSetOutput => {
  let contents: any = {
    __type: "CreateMatchmakingRuleSetOutput",
    RuleSet: undefined
  };
  if (output.RuleSet !== undefined && output.RuleSet !== null) {
    contents.RuleSet = deserializeAws_json1_1MatchmakingRuleSet(
      output.RuleSet,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreatePlayerSessionOutput = (
  output: any,
  context: __SerdeContext
): CreatePlayerSessionOutput => {
  let contents: any = {
    __type: "CreatePlayerSessionOutput",
    PlayerSession: undefined
  };
  if (output.PlayerSession !== undefined && output.PlayerSession !== null) {
    contents.PlayerSession = deserializeAws_json1_1PlayerSession(
      output.PlayerSession,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreatePlayerSessionsOutput = (
  output: any,
  context: __SerdeContext
): CreatePlayerSessionsOutput => {
  let contents: any = {
    __type: "CreatePlayerSessionsOutput",
    PlayerSessions: undefined
  };
  if (output.PlayerSessions !== undefined && output.PlayerSessions !== null) {
    contents.PlayerSessions = deserializeAws_json1_1PlayerSessionList(
      output.PlayerSessions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateScriptOutput = (
  output: any,
  context: __SerdeContext
): CreateScriptOutput => {
  let contents: any = {
    __type: "CreateScriptOutput",
    Script: undefined
  };
  if (output.Script !== undefined && output.Script !== null) {
    contents.Script = deserializeAws_json1_1Script(output.Script, context);
  }
  return contents;
};

const deserializeAws_json1_1CreateVpcPeeringAuthorizationOutput = (
  output: any,
  context: __SerdeContext
): CreateVpcPeeringAuthorizationOutput => {
  let contents: any = {
    __type: "CreateVpcPeeringAuthorizationOutput",
    VpcPeeringAuthorization: undefined
  };
  if (
    output.VpcPeeringAuthorization !== undefined &&
    output.VpcPeeringAuthorization !== null
  ) {
    contents.VpcPeeringAuthorization = deserializeAws_json1_1VpcPeeringAuthorization(
      output.VpcPeeringAuthorization,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateVpcPeeringConnectionOutput = (
  output: any,
  context: __SerdeContext
): CreateVpcPeeringConnectionOutput => {
  let contents: any = {
    __type: "CreateVpcPeeringConnectionOutput"
  };
  return contents;
};

const deserializeAws_json1_1DeleteGameSessionQueueOutput = (
  output: any,
  context: __SerdeContext
): DeleteGameSessionQueueOutput => {
  let contents: any = {
    __type: "DeleteGameSessionQueueOutput"
  };
  return contents;
};

const deserializeAws_json1_1DeleteMatchmakingConfigurationOutput = (
  output: any,
  context: __SerdeContext
): DeleteMatchmakingConfigurationOutput => {
  let contents: any = {
    __type: "DeleteMatchmakingConfigurationOutput"
  };
  return contents;
};

const deserializeAws_json1_1DeleteMatchmakingRuleSetOutput = (
  output: any,
  context: __SerdeContext
): DeleteMatchmakingRuleSetOutput => {
  let contents: any = {
    __type: "DeleteMatchmakingRuleSetOutput"
  };
  return contents;
};

const deserializeAws_json1_1DeleteVpcPeeringAuthorizationOutput = (
  output: any,
  context: __SerdeContext
): DeleteVpcPeeringAuthorizationOutput => {
  let contents: any = {
    __type: "DeleteVpcPeeringAuthorizationOutput"
  };
  return contents;
};

const deserializeAws_json1_1DeleteVpcPeeringConnectionOutput = (
  output: any,
  context: __SerdeContext
): DeleteVpcPeeringConnectionOutput => {
  let contents: any = {
    __type: "DeleteVpcPeeringConnectionOutput"
  };
  return contents;
};

const deserializeAws_json1_1DescribeAliasOutput = (
  output: any,
  context: __SerdeContext
): DescribeAliasOutput => {
  let contents: any = {
    __type: "DescribeAliasOutput",
    Alias: undefined
  };
  if (output.Alias !== undefined && output.Alias !== null) {
    contents.Alias = deserializeAws_json1_1Alias(output.Alias, context);
  }
  return contents;
};

const deserializeAws_json1_1DescribeBuildOutput = (
  output: any,
  context: __SerdeContext
): DescribeBuildOutput => {
  let contents: any = {
    __type: "DescribeBuildOutput",
    Build: undefined
  };
  if (output.Build !== undefined && output.Build !== null) {
    contents.Build = deserializeAws_json1_1Build(output.Build, context);
  }
  return contents;
};

const deserializeAws_json1_1DescribeEC2InstanceLimitsOutput = (
  output: any,
  context: __SerdeContext
): DescribeEC2InstanceLimitsOutput => {
  let contents: any = {
    __type: "DescribeEC2InstanceLimitsOutput",
    EC2InstanceLimits: undefined
  };
  if (
    output.EC2InstanceLimits !== undefined &&
    output.EC2InstanceLimits !== null
  ) {
    contents.EC2InstanceLimits = deserializeAws_json1_1EC2InstanceLimitList(
      output.EC2InstanceLimits,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeFleetAttributesOutput = (
  output: any,
  context: __SerdeContext
): DescribeFleetAttributesOutput => {
  let contents: any = {
    __type: "DescribeFleetAttributesOutput",
    FleetAttributes: undefined,
    NextToken: undefined
  };
  if (output.FleetAttributes !== undefined && output.FleetAttributes !== null) {
    contents.FleetAttributes = deserializeAws_json1_1FleetAttributesList(
      output.FleetAttributes,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeFleetCapacityOutput = (
  output: any,
  context: __SerdeContext
): DescribeFleetCapacityOutput => {
  let contents: any = {
    __type: "DescribeFleetCapacityOutput",
    FleetCapacity: undefined,
    NextToken: undefined
  };
  if (output.FleetCapacity !== undefined && output.FleetCapacity !== null) {
    contents.FleetCapacity = deserializeAws_json1_1FleetCapacityList(
      output.FleetCapacity,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeFleetEventsOutput = (
  output: any,
  context: __SerdeContext
): DescribeFleetEventsOutput => {
  let contents: any = {
    __type: "DescribeFleetEventsOutput",
    Events: undefined,
    NextToken: undefined
  };
  if (output.Events !== undefined && output.Events !== null) {
    contents.Events = deserializeAws_json1_1EventList(output.Events, context);
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeFleetPortSettingsOutput = (
  output: any,
  context: __SerdeContext
): DescribeFleetPortSettingsOutput => {
  let contents: any = {
    __type: "DescribeFleetPortSettingsOutput",
    InboundPermissions: undefined
  };
  if (
    output.InboundPermissions !== undefined &&
    output.InboundPermissions !== null
  ) {
    contents.InboundPermissions = deserializeAws_json1_1IpPermissionsList(
      output.InboundPermissions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeFleetUtilizationOutput = (
  output: any,
  context: __SerdeContext
): DescribeFleetUtilizationOutput => {
  let contents: any = {
    __type: "DescribeFleetUtilizationOutput",
    FleetUtilization: undefined,
    NextToken: undefined
  };
  if (
    output.FleetUtilization !== undefined &&
    output.FleetUtilization !== null
  ) {
    contents.FleetUtilization = deserializeAws_json1_1FleetUtilizationList(
      output.FleetUtilization,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeGameSessionDetailsOutput = (
  output: any,
  context: __SerdeContext
): DescribeGameSessionDetailsOutput => {
  let contents: any = {
    __type: "DescribeGameSessionDetailsOutput",
    GameSessionDetails: undefined,
    NextToken: undefined
  };
  if (
    output.GameSessionDetails !== undefined &&
    output.GameSessionDetails !== null
  ) {
    contents.GameSessionDetails = deserializeAws_json1_1GameSessionDetailList(
      output.GameSessionDetails,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeGameSessionPlacementOutput = (
  output: any,
  context: __SerdeContext
): DescribeGameSessionPlacementOutput => {
  let contents: any = {
    __type: "DescribeGameSessionPlacementOutput",
    GameSessionPlacement: undefined
  };
  if (
    output.GameSessionPlacement !== undefined &&
    output.GameSessionPlacement !== null
  ) {
    contents.GameSessionPlacement = deserializeAws_json1_1GameSessionPlacement(
      output.GameSessionPlacement,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeGameSessionQueuesOutput = (
  output: any,
  context: __SerdeContext
): DescribeGameSessionQueuesOutput => {
  let contents: any = {
    __type: "DescribeGameSessionQueuesOutput",
    GameSessionQueues: undefined,
    NextToken: undefined
  };
  if (
    output.GameSessionQueues !== undefined &&
    output.GameSessionQueues !== null
  ) {
    contents.GameSessionQueues = deserializeAws_json1_1GameSessionQueueList(
      output.GameSessionQueues,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeGameSessionsOutput = (
  output: any,
  context: __SerdeContext
): DescribeGameSessionsOutput => {
  let contents: any = {
    __type: "DescribeGameSessionsOutput",
    GameSessions: undefined,
    NextToken: undefined
  };
  if (output.GameSessions !== undefined && output.GameSessions !== null) {
    contents.GameSessions = deserializeAws_json1_1GameSessionList(
      output.GameSessions,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeInstancesOutput = (
  output: any,
  context: __SerdeContext
): DescribeInstancesOutput => {
  let contents: any = {
    __type: "DescribeInstancesOutput",
    Instances: undefined,
    NextToken: undefined
  };
  if (output.Instances !== undefined && output.Instances !== null) {
    contents.Instances = deserializeAws_json1_1InstanceList(
      output.Instances,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeMatchmakingConfigurationsOutput = (
  output: any,
  context: __SerdeContext
): DescribeMatchmakingConfigurationsOutput => {
  let contents: any = {
    __type: "DescribeMatchmakingConfigurationsOutput",
    Configurations: undefined,
    NextToken: undefined
  };
  if (output.Configurations !== undefined && output.Configurations !== null) {
    contents.Configurations = deserializeAws_json1_1MatchmakingConfigurationList(
      output.Configurations,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1DescribeMatchmakingOutput = (
  output: any,
  context: __SerdeContext
): DescribeMatchmakingOutput => {
  let contents: any = {
    __type: "DescribeMatchmakingOutput",
    TicketList: undefined
  };
  if (output.TicketList !== undefined && output.TicketList !== null) {
    contents.TicketList = deserializeAws_json1_1MatchmakingTicketList(
      output.TicketList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeMatchmakingRuleSetsOutput = (
  output: any,
  context: __SerdeContext
): DescribeMatchmakingRuleSetsOutput => {
  let contents: any = {
    __type: "DescribeMatchmakingRuleSetsOutput",
    NextToken: undefined,
    RuleSets: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.RuleSets !== undefined && output.RuleSets !== null) {
    contents.RuleSets = deserializeAws_json1_1MatchmakingRuleSetList(
      output.RuleSets,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribePlayerSessionsOutput = (
  output: any,
  context: __SerdeContext
): DescribePlayerSessionsOutput => {
  let contents: any = {
    __type: "DescribePlayerSessionsOutput",
    NextToken: undefined,
    PlayerSessions: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.PlayerSessions !== undefined && output.PlayerSessions !== null) {
    contents.PlayerSessions = deserializeAws_json1_1PlayerSessionList(
      output.PlayerSessions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeRuntimeConfigurationOutput = (
  output: any,
  context: __SerdeContext
): DescribeRuntimeConfigurationOutput => {
  let contents: any = {
    __type: "DescribeRuntimeConfigurationOutput",
    RuntimeConfiguration: undefined
  };
  if (
    output.RuntimeConfiguration !== undefined &&
    output.RuntimeConfiguration !== null
  ) {
    contents.RuntimeConfiguration = deserializeAws_json1_1RuntimeConfiguration(
      output.RuntimeConfiguration,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeScalingPoliciesOutput = (
  output: any,
  context: __SerdeContext
): DescribeScalingPoliciesOutput => {
  let contents: any = {
    __type: "DescribeScalingPoliciesOutput",
    NextToken: undefined,
    ScalingPolicies: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.ScalingPolicies !== undefined && output.ScalingPolicies !== null) {
    contents.ScalingPolicies = deserializeAws_json1_1ScalingPolicyList(
      output.ScalingPolicies,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeScriptOutput = (
  output: any,
  context: __SerdeContext
): DescribeScriptOutput => {
  let contents: any = {
    __type: "DescribeScriptOutput",
    Script: undefined
  };
  if (output.Script !== undefined && output.Script !== null) {
    contents.Script = deserializeAws_json1_1Script(output.Script, context);
  }
  return contents;
};

const deserializeAws_json1_1DescribeVpcPeeringAuthorizationsOutput = (
  output: any,
  context: __SerdeContext
): DescribeVpcPeeringAuthorizationsOutput => {
  let contents: any = {
    __type: "DescribeVpcPeeringAuthorizationsOutput",
    VpcPeeringAuthorizations: undefined
  };
  if (
    output.VpcPeeringAuthorizations !== undefined &&
    output.VpcPeeringAuthorizations !== null
  ) {
    contents.VpcPeeringAuthorizations = deserializeAws_json1_1VpcPeeringAuthorizationList(
      output.VpcPeeringAuthorizations,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeVpcPeeringConnectionsOutput = (
  output: any,
  context: __SerdeContext
): DescribeVpcPeeringConnectionsOutput => {
  let contents: any = {
    __type: "DescribeVpcPeeringConnectionsOutput",
    VpcPeeringConnections: undefined
  };
  if (
    output.VpcPeeringConnections !== undefined &&
    output.VpcPeeringConnections !== null
  ) {
    contents.VpcPeeringConnections = deserializeAws_json1_1VpcPeeringConnectionList(
      output.VpcPeeringConnections,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1EC2InstanceCounts = (
  output: any,
  context: __SerdeContext
): EC2InstanceCounts => {
  let contents: any = {
    __type: "EC2InstanceCounts",
    ACTIVE: undefined,
    DESIRED: undefined,
    IDLE: undefined,
    MAXIMUM: undefined,
    MINIMUM: undefined,
    PENDING: undefined,
    TERMINATING: undefined
  };
  if (output.ACTIVE !== undefined && output.ACTIVE !== null) {
    contents.ACTIVE = output.ACTIVE;
  }
  if (output.DESIRED !== undefined && output.DESIRED !== null) {
    contents.DESIRED = output.DESIRED;
  }
  if (output.IDLE !== undefined && output.IDLE !== null) {
    contents.IDLE = output.IDLE;
  }
  if (output.MAXIMUM !== undefined && output.MAXIMUM !== null) {
    contents.MAXIMUM = output.MAXIMUM;
  }
  if (output.MINIMUM !== undefined && output.MINIMUM !== null) {
    contents.MINIMUM = output.MINIMUM;
  }
  if (output.PENDING !== undefined && output.PENDING !== null) {
    contents.PENDING = output.PENDING;
  }
  if (output.TERMINATING !== undefined && output.TERMINATING !== null) {
    contents.TERMINATING = output.TERMINATING;
  }
  return contents;
};

const deserializeAws_json1_1EC2InstanceLimit = (
  output: any,
  context: __SerdeContext
): EC2InstanceLimit => {
  let contents: any = {
    __type: "EC2InstanceLimit",
    CurrentInstances: undefined,
    EC2InstanceType: undefined,
    InstanceLimit: undefined
  };
  if (
    output.CurrentInstances !== undefined &&
    output.CurrentInstances !== null
  ) {
    contents.CurrentInstances = output.CurrentInstances;
  }
  if (output.EC2InstanceType !== undefined && output.EC2InstanceType !== null) {
    contents.EC2InstanceType = output.EC2InstanceType;
  }
  if (output.InstanceLimit !== undefined && output.InstanceLimit !== null) {
    contents.InstanceLimit = output.InstanceLimit;
  }
  return contents;
};

const deserializeAws_json1_1EC2InstanceLimitList = (
  output: any,
  context: __SerdeContext
): Array<EC2InstanceLimit> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EC2InstanceLimit(entry, context)
  );
};

const deserializeAws_json1_1Event = (
  output: any,
  context: __SerdeContext
): Event => {
  let contents: any = {
    __type: "Event",
    EventCode: undefined,
    EventId: undefined,
    EventTime: undefined,
    Message: undefined,
    PreSignedLogUrl: undefined,
    ResourceId: undefined
  };
  if (output.EventCode !== undefined && output.EventCode !== null) {
    contents.EventCode = output.EventCode;
  }
  if (output.EventId !== undefined && output.EventId !== null) {
    contents.EventId = output.EventId;
  }
  if (output.EventTime !== undefined && output.EventTime !== null) {
    contents.EventTime = new Date(Math.round(output.EventTime * 1000));
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.PreSignedLogUrl !== undefined && output.PreSignedLogUrl !== null) {
    contents.PreSignedLogUrl = output.PreSignedLogUrl;
  }
  if (output.ResourceId !== undefined && output.ResourceId !== null) {
    contents.ResourceId = output.ResourceId;
  }
  return contents;
};

const deserializeAws_json1_1EventList = (
  output: any,
  context: __SerdeContext
): Array<Event> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Event(entry, context)
  );
};

const deserializeAws_json1_1FleetActionList = (
  output: any,
  context: __SerdeContext
): Array<FleetAction | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1FleetAttributes = (
  output: any,
  context: __SerdeContext
): FleetAttributes => {
  let contents: any = {
    __type: "FleetAttributes",
    BuildArn: undefined,
    BuildId: undefined,
    CertificateConfiguration: undefined,
    CreationTime: undefined,
    Description: undefined,
    FleetArn: undefined,
    FleetId: undefined,
    FleetType: undefined,
    InstanceRoleArn: undefined,
    InstanceType: undefined,
    LogPaths: undefined,
    MetricGroups: undefined,
    Name: undefined,
    NewGameSessionProtectionPolicy: undefined,
    OperatingSystem: undefined,
    ResourceCreationLimitPolicy: undefined,
    ScriptArn: undefined,
    ScriptId: undefined,
    ServerLaunchParameters: undefined,
    ServerLaunchPath: undefined,
    Status: undefined,
    StoppedActions: undefined,
    TerminationTime: undefined
  };
  if (output.BuildArn !== undefined && output.BuildArn !== null) {
    contents.BuildArn = output.BuildArn;
  }
  if (output.BuildId !== undefined && output.BuildId !== null) {
    contents.BuildId = output.BuildId;
  }
  if (
    output.CertificateConfiguration !== undefined &&
    output.CertificateConfiguration !== null
  ) {
    contents.CertificateConfiguration = deserializeAws_json1_1CertificateConfiguration(
      output.CertificateConfiguration,
      context
    );
  }
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.FleetArn !== undefined && output.FleetArn !== null) {
    contents.FleetArn = output.FleetArn;
  }
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  if (output.FleetType !== undefined && output.FleetType !== null) {
    contents.FleetType = output.FleetType;
  }
  if (output.InstanceRoleArn !== undefined && output.InstanceRoleArn !== null) {
    contents.InstanceRoleArn = output.InstanceRoleArn;
  }
  if (output.InstanceType !== undefined && output.InstanceType !== null) {
    contents.InstanceType = output.InstanceType;
  }
  if (output.LogPaths !== undefined && output.LogPaths !== null) {
    contents.LogPaths = deserializeAws_json1_1StringList(
      output.LogPaths,
      context
    );
  }
  if (output.MetricGroups !== undefined && output.MetricGroups !== null) {
    contents.MetricGroups = deserializeAws_json1_1MetricGroupList(
      output.MetricGroups,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.NewGameSessionProtectionPolicy !== undefined &&
    output.NewGameSessionProtectionPolicy !== null
  ) {
    contents.NewGameSessionProtectionPolicy =
      output.NewGameSessionProtectionPolicy;
  }
  if (output.OperatingSystem !== undefined && output.OperatingSystem !== null) {
    contents.OperatingSystem = output.OperatingSystem;
  }
  if (
    output.ResourceCreationLimitPolicy !== undefined &&
    output.ResourceCreationLimitPolicy !== null
  ) {
    contents.ResourceCreationLimitPolicy = deserializeAws_json1_1ResourceCreationLimitPolicy(
      output.ResourceCreationLimitPolicy,
      context
    );
  }
  if (output.ScriptArn !== undefined && output.ScriptArn !== null) {
    contents.ScriptArn = output.ScriptArn;
  }
  if (output.ScriptId !== undefined && output.ScriptId !== null) {
    contents.ScriptId = output.ScriptId;
  }
  if (
    output.ServerLaunchParameters !== undefined &&
    output.ServerLaunchParameters !== null
  ) {
    contents.ServerLaunchParameters = output.ServerLaunchParameters;
  }
  if (
    output.ServerLaunchPath !== undefined &&
    output.ServerLaunchPath !== null
  ) {
    contents.ServerLaunchPath = output.ServerLaunchPath;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StoppedActions !== undefined && output.StoppedActions !== null) {
    contents.StoppedActions = deserializeAws_json1_1FleetActionList(
      output.StoppedActions,
      context
    );
  }
  if (output.TerminationTime !== undefined && output.TerminationTime !== null) {
    contents.TerminationTime = new Date(
      Math.round(output.TerminationTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1FleetAttributesList = (
  output: any,
  context: __SerdeContext
): Array<FleetAttributes> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1FleetAttributes(entry, context)
  );
};

const deserializeAws_json1_1FleetCapacity = (
  output: any,
  context: __SerdeContext
): FleetCapacity => {
  let contents: any = {
    __type: "FleetCapacity",
    FleetId: undefined,
    InstanceCounts: undefined,
    InstanceType: undefined
  };
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  if (output.InstanceCounts !== undefined && output.InstanceCounts !== null) {
    contents.InstanceCounts = deserializeAws_json1_1EC2InstanceCounts(
      output.InstanceCounts,
      context
    );
  }
  if (output.InstanceType !== undefined && output.InstanceType !== null) {
    contents.InstanceType = output.InstanceType;
  }
  return contents;
};

const deserializeAws_json1_1FleetCapacityExceededException = (
  output: any,
  context: __SerdeContext
): FleetCapacityExceededException => {
  let contents: any = {
    __type: "FleetCapacityExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1FleetCapacityList = (
  output: any,
  context: __SerdeContext
): Array<FleetCapacity> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1FleetCapacity(entry, context)
  );
};

const deserializeAws_json1_1FleetIdList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1FleetUtilization = (
  output: any,
  context: __SerdeContext
): FleetUtilization => {
  let contents: any = {
    __type: "FleetUtilization",
    ActiveGameSessionCount: undefined,
    ActiveServerProcessCount: undefined,
    CurrentPlayerSessionCount: undefined,
    FleetId: undefined,
    MaximumPlayerSessionCount: undefined
  };
  if (
    output.ActiveGameSessionCount !== undefined &&
    output.ActiveGameSessionCount !== null
  ) {
    contents.ActiveGameSessionCount = output.ActiveGameSessionCount;
  }
  if (
    output.ActiveServerProcessCount !== undefined &&
    output.ActiveServerProcessCount !== null
  ) {
    contents.ActiveServerProcessCount = output.ActiveServerProcessCount;
  }
  if (
    output.CurrentPlayerSessionCount !== undefined &&
    output.CurrentPlayerSessionCount !== null
  ) {
    contents.CurrentPlayerSessionCount = output.CurrentPlayerSessionCount;
  }
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  if (
    output.MaximumPlayerSessionCount !== undefined &&
    output.MaximumPlayerSessionCount !== null
  ) {
    contents.MaximumPlayerSessionCount = output.MaximumPlayerSessionCount;
  }
  return contents;
};

const deserializeAws_json1_1FleetUtilizationList = (
  output: any,
  context: __SerdeContext
): Array<FleetUtilization> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1FleetUtilization(entry, context)
  );
};

const deserializeAws_json1_1GameProperty = (
  output: any,
  context: __SerdeContext
): GameProperty => {
  let contents: any = {
    __type: "GameProperty",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1GamePropertyList = (
  output: any,
  context: __SerdeContext
): Array<GameProperty> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1GameProperty(entry, context)
  );
};

const deserializeAws_json1_1GameSession = (
  output: any,
  context: __SerdeContext
): GameSession => {
  let contents: any = {
    __type: "GameSession",
    CreationTime: undefined,
    CreatorId: undefined,
    CurrentPlayerSessionCount: undefined,
    DnsName: undefined,
    FleetArn: undefined,
    FleetId: undefined,
    GameProperties: undefined,
    GameSessionData: undefined,
    GameSessionId: undefined,
    IpAddress: undefined,
    MatchmakerData: undefined,
    MaximumPlayerSessionCount: undefined,
    Name: undefined,
    PlayerSessionCreationPolicy: undefined,
    Port: undefined,
    Status: undefined,
    StatusReason: undefined,
    TerminationTime: undefined
  };
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.CreatorId !== undefined && output.CreatorId !== null) {
    contents.CreatorId = output.CreatorId;
  }
  if (
    output.CurrentPlayerSessionCount !== undefined &&
    output.CurrentPlayerSessionCount !== null
  ) {
    contents.CurrentPlayerSessionCount = output.CurrentPlayerSessionCount;
  }
  if (output.DnsName !== undefined && output.DnsName !== null) {
    contents.DnsName = output.DnsName;
  }
  if (output.FleetArn !== undefined && output.FleetArn !== null) {
    contents.FleetArn = output.FleetArn;
  }
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  if (output.GameProperties !== undefined && output.GameProperties !== null) {
    contents.GameProperties = deserializeAws_json1_1GamePropertyList(
      output.GameProperties,
      context
    );
  }
  if (output.GameSessionData !== undefined && output.GameSessionData !== null) {
    contents.GameSessionData = output.GameSessionData;
  }
  if (output.GameSessionId !== undefined && output.GameSessionId !== null) {
    contents.GameSessionId = output.GameSessionId;
  }
  if (output.IpAddress !== undefined && output.IpAddress !== null) {
    contents.IpAddress = output.IpAddress;
  }
  if (output.MatchmakerData !== undefined && output.MatchmakerData !== null) {
    contents.MatchmakerData = output.MatchmakerData;
  }
  if (
    output.MaximumPlayerSessionCount !== undefined &&
    output.MaximumPlayerSessionCount !== null
  ) {
    contents.MaximumPlayerSessionCount = output.MaximumPlayerSessionCount;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.PlayerSessionCreationPolicy !== undefined &&
    output.PlayerSessionCreationPolicy !== null
  ) {
    contents.PlayerSessionCreationPolicy = output.PlayerSessionCreationPolicy;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusReason !== undefined && output.StatusReason !== null) {
    contents.StatusReason = output.StatusReason;
  }
  if (output.TerminationTime !== undefined && output.TerminationTime !== null) {
    contents.TerminationTime = new Date(
      Math.round(output.TerminationTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1GameSessionConnectionInfo = (
  output: any,
  context: __SerdeContext
): GameSessionConnectionInfo => {
  let contents: any = {
    __type: "GameSessionConnectionInfo",
    DnsName: undefined,
    GameSessionArn: undefined,
    IpAddress: undefined,
    MatchedPlayerSessions: undefined,
    Port: undefined
  };
  if (output.DnsName !== undefined && output.DnsName !== null) {
    contents.DnsName = output.DnsName;
  }
  if (output.GameSessionArn !== undefined && output.GameSessionArn !== null) {
    contents.GameSessionArn = output.GameSessionArn;
  }
  if (output.IpAddress !== undefined && output.IpAddress !== null) {
    contents.IpAddress = output.IpAddress;
  }
  if (
    output.MatchedPlayerSessions !== undefined &&
    output.MatchedPlayerSessions !== null
  ) {
    contents.MatchedPlayerSessions = deserializeAws_json1_1MatchedPlayerSessionList(
      output.MatchedPlayerSessions,
      context
    );
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  return contents;
};

const deserializeAws_json1_1GameSessionDetail = (
  output: any,
  context: __SerdeContext
): GameSessionDetail => {
  let contents: any = {
    __type: "GameSessionDetail",
    GameSession: undefined,
    ProtectionPolicy: undefined
  };
  if (output.GameSession !== undefined && output.GameSession !== null) {
    contents.GameSession = deserializeAws_json1_1GameSession(
      output.GameSession,
      context
    );
  }
  if (
    output.ProtectionPolicy !== undefined &&
    output.ProtectionPolicy !== null
  ) {
    contents.ProtectionPolicy = output.ProtectionPolicy;
  }
  return contents;
};

const deserializeAws_json1_1GameSessionDetailList = (
  output: any,
  context: __SerdeContext
): Array<GameSessionDetail> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1GameSessionDetail(entry, context)
  );
};

const deserializeAws_json1_1GameSessionFullException = (
  output: any,
  context: __SerdeContext
): GameSessionFullException => {
  let contents: any = {
    __type: "GameSessionFullException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1GameSessionList = (
  output: any,
  context: __SerdeContext
): Array<GameSession> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1GameSession(entry, context)
  );
};

const deserializeAws_json1_1GameSessionPlacement = (
  output: any,
  context: __SerdeContext
): GameSessionPlacement => {
  let contents: any = {
    __type: "GameSessionPlacement",
    DnsName: undefined,
    EndTime: undefined,
    GameProperties: undefined,
    GameSessionArn: undefined,
    GameSessionData: undefined,
    GameSessionId: undefined,
    GameSessionName: undefined,
    GameSessionQueueName: undefined,
    GameSessionRegion: undefined,
    IpAddress: undefined,
    MatchmakerData: undefined,
    MaximumPlayerSessionCount: undefined,
    PlacedPlayerSessions: undefined,
    PlacementId: undefined,
    PlayerLatencies: undefined,
    Port: undefined,
    StartTime: undefined,
    Status: undefined
  };
  if (output.DnsName !== undefined && output.DnsName !== null) {
    contents.DnsName = output.DnsName;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (output.GameProperties !== undefined && output.GameProperties !== null) {
    contents.GameProperties = deserializeAws_json1_1GamePropertyList(
      output.GameProperties,
      context
    );
  }
  if (output.GameSessionArn !== undefined && output.GameSessionArn !== null) {
    contents.GameSessionArn = output.GameSessionArn;
  }
  if (output.GameSessionData !== undefined && output.GameSessionData !== null) {
    contents.GameSessionData = output.GameSessionData;
  }
  if (output.GameSessionId !== undefined && output.GameSessionId !== null) {
    contents.GameSessionId = output.GameSessionId;
  }
  if (output.GameSessionName !== undefined && output.GameSessionName !== null) {
    contents.GameSessionName = output.GameSessionName;
  }
  if (
    output.GameSessionQueueName !== undefined &&
    output.GameSessionQueueName !== null
  ) {
    contents.GameSessionQueueName = output.GameSessionQueueName;
  }
  if (
    output.GameSessionRegion !== undefined &&
    output.GameSessionRegion !== null
  ) {
    contents.GameSessionRegion = output.GameSessionRegion;
  }
  if (output.IpAddress !== undefined && output.IpAddress !== null) {
    contents.IpAddress = output.IpAddress;
  }
  if (output.MatchmakerData !== undefined && output.MatchmakerData !== null) {
    contents.MatchmakerData = output.MatchmakerData;
  }
  if (
    output.MaximumPlayerSessionCount !== undefined &&
    output.MaximumPlayerSessionCount !== null
  ) {
    contents.MaximumPlayerSessionCount = output.MaximumPlayerSessionCount;
  }
  if (
    output.PlacedPlayerSessions !== undefined &&
    output.PlacedPlayerSessions !== null
  ) {
    contents.PlacedPlayerSessions = deserializeAws_json1_1PlacedPlayerSessionList(
      output.PlacedPlayerSessions,
      context
    );
  }
  if (output.PlacementId !== undefined && output.PlacementId !== null) {
    contents.PlacementId = output.PlacementId;
  }
  if (output.PlayerLatencies !== undefined && output.PlayerLatencies !== null) {
    contents.PlayerLatencies = deserializeAws_json1_1PlayerLatencyList(
      output.PlayerLatencies,
      context
    );
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1GameSessionQueue = (
  output: any,
  context: __SerdeContext
): GameSessionQueue => {
  let contents: any = {
    __type: "GameSessionQueue",
    Destinations: undefined,
    GameSessionQueueArn: undefined,
    Name: undefined,
    PlayerLatencyPolicies: undefined,
    TimeoutInSeconds: undefined
  };
  if (output.Destinations !== undefined && output.Destinations !== null) {
    contents.Destinations = deserializeAws_json1_1GameSessionQueueDestinationList(
      output.Destinations,
      context
    );
  }
  if (
    output.GameSessionQueueArn !== undefined &&
    output.GameSessionQueueArn !== null
  ) {
    contents.GameSessionQueueArn = output.GameSessionQueueArn;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.PlayerLatencyPolicies !== undefined &&
    output.PlayerLatencyPolicies !== null
  ) {
    contents.PlayerLatencyPolicies = deserializeAws_json1_1PlayerLatencyPolicyList(
      output.PlayerLatencyPolicies,
      context
    );
  }
  if (
    output.TimeoutInSeconds !== undefined &&
    output.TimeoutInSeconds !== null
  ) {
    contents.TimeoutInSeconds = output.TimeoutInSeconds;
  }
  return contents;
};

const deserializeAws_json1_1GameSessionQueueDestination = (
  output: any,
  context: __SerdeContext
): GameSessionQueueDestination => {
  let contents: any = {
    __type: "GameSessionQueueDestination",
    DestinationArn: undefined
  };
  if (output.DestinationArn !== undefined && output.DestinationArn !== null) {
    contents.DestinationArn = output.DestinationArn;
  }
  return contents;
};

const deserializeAws_json1_1GameSessionQueueDestinationList = (
  output: any,
  context: __SerdeContext
): Array<GameSessionQueueDestination> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1GameSessionQueueDestination(entry, context)
  );
};

const deserializeAws_json1_1GameSessionQueueList = (
  output: any,
  context: __SerdeContext
): Array<GameSessionQueue> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1GameSessionQueue(entry, context)
  );
};

const deserializeAws_json1_1GetGameSessionLogUrlOutput = (
  output: any,
  context: __SerdeContext
): GetGameSessionLogUrlOutput => {
  let contents: any = {
    __type: "GetGameSessionLogUrlOutput",
    PreSignedUrl: undefined
  };
  if (output.PreSignedUrl !== undefined && output.PreSignedUrl !== null) {
    contents.PreSignedUrl = output.PreSignedUrl;
  }
  return contents;
};

const deserializeAws_json1_1GetInstanceAccessOutput = (
  output: any,
  context: __SerdeContext
): GetInstanceAccessOutput => {
  let contents: any = {
    __type: "GetInstanceAccessOutput",
    InstanceAccess: undefined
  };
  if (output.InstanceAccess !== undefined && output.InstanceAccess !== null) {
    contents.InstanceAccess = deserializeAws_json1_1InstanceAccess(
      output.InstanceAccess,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1IdempotentParameterMismatchException = (
  output: any,
  context: __SerdeContext
): IdempotentParameterMismatchException => {
  let contents: any = {
    __type: "IdempotentParameterMismatchException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1Instance = (
  output: any,
  context: __SerdeContext
): Instance => {
  let contents: any = {
    __type: "Instance",
    CreationTime: undefined,
    DnsName: undefined,
    FleetId: undefined,
    InstanceId: undefined,
    IpAddress: undefined,
    OperatingSystem: undefined,
    Status: undefined,
    Type: undefined
  };
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DnsName !== undefined && output.DnsName !== null) {
    contents.DnsName = output.DnsName;
  }
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (output.IpAddress !== undefined && output.IpAddress !== null) {
    contents.IpAddress = output.IpAddress;
  }
  if (output.OperatingSystem !== undefined && output.OperatingSystem !== null) {
    contents.OperatingSystem = output.OperatingSystem;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1InstanceAccess = (
  output: any,
  context: __SerdeContext
): InstanceAccess => {
  let contents: any = {
    __type: "InstanceAccess",
    Credentials: undefined,
    FleetId: undefined,
    InstanceId: undefined,
    IpAddress: undefined,
    OperatingSystem: undefined
  };
  if (output.Credentials !== undefined && output.Credentials !== null) {
    contents.Credentials = deserializeAws_json1_1InstanceCredentials(
      output.Credentials,
      context
    );
  }
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  if (output.InstanceId !== undefined && output.InstanceId !== null) {
    contents.InstanceId = output.InstanceId;
  }
  if (output.IpAddress !== undefined && output.IpAddress !== null) {
    contents.IpAddress = output.IpAddress;
  }
  if (output.OperatingSystem !== undefined && output.OperatingSystem !== null) {
    contents.OperatingSystem = output.OperatingSystem;
  }
  return contents;
};

const deserializeAws_json1_1InstanceCredentials = (
  output: any,
  context: __SerdeContext
): InstanceCredentials => {
  let contents: any = {
    __type: "InstanceCredentials",
    Secret: undefined,
    UserName: undefined
  };
  if (output.Secret !== undefined && output.Secret !== null) {
    contents.Secret = output.Secret;
  }
  if (output.UserName !== undefined && output.UserName !== null) {
    contents.UserName = output.UserName;
  }
  return contents;
};

const deserializeAws_json1_1InstanceList = (
  output: any,
  context: __SerdeContext
): Array<Instance> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Instance(entry, context)
  );
};

const deserializeAws_json1_1InternalServiceException = (
  output: any,
  context: __SerdeContext
): InternalServiceException => {
  let contents: any = {
    __type: "InternalServiceException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidFleetStatusException = (
  output: any,
  context: __SerdeContext
): InvalidFleetStatusException => {
  let contents: any = {
    __type: "InvalidFleetStatusException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidGameSessionStatusException = (
  output: any,
  context: __SerdeContext
): InvalidGameSessionStatusException => {
  let contents: any = {
    __type: "InvalidGameSessionStatusException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidRequestException = (
  output: any,
  context: __SerdeContext
): InvalidRequestException => {
  let contents: any = {
    __type: "InvalidRequestException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1IpPermission = (
  output: any,
  context: __SerdeContext
): IpPermission => {
  let contents: any = {
    __type: "IpPermission",
    FromPort: undefined,
    IpRange: undefined,
    Protocol: undefined,
    ToPort: undefined
  };
  if (output.FromPort !== undefined && output.FromPort !== null) {
    contents.FromPort = output.FromPort;
  }
  if (output.IpRange !== undefined && output.IpRange !== null) {
    contents.IpRange = output.IpRange;
  }
  if (output.Protocol !== undefined && output.Protocol !== null) {
    contents.Protocol = output.Protocol;
  }
  if (output.ToPort !== undefined && output.ToPort !== null) {
    contents.ToPort = output.ToPort;
  }
  return contents;
};

const deserializeAws_json1_1IpPermissionsList = (
  output: any,
  context: __SerdeContext
): Array<IpPermission> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1IpPermission(entry, context)
  );
};

const deserializeAws_json1_1LatencyMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: number } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1LimitExceededException = (
  output: any,
  context: __SerdeContext
): LimitExceededException => {
  let contents: any = {
    __type: "LimitExceededException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1ListAliasesOutput = (
  output: any,
  context: __SerdeContext
): ListAliasesOutput => {
  let contents: any = {
    __type: "ListAliasesOutput",
    Aliases: undefined,
    NextToken: undefined
  };
  if (output.Aliases !== undefined && output.Aliases !== null) {
    contents.Aliases = deserializeAws_json1_1AliasList(output.Aliases, context);
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListBuildsOutput = (
  output: any,
  context: __SerdeContext
): ListBuildsOutput => {
  let contents: any = {
    __type: "ListBuildsOutput",
    Builds: undefined,
    NextToken: undefined
  };
  if (output.Builds !== undefined && output.Builds !== null) {
    contents.Builds = deserializeAws_json1_1BuildList(output.Builds, context);
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListFleetsOutput = (
  output: any,
  context: __SerdeContext
): ListFleetsOutput => {
  let contents: any = {
    __type: "ListFleetsOutput",
    FleetIds: undefined,
    NextToken: undefined
  };
  if (output.FleetIds !== undefined && output.FleetIds !== null) {
    contents.FleetIds = deserializeAws_json1_1FleetIdList(
      output.FleetIds,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ListScriptsOutput = (
  output: any,
  context: __SerdeContext
): ListScriptsOutput => {
  let contents: any = {
    __type: "ListScriptsOutput",
    NextToken: undefined,
    Scripts: undefined
  };
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  if (output.Scripts !== undefined && output.Scripts !== null) {
    contents.Scripts = deserializeAws_json1_1ScriptList(
      output.Scripts,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ListTagsForResourceResponse = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceResponse => {
  let contents: any = {
    __type: "ListTagsForResourceResponse",
    Tags: undefined
  };
  if (output.Tags !== undefined && output.Tags !== null) {
    contents.Tags = deserializeAws_json1_1TagList(output.Tags, context);
  }
  return contents;
};

const deserializeAws_json1_1MatchedPlayerSession = (
  output: any,
  context: __SerdeContext
): MatchedPlayerSession => {
  let contents: any = {
    __type: "MatchedPlayerSession",
    PlayerId: undefined,
    PlayerSessionId: undefined
  };
  if (output.PlayerId !== undefined && output.PlayerId !== null) {
    contents.PlayerId = output.PlayerId;
  }
  if (output.PlayerSessionId !== undefined && output.PlayerSessionId !== null) {
    contents.PlayerSessionId = output.PlayerSessionId;
  }
  return contents;
};

const deserializeAws_json1_1MatchedPlayerSessionList = (
  output: any,
  context: __SerdeContext
): Array<MatchedPlayerSession> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MatchedPlayerSession(entry, context)
  );
};

const deserializeAws_json1_1MatchmakingConfiguration = (
  output: any,
  context: __SerdeContext
): MatchmakingConfiguration => {
  let contents: any = {
    __type: "MatchmakingConfiguration",
    AcceptanceRequired: undefined,
    AcceptanceTimeoutSeconds: undefined,
    AdditionalPlayerCount: undefined,
    BackfillMode: undefined,
    ConfigurationArn: undefined,
    CreationTime: undefined,
    CustomEventData: undefined,
    Description: undefined,
    GameProperties: undefined,
    GameSessionData: undefined,
    GameSessionQueueArns: undefined,
    Name: undefined,
    NotificationTarget: undefined,
    RequestTimeoutSeconds: undefined,
    RuleSetArn: undefined,
    RuleSetName: undefined
  };
  if (
    output.AcceptanceRequired !== undefined &&
    output.AcceptanceRequired !== null
  ) {
    contents.AcceptanceRequired = output.AcceptanceRequired;
  }
  if (
    output.AcceptanceTimeoutSeconds !== undefined &&
    output.AcceptanceTimeoutSeconds !== null
  ) {
    contents.AcceptanceTimeoutSeconds = output.AcceptanceTimeoutSeconds;
  }
  if (
    output.AdditionalPlayerCount !== undefined &&
    output.AdditionalPlayerCount !== null
  ) {
    contents.AdditionalPlayerCount = output.AdditionalPlayerCount;
  }
  if (output.BackfillMode !== undefined && output.BackfillMode !== null) {
    contents.BackfillMode = output.BackfillMode;
  }
  if (
    output.ConfigurationArn !== undefined &&
    output.ConfigurationArn !== null
  ) {
    contents.ConfigurationArn = output.ConfigurationArn;
  }
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.CustomEventData !== undefined && output.CustomEventData !== null) {
    contents.CustomEventData = output.CustomEventData;
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.GameProperties !== undefined && output.GameProperties !== null) {
    contents.GameProperties = deserializeAws_json1_1GamePropertyList(
      output.GameProperties,
      context
    );
  }
  if (output.GameSessionData !== undefined && output.GameSessionData !== null) {
    contents.GameSessionData = output.GameSessionData;
  }
  if (
    output.GameSessionQueueArns !== undefined &&
    output.GameSessionQueueArns !== null
  ) {
    contents.GameSessionQueueArns = deserializeAws_json1_1QueueArnsList(
      output.GameSessionQueueArns,
      context
    );
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (
    output.NotificationTarget !== undefined &&
    output.NotificationTarget !== null
  ) {
    contents.NotificationTarget = output.NotificationTarget;
  }
  if (
    output.RequestTimeoutSeconds !== undefined &&
    output.RequestTimeoutSeconds !== null
  ) {
    contents.RequestTimeoutSeconds = output.RequestTimeoutSeconds;
  }
  if (output.RuleSetArn !== undefined && output.RuleSetArn !== null) {
    contents.RuleSetArn = output.RuleSetArn;
  }
  if (output.RuleSetName !== undefined && output.RuleSetName !== null) {
    contents.RuleSetName = output.RuleSetName;
  }
  return contents;
};

const deserializeAws_json1_1MatchmakingConfigurationList = (
  output: any,
  context: __SerdeContext
): Array<MatchmakingConfiguration> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MatchmakingConfiguration(entry, context)
  );
};

const deserializeAws_json1_1MatchmakingRuleSet = (
  output: any,
  context: __SerdeContext
): MatchmakingRuleSet => {
  let contents: any = {
    __type: "MatchmakingRuleSet",
    CreationTime: undefined,
    RuleSetArn: undefined,
    RuleSetBody: undefined,
    RuleSetName: undefined
  };
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.RuleSetArn !== undefined && output.RuleSetArn !== null) {
    contents.RuleSetArn = output.RuleSetArn;
  }
  if (output.RuleSetBody !== undefined && output.RuleSetBody !== null) {
    contents.RuleSetBody = output.RuleSetBody;
  }
  if (output.RuleSetName !== undefined && output.RuleSetName !== null) {
    contents.RuleSetName = output.RuleSetName;
  }
  return contents;
};

const deserializeAws_json1_1MatchmakingRuleSetList = (
  output: any,
  context: __SerdeContext
): Array<MatchmakingRuleSet> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MatchmakingRuleSet(entry, context)
  );
};

const deserializeAws_json1_1MatchmakingTicket = (
  output: any,
  context: __SerdeContext
): MatchmakingTicket => {
  let contents: any = {
    __type: "MatchmakingTicket",
    ConfigurationArn: undefined,
    ConfigurationName: undefined,
    EndTime: undefined,
    EstimatedWaitTime: undefined,
    GameSessionConnectionInfo: undefined,
    Players: undefined,
    StartTime: undefined,
    Status: undefined,
    StatusMessage: undefined,
    StatusReason: undefined,
    TicketId: undefined
  };
  if (
    output.ConfigurationArn !== undefined &&
    output.ConfigurationArn !== null
  ) {
    contents.ConfigurationArn = output.ConfigurationArn;
  }
  if (
    output.ConfigurationName !== undefined &&
    output.ConfigurationName !== null
  ) {
    contents.ConfigurationName = output.ConfigurationName;
  }
  if (output.EndTime !== undefined && output.EndTime !== null) {
    contents.EndTime = new Date(Math.round(output.EndTime * 1000));
  }
  if (
    output.EstimatedWaitTime !== undefined &&
    output.EstimatedWaitTime !== null
  ) {
    contents.EstimatedWaitTime = output.EstimatedWaitTime;
  }
  if (
    output.GameSessionConnectionInfo !== undefined &&
    output.GameSessionConnectionInfo !== null
  ) {
    contents.GameSessionConnectionInfo = deserializeAws_json1_1GameSessionConnectionInfo(
      output.GameSessionConnectionInfo,
      context
    );
  }
  if (output.Players !== undefined && output.Players !== null) {
    contents.Players = deserializeAws_json1_1PlayerList(
      output.Players,
      context
    );
  }
  if (output.StartTime !== undefined && output.StartTime !== null) {
    contents.StartTime = new Date(Math.round(output.StartTime * 1000));
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StatusMessage !== undefined && output.StatusMessage !== null) {
    contents.StatusMessage = output.StatusMessage;
  }
  if (output.StatusReason !== undefined && output.StatusReason !== null) {
    contents.StatusReason = output.StatusReason;
  }
  if (output.TicketId !== undefined && output.TicketId !== null) {
    contents.TicketId = output.TicketId;
  }
  return contents;
};

const deserializeAws_json1_1MatchmakingTicketList = (
  output: any,
  context: __SerdeContext
): Array<MatchmakingTicket> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1MatchmakingTicket(entry, context)
  );
};

const deserializeAws_json1_1MetricGroupList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1NotFoundException = (
  output: any,
  context: __SerdeContext
): NotFoundException => {
  let contents: any = {
    __type: "NotFoundException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1PlacedPlayerSession = (
  output: any,
  context: __SerdeContext
): PlacedPlayerSession => {
  let contents: any = {
    __type: "PlacedPlayerSession",
    PlayerId: undefined,
    PlayerSessionId: undefined
  };
  if (output.PlayerId !== undefined && output.PlayerId !== null) {
    contents.PlayerId = output.PlayerId;
  }
  if (output.PlayerSessionId !== undefined && output.PlayerSessionId !== null) {
    contents.PlayerSessionId = output.PlayerSessionId;
  }
  return contents;
};

const deserializeAws_json1_1PlacedPlayerSessionList = (
  output: any,
  context: __SerdeContext
): Array<PlacedPlayerSession> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PlacedPlayerSession(entry, context)
  );
};

const deserializeAws_json1_1Player = (
  output: any,
  context: __SerdeContext
): Player => {
  let contents: any = {
    __type: "Player",
    LatencyInMs: undefined,
    PlayerAttributes: undefined,
    PlayerId: undefined,
    Team: undefined
  };
  if (output.LatencyInMs !== undefined && output.LatencyInMs !== null) {
    contents.LatencyInMs = deserializeAws_json1_1LatencyMap(
      output.LatencyInMs,
      context
    );
  }
  if (
    output.PlayerAttributes !== undefined &&
    output.PlayerAttributes !== null
  ) {
    contents.PlayerAttributes = deserializeAws_json1_1PlayerAttributeMap(
      output.PlayerAttributes,
      context
    );
  }
  if (output.PlayerId !== undefined && output.PlayerId !== null) {
    contents.PlayerId = output.PlayerId;
  }
  if (output.Team !== undefined && output.Team !== null) {
    contents.Team = output.Team;
  }
  return contents;
};

const deserializeAws_json1_1PlayerAttributeMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: AttributeValue } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_json1_1AttributeValue(output[key], context);
  });
  return mapParams;
};

const deserializeAws_json1_1PlayerLatency = (
  output: any,
  context: __SerdeContext
): PlayerLatency => {
  let contents: any = {
    __type: "PlayerLatency",
    LatencyInMilliseconds: undefined,
    PlayerId: undefined,
    RegionIdentifier: undefined
  };
  if (
    output.LatencyInMilliseconds !== undefined &&
    output.LatencyInMilliseconds !== null
  ) {
    contents.LatencyInMilliseconds = output.LatencyInMilliseconds;
  }
  if (output.PlayerId !== undefined && output.PlayerId !== null) {
    contents.PlayerId = output.PlayerId;
  }
  if (
    output.RegionIdentifier !== undefined &&
    output.RegionIdentifier !== null
  ) {
    contents.RegionIdentifier = output.RegionIdentifier;
  }
  return contents;
};

const deserializeAws_json1_1PlayerLatencyList = (
  output: any,
  context: __SerdeContext
): Array<PlayerLatency> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PlayerLatency(entry, context)
  );
};

const deserializeAws_json1_1PlayerLatencyPolicy = (
  output: any,
  context: __SerdeContext
): PlayerLatencyPolicy => {
  let contents: any = {
    __type: "PlayerLatencyPolicy",
    MaximumIndividualPlayerLatencyMilliseconds: undefined,
    PolicyDurationSeconds: undefined
  };
  if (
    output.MaximumIndividualPlayerLatencyMilliseconds !== undefined &&
    output.MaximumIndividualPlayerLatencyMilliseconds !== null
  ) {
    contents.MaximumIndividualPlayerLatencyMilliseconds =
      output.MaximumIndividualPlayerLatencyMilliseconds;
  }
  if (
    output.PolicyDurationSeconds !== undefined &&
    output.PolicyDurationSeconds !== null
  ) {
    contents.PolicyDurationSeconds = output.PolicyDurationSeconds;
  }
  return contents;
};

const deserializeAws_json1_1PlayerLatencyPolicyList = (
  output: any,
  context: __SerdeContext
): Array<PlayerLatencyPolicy> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PlayerLatencyPolicy(entry, context)
  );
};

const deserializeAws_json1_1PlayerList = (
  output: any,
  context: __SerdeContext
): Array<Player> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Player(entry, context)
  );
};

const deserializeAws_json1_1PlayerSession = (
  output: any,
  context: __SerdeContext
): PlayerSession => {
  let contents: any = {
    __type: "PlayerSession",
    CreationTime: undefined,
    DnsName: undefined,
    FleetArn: undefined,
    FleetId: undefined,
    GameSessionId: undefined,
    IpAddress: undefined,
    PlayerData: undefined,
    PlayerId: undefined,
    PlayerSessionId: undefined,
    Port: undefined,
    Status: undefined,
    TerminationTime: undefined
  };
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.DnsName !== undefined && output.DnsName !== null) {
    contents.DnsName = output.DnsName;
  }
  if (output.FleetArn !== undefined && output.FleetArn !== null) {
    contents.FleetArn = output.FleetArn;
  }
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  if (output.GameSessionId !== undefined && output.GameSessionId !== null) {
    contents.GameSessionId = output.GameSessionId;
  }
  if (output.IpAddress !== undefined && output.IpAddress !== null) {
    contents.IpAddress = output.IpAddress;
  }
  if (output.PlayerData !== undefined && output.PlayerData !== null) {
    contents.PlayerData = output.PlayerData;
  }
  if (output.PlayerId !== undefined && output.PlayerId !== null) {
    contents.PlayerId = output.PlayerId;
  }
  if (output.PlayerSessionId !== undefined && output.PlayerSessionId !== null) {
    contents.PlayerSessionId = output.PlayerSessionId;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.TerminationTime !== undefined && output.TerminationTime !== null) {
    contents.TerminationTime = new Date(
      Math.round(output.TerminationTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_json1_1PlayerSessionList = (
  output: any,
  context: __SerdeContext
): Array<PlayerSession> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PlayerSession(entry, context)
  );
};

const deserializeAws_json1_1PutScalingPolicyOutput = (
  output: any,
  context: __SerdeContext
): PutScalingPolicyOutput => {
  let contents: any = {
    __type: "PutScalingPolicyOutput",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1QueueArnsList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1RequestUploadCredentialsOutput = (
  output: any,
  context: __SerdeContext
): RequestUploadCredentialsOutput => {
  let contents: any = {
    __type: "RequestUploadCredentialsOutput",
    StorageLocation: undefined,
    UploadCredentials: undefined
  };
  if (output.StorageLocation !== undefined && output.StorageLocation !== null) {
    contents.StorageLocation = deserializeAws_json1_1S3Location(
      output.StorageLocation,
      context
    );
  }
  if (
    output.UploadCredentials !== undefined &&
    output.UploadCredentials !== null
  ) {
    contents.UploadCredentials = deserializeAws_json1_1AwsCredentials(
      output.UploadCredentials,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ResolveAliasOutput = (
  output: any,
  context: __SerdeContext
): ResolveAliasOutput => {
  let contents: any = {
    __type: "ResolveAliasOutput",
    FleetArn: undefined,
    FleetId: undefined
  };
  if (output.FleetArn !== undefined && output.FleetArn !== null) {
    contents.FleetArn = output.FleetArn;
  }
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  return contents;
};

const deserializeAws_json1_1ResourceCreationLimitPolicy = (
  output: any,
  context: __SerdeContext
): ResourceCreationLimitPolicy => {
  let contents: any = {
    __type: "ResourceCreationLimitPolicy",
    NewGameSessionsPerCreator: undefined,
    PolicyPeriodInMinutes: undefined
  };
  if (
    output.NewGameSessionsPerCreator !== undefined &&
    output.NewGameSessionsPerCreator !== null
  ) {
    contents.NewGameSessionsPerCreator = output.NewGameSessionsPerCreator;
  }
  if (
    output.PolicyPeriodInMinutes !== undefined &&
    output.PolicyPeriodInMinutes !== null
  ) {
    contents.PolicyPeriodInMinutes = output.PolicyPeriodInMinutes;
  }
  return contents;
};

const deserializeAws_json1_1RoutingStrategy = (
  output: any,
  context: __SerdeContext
): RoutingStrategy => {
  let contents: any = {
    __type: "RoutingStrategy",
    FleetId: undefined,
    Message: undefined,
    Type: undefined
  };
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (output.Type !== undefined && output.Type !== null) {
    contents.Type = output.Type;
  }
  return contents;
};

const deserializeAws_json1_1RuntimeConfiguration = (
  output: any,
  context: __SerdeContext
): RuntimeConfiguration => {
  let contents: any = {
    __type: "RuntimeConfiguration",
    GameSessionActivationTimeoutSeconds: undefined,
    MaxConcurrentGameSessionActivations: undefined,
    ServerProcesses: undefined
  };
  if (
    output.GameSessionActivationTimeoutSeconds !== undefined &&
    output.GameSessionActivationTimeoutSeconds !== null
  ) {
    contents.GameSessionActivationTimeoutSeconds =
      output.GameSessionActivationTimeoutSeconds;
  }
  if (
    output.MaxConcurrentGameSessionActivations !== undefined &&
    output.MaxConcurrentGameSessionActivations !== null
  ) {
    contents.MaxConcurrentGameSessionActivations =
      output.MaxConcurrentGameSessionActivations;
  }
  if (output.ServerProcesses !== undefined && output.ServerProcesses !== null) {
    contents.ServerProcesses = deserializeAws_json1_1ServerProcessList(
      output.ServerProcesses,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1S3Location = (
  output: any,
  context: __SerdeContext
): S3Location => {
  let contents: any = {
    __type: "S3Location",
    Bucket: undefined,
    Key: undefined,
    ObjectVersion: undefined,
    RoleArn: undefined
  };
  if (output.Bucket !== undefined && output.Bucket !== null) {
    contents.Bucket = output.Bucket;
  }
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.ObjectVersion !== undefined && output.ObjectVersion !== null) {
    contents.ObjectVersion = output.ObjectVersion;
  }
  if (output.RoleArn !== undefined && output.RoleArn !== null) {
    contents.RoleArn = output.RoleArn;
  }
  return contents;
};

const deserializeAws_json1_1ScalingPolicy = (
  output: any,
  context: __SerdeContext
): ScalingPolicy => {
  let contents: any = {
    __type: "ScalingPolicy",
    ComparisonOperator: undefined,
    EvaluationPeriods: undefined,
    FleetId: undefined,
    MetricName: undefined,
    Name: undefined,
    PolicyType: undefined,
    ScalingAdjustment: undefined,
    ScalingAdjustmentType: undefined,
    Status: undefined,
    TargetConfiguration: undefined,
    Threshold: undefined
  };
  if (
    output.ComparisonOperator !== undefined &&
    output.ComparisonOperator !== null
  ) {
    contents.ComparisonOperator = output.ComparisonOperator;
  }
  if (
    output.EvaluationPeriods !== undefined &&
    output.EvaluationPeriods !== null
  ) {
    contents.EvaluationPeriods = output.EvaluationPeriods;
  }
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  if (output.MetricName !== undefined && output.MetricName !== null) {
    contents.MetricName = output.MetricName;
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.PolicyType !== undefined && output.PolicyType !== null) {
    contents.PolicyType = output.PolicyType;
  }
  if (
    output.ScalingAdjustment !== undefined &&
    output.ScalingAdjustment !== null
  ) {
    contents.ScalingAdjustment = output.ScalingAdjustment;
  }
  if (
    output.ScalingAdjustmentType !== undefined &&
    output.ScalingAdjustmentType !== null
  ) {
    contents.ScalingAdjustmentType = output.ScalingAdjustmentType;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (
    output.TargetConfiguration !== undefined &&
    output.TargetConfiguration !== null
  ) {
    contents.TargetConfiguration = deserializeAws_json1_1TargetConfiguration(
      output.TargetConfiguration,
      context
    );
  }
  if (output.Threshold !== undefined && output.Threshold !== null) {
    contents.Threshold = output.Threshold;
  }
  return contents;
};

const deserializeAws_json1_1ScalingPolicyList = (
  output: any,
  context: __SerdeContext
): Array<ScalingPolicy> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ScalingPolicy(entry, context)
  );
};

const deserializeAws_json1_1Script = (
  output: any,
  context: __SerdeContext
): Script => {
  let contents: any = {
    __type: "Script",
    CreationTime: undefined,
    Name: undefined,
    ScriptArn: undefined,
    ScriptId: undefined,
    SizeOnDisk: undefined,
    StorageLocation: undefined,
    Version: undefined
  };
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  if (output.ScriptArn !== undefined && output.ScriptArn !== null) {
    contents.ScriptArn = output.ScriptArn;
  }
  if (output.ScriptId !== undefined && output.ScriptId !== null) {
    contents.ScriptId = output.ScriptId;
  }
  if (output.SizeOnDisk !== undefined && output.SizeOnDisk !== null) {
    contents.SizeOnDisk = output.SizeOnDisk;
  }
  if (output.StorageLocation !== undefined && output.StorageLocation !== null) {
    contents.StorageLocation = deserializeAws_json1_1S3Location(
      output.StorageLocation,
      context
    );
  }
  if (output.Version !== undefined && output.Version !== null) {
    contents.Version = output.Version;
  }
  return contents;
};

const deserializeAws_json1_1ScriptList = (
  output: any,
  context: __SerdeContext
): Array<Script> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Script(entry, context)
  );
};

const deserializeAws_json1_1SearchGameSessionsOutput = (
  output: any,
  context: __SerdeContext
): SearchGameSessionsOutput => {
  let contents: any = {
    __type: "SearchGameSessionsOutput",
    GameSessions: undefined,
    NextToken: undefined
  };
  if (output.GameSessions !== undefined && output.GameSessions !== null) {
    contents.GameSessions = deserializeAws_json1_1GameSessionList(
      output.GameSessions,
      context
    );
  }
  if (output.NextToken !== undefined && output.NextToken !== null) {
    contents.NextToken = output.NextToken;
  }
  return contents;
};

const deserializeAws_json1_1ServerProcess = (
  output: any,
  context: __SerdeContext
): ServerProcess => {
  let contents: any = {
    __type: "ServerProcess",
    ConcurrentExecutions: undefined,
    LaunchPath: undefined,
    Parameters: undefined
  };
  if (
    output.ConcurrentExecutions !== undefined &&
    output.ConcurrentExecutions !== null
  ) {
    contents.ConcurrentExecutions = output.ConcurrentExecutions;
  }
  if (output.LaunchPath !== undefined && output.LaunchPath !== null) {
    contents.LaunchPath = output.LaunchPath;
  }
  if (output.Parameters !== undefined && output.Parameters !== null) {
    contents.Parameters = output.Parameters;
  }
  return contents;
};

const deserializeAws_json1_1ServerProcessList = (
  output: any,
  context: __SerdeContext
): Array<ServerProcess> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ServerProcess(entry, context)
  );
};

const deserializeAws_json1_1StartFleetActionsOutput = (
  output: any,
  context: __SerdeContext
): StartFleetActionsOutput => {
  let contents: any = {
    __type: "StartFleetActionsOutput"
  };
  return contents;
};

const deserializeAws_json1_1StartGameSessionPlacementOutput = (
  output: any,
  context: __SerdeContext
): StartGameSessionPlacementOutput => {
  let contents: any = {
    __type: "StartGameSessionPlacementOutput",
    GameSessionPlacement: undefined
  };
  if (
    output.GameSessionPlacement !== undefined &&
    output.GameSessionPlacement !== null
  ) {
    contents.GameSessionPlacement = deserializeAws_json1_1GameSessionPlacement(
      output.GameSessionPlacement,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1StartMatchBackfillOutput = (
  output: any,
  context: __SerdeContext
): StartMatchBackfillOutput => {
  let contents: any = {
    __type: "StartMatchBackfillOutput",
    MatchmakingTicket: undefined
  };
  if (
    output.MatchmakingTicket !== undefined &&
    output.MatchmakingTicket !== null
  ) {
    contents.MatchmakingTicket = deserializeAws_json1_1MatchmakingTicket(
      output.MatchmakingTicket,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1StartMatchmakingOutput = (
  output: any,
  context: __SerdeContext
): StartMatchmakingOutput => {
  let contents: any = {
    __type: "StartMatchmakingOutput",
    MatchmakingTicket: undefined
  };
  if (
    output.MatchmakingTicket !== undefined &&
    output.MatchmakingTicket !== null
  ) {
    contents.MatchmakingTicket = deserializeAws_json1_1MatchmakingTicket(
      output.MatchmakingTicket,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1StopFleetActionsOutput = (
  output: any,
  context: __SerdeContext
): StopFleetActionsOutput => {
  let contents: any = {
    __type: "StopFleetActionsOutput"
  };
  return contents;
};

const deserializeAws_json1_1StopGameSessionPlacementOutput = (
  output: any,
  context: __SerdeContext
): StopGameSessionPlacementOutput => {
  let contents: any = {
    __type: "StopGameSessionPlacementOutput",
    GameSessionPlacement: undefined
  };
  if (
    output.GameSessionPlacement !== undefined &&
    output.GameSessionPlacement !== null
  ) {
    contents.GameSessionPlacement = deserializeAws_json1_1GameSessionPlacement(
      output.GameSessionPlacement,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1StopMatchmakingOutput = (
  output: any,
  context: __SerdeContext
): StopMatchmakingOutput => {
  let contents: any = {
    __type: "StopMatchmakingOutput"
  };
  return contents;
};

const deserializeAws_json1_1StringDoubleMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: number } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_json1_1StringList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1TagResourceResponse = (
  output: any,
  context: __SerdeContext
): TagResourceResponse => {
  let contents: any = {
    __type: "TagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1TaggingFailedException = (
  output: any,
  context: __SerdeContext
): TaggingFailedException => {
  let contents: any = {
    __type: "TaggingFailedException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1TargetConfiguration = (
  output: any,
  context: __SerdeContext
): TargetConfiguration => {
  let contents: any = {
    __type: "TargetConfiguration",
    TargetValue: undefined
  };
  if (output.TargetValue !== undefined && output.TargetValue !== null) {
    contents.TargetValue = output.TargetValue;
  }
  return contents;
};

const deserializeAws_json1_1TerminalRoutingStrategyException = (
  output: any,
  context: __SerdeContext
): TerminalRoutingStrategyException => {
  let contents: any = {
    __type: "TerminalRoutingStrategyException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UnauthorizedException = (
  output: any,
  context: __SerdeContext
): UnauthorizedException => {
  let contents: any = {
    __type: "UnauthorizedException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UnsupportedRegionException = (
  output: any,
  context: __SerdeContext
): UnsupportedRegionException => {
  let contents: any = {
    __type: "UnsupportedRegionException",
    Message: undefined
  };
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeAws_json1_1UntagResourceResponse = (
  output: any,
  context: __SerdeContext
): UntagResourceResponse => {
  let contents: any = {
    __type: "UntagResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1UpdateAliasOutput = (
  output: any,
  context: __SerdeContext
): UpdateAliasOutput => {
  let contents: any = {
    __type: "UpdateAliasOutput",
    Alias: undefined
  };
  if (output.Alias !== undefined && output.Alias !== null) {
    contents.Alias = deserializeAws_json1_1Alias(output.Alias, context);
  }
  return contents;
};

const deserializeAws_json1_1UpdateBuildOutput = (
  output: any,
  context: __SerdeContext
): UpdateBuildOutput => {
  let contents: any = {
    __type: "UpdateBuildOutput",
    Build: undefined
  };
  if (output.Build !== undefined && output.Build !== null) {
    contents.Build = deserializeAws_json1_1Build(output.Build, context);
  }
  return contents;
};

const deserializeAws_json1_1UpdateFleetAttributesOutput = (
  output: any,
  context: __SerdeContext
): UpdateFleetAttributesOutput => {
  let contents: any = {
    __type: "UpdateFleetAttributesOutput",
    FleetId: undefined
  };
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  return contents;
};

const deserializeAws_json1_1UpdateFleetCapacityOutput = (
  output: any,
  context: __SerdeContext
): UpdateFleetCapacityOutput => {
  let contents: any = {
    __type: "UpdateFleetCapacityOutput",
    FleetId: undefined
  };
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  return contents;
};

const deserializeAws_json1_1UpdateFleetPortSettingsOutput = (
  output: any,
  context: __SerdeContext
): UpdateFleetPortSettingsOutput => {
  let contents: any = {
    __type: "UpdateFleetPortSettingsOutput",
    FleetId: undefined
  };
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  return contents;
};

const deserializeAws_json1_1UpdateGameSessionOutput = (
  output: any,
  context: __SerdeContext
): UpdateGameSessionOutput => {
  let contents: any = {
    __type: "UpdateGameSessionOutput",
    GameSession: undefined
  };
  if (output.GameSession !== undefined && output.GameSession !== null) {
    contents.GameSession = deserializeAws_json1_1GameSession(
      output.GameSession,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateGameSessionQueueOutput = (
  output: any,
  context: __SerdeContext
): UpdateGameSessionQueueOutput => {
  let contents: any = {
    __type: "UpdateGameSessionQueueOutput",
    GameSessionQueue: undefined
  };
  if (
    output.GameSessionQueue !== undefined &&
    output.GameSessionQueue !== null
  ) {
    contents.GameSessionQueue = deserializeAws_json1_1GameSessionQueue(
      output.GameSessionQueue,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateMatchmakingConfigurationOutput = (
  output: any,
  context: __SerdeContext
): UpdateMatchmakingConfigurationOutput => {
  let contents: any = {
    __type: "UpdateMatchmakingConfigurationOutput",
    Configuration: undefined
  };
  if (output.Configuration !== undefined && output.Configuration !== null) {
    contents.Configuration = deserializeAws_json1_1MatchmakingConfiguration(
      output.Configuration,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateRuntimeConfigurationOutput = (
  output: any,
  context: __SerdeContext
): UpdateRuntimeConfigurationOutput => {
  let contents: any = {
    __type: "UpdateRuntimeConfigurationOutput",
    RuntimeConfiguration: undefined
  };
  if (
    output.RuntimeConfiguration !== undefined &&
    output.RuntimeConfiguration !== null
  ) {
    contents.RuntimeConfiguration = deserializeAws_json1_1RuntimeConfiguration(
      output.RuntimeConfiguration,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1UpdateScriptOutput = (
  output: any,
  context: __SerdeContext
): UpdateScriptOutput => {
  let contents: any = {
    __type: "UpdateScriptOutput",
    Script: undefined
  };
  if (output.Script !== undefined && output.Script !== null) {
    contents.Script = deserializeAws_json1_1Script(output.Script, context);
  }
  return contents;
};

const deserializeAws_json1_1ValidateMatchmakingRuleSetOutput = (
  output: any,
  context: __SerdeContext
): ValidateMatchmakingRuleSetOutput => {
  let contents: any = {
    __type: "ValidateMatchmakingRuleSetOutput",
    Valid: undefined
  };
  if (output.Valid !== undefined && output.Valid !== null) {
    contents.Valid = output.Valid;
  }
  return contents;
};

const deserializeAws_json1_1VpcPeeringAuthorization = (
  output: any,
  context: __SerdeContext
): VpcPeeringAuthorization => {
  let contents: any = {
    __type: "VpcPeeringAuthorization",
    CreationTime: undefined,
    ExpirationTime: undefined,
    GameLiftAwsAccountId: undefined,
    PeerVpcAwsAccountId: undefined,
    PeerVpcId: undefined
  };
  if (output.CreationTime !== undefined && output.CreationTime !== null) {
    contents.CreationTime = new Date(Math.round(output.CreationTime * 1000));
  }
  if (output.ExpirationTime !== undefined && output.ExpirationTime !== null) {
    contents.ExpirationTime = new Date(
      Math.round(output.ExpirationTime * 1000)
    );
  }
  if (
    output.GameLiftAwsAccountId !== undefined &&
    output.GameLiftAwsAccountId !== null
  ) {
    contents.GameLiftAwsAccountId = output.GameLiftAwsAccountId;
  }
  if (
    output.PeerVpcAwsAccountId !== undefined &&
    output.PeerVpcAwsAccountId !== null
  ) {
    contents.PeerVpcAwsAccountId = output.PeerVpcAwsAccountId;
  }
  if (output.PeerVpcId !== undefined && output.PeerVpcId !== null) {
    contents.PeerVpcId = output.PeerVpcId;
  }
  return contents;
};

const deserializeAws_json1_1VpcPeeringAuthorizationList = (
  output: any,
  context: __SerdeContext
): Array<VpcPeeringAuthorization> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1VpcPeeringAuthorization(entry, context)
  );
};

const deserializeAws_json1_1VpcPeeringConnection = (
  output: any,
  context: __SerdeContext
): VpcPeeringConnection => {
  let contents: any = {
    __type: "VpcPeeringConnection",
    FleetArn: undefined,
    FleetId: undefined,
    GameLiftVpcId: undefined,
    IpV4CidrBlock: undefined,
    PeerVpcId: undefined,
    Status: undefined,
    VpcPeeringConnectionId: undefined
  };
  if (output.FleetArn !== undefined && output.FleetArn !== null) {
    contents.FleetArn = output.FleetArn;
  }
  if (output.FleetId !== undefined && output.FleetId !== null) {
    contents.FleetId = output.FleetId;
  }
  if (output.GameLiftVpcId !== undefined && output.GameLiftVpcId !== null) {
    contents.GameLiftVpcId = output.GameLiftVpcId;
  }
  if (output.IpV4CidrBlock !== undefined && output.IpV4CidrBlock !== null) {
    contents.IpV4CidrBlock = output.IpV4CidrBlock;
  }
  if (output.PeerVpcId !== undefined && output.PeerVpcId !== null) {
    contents.PeerVpcId = output.PeerVpcId;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = deserializeAws_json1_1VpcPeeringConnectionStatus(
      output.Status,
      context
    );
  }
  if (
    output.VpcPeeringConnectionId !== undefined &&
    output.VpcPeeringConnectionId !== null
  ) {
    contents.VpcPeeringConnectionId = output.VpcPeeringConnectionId;
  }
  return contents;
};

const deserializeAws_json1_1VpcPeeringConnectionList = (
  output: any,
  context: __SerdeContext
): Array<VpcPeeringConnection> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1VpcPeeringConnection(entry, context)
  );
};

const deserializeAws_json1_1VpcPeeringConnectionStatus = (
  output: any,
  context: __SerdeContext
): VpcPeeringConnectionStatus => {
  let contents: any = {
    __type: "VpcPeeringConnectionStatus",
    Code: undefined,
    Message: undefined
  };
  if (output.Code !== undefined && output.Code !== null) {
    contents.Code = output.Code;
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const buildHttpRpcRequest = (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): __HttpRequest => {
  const contents: any = {
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: path,
    headers: headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
