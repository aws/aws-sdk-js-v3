import {
  AcceptCertificateTransferCommandInput,
  AcceptCertificateTransferCommandOutput
} from "../commands/AcceptCertificateTransferCommand";
import {
  AddThingToBillingGroupCommandInput,
  AddThingToBillingGroupCommandOutput
} from "../commands/AddThingToBillingGroupCommand";
import {
  AddThingToThingGroupCommandInput,
  AddThingToThingGroupCommandOutput
} from "../commands/AddThingToThingGroupCommand";
import {
  AssociateTargetsWithJobCommandInput,
  AssociateTargetsWithJobCommandOutput
} from "../commands/AssociateTargetsWithJobCommand";
import {
  AttachPolicyCommandInput,
  AttachPolicyCommandOutput
} from "../commands/AttachPolicyCommand";
import {
  AttachPrincipalPolicyCommandInput,
  AttachPrincipalPolicyCommandOutput
} from "../commands/AttachPrincipalPolicyCommand";
import {
  AttachSecurityProfileCommandInput,
  AttachSecurityProfileCommandOutput
} from "../commands/AttachSecurityProfileCommand";
import {
  AttachThingPrincipalCommandInput,
  AttachThingPrincipalCommandOutput
} from "../commands/AttachThingPrincipalCommand";
import {
  CancelAuditMitigationActionsTaskCommandInput,
  CancelAuditMitigationActionsTaskCommandOutput
} from "../commands/CancelAuditMitigationActionsTaskCommand";
import {
  CancelAuditTaskCommandInput,
  CancelAuditTaskCommandOutput
} from "../commands/CancelAuditTaskCommand";
import {
  CancelCertificateTransferCommandInput,
  CancelCertificateTransferCommandOutput
} from "../commands/CancelCertificateTransferCommand";
import {
  CancelJobCommandInput,
  CancelJobCommandOutput
} from "../commands/CancelJobCommand";
import {
  CancelJobExecutionCommandInput,
  CancelJobExecutionCommandOutput
} from "../commands/CancelJobExecutionCommand";
import {
  ClearDefaultAuthorizerCommandInput,
  ClearDefaultAuthorizerCommandOutput
} from "../commands/ClearDefaultAuthorizerCommand";
import {
  ConfirmTopicRuleDestinationCommandInput,
  ConfirmTopicRuleDestinationCommandOutput
} from "../commands/ConfirmTopicRuleDestinationCommand";
import {
  CreateAuthorizerCommandInput,
  CreateAuthorizerCommandOutput
} from "../commands/CreateAuthorizerCommand";
import {
  CreateBillingGroupCommandInput,
  CreateBillingGroupCommandOutput
} from "../commands/CreateBillingGroupCommand";
import {
  CreateCertificateFromCsrCommandInput,
  CreateCertificateFromCsrCommandOutput
} from "../commands/CreateCertificateFromCsrCommand";
import {
  CreateDomainConfigurationCommandInput,
  CreateDomainConfigurationCommandOutput
} from "../commands/CreateDomainConfigurationCommand";
import {
  CreateDynamicThingGroupCommandInput,
  CreateDynamicThingGroupCommandOutput
} from "../commands/CreateDynamicThingGroupCommand";
import {
  CreateJobCommandInput,
  CreateJobCommandOutput
} from "../commands/CreateJobCommand";
import {
  CreateKeysAndCertificateCommandInput,
  CreateKeysAndCertificateCommandOutput
} from "../commands/CreateKeysAndCertificateCommand";
import {
  CreateMitigationActionCommandInput,
  CreateMitigationActionCommandOutput
} from "../commands/CreateMitigationActionCommand";
import {
  CreateOTAUpdateCommandInput,
  CreateOTAUpdateCommandOutput
} from "../commands/CreateOTAUpdateCommand";
import {
  CreatePolicyCommandInput,
  CreatePolicyCommandOutput
} from "../commands/CreatePolicyCommand";
import {
  CreatePolicyVersionCommandInput,
  CreatePolicyVersionCommandOutput
} from "../commands/CreatePolicyVersionCommand";
import {
  CreateProvisioningClaimCommandInput,
  CreateProvisioningClaimCommandOutput
} from "../commands/CreateProvisioningClaimCommand";
import {
  CreateProvisioningTemplateCommandInput,
  CreateProvisioningTemplateCommandOutput
} from "../commands/CreateProvisioningTemplateCommand";
import {
  CreateProvisioningTemplateVersionCommandInput,
  CreateProvisioningTemplateVersionCommandOutput
} from "../commands/CreateProvisioningTemplateVersionCommand";
import {
  CreateRoleAliasCommandInput,
  CreateRoleAliasCommandOutput
} from "../commands/CreateRoleAliasCommand";
import {
  CreateScheduledAuditCommandInput,
  CreateScheduledAuditCommandOutput
} from "../commands/CreateScheduledAuditCommand";
import {
  CreateSecurityProfileCommandInput,
  CreateSecurityProfileCommandOutput
} from "../commands/CreateSecurityProfileCommand";
import {
  CreateStreamCommandInput,
  CreateStreamCommandOutput
} from "../commands/CreateStreamCommand";
import {
  CreateThingCommandInput,
  CreateThingCommandOutput
} from "../commands/CreateThingCommand";
import {
  CreateThingGroupCommandInput,
  CreateThingGroupCommandOutput
} from "../commands/CreateThingGroupCommand";
import {
  CreateThingTypeCommandInput,
  CreateThingTypeCommandOutput
} from "../commands/CreateThingTypeCommand";
import {
  CreateTopicRuleCommandInput,
  CreateTopicRuleCommandOutput
} from "../commands/CreateTopicRuleCommand";
import {
  CreateTopicRuleDestinationCommandInput,
  CreateTopicRuleDestinationCommandOutput
} from "../commands/CreateTopicRuleDestinationCommand";
import {
  DeleteAccountAuditConfigurationCommandInput,
  DeleteAccountAuditConfigurationCommandOutput
} from "../commands/DeleteAccountAuditConfigurationCommand";
import {
  DeleteAuthorizerCommandInput,
  DeleteAuthorizerCommandOutput
} from "../commands/DeleteAuthorizerCommand";
import {
  DeleteBillingGroupCommandInput,
  DeleteBillingGroupCommandOutput
} from "../commands/DeleteBillingGroupCommand";
import {
  DeleteCACertificateCommandInput,
  DeleteCACertificateCommandOutput
} from "../commands/DeleteCACertificateCommand";
import {
  DeleteCertificateCommandInput,
  DeleteCertificateCommandOutput
} from "../commands/DeleteCertificateCommand";
import {
  DeleteDomainConfigurationCommandInput,
  DeleteDomainConfigurationCommandOutput
} from "../commands/DeleteDomainConfigurationCommand";
import {
  DeleteDynamicThingGroupCommandInput,
  DeleteDynamicThingGroupCommandOutput
} from "../commands/DeleteDynamicThingGroupCommand";
import {
  DeleteJobCommandInput,
  DeleteJobCommandOutput
} from "../commands/DeleteJobCommand";
import {
  DeleteJobExecutionCommandInput,
  DeleteJobExecutionCommandOutput
} from "../commands/DeleteJobExecutionCommand";
import {
  DeleteMitigationActionCommandInput,
  DeleteMitigationActionCommandOutput
} from "../commands/DeleteMitigationActionCommand";
import {
  DeleteOTAUpdateCommandInput,
  DeleteOTAUpdateCommandOutput
} from "../commands/DeleteOTAUpdateCommand";
import {
  DeletePolicyCommandInput,
  DeletePolicyCommandOutput
} from "../commands/DeletePolicyCommand";
import {
  DeletePolicyVersionCommandInput,
  DeletePolicyVersionCommandOutput
} from "../commands/DeletePolicyVersionCommand";
import {
  DeleteProvisioningTemplateCommandInput,
  DeleteProvisioningTemplateCommandOutput
} from "../commands/DeleteProvisioningTemplateCommand";
import {
  DeleteProvisioningTemplateVersionCommandInput,
  DeleteProvisioningTemplateVersionCommandOutput
} from "../commands/DeleteProvisioningTemplateVersionCommand";
import {
  DeleteRegistrationCodeCommandInput,
  DeleteRegistrationCodeCommandOutput
} from "../commands/DeleteRegistrationCodeCommand";
import {
  DeleteRoleAliasCommandInput,
  DeleteRoleAliasCommandOutput
} from "../commands/DeleteRoleAliasCommand";
import {
  DeleteScheduledAuditCommandInput,
  DeleteScheduledAuditCommandOutput
} from "../commands/DeleteScheduledAuditCommand";
import {
  DeleteSecurityProfileCommandInput,
  DeleteSecurityProfileCommandOutput
} from "../commands/DeleteSecurityProfileCommand";
import {
  DeleteStreamCommandInput,
  DeleteStreamCommandOutput
} from "../commands/DeleteStreamCommand";
import {
  DeleteThingCommandInput,
  DeleteThingCommandOutput
} from "../commands/DeleteThingCommand";
import {
  DeleteThingGroupCommandInput,
  DeleteThingGroupCommandOutput
} from "../commands/DeleteThingGroupCommand";
import {
  DeleteThingTypeCommandInput,
  DeleteThingTypeCommandOutput
} from "../commands/DeleteThingTypeCommand";
import {
  DeleteTopicRuleCommandInput,
  DeleteTopicRuleCommandOutput
} from "../commands/DeleteTopicRuleCommand";
import {
  DeleteTopicRuleDestinationCommandInput,
  DeleteTopicRuleDestinationCommandOutput
} from "../commands/DeleteTopicRuleDestinationCommand";
import {
  DeleteV2LoggingLevelCommandInput,
  DeleteV2LoggingLevelCommandOutput
} from "../commands/DeleteV2LoggingLevelCommand";
import {
  DeprecateThingTypeCommandInput,
  DeprecateThingTypeCommandOutput
} from "../commands/DeprecateThingTypeCommand";
import {
  DescribeAccountAuditConfigurationCommandInput,
  DescribeAccountAuditConfigurationCommandOutput
} from "../commands/DescribeAccountAuditConfigurationCommand";
import {
  DescribeAuditFindingCommandInput,
  DescribeAuditFindingCommandOutput
} from "../commands/DescribeAuditFindingCommand";
import {
  DescribeAuditMitigationActionsTaskCommandInput,
  DescribeAuditMitigationActionsTaskCommandOutput
} from "../commands/DescribeAuditMitigationActionsTaskCommand";
import {
  DescribeAuditTaskCommandInput,
  DescribeAuditTaskCommandOutput
} from "../commands/DescribeAuditTaskCommand";
import {
  DescribeAuthorizerCommandInput,
  DescribeAuthorizerCommandOutput
} from "../commands/DescribeAuthorizerCommand";
import {
  DescribeBillingGroupCommandInput,
  DescribeBillingGroupCommandOutput
} from "../commands/DescribeBillingGroupCommand";
import {
  DescribeCACertificateCommandInput,
  DescribeCACertificateCommandOutput
} from "../commands/DescribeCACertificateCommand";
import {
  DescribeCertificateCommandInput,
  DescribeCertificateCommandOutput
} from "../commands/DescribeCertificateCommand";
import {
  DescribeDefaultAuthorizerCommandInput,
  DescribeDefaultAuthorizerCommandOutput
} from "../commands/DescribeDefaultAuthorizerCommand";
import {
  DescribeDomainConfigurationCommandInput,
  DescribeDomainConfigurationCommandOutput
} from "../commands/DescribeDomainConfigurationCommand";
import {
  DescribeEndpointCommandInput,
  DescribeEndpointCommandOutput
} from "../commands/DescribeEndpointCommand";
import {
  DescribeEventConfigurationsCommandInput,
  DescribeEventConfigurationsCommandOutput
} from "../commands/DescribeEventConfigurationsCommand";
import {
  DescribeIndexCommandInput,
  DescribeIndexCommandOutput
} from "../commands/DescribeIndexCommand";
import {
  DescribeJobCommandInput,
  DescribeJobCommandOutput
} from "../commands/DescribeJobCommand";
import {
  DescribeJobExecutionCommandInput,
  DescribeJobExecutionCommandOutput
} from "../commands/DescribeJobExecutionCommand";
import {
  DescribeMitigationActionCommandInput,
  DescribeMitigationActionCommandOutput
} from "../commands/DescribeMitigationActionCommand";
import {
  DescribeProvisioningTemplateCommandInput,
  DescribeProvisioningTemplateCommandOutput
} from "../commands/DescribeProvisioningTemplateCommand";
import {
  DescribeProvisioningTemplateVersionCommandInput,
  DescribeProvisioningTemplateVersionCommandOutput
} from "../commands/DescribeProvisioningTemplateVersionCommand";
import {
  DescribeRoleAliasCommandInput,
  DescribeRoleAliasCommandOutput
} from "../commands/DescribeRoleAliasCommand";
import {
  DescribeScheduledAuditCommandInput,
  DescribeScheduledAuditCommandOutput
} from "../commands/DescribeScheduledAuditCommand";
import {
  DescribeSecurityProfileCommandInput,
  DescribeSecurityProfileCommandOutput
} from "../commands/DescribeSecurityProfileCommand";
import {
  DescribeStreamCommandInput,
  DescribeStreamCommandOutput
} from "../commands/DescribeStreamCommand";
import {
  DescribeThingCommandInput,
  DescribeThingCommandOutput
} from "../commands/DescribeThingCommand";
import {
  DescribeThingGroupCommandInput,
  DescribeThingGroupCommandOutput
} from "../commands/DescribeThingGroupCommand";
import {
  DescribeThingRegistrationTaskCommandInput,
  DescribeThingRegistrationTaskCommandOutput
} from "../commands/DescribeThingRegistrationTaskCommand";
import {
  DescribeThingTypeCommandInput,
  DescribeThingTypeCommandOutput
} from "../commands/DescribeThingTypeCommand";
import {
  DetachPolicyCommandInput,
  DetachPolicyCommandOutput
} from "../commands/DetachPolicyCommand";
import {
  DetachPrincipalPolicyCommandInput,
  DetachPrincipalPolicyCommandOutput
} from "../commands/DetachPrincipalPolicyCommand";
import {
  DetachSecurityProfileCommandInput,
  DetachSecurityProfileCommandOutput
} from "../commands/DetachSecurityProfileCommand";
import {
  DetachThingPrincipalCommandInput,
  DetachThingPrincipalCommandOutput
} from "../commands/DetachThingPrincipalCommand";
import {
  DisableTopicRuleCommandInput,
  DisableTopicRuleCommandOutput
} from "../commands/DisableTopicRuleCommand";
import {
  EnableTopicRuleCommandInput,
  EnableTopicRuleCommandOutput
} from "../commands/EnableTopicRuleCommand";
import {
  GetCardinalityCommandInput,
  GetCardinalityCommandOutput
} from "../commands/GetCardinalityCommand";
import {
  GetEffectivePoliciesCommandInput,
  GetEffectivePoliciesCommandOutput
} from "../commands/GetEffectivePoliciesCommand";
import {
  GetIndexingConfigurationCommandInput,
  GetIndexingConfigurationCommandOutput
} from "../commands/GetIndexingConfigurationCommand";
import {
  GetJobDocumentCommandInput,
  GetJobDocumentCommandOutput
} from "../commands/GetJobDocumentCommand";
import {
  GetLoggingOptionsCommandInput,
  GetLoggingOptionsCommandOutput
} from "../commands/GetLoggingOptionsCommand";
import {
  GetOTAUpdateCommandInput,
  GetOTAUpdateCommandOutput
} from "../commands/GetOTAUpdateCommand";
import {
  GetPercentilesCommandInput,
  GetPercentilesCommandOutput
} from "../commands/GetPercentilesCommand";
import {
  GetPolicyCommandInput,
  GetPolicyCommandOutput
} from "../commands/GetPolicyCommand";
import {
  GetPolicyVersionCommandInput,
  GetPolicyVersionCommandOutput
} from "../commands/GetPolicyVersionCommand";
import {
  GetRegistrationCodeCommandInput,
  GetRegistrationCodeCommandOutput
} from "../commands/GetRegistrationCodeCommand";
import {
  GetStatisticsCommandInput,
  GetStatisticsCommandOutput
} from "../commands/GetStatisticsCommand";
import {
  GetTopicRuleCommandInput,
  GetTopicRuleCommandOutput
} from "../commands/GetTopicRuleCommand";
import {
  GetTopicRuleDestinationCommandInput,
  GetTopicRuleDestinationCommandOutput
} from "../commands/GetTopicRuleDestinationCommand";
import {
  GetV2LoggingOptionsCommandInput,
  GetV2LoggingOptionsCommandOutput
} from "../commands/GetV2LoggingOptionsCommand";
import {
  ListActiveViolationsCommandInput,
  ListActiveViolationsCommandOutput
} from "../commands/ListActiveViolationsCommand";
import {
  ListAttachedPoliciesCommandInput,
  ListAttachedPoliciesCommandOutput
} from "../commands/ListAttachedPoliciesCommand";
import {
  ListAuditFindingsCommandInput,
  ListAuditFindingsCommandOutput
} from "../commands/ListAuditFindingsCommand";
import {
  ListAuditMitigationActionsExecutionsCommandInput,
  ListAuditMitigationActionsExecutionsCommandOutput
} from "../commands/ListAuditMitigationActionsExecutionsCommand";
import {
  ListAuditMitigationActionsTasksCommandInput,
  ListAuditMitigationActionsTasksCommandOutput
} from "../commands/ListAuditMitigationActionsTasksCommand";
import {
  ListAuditTasksCommandInput,
  ListAuditTasksCommandOutput
} from "../commands/ListAuditTasksCommand";
import {
  ListAuthorizersCommandInput,
  ListAuthorizersCommandOutput
} from "../commands/ListAuthorizersCommand";
import {
  ListBillingGroupsCommandInput,
  ListBillingGroupsCommandOutput
} from "../commands/ListBillingGroupsCommand";
import {
  ListCACertificatesCommandInput,
  ListCACertificatesCommandOutput
} from "../commands/ListCACertificatesCommand";
import {
  ListCertificatesByCACommandInput,
  ListCertificatesByCACommandOutput
} from "../commands/ListCertificatesByCACommand";
import {
  ListCertificatesCommandInput,
  ListCertificatesCommandOutput
} from "../commands/ListCertificatesCommand";
import {
  ListDomainConfigurationsCommandInput,
  ListDomainConfigurationsCommandOutput
} from "../commands/ListDomainConfigurationsCommand";
import {
  ListIndicesCommandInput,
  ListIndicesCommandOutput
} from "../commands/ListIndicesCommand";
import {
  ListJobExecutionsForJobCommandInput,
  ListJobExecutionsForJobCommandOutput
} from "../commands/ListJobExecutionsForJobCommand";
import {
  ListJobExecutionsForThingCommandInput,
  ListJobExecutionsForThingCommandOutput
} from "../commands/ListJobExecutionsForThingCommand";
import {
  ListJobsCommandInput,
  ListJobsCommandOutput
} from "../commands/ListJobsCommand";
import {
  ListMitigationActionsCommandInput,
  ListMitigationActionsCommandOutput
} from "../commands/ListMitigationActionsCommand";
import {
  ListOTAUpdatesCommandInput,
  ListOTAUpdatesCommandOutput
} from "../commands/ListOTAUpdatesCommand";
import {
  ListOutgoingCertificatesCommandInput,
  ListOutgoingCertificatesCommandOutput
} from "../commands/ListOutgoingCertificatesCommand";
import {
  ListPoliciesCommandInput,
  ListPoliciesCommandOutput
} from "../commands/ListPoliciesCommand";
import {
  ListPolicyPrincipalsCommandInput,
  ListPolicyPrincipalsCommandOutput
} from "../commands/ListPolicyPrincipalsCommand";
import {
  ListPolicyVersionsCommandInput,
  ListPolicyVersionsCommandOutput
} from "../commands/ListPolicyVersionsCommand";
import {
  ListPrincipalPoliciesCommandInput,
  ListPrincipalPoliciesCommandOutput
} from "../commands/ListPrincipalPoliciesCommand";
import {
  ListPrincipalThingsCommandInput,
  ListPrincipalThingsCommandOutput
} from "../commands/ListPrincipalThingsCommand";
import {
  ListProvisioningTemplateVersionsCommandInput,
  ListProvisioningTemplateVersionsCommandOutput
} from "../commands/ListProvisioningTemplateVersionsCommand";
import {
  ListProvisioningTemplatesCommandInput,
  ListProvisioningTemplatesCommandOutput
} from "../commands/ListProvisioningTemplatesCommand";
import {
  ListRoleAliasesCommandInput,
  ListRoleAliasesCommandOutput
} from "../commands/ListRoleAliasesCommand";
import {
  ListScheduledAuditsCommandInput,
  ListScheduledAuditsCommandOutput
} from "../commands/ListScheduledAuditsCommand";
import {
  ListSecurityProfilesCommandInput,
  ListSecurityProfilesCommandOutput
} from "../commands/ListSecurityProfilesCommand";
import {
  ListSecurityProfilesForTargetCommandInput,
  ListSecurityProfilesForTargetCommandOutput
} from "../commands/ListSecurityProfilesForTargetCommand";
import {
  ListStreamsCommandInput,
  ListStreamsCommandOutput
} from "../commands/ListStreamsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ListTargetsForPolicyCommandInput,
  ListTargetsForPolicyCommandOutput
} from "../commands/ListTargetsForPolicyCommand";
import {
  ListTargetsForSecurityProfileCommandInput,
  ListTargetsForSecurityProfileCommandOutput
} from "../commands/ListTargetsForSecurityProfileCommand";
import {
  ListThingGroupsCommandInput,
  ListThingGroupsCommandOutput
} from "../commands/ListThingGroupsCommand";
import {
  ListThingGroupsForThingCommandInput,
  ListThingGroupsForThingCommandOutput
} from "../commands/ListThingGroupsForThingCommand";
import {
  ListThingPrincipalsCommandInput,
  ListThingPrincipalsCommandOutput
} from "../commands/ListThingPrincipalsCommand";
import {
  ListThingRegistrationTaskReportsCommandInput,
  ListThingRegistrationTaskReportsCommandOutput
} from "../commands/ListThingRegistrationTaskReportsCommand";
import {
  ListThingRegistrationTasksCommandInput,
  ListThingRegistrationTasksCommandOutput
} from "../commands/ListThingRegistrationTasksCommand";
import {
  ListThingTypesCommandInput,
  ListThingTypesCommandOutput
} from "../commands/ListThingTypesCommand";
import {
  ListThingsCommandInput,
  ListThingsCommandOutput
} from "../commands/ListThingsCommand";
import {
  ListThingsInBillingGroupCommandInput,
  ListThingsInBillingGroupCommandOutput
} from "../commands/ListThingsInBillingGroupCommand";
import {
  ListThingsInThingGroupCommandInput,
  ListThingsInThingGroupCommandOutput
} from "../commands/ListThingsInThingGroupCommand";
import {
  ListTopicRuleDestinationsCommandInput,
  ListTopicRuleDestinationsCommandOutput
} from "../commands/ListTopicRuleDestinationsCommand";
import {
  ListTopicRulesCommandInput,
  ListTopicRulesCommandOutput
} from "../commands/ListTopicRulesCommand";
import {
  ListV2LoggingLevelsCommandInput,
  ListV2LoggingLevelsCommandOutput
} from "../commands/ListV2LoggingLevelsCommand";
import {
  ListViolationEventsCommandInput,
  ListViolationEventsCommandOutput
} from "../commands/ListViolationEventsCommand";
import {
  RegisterCACertificateCommandInput,
  RegisterCACertificateCommandOutput
} from "../commands/RegisterCACertificateCommand";
import {
  RegisterCertificateCommandInput,
  RegisterCertificateCommandOutput
} from "../commands/RegisterCertificateCommand";
import {
  RegisterThingCommandInput,
  RegisterThingCommandOutput
} from "../commands/RegisterThingCommand";
import {
  RejectCertificateTransferCommandInput,
  RejectCertificateTransferCommandOutput
} from "../commands/RejectCertificateTransferCommand";
import {
  RemoveThingFromBillingGroupCommandInput,
  RemoveThingFromBillingGroupCommandOutput
} from "../commands/RemoveThingFromBillingGroupCommand";
import {
  RemoveThingFromThingGroupCommandInput,
  RemoveThingFromThingGroupCommandOutput
} from "../commands/RemoveThingFromThingGroupCommand";
import {
  ReplaceTopicRuleCommandInput,
  ReplaceTopicRuleCommandOutput
} from "../commands/ReplaceTopicRuleCommand";
import {
  SearchIndexCommandInput,
  SearchIndexCommandOutput
} from "../commands/SearchIndexCommand";
import {
  SetDefaultAuthorizerCommandInput,
  SetDefaultAuthorizerCommandOutput
} from "../commands/SetDefaultAuthorizerCommand";
import {
  SetDefaultPolicyVersionCommandInput,
  SetDefaultPolicyVersionCommandOutput
} from "../commands/SetDefaultPolicyVersionCommand";
import {
  SetLoggingOptionsCommandInput,
  SetLoggingOptionsCommandOutput
} from "../commands/SetLoggingOptionsCommand";
import {
  SetV2LoggingLevelCommandInput,
  SetV2LoggingLevelCommandOutput
} from "../commands/SetV2LoggingLevelCommand";
import {
  SetV2LoggingOptionsCommandInput,
  SetV2LoggingOptionsCommandOutput
} from "../commands/SetV2LoggingOptionsCommand";
import {
  StartAuditMitigationActionsTaskCommandInput,
  StartAuditMitigationActionsTaskCommandOutput
} from "../commands/StartAuditMitigationActionsTaskCommand";
import {
  StartOnDemandAuditTaskCommandInput,
  StartOnDemandAuditTaskCommandOutput
} from "../commands/StartOnDemandAuditTaskCommand";
import {
  StartThingRegistrationTaskCommandInput,
  StartThingRegistrationTaskCommandOutput
} from "../commands/StartThingRegistrationTaskCommand";
import {
  StopThingRegistrationTaskCommandInput,
  StopThingRegistrationTaskCommandOutput
} from "../commands/StopThingRegistrationTaskCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput
} from "../commands/TagResourceCommand";
import {
  TestAuthorizationCommandInput,
  TestAuthorizationCommandOutput
} from "../commands/TestAuthorizationCommand";
import {
  TestInvokeAuthorizerCommandInput,
  TestInvokeAuthorizerCommandOutput
} from "../commands/TestInvokeAuthorizerCommand";
import {
  TransferCertificateCommandInput,
  TransferCertificateCommandOutput
} from "../commands/TransferCertificateCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput
} from "../commands/UntagResourceCommand";
import {
  UpdateAccountAuditConfigurationCommandInput,
  UpdateAccountAuditConfigurationCommandOutput
} from "../commands/UpdateAccountAuditConfigurationCommand";
import {
  UpdateAuthorizerCommandInput,
  UpdateAuthorizerCommandOutput
} from "../commands/UpdateAuthorizerCommand";
import {
  UpdateBillingGroupCommandInput,
  UpdateBillingGroupCommandOutput
} from "../commands/UpdateBillingGroupCommand";
import {
  UpdateCACertificateCommandInput,
  UpdateCACertificateCommandOutput
} from "../commands/UpdateCACertificateCommand";
import {
  UpdateCertificateCommandInput,
  UpdateCertificateCommandOutput
} from "../commands/UpdateCertificateCommand";
import {
  UpdateDomainConfigurationCommandInput,
  UpdateDomainConfigurationCommandOutput
} from "../commands/UpdateDomainConfigurationCommand";
import {
  UpdateDynamicThingGroupCommandInput,
  UpdateDynamicThingGroupCommandOutput
} from "../commands/UpdateDynamicThingGroupCommand";
import {
  UpdateEventConfigurationsCommandInput,
  UpdateEventConfigurationsCommandOutput
} from "../commands/UpdateEventConfigurationsCommand";
import {
  UpdateIndexingConfigurationCommandInput,
  UpdateIndexingConfigurationCommandOutput
} from "../commands/UpdateIndexingConfigurationCommand";
import {
  UpdateJobCommandInput,
  UpdateJobCommandOutput
} from "../commands/UpdateJobCommand";
import {
  UpdateMitigationActionCommandInput,
  UpdateMitigationActionCommandOutput
} from "../commands/UpdateMitigationActionCommand";
import {
  UpdateProvisioningTemplateCommandInput,
  UpdateProvisioningTemplateCommandOutput
} from "../commands/UpdateProvisioningTemplateCommand";
import {
  UpdateRoleAliasCommandInput,
  UpdateRoleAliasCommandOutput
} from "../commands/UpdateRoleAliasCommand";
import {
  UpdateScheduledAuditCommandInput,
  UpdateScheduledAuditCommandOutput
} from "../commands/UpdateScheduledAuditCommand";
import {
  UpdateSecurityProfileCommandInput,
  UpdateSecurityProfileCommandOutput
} from "../commands/UpdateSecurityProfileCommand";
import {
  UpdateStreamCommandInput,
  UpdateStreamCommandOutput
} from "../commands/UpdateStreamCommand";
import {
  UpdateThingCommandInput,
  UpdateThingCommandOutput
} from "../commands/UpdateThingCommand";
import {
  UpdateThingGroupCommandInput,
  UpdateThingGroupCommandOutput
} from "../commands/UpdateThingGroupCommand";
import {
  UpdateThingGroupsForThingCommandInput,
  UpdateThingGroupsForThingCommandOutput
} from "../commands/UpdateThingGroupsForThingCommand";
import {
  UpdateTopicRuleDestinationCommandInput,
  UpdateTopicRuleDestinationCommandOutput
} from "../commands/UpdateTopicRuleDestinationCommand";
import {
  ValidateSecurityProfileBehaviorsCommandInput,
  ValidateSecurityProfileBehaviorsCommandOutput
} from "../commands/ValidateSecurityProfileBehaviorsCommand";
import {
  AbortConfig,
  AbortCriteria,
  Action,
  ActiveViolation,
  AddThingsToThingGroupParams,
  AlertTarget,
  Allowed,
  AssetPropertyTimestamp,
  AssetPropertyValue,
  AssetPropertyVariant,
  AttributePayload,
  AuditCheckConfiguration,
  AuditCheckDetails,
  AuditFinding,
  AuditMitigationActionExecutionMetadata,
  AuditMitigationActionsTaskMetadata,
  AuditMitigationActionsTaskTarget,
  AuditNotificationTarget,
  AuditTaskMetadata,
  AuthInfo,
  AuthResult,
  AuthorizerConfig,
  AuthorizerDescription,
  AuthorizerSummary,
  AwsJobExecutionsRolloutConfig,
  AwsJobPresignedUrlConfig,
  Behavior,
  BehaviorCriteria,
  BillingGroupMetadata,
  BillingGroupProperties,
  CACertificate,
  CACertificateDescription,
  Certificate,
  CertificateConflictException,
  CertificateDescription,
  CertificateStateException,
  CertificateValidationException,
  CertificateValidity,
  CloudwatchAlarmAction,
  CloudwatchMetricAction,
  CodeSigning,
  CodeSigningCertificateChain,
  CodeSigningSignature,
  Configuration,
  ConflictingResourceUpdateException,
  CustomCodeSigning,
  DeleteConflictException,
  Denied,
  Destination,
  DomainConfigurationSummary,
  DynamoDBAction,
  DynamoDBv2Action,
  EffectivePolicy,
  ElasticsearchAction,
  EnableIoTLoggingParams,
  ErrorInfo,
  ExplicitDeny,
  ExponentialRolloutRate,
  Field,
  FileLocation,
  FirehoseAction,
  GroupNameAndArn,
  HttpAction,
  HttpActionHeader,
  HttpAuthorization,
  HttpContext,
  HttpUrlDestinationConfiguration,
  HttpUrlDestinationProperties,
  HttpUrlDestinationSummary,
  ImplicitDeny,
  IndexNotReadyException,
  InternalException,
  InternalFailureException,
  InvalidAggregationException,
  InvalidQueryException,
  InvalidRequestException,
  InvalidResponseException,
  InvalidStateTransitionException,
  IotAnalyticsAction,
  IotEventsAction,
  IotSiteWiseAction,
  Job,
  JobExecution,
  JobExecutionStatusDetails,
  JobExecutionSummary,
  JobExecutionSummaryForJob,
  JobExecutionSummaryForThing,
  JobExecutionsRolloutConfig,
  JobProcessDetails,
  JobSummary,
  KeyPair,
  KinesisAction,
  LambdaAction,
  LimitExceededException,
  LogTarget,
  LogTargetConfiguration,
  LoggingOptionsPayload,
  MalformedPolicyException,
  MetricValue,
  MitigationAction,
  MitigationActionIdentifier,
  MitigationActionParams,
  MqttContext,
  NonCompliantResource,
  NotConfiguredException,
  OTAUpdateFile,
  OTAUpdateInfo,
  OTAUpdateSummary,
  OutgoingCertificate,
  PercentPair,
  Policy,
  PolicyVersion,
  PolicyVersionIdentifier,
  PresignedUrlConfig,
  Protocol,
  ProvisioningTemplateSummary,
  ProvisioningTemplateVersionSummary,
  PublishFindingToSnsParams,
  PutAssetPropertyValueEntry,
  PutItemInput,
  RateIncreaseCriteria,
  RegistrationCodeValidationException,
  RegistrationConfig,
  RelatedResource,
  ReplaceDefaultPolicyVersionParams,
  RepublishAction,
  ResourceAlreadyExistsException,
  ResourceIdentifier,
  ResourceNotFoundException,
  ResourceRegistrationFailureException,
  RoleAliasDescription,
  S3Action,
  S3Destination,
  S3Location,
  SalesforceAction,
  ScheduledAuditMetadata,
  SecurityProfileIdentifier,
  SecurityProfileTarget,
  SecurityProfileTargetMapping,
  ServerCertificateSummary,
  ServiceUnavailableException,
  SigV4Authorization,
  SigningProfileParameter,
  SnsAction,
  SqlParseException,
  SqsAction,
  StartSigningJobParameter,
  StatisticalThreshold,
  Statistics,
  StepFunctionsAction,
  StreamFile,
  StreamInfo,
  StreamSummary,
  Tag,
  TaskAlreadyExistsException,
  TaskStatistics,
  TaskStatisticsForAuditCheck,
  ThingAttribute,
  ThingConnectivity,
  ThingDocument,
  ThingGroupDocument,
  ThingGroupIndexingConfiguration,
  ThingGroupMetadata,
  ThingGroupProperties,
  ThingIndexingConfiguration,
  ThingTypeDefinition,
  ThingTypeMetadata,
  ThingTypeProperties,
  ThrottlingException,
  TimeoutConfig,
  TlsContext,
  TopicRule,
  TopicRuleDestination,
  TopicRuleDestinationConfiguration,
  TopicRuleDestinationSummary,
  TopicRuleListItem,
  TopicRulePayload,
  TransferAlreadyCompletedException,
  TransferConflictException,
  TransferData,
  UnauthorizedException,
  UpdateCACertificateParams,
  UpdateDeviceCertificateParams,
  ValidationError,
  VersionConflictException,
  VersionsLimitExceededException,
  ViolationEvent,
  _Stream
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import { v4 as generateIdempotencyToken } from "uuid";

export async function serializeAws_restJson1_1ConfirmTopicRuleDestinationCommand(
  input: ConfirmTopicRuleDestinationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/confirmdestination/{confirmationToken+}";
  if (input.confirmationToken !== undefined) {
    const labelValue: string = input.confirmationToken;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: confirmationToken."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{confirmationToken+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: confirmationToken."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1CreateTopicRuleCommand(
  input: CreateTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  if (input.tags !== undefined) {
    headers["x-amz-tagging"] = input.tags;
  }
  let resolvedPath = "/rules/{ruleName}";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace(
      "{ruleName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  let body: any;
  if (input.topicRulePayload !== undefined) {
    body = serializeAws_restJson1_1TopicRulePayload(
      input.topicRulePayload,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateTopicRuleDestinationCommand(
  input: CreateTopicRuleDestinationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/destinations";
  let body: any;
  const bodyParams: any = {};
  if (input.destinationConfiguration !== undefined) {
    bodyParams[
      "destinationConfiguration"
    ] = serializeAws_restJson1_1TopicRuleDestinationConfiguration(
      input.destinationConfiguration,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteTopicRuleCommand(
  input: DeleteTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/rules/{ruleName}";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace(
      "{ruleName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteTopicRuleDestinationCommand(
  input: DeleteTopicRuleDestinationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/destinations/{arn+}";
  if (input.arn !== undefined) {
    const labelValue: string = input.arn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: arn.");
    }
    resolvedPath = resolvedPath.replace(
      "{arn+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: arn.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteV2LoggingLevelCommand(
  input: DeleteV2LoggingLevelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v2LoggingLevel";
  const query: any = {};
  if (input.targetName !== undefined) {
    query["targetName"] = input.targetName;
  }
  if (input.targetType !== undefined) {
    query["targetType"] = input.targetType;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DisableTopicRuleCommand(
  input: DisableTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/rules/{ruleName}/disable";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace(
      "{ruleName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1EnableTopicRuleCommand(
  input: EnableTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/rules/{ruleName}/enable";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace(
      "{ruleName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetLoggingOptionsCommand(
  input: GetLoggingOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/loggingOptions";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetTopicRuleCommand(
  input: GetTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/rules/{ruleName}";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace(
      "{ruleName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetTopicRuleDestinationCommand(
  input: GetTopicRuleDestinationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/destinations/{arn+}";
  if (input.arn !== undefined) {
    const labelValue: string = input.arn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: arn.");
    }
    resolvedPath = resolvedPath.replace(
      "{arn+}",
      labelValue
        .split("/")
        .map(segment => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: arn.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetV2LoggingOptionsCommand(
  input: GetV2LoggingOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v2LoggingOptions";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ListTopicRuleDestinationsCommand(
  input: ListTopicRuleDestinationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/destinations";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListTopicRulesCommand(
  input: ListTopicRulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/rules";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.ruleDisabled !== undefined) {
    query["ruleDisabled"] = input.ruleDisabled.toString();
  }
  if (input.topic !== undefined) {
    query["topic"] = input.topic;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListV2LoggingLevelsCommand(
  input: ListV2LoggingLevelsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/v2LoggingLevel";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.targetType !== undefined) {
    query["targetType"] = input.targetType;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ReplaceTopicRuleCommand(
  input: ReplaceTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/rules/{ruleName}";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace(
      "{ruleName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  let body: any;
  if (input.topicRulePayload !== undefined) {
    body = serializeAws_restJson1_1TopicRulePayload(
      input.topicRulePayload,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1SetLoggingOptionsCommand(
  input: SetLoggingOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/loggingOptions";
  let body: any;
  if (input.loggingOptionsPayload !== undefined) {
    body = serializeAws_restJson1_1LoggingOptionsPayload(
      input.loggingOptionsPayload,
      context
    );
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1SetV2LoggingLevelCommand(
  input: SetV2LoggingLevelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v2LoggingLevel";
  let body: any;
  const bodyParams: any = {};
  if (input.logLevel !== undefined) {
    bodyParams["logLevel"] = input.logLevel;
  }
  if (input.logTarget !== undefined) {
    bodyParams["logTarget"] = serializeAws_restJson1_1LogTarget(
      input.logTarget,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1SetV2LoggingOptionsCommand(
  input: SetV2LoggingOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/v2LoggingOptions";
  let body: any;
  const bodyParams: any = {};
  if (input.defaultLogLevel !== undefined) {
    bodyParams["defaultLogLevel"] = input.defaultLogLevel;
  }
  if (input.disableAllLogs !== undefined) {
    bodyParams["disableAllLogs"] = input.disableAllLogs;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateTopicRuleDestinationCommand(
  input: UpdateTopicRuleDestinationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/destinations";
  let body: any;
  const bodyParams: any = {};
  if (input.arn !== undefined) {
    bodyParams["arn"] = input.arn;
  }
  if (input.status !== undefined) {
    bodyParams["status"] = input.status;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1AcceptCertificateTransferCommand(
  input: AcceptCertificateTransferCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/accept-certificate-transfer/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: certificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{certificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  const query: any = {};
  if (input.setAsActive !== undefined) {
    query["setAsActive"] = input.setAsActive.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1AttachPolicyCommand(
  input: AttachPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/target-policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.target !== undefined) {
    bodyParams["target"] = input.target;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1AttachPrincipalPolicyCommand(
  input: AttachPrincipalPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.principal !== undefined) {
    headers["x-amzn-iot-principal"] = input.principal;
  }
  let resolvedPath = "/principal-policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1CancelCertificateTransferCommand(
  input: CancelCertificateTransferCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/cancel-certificate-transfer/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: certificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{certificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ClearDefaultAuthorizerCommand(
  input: ClearDefaultAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/default-authorizer";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1CreateAuthorizerCommand(
  input: CreateAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/authorizer/{authorizerName}";
  if (input.authorizerName !== undefined) {
    const labelValue: string = input.authorizerName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: authorizerName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{authorizerName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: authorizerName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.authorizerFunctionArn !== undefined) {
    bodyParams["authorizerFunctionArn"] = input.authorizerFunctionArn;
  }
  if (input.signingDisabled !== undefined) {
    bodyParams["signingDisabled"] = input.signingDisabled;
  }
  if (input.status !== undefined) {
    bodyParams["status"] = input.status;
  }
  if (input.tokenKeyName !== undefined) {
    bodyParams["tokenKeyName"] = input.tokenKeyName;
  }
  if (input.tokenSigningPublicKeys !== undefined) {
    bodyParams["tokenSigningPublicKeys"] = serializeAws_restJson1_1PublicKeyMap(
      input.tokenSigningPublicKeys,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateCertificateFromCsrCommand(
  input: CreateCertificateFromCsrCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/certificates";
  const query: any = {};
  if (input.setAsActive !== undefined) {
    query["setAsActive"] = input.setAsActive.toString();
  }
  let body: any;
  const bodyParams: any = {};
  if (input.certificateSigningRequest !== undefined) {
    bodyParams["certificateSigningRequest"] = input.certificateSigningRequest;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateDomainConfigurationCommand(
  input: CreateDomainConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/domainConfigurations/{domainConfigurationName}";
  if (input.domainConfigurationName !== undefined) {
    const labelValue: string = input.domainConfigurationName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: domainConfigurationName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{domainConfigurationName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: domainConfigurationName."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.authorizerConfig !== undefined) {
    bodyParams["authorizerConfig"] = serializeAws_restJson1_1AuthorizerConfig(
      input.authorizerConfig,
      context
    );
  }
  if (input.domainName !== undefined) {
    bodyParams["domainName"] = input.domainName;
  }
  if (input.serverCertificateArns !== undefined) {
    bodyParams[
      "serverCertificateArns"
    ] = serializeAws_restJson1_1ServerCertificateArns(
      input.serverCertificateArns,
      context
    );
  }
  if (input.serviceType !== undefined) {
    bodyParams["serviceType"] = input.serviceType;
  }
  if (input.validationCertificateArn !== undefined) {
    bodyParams["validationCertificateArn"] = input.validationCertificateArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateKeysAndCertificateCommand(
  input: CreateKeysAndCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/keys-and-certificate";
  const query: any = {};
  if (input.setAsActive !== undefined) {
    query["setAsActive"] = input.setAsActive.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1CreatePolicyCommand(
  input: CreatePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.policyDocument !== undefined) {
    bodyParams["policyDocument"] = input.policyDocument;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreatePolicyVersionCommand(
  input: CreatePolicyVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/policies/{policyName}/version";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  const query: any = {};
  if (input.setAsDefault !== undefined) {
    query["setAsDefault"] = input.setAsDefault.toString();
  }
  let body: any;
  const bodyParams: any = {};
  if (input.policyDocument !== undefined) {
    bodyParams["policyDocument"] = input.policyDocument;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateProvisioningClaimCommand(
  input: CreateProvisioningClaimCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/provisioning-templates/{templateName}/provisioning-claim";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: templateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{templateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1CreateProvisioningTemplateCommand(
  input: CreateProvisioningTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/provisioning-templates";
  let body: any;
  const bodyParams: any = {};
  if (input.description !== undefined) {
    bodyParams["description"] = input.description;
  }
  if (input.enabled !== undefined) {
    bodyParams["enabled"] = input.enabled;
  }
  if (input.provisioningRoleArn !== undefined) {
    bodyParams["provisioningRoleArn"] = input.provisioningRoleArn;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  if (input.templateBody !== undefined) {
    bodyParams["templateBody"] = input.templateBody;
  }
  if (input.templateName !== undefined) {
    bodyParams["templateName"] = input.templateName;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateProvisioningTemplateVersionCommand(
  input: CreateProvisioningTemplateVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/provisioning-templates/{templateName}/versions";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: templateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{templateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  const query: any = {};
  if (input.setAsDefault !== undefined) {
    query["setAsDefault"] = input.setAsDefault.toString();
  }
  let body: any;
  const bodyParams: any = {};
  if (input.templateBody !== undefined) {
    bodyParams["templateBody"] = input.templateBody;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateRoleAliasCommand(
  input: CreateRoleAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/role-aliases/{roleAlias}";
  if (input.roleAlias !== undefined) {
    const labelValue: string = input.roleAlias;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: roleAlias.");
    }
    resolvedPath = resolvedPath.replace(
      "{roleAlias}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: roleAlias.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.credentialDurationSeconds !== undefined) {
    bodyParams["credentialDurationSeconds"] = input.credentialDurationSeconds;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteAuthorizerCommand(
  input: DeleteAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/authorizer/{authorizerName}";
  if (input.authorizerName !== undefined) {
    const labelValue: string = input.authorizerName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: authorizerName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{authorizerName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: authorizerName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteCACertificateCommand(
  input: DeleteCACertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/cacertificate/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: certificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{certificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteCertificateCommand(
  input: DeleteCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/certificates/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: certificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{certificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  const query: any = {};
  if (input.forceDelete !== undefined) {
    query["forceDelete"] = input.forceDelete.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DeleteDomainConfigurationCommand(
  input: DeleteDomainConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/domainConfigurations/{domainConfigurationName}";
  if (input.domainConfigurationName !== undefined) {
    const labelValue: string = input.domainConfigurationName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: domainConfigurationName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{domainConfigurationName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: domainConfigurationName."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeletePolicyCommand(
  input: DeletePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeletePolicyVersionCommand(
  input: DeletePolicyVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/policies/{policyName}/version/{policyVersionId}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  if (input.policyVersionId !== undefined) {
    const labelValue: string = input.policyVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: policyVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{policyVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyVersionId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteProvisioningTemplateCommand(
  input: DeleteProvisioningTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/provisioning-templates/{templateName}";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: templateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{templateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteProvisioningTemplateVersionCommand(
  input: DeleteProvisioningTemplateVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/provisioning-templates/{templateName}/versions/{versionId}";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: templateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{templateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  if (input.versionId !== undefined) {
    const labelValue: string = input.versionId.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: versionId.");
    }
    resolvedPath = resolvedPath.replace(
      "{versionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: versionId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteRegistrationCodeCommand(
  input: DeleteRegistrationCodeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/registrationcode";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteRoleAliasCommand(
  input: DeleteRoleAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/role-aliases/{roleAlias}";
  if (input.roleAlias !== undefined) {
    const labelValue: string = input.roleAlias;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: roleAlias.");
    }
    resolvedPath = resolvedPath.replace(
      "{roleAlias}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: roleAlias.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeAuthorizerCommand(
  input: DescribeAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/authorizer/{authorizerName}";
  if (input.authorizerName !== undefined) {
    const labelValue: string = input.authorizerName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: authorizerName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{authorizerName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: authorizerName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeCACertificateCommand(
  input: DescribeCACertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/cacertificate/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: certificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{certificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeCertificateCommand(
  input: DescribeCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/certificates/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: certificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{certificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeDefaultAuthorizerCommand(
  input: DescribeDefaultAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/default-authorizer";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeDomainConfigurationCommand(
  input: DescribeDomainConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/domainConfigurations/{domainConfigurationName}";
  if (input.domainConfigurationName !== undefined) {
    const labelValue: string = input.domainConfigurationName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: domainConfigurationName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{domainConfigurationName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: domainConfigurationName."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeEndpointCommand(
  input: DescribeEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/endpoint";
  const query: any = {};
  if (input.endpointType !== undefined) {
    query["endpointType"] = input.endpointType;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DescribeProvisioningTemplateCommand(
  input: DescribeProvisioningTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/provisioning-templates/{templateName}";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: templateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{templateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeProvisioningTemplateVersionCommand(
  input: DescribeProvisioningTemplateVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/provisioning-templates/{templateName}/versions/{versionId}";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: templateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{templateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  if (input.versionId !== undefined) {
    const labelValue: string = input.versionId.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: versionId.");
    }
    resolvedPath = resolvedPath.replace(
      "{versionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: versionId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeRoleAliasCommand(
  input: DescribeRoleAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/role-aliases/{roleAlias}";
  if (input.roleAlias !== undefined) {
    const labelValue: string = input.roleAlias;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: roleAlias.");
    }
    resolvedPath = resolvedPath.replace(
      "{roleAlias}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: roleAlias.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DetachPolicyCommand(
  input: DetachPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/target-policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.target !== undefined) {
    bodyParams["target"] = input.target;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DetachPrincipalPolicyCommand(
  input: DetachPrincipalPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.principal !== undefined) {
    headers["x-amzn-iot-principal"] = input.principal;
  }
  let resolvedPath = "/principal-policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetEffectivePoliciesCommand(
  input: GetEffectivePoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/effective-policies";
  const query: any = {};
  if (input.thingName !== undefined) {
    query["thingName"] = input.thingName;
  }
  let body: any;
  const bodyParams: any = {};
  if (input.cognitoIdentityPoolId !== undefined) {
    bodyParams["cognitoIdentityPoolId"] = input.cognitoIdentityPoolId;
  }
  if (input.principal !== undefined) {
    bodyParams["principal"] = input.principal;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1GetPolicyCommand(
  input: GetPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetPolicyVersionCommand(
  input: GetPolicyVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/policies/{policyName}/version/{policyVersionId}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  if (input.policyVersionId !== undefined) {
    const labelValue: string = input.policyVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: policyVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{policyVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyVersionId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetRegistrationCodeCommand(
  input: GetRegistrationCodeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/registrationcode";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ListAttachedPoliciesCommand(
  input: ListAttachedPoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/attached-policies/{target}";
  if (input.target !== undefined) {
    const labelValue: string = input.target;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: target.");
    }
    resolvedPath = resolvedPath.replace(
      "{target}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: target.");
  }
  const query: any = {};
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  if (input.recursive !== undefined) {
    query["recursive"] = input.recursive.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListAuthorizersCommand(
  input: ListAuthorizersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/authorizers";
  const query: any = {};
  if (input.ascendingOrder !== undefined) {
    query["isAscendingOrder"] = input.ascendingOrder.toString();
  }
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  if (input.status !== undefined) {
    query["status"] = input.status;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListCACertificatesCommand(
  input: ListCACertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/cacertificates";
  const query: any = {};
  if (input.ascendingOrder !== undefined) {
    query["isAscendingOrder"] = input.ascendingOrder.toString();
  }
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListCertificatesCommand(
  input: ListCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/certificates";
  const query: any = {};
  if (input.ascendingOrder !== undefined) {
    query["isAscendingOrder"] = input.ascendingOrder.toString();
  }
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListCertificatesByCACommand(
  input: ListCertificatesByCACommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/certificates-by-ca/{caCertificateId}";
  if (input.caCertificateId !== undefined) {
    const labelValue: string = input.caCertificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: caCertificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{caCertificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: caCertificateId.");
  }
  const query: any = {};
  if (input.ascendingOrder !== undefined) {
    query["isAscendingOrder"] = input.ascendingOrder.toString();
  }
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListDomainConfigurationsCommand(
  input: ListDomainConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/domainConfigurations";
  const query: any = {};
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  if (input.serviceType !== undefined) {
    query["serviceType"] = input.serviceType;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListOutgoingCertificatesCommand(
  input: ListOutgoingCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/certificates-out-going";
  const query: any = {};
  if (input.ascendingOrder !== undefined) {
    query["isAscendingOrder"] = input.ascendingOrder.toString();
  }
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListPoliciesCommand(
  input: ListPoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/policies";
  const query: any = {};
  if (input.ascendingOrder !== undefined) {
    query["isAscendingOrder"] = input.ascendingOrder.toString();
  }
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListPolicyPrincipalsCommand(
  input: ListPolicyPrincipalsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.policyName !== undefined) {
    headers["x-amzn-iot-policy"] = input.policyName;
  }
  let resolvedPath = "/policy-principals";
  const query: any = {};
  if (input.ascendingOrder !== undefined) {
    query["isAscendingOrder"] = input.ascendingOrder.toString();
  }
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListPolicyVersionsCommand(
  input: ListPolicyVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/policies/{policyName}/version";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ListPrincipalPoliciesCommand(
  input: ListPrincipalPoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.principal !== undefined) {
    headers["x-amzn-iot-principal"] = input.principal;
  }
  let resolvedPath = "/principal-policies";
  const query: any = {};
  if (input.ascendingOrder !== undefined) {
    query["isAscendingOrder"] = input.ascendingOrder.toString();
  }
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListProvisioningTemplateVersionsCommand(
  input: ListProvisioningTemplateVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/provisioning-templates/{templateName}/versions";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: templateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{templateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListProvisioningTemplatesCommand(
  input: ListProvisioningTemplatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/provisioning-templates";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListRoleAliasesCommand(
  input: ListRoleAliasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/role-aliases";
  const query: any = {};
  if (input.ascendingOrder !== undefined) {
    query["isAscendingOrder"] = input.ascendingOrder.toString();
  }
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListTargetsForPolicyCommand(
  input: ListTargetsForPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/policy-targets/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  const query: any = {};
  if (input.marker !== undefined) {
    query["marker"] = input.marker;
  }
  if (input.pageSize !== undefined) {
    query["pageSize"] = input.pageSize.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1RegisterCACertificateCommand(
  input: RegisterCACertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/cacertificate";
  const query: any = {};
  if (input.allowAutoRegistration !== undefined) {
    query["allowAutoRegistration"] = input.allowAutoRegistration.toString();
  }
  if (input.setAsActive !== undefined) {
    query["setAsActive"] = input.setAsActive.toString();
  }
  let body: any;
  const bodyParams: any = {};
  if (input.caCertificate !== undefined) {
    bodyParams["caCertificate"] = input.caCertificate;
  }
  if (input.registrationConfig !== undefined) {
    bodyParams[
      "registrationConfig"
    ] = serializeAws_restJson1_1RegistrationConfig(
      input.registrationConfig,
      context
    );
  }
  if (input.verificationCertificate !== undefined) {
    bodyParams["verificationCertificate"] = input.verificationCertificate;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1RegisterCertificateCommand(
  input: RegisterCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/certificate/register";
  const query: any = {};
  if (input.setAsActive !== undefined) {
    query["setAsActive"] = input.setAsActive.toString();
  }
  let body: any;
  const bodyParams: any = {};
  if (input.caCertificatePem !== undefined) {
    bodyParams["caCertificatePem"] = input.caCertificatePem;
  }
  if (input.certificatePem !== undefined) {
    bodyParams["certificatePem"] = input.certificatePem;
  }
  if (input.status !== undefined) {
    bodyParams["status"] = input.status;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1RegisterThingCommand(
  input: RegisterThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/things";
  let body: any;
  const bodyParams: any = {};
  if (input.parameters !== undefined) {
    bodyParams["parameters"] = serializeAws_restJson1_1Parameters(
      input.parameters,
      context
    );
  }
  if (input.templateBody !== undefined) {
    bodyParams["templateBody"] = input.templateBody;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1RejectCertificateTransferCommand(
  input: RejectCertificateTransferCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/reject-certificate-transfer/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: certificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{certificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.rejectReason !== undefined) {
    bodyParams["rejectReason"] = input.rejectReason;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1SetDefaultAuthorizerCommand(
  input: SetDefaultAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/default-authorizer";
  let body: any;
  const bodyParams: any = {};
  if (input.authorizerName !== undefined) {
    bodyParams["authorizerName"] = input.authorizerName;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1SetDefaultPolicyVersionCommand(
  input: SetDefaultPolicyVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/policies/{policyName}/version/{policyVersionId}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace(
      "{policyName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  if (input.policyVersionId !== undefined) {
    const labelValue: string = input.policyVersionId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: policyVersionId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{policyVersionId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: policyVersionId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1TestAuthorizationCommand(
  input: TestAuthorizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/test-authorization";
  const query: any = {};
  if (input.clientId !== undefined) {
    query["clientId"] = input.clientId;
  }
  let body: any;
  const bodyParams: any = {};
  if (input.authInfos !== undefined) {
    bodyParams["authInfos"] = serializeAws_restJson1_1AuthInfos(
      input.authInfos,
      context
    );
  }
  if (input.cognitoIdentityPoolId !== undefined) {
    bodyParams["cognitoIdentityPoolId"] = input.cognitoIdentityPoolId;
  }
  if (input.policyNamesToAdd !== undefined) {
    bodyParams["policyNamesToAdd"] = serializeAws_restJson1_1PolicyNames(
      input.policyNamesToAdd,
      context
    );
  }
  if (input.policyNamesToSkip !== undefined) {
    bodyParams["policyNamesToSkip"] = serializeAws_restJson1_1PolicyNames(
      input.policyNamesToSkip,
      context
    );
  }
  if (input.principal !== undefined) {
    bodyParams["principal"] = input.principal;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1TestInvokeAuthorizerCommand(
  input: TestInvokeAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/authorizer/{authorizerName}/test";
  if (input.authorizerName !== undefined) {
    const labelValue: string = input.authorizerName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: authorizerName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{authorizerName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: authorizerName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.httpContext !== undefined) {
    bodyParams["httpContext"] = serializeAws_restJson1_1HttpContext(
      input.httpContext,
      context
    );
  }
  if (input.mqttContext !== undefined) {
    bodyParams["mqttContext"] = serializeAws_restJson1_1MqttContext(
      input.mqttContext,
      context
    );
  }
  if (input.tlsContext !== undefined) {
    bodyParams["tlsContext"] = serializeAws_restJson1_1TlsContext(
      input.tlsContext,
      context
    );
  }
  if (input.token !== undefined) {
    bodyParams["token"] = input.token;
  }
  if (input.tokenSignature !== undefined) {
    bodyParams["tokenSignature"] = input.tokenSignature;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1TransferCertificateCommand(
  input: TransferCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/transfer-certificate/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: certificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{certificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  const query: any = {};
  if (input.targetAwsAccount !== undefined) {
    query["targetAwsAccount"] = input.targetAwsAccount;
  }
  let body: any;
  const bodyParams: any = {};
  if (input.transferMessage !== undefined) {
    bodyParams["transferMessage"] = input.transferMessage;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateAuthorizerCommand(
  input: UpdateAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/authorizer/{authorizerName}";
  if (input.authorizerName !== undefined) {
    const labelValue: string = input.authorizerName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: authorizerName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{authorizerName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: authorizerName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.authorizerFunctionArn !== undefined) {
    bodyParams["authorizerFunctionArn"] = input.authorizerFunctionArn;
  }
  if (input.status !== undefined) {
    bodyParams["status"] = input.status;
  }
  if (input.tokenKeyName !== undefined) {
    bodyParams["tokenKeyName"] = input.tokenKeyName;
  }
  if (input.tokenSigningPublicKeys !== undefined) {
    bodyParams["tokenSigningPublicKeys"] = serializeAws_restJson1_1PublicKeyMap(
      input.tokenSigningPublicKeys,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateCACertificateCommand(
  input: UpdateCACertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/cacertificate/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: certificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{certificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  const query: any = {};
  if (input.newAutoRegistrationStatus !== undefined) {
    query["newAutoRegistrationStatus"] = input.newAutoRegistrationStatus;
  }
  if (input.newStatus !== undefined) {
    query["newStatus"] = input.newStatus;
  }
  let body: any;
  const bodyParams: any = {};
  if (input.registrationConfig !== undefined) {
    bodyParams[
      "registrationConfig"
    ] = serializeAws_restJson1_1RegistrationConfig(
      input.registrationConfig,
      context
    );
  }
  if (input.removeAutoRegistration !== undefined) {
    bodyParams["removeAutoRegistration"] = input.removeAutoRegistration;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateCertificateCommand(
  input: UpdateCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/certificates/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: certificateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{certificateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  const query: any = {};
  if (input.newStatus !== undefined) {
    query["newStatus"] = input.newStatus;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1UpdateDomainConfigurationCommand(
  input: UpdateDomainConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/domainConfigurations/{domainConfigurationName}";
  if (input.domainConfigurationName !== undefined) {
    const labelValue: string = input.domainConfigurationName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: domainConfigurationName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{domainConfigurationName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: domainConfigurationName."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.authorizerConfig !== undefined) {
    bodyParams["authorizerConfig"] = serializeAws_restJson1_1AuthorizerConfig(
      input.authorizerConfig,
      context
    );
  }
  if (input.domainConfigurationStatus !== undefined) {
    bodyParams["domainConfigurationStatus"] = input.domainConfigurationStatus;
  }
  if (input.removeAuthorizerConfig !== undefined) {
    bodyParams["removeAuthorizerConfig"] = input.removeAuthorizerConfig;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateProvisioningTemplateCommand(
  input: UpdateProvisioningTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/provisioning-templates/{templateName}";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: templateName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{templateName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.defaultVersionId !== undefined) {
    bodyParams["defaultVersionId"] = input.defaultVersionId;
  }
  if (input.description !== undefined) {
    bodyParams["description"] = input.description;
  }
  if (input.enabled !== undefined) {
    bodyParams["enabled"] = input.enabled;
  }
  if (input.provisioningRoleArn !== undefined) {
    bodyParams["provisioningRoleArn"] = input.provisioningRoleArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateRoleAliasCommand(
  input: UpdateRoleAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/role-aliases/{roleAlias}";
  if (input.roleAlias !== undefined) {
    const labelValue: string = input.roleAlias;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: roleAlias.");
    }
    resolvedPath = resolvedPath.replace(
      "{roleAlias}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: roleAlias.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.credentialDurationSeconds !== undefined) {
    bodyParams["credentialDurationSeconds"] = input.credentialDurationSeconds;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DescribeIndexCommand(
  input: DescribeIndexCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/indices/{indexName}";
  if (input.indexName !== undefined) {
    const labelValue: string = input.indexName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: indexName.");
    }
    resolvedPath = resolvedPath.replace(
      "{indexName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: indexName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetCardinalityCommand(
  input: GetCardinalityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/indices/cardinality";
  let body: any;
  const bodyParams: any = {};
  if (input.aggregationField !== undefined) {
    bodyParams["aggregationField"] = input.aggregationField;
  }
  if (input.indexName !== undefined) {
    bodyParams["indexName"] = input.indexName;
  }
  if (input.queryString !== undefined) {
    bodyParams["queryString"] = input.queryString;
  }
  if (input.queryVersion !== undefined) {
    bodyParams["queryVersion"] = input.queryVersion;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetIndexingConfigurationCommand(
  input: GetIndexingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/indexing/config";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1GetPercentilesCommand(
  input: GetPercentilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/indices/percentiles";
  let body: any;
  const bodyParams: any = {};
  if (input.aggregationField !== undefined) {
    bodyParams["aggregationField"] = input.aggregationField;
  }
  if (input.indexName !== undefined) {
    bodyParams["indexName"] = input.indexName;
  }
  if (input.percents !== undefined) {
    bodyParams["percents"] = serializeAws_restJson1_1PercentList(
      input.percents,
      context
    );
  }
  if (input.queryString !== undefined) {
    bodyParams["queryString"] = input.queryString;
  }
  if (input.queryVersion !== undefined) {
    bodyParams["queryVersion"] = input.queryVersion;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1GetStatisticsCommand(
  input: GetStatisticsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/indices/statistics";
  let body: any;
  const bodyParams: any = {};
  if (input.aggregationField !== undefined) {
    bodyParams["aggregationField"] = input.aggregationField;
  }
  if (input.indexName !== undefined) {
    bodyParams["indexName"] = input.indexName;
  }
  if (input.queryString !== undefined) {
    bodyParams["queryString"] = input.queryString;
  }
  if (input.queryVersion !== undefined) {
    bodyParams["queryVersion"] = input.queryVersion;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1ListIndicesCommand(
  input: ListIndicesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/indices";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1SearchIndexCommand(
  input: SearchIndexCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/indices/search";
  let body: any;
  const bodyParams: any = {};
  if (input.indexName !== undefined) {
    bodyParams["indexName"] = input.indexName;
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.queryString !== undefined) {
    bodyParams["queryString"] = input.queryString;
  }
  if (input.queryVersion !== undefined) {
    bodyParams["queryVersion"] = input.queryVersion;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateIndexingConfigurationCommand(
  input: UpdateIndexingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/indexing/config";
  let body: any;
  const bodyParams: any = {};
  if (input.thingGroupIndexingConfiguration !== undefined) {
    bodyParams[
      "thingGroupIndexingConfiguration"
    ] = serializeAws_restJson1_1ThingGroupIndexingConfiguration(
      input.thingGroupIndexingConfiguration,
      context
    );
  }
  if (input.thingIndexingConfiguration !== undefined) {
    bodyParams[
      "thingIndexingConfiguration"
    ] = serializeAws_restJson1_1ThingIndexingConfiguration(
      input.thingIndexingConfiguration,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1AssociateTargetsWithJobCommand(
  input: AssociateTargetsWithJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/jobs/{jobId}/targets";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.comment !== undefined) {
    bodyParams["comment"] = input.comment;
  }
  if (input.targets !== undefined) {
    bodyParams["targets"] = serializeAws_restJson1_1JobTargets(
      input.targets,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CancelJobCommand(
  input: CancelJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/jobs/{jobId}/cancel";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  const query: any = {};
  if (input.force !== undefined) {
    query["force"] = input.force.toString();
  }
  let body: any;
  const bodyParams: any = {};
  if (input.comment !== undefined) {
    bodyParams["comment"] = input.comment;
  }
  if (input.reasonCode !== undefined) {
    bodyParams["reasonCode"] = input.reasonCode;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1CancelJobExecutionCommand(
  input: CancelJobExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/things/{thingName}/jobs/{jobId}/cancel";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {};
  if (input.force !== undefined) {
    query["force"] = input.force.toString();
  }
  let body: any;
  const bodyParams: any = {};
  if (input.expectedVersion !== undefined) {
    bodyParams["expectedVersion"] = input.expectedVersion;
  }
  if (input.statusDetails !== undefined) {
    bodyParams["statusDetails"] = serializeAws_restJson1_1DetailsMap(
      input.statusDetails,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateJobCommand(
  input: CreateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/jobs/{jobId}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.abortConfig !== undefined) {
    bodyParams["abortConfig"] = serializeAws_restJson1_1AbortConfig(
      input.abortConfig,
      context
    );
  }
  if (input.description !== undefined) {
    bodyParams["description"] = input.description;
  }
  if (input.document !== undefined) {
    bodyParams["document"] = input.document;
  }
  if (input.documentSource !== undefined) {
    bodyParams["documentSource"] = input.documentSource;
  }
  if (input.jobExecutionsRolloutConfig !== undefined) {
    bodyParams[
      "jobExecutionsRolloutConfig"
    ] = serializeAws_restJson1_1JobExecutionsRolloutConfig(
      input.jobExecutionsRolloutConfig,
      context
    );
  }
  if (input.presignedUrlConfig !== undefined) {
    bodyParams[
      "presignedUrlConfig"
    ] = serializeAws_restJson1_1PresignedUrlConfig(
      input.presignedUrlConfig,
      context
    );
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  if (input.targetSelection !== undefined) {
    bodyParams["targetSelection"] = input.targetSelection;
  }
  if (input.targets !== undefined) {
    bodyParams["targets"] = serializeAws_restJson1_1JobTargets(
      input.targets,
      context
    );
  }
  if (input.timeoutConfig !== undefined) {
    bodyParams["timeoutConfig"] = serializeAws_restJson1_1TimeoutConfig(
      input.timeoutConfig,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteJobCommand(
  input: DeleteJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/jobs/{jobId}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  const query: any = {};
  if (input.force !== undefined) {
    query["force"] = input.force.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DeleteJobExecutionCommand(
  input: DeleteJobExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}";
  if (input.executionNumber !== undefined) {
    const labelValue: string = input.executionNumber.toString();
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: executionNumber."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{executionNumber}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: executionNumber.");
  }
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {};
  if (input.force !== undefined) {
    query["force"] = input.force.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DescribeJobCommand(
  input: DescribeJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/jobs/{jobId}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeJobExecutionCommand(
  input: DescribeJobExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/things/{thingName}/jobs/{jobId}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {};
  if (input.executionNumber !== undefined) {
    query["executionNumber"] = input.executionNumber.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1GetJobDocumentCommand(
  input: GetJobDocumentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/jobs/{jobId}/job-document";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ListJobExecutionsForJobCommand(
  input: ListJobExecutionsForJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/jobs/{jobId}/things";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.status !== undefined) {
    query["status"] = input.status;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListJobExecutionsForThingCommand(
  input: ListJobExecutionsForThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/things/{thingName}/jobs";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.status !== undefined) {
    query["status"] = input.status;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListJobsCommand(
  input: ListJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/jobs";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.status !== undefined) {
    query["status"] = input.status;
  }
  if (input.targetSelection !== undefined) {
    query["targetSelection"] = input.targetSelection;
  }
  if (input.thingGroupId !== undefined) {
    query["thingGroupId"] = input.thingGroupId;
  }
  if (input.thingGroupName !== undefined) {
    query["thingGroupName"] = input.thingGroupName;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1UpdateJobCommand(
  input: UpdateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/jobs/{jobId}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace(
      "{jobId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.abortConfig !== undefined) {
    bodyParams["abortConfig"] = serializeAws_restJson1_1AbortConfig(
      input.abortConfig,
      context
    );
  }
  if (input.description !== undefined) {
    bodyParams["description"] = input.description;
  }
  if (input.jobExecutionsRolloutConfig !== undefined) {
    bodyParams[
      "jobExecutionsRolloutConfig"
    ] = serializeAws_restJson1_1JobExecutionsRolloutConfig(
      input.jobExecutionsRolloutConfig,
      context
    );
  }
  if (input.presignedUrlConfig !== undefined) {
    bodyParams[
      "presignedUrlConfig"
    ] = serializeAws_restJson1_1PresignedUrlConfig(
      input.presignedUrlConfig,
      context
    );
  }
  if (input.timeoutConfig !== undefined) {
    bodyParams["timeoutConfig"] = serializeAws_restJson1_1TimeoutConfig(
      input.timeoutConfig,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateOTAUpdateCommand(
  input: CreateOTAUpdateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/otaUpdates/{otaUpdateId}";
  if (input.otaUpdateId !== undefined) {
    const labelValue: string = input.otaUpdateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: otaUpdateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{otaUpdateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: otaUpdateId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.additionalParameters !== undefined) {
    bodyParams[
      "additionalParameters"
    ] = serializeAws_restJson1_1AdditionalParameterMap(
      input.additionalParameters,
      context
    );
  }
  if (input.awsJobExecutionsRolloutConfig !== undefined) {
    bodyParams[
      "awsJobExecutionsRolloutConfig"
    ] = serializeAws_restJson1_1AwsJobExecutionsRolloutConfig(
      input.awsJobExecutionsRolloutConfig,
      context
    );
  }
  if (input.awsJobPresignedUrlConfig !== undefined) {
    bodyParams[
      "awsJobPresignedUrlConfig"
    ] = serializeAws_restJson1_1AwsJobPresignedUrlConfig(
      input.awsJobPresignedUrlConfig,
      context
    );
  }
  if (input.description !== undefined) {
    bodyParams["description"] = input.description;
  }
  if (input.files !== undefined) {
    bodyParams["files"] = serializeAws_restJson1_1OTAUpdateFiles(
      input.files,
      context
    );
  }
  if (input.protocols !== undefined) {
    bodyParams["protocols"] = serializeAws_restJson1_1Protocols(
      input.protocols,
      context
    );
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  if (input.targetSelection !== undefined) {
    bodyParams["targetSelection"] = input.targetSelection;
  }
  if (input.targets !== undefined) {
    bodyParams["targets"] = serializeAws_restJson1_1Targets(
      input.targets,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteOTAUpdateCommand(
  input: DeleteOTAUpdateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/otaUpdates/{otaUpdateId}";
  if (input.otaUpdateId !== undefined) {
    const labelValue: string = input.otaUpdateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: otaUpdateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{otaUpdateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: otaUpdateId.");
  }
  const query: any = {};
  if (input.deleteStream !== undefined) {
    query["deleteStream"] = input.deleteStream.toString();
  }
  if (input.forceDeleteAWSJob !== undefined) {
    query["forceDeleteAWSJob"] = input.forceDeleteAWSJob.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1GetOTAUpdateCommand(
  input: GetOTAUpdateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/otaUpdates/{otaUpdateId}";
  if (input.otaUpdateId !== undefined) {
    const labelValue: string = input.otaUpdateId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: otaUpdateId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{otaUpdateId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: otaUpdateId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ListOTAUpdatesCommand(
  input: ListOTAUpdatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/otaUpdates";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.otaUpdateStatus !== undefined) {
    query["otaUpdateStatus"] = input.otaUpdateStatus;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1AddThingToBillingGroupCommand(
  input: AddThingToBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/billing-groups/addThingToBillingGroup";
  let body: any;
  const bodyParams: any = {};
  if (input.billingGroupArn !== undefined) {
    bodyParams["billingGroupArn"] = input.billingGroupArn;
  }
  if (input.billingGroupName !== undefined) {
    bodyParams["billingGroupName"] = input.billingGroupName;
  }
  if (input.thingArn !== undefined) {
    bodyParams["thingArn"] = input.thingArn;
  }
  if (input.thingName !== undefined) {
    bodyParams["thingName"] = input.thingName;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1AddThingToThingGroupCommand(
  input: AddThingToThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/thing-groups/addThingToThingGroup";
  let body: any;
  const bodyParams: any = {};
  if (input.overrideDynamicGroups !== undefined) {
    bodyParams["overrideDynamicGroups"] = input.overrideDynamicGroups;
  }
  if (input.thingArn !== undefined) {
    bodyParams["thingArn"] = input.thingArn;
  }
  if (input.thingGroupArn !== undefined) {
    bodyParams["thingGroupArn"] = input.thingGroupArn;
  }
  if (input.thingGroupName !== undefined) {
    bodyParams["thingGroupName"] = input.thingGroupName;
  }
  if (input.thingName !== undefined) {
    bodyParams["thingName"] = input.thingName;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1AttachThingPrincipalCommand(
  input: AttachThingPrincipalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.principal !== undefined) {
    headers["x-amzn-principal"] = input.principal;
  }
  let resolvedPath = "/things/{thingName}/principals";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1CreateBillingGroupCommand(
  input: CreateBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/billing-groups/{billingGroupName}";
  if (input.billingGroupName !== undefined) {
    const labelValue: string = input.billingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: billingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{billingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: billingGroupName."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.billingGroupProperties !== undefined) {
    bodyParams[
      "billingGroupProperties"
    ] = serializeAws_restJson1_1BillingGroupProperties(
      input.billingGroupProperties,
      context
    );
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateDynamicThingGroupCommand(
  input: CreateDynamicThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/dynamic-thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.indexName !== undefined) {
    bodyParams["indexName"] = input.indexName;
  }
  if (input.queryString !== undefined) {
    bodyParams["queryString"] = input.queryString;
  }
  if (input.queryVersion !== undefined) {
    bodyParams["queryVersion"] = input.queryVersion;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  if (input.thingGroupProperties !== undefined) {
    bodyParams[
      "thingGroupProperties"
    ] = serializeAws_restJson1_1ThingGroupProperties(
      input.thingGroupProperties,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateThingCommand(
  input: CreateThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/things/{thingName}";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.attributePayload !== undefined) {
    bodyParams["attributePayload"] = serializeAws_restJson1_1AttributePayload(
      input.attributePayload,
      context
    );
  }
  if (input.billingGroupName !== undefined) {
    bodyParams["billingGroupName"] = input.billingGroupName;
  }
  if (input.thingTypeName !== undefined) {
    bodyParams["thingTypeName"] = input.thingTypeName;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateThingGroupCommand(
  input: CreateThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.parentGroupName !== undefined) {
    bodyParams["parentGroupName"] = input.parentGroupName;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  if (input.thingGroupProperties !== undefined) {
    bodyParams[
      "thingGroupProperties"
    ] = serializeAws_restJson1_1ThingGroupProperties(
      input.thingGroupProperties,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateThingTypeCommand(
  input: CreateThingTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/thing-types/{thingTypeName}";
  if (input.thingTypeName !== undefined) {
    const labelValue: string = input.thingTypeName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingTypeName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingTypeName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingTypeName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  if (input.thingTypeProperties !== undefined) {
    bodyParams[
      "thingTypeProperties"
    ] = serializeAws_restJson1_1ThingTypeProperties(
      input.thingTypeProperties,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteBillingGroupCommand(
  input: DeleteBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/billing-groups/{billingGroupName}";
  if (input.billingGroupName !== undefined) {
    const labelValue: string = input.billingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: billingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{billingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: billingGroupName."
    );
  }
  const query: any = {};
  if (input.expectedVersion !== undefined) {
    query["expectedVersion"] = input.expectedVersion.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DeleteDynamicThingGroupCommand(
  input: DeleteDynamicThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/dynamic-thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  const query: any = {};
  if (input.expectedVersion !== undefined) {
    query["expectedVersion"] = input.expectedVersion.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DeleteThingCommand(
  input: DeleteThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/things/{thingName}";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {};
  if (input.expectedVersion !== undefined) {
    query["expectedVersion"] = input.expectedVersion.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DeleteThingGroupCommand(
  input: DeleteThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  const query: any = {};
  if (input.expectedVersion !== undefined) {
    query["expectedVersion"] = input.expectedVersion.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DeleteThingTypeCommand(
  input: DeleteThingTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-types/{thingTypeName}";
  if (input.thingTypeName !== undefined) {
    const labelValue: string = input.thingTypeName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingTypeName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingTypeName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingTypeName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeprecateThingTypeCommand(
  input: DeprecateThingTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/thing-types/{thingTypeName}/deprecate";
  if (input.thingTypeName !== undefined) {
    const labelValue: string = input.thingTypeName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingTypeName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingTypeName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingTypeName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.undoDeprecate !== undefined) {
    bodyParams["undoDeprecate"] = input.undoDeprecate;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DescribeBillingGroupCommand(
  input: DescribeBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/billing-groups/{billingGroupName}";
  if (input.billingGroupName !== undefined) {
    const labelValue: string = input.billingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: billingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{billingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: billingGroupName."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeEventConfigurationsCommand(
  input: DescribeEventConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/event-configurations";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeThingCommand(
  input: DescribeThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/things/{thingName}";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeThingGroupCommand(
  input: DescribeThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeThingRegistrationTaskCommand(
  input: DescribeThingRegistrationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-registration-tasks/{taskId}";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace(
      "{taskId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeThingTypeCommand(
  input: DescribeThingTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-types/{thingTypeName}";
  if (input.thingTypeName !== undefined) {
    const labelValue: string = input.thingTypeName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingTypeName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingTypeName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingTypeName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DetachThingPrincipalCommand(
  input: DetachThingPrincipalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.principal !== undefined) {
    headers["x-amzn-principal"] = input.principal;
  }
  let resolvedPath = "/things/{thingName}/principals";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ListBillingGroupsCommand(
  input: ListBillingGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/billing-groups";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.namePrefixFilter !== undefined) {
    query["namePrefixFilter"] = input.namePrefixFilter;
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListPrincipalThingsCommand(
  input: ListPrincipalThingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  if (input.principal !== undefined) {
    headers["x-amzn-principal"] = input.principal;
  }
  let resolvedPath = "/principals/things";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/tags";
  const query: any = {};
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.resourceArn !== undefined) {
    query["resourceArn"] = input.resourceArn;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListThingGroupsCommand(
  input: ListThingGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-groups";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.namePrefixFilter !== undefined) {
    query["namePrefixFilter"] = input.namePrefixFilter;
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.parentGroup !== undefined) {
    query["parentGroup"] = input.parentGroup;
  }
  if (input.recursive !== undefined) {
    query["recursive"] = input.recursive.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListThingGroupsForThingCommand(
  input: ListThingGroupsForThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/things/{thingName}/thing-groups";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListThingPrincipalsCommand(
  input: ListThingPrincipalsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/things/{thingName}/principals";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ListThingRegistrationTaskReportsCommand(
  input: ListThingRegistrationTaskReportsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-registration-tasks/{taskId}/reports";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace(
      "{taskId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.reportType !== undefined) {
    query["reportType"] = input.reportType;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListThingRegistrationTasksCommand(
  input: ListThingRegistrationTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-registration-tasks";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.status !== undefined) {
    query["status"] = input.status;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListThingTypesCommand(
  input: ListThingTypesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-types";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.thingTypeName !== undefined) {
    query["thingTypeName"] = input.thingTypeName;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListThingsCommand(
  input: ListThingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/things";
  const query: any = {};
  if (input.attributeName !== undefined) {
    query["attributeName"] = input.attributeName;
  }
  if (input.attributeValue !== undefined) {
    query["attributeValue"] = input.attributeValue;
  }
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.thingTypeName !== undefined) {
    query["thingTypeName"] = input.thingTypeName;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListThingsInBillingGroupCommand(
  input: ListThingsInBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/billing-groups/{billingGroupName}/things";
  if (input.billingGroupName !== undefined) {
    const labelValue: string = input.billingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: billingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{billingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: billingGroupName."
    );
  }
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListThingsInThingGroupCommand(
  input: ListThingsInThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-groups/{thingGroupName}/things";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.recursive !== undefined) {
    query["recursive"] = input.recursive.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1RemoveThingFromBillingGroupCommand(
  input: RemoveThingFromBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/billing-groups/removeThingFromBillingGroup";
  let body: any;
  const bodyParams: any = {};
  if (input.billingGroupArn !== undefined) {
    bodyParams["billingGroupArn"] = input.billingGroupArn;
  }
  if (input.billingGroupName !== undefined) {
    bodyParams["billingGroupName"] = input.billingGroupName;
  }
  if (input.thingArn !== undefined) {
    bodyParams["thingArn"] = input.thingArn;
  }
  if (input.thingName !== undefined) {
    bodyParams["thingName"] = input.thingName;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1RemoveThingFromThingGroupCommand(
  input: RemoveThingFromThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/thing-groups/removeThingFromThingGroup";
  let body: any;
  const bodyParams: any = {};
  if (input.thingArn !== undefined) {
    bodyParams["thingArn"] = input.thingArn;
  }
  if (input.thingGroupArn !== undefined) {
    bodyParams["thingGroupArn"] = input.thingGroupArn;
  }
  if (input.thingGroupName !== undefined) {
    bodyParams["thingGroupName"] = input.thingGroupName;
  }
  if (input.thingName !== undefined) {
    bodyParams["thingName"] = input.thingName;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1StartThingRegistrationTaskCommand(
  input: StartThingRegistrationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/thing-registration-tasks";
  let body: any;
  const bodyParams: any = {};
  if (input.inputFileBucket !== undefined) {
    bodyParams["inputFileBucket"] = input.inputFileBucket;
  }
  if (input.inputFileKey !== undefined) {
    bodyParams["inputFileKey"] = input.inputFileKey;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.templateBody !== undefined) {
    bodyParams["templateBody"] = input.templateBody;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1StopThingRegistrationTaskCommand(
  input: StopThingRegistrationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/thing-registration-tasks/{taskId}/cancel";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace(
      "{taskId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1TagResourceCommand(
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/tags";
  let body: any;
  const bodyParams: any = {};
  if (input.resourceArn !== undefined) {
    bodyParams["resourceArn"] = input.resourceArn;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UntagResourceCommand(
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/untag";
  let body: any;
  const bodyParams: any = {};
  if (input.resourceArn !== undefined) {
    bodyParams["resourceArn"] = input.resourceArn;
  }
  if (input.tagKeys !== undefined) {
    bodyParams["tagKeys"] = serializeAws_restJson1_1TagKeyList(
      input.tagKeys,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateBillingGroupCommand(
  input: UpdateBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/billing-groups/{billingGroupName}";
  if (input.billingGroupName !== undefined) {
    const labelValue: string = input.billingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: billingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{billingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: billingGroupName."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.billingGroupProperties !== undefined) {
    bodyParams[
      "billingGroupProperties"
    ] = serializeAws_restJson1_1BillingGroupProperties(
      input.billingGroupProperties,
      context
    );
  }
  if (input.expectedVersion !== undefined) {
    bodyParams["expectedVersion"] = input.expectedVersion;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateDynamicThingGroupCommand(
  input: UpdateDynamicThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/dynamic-thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.expectedVersion !== undefined) {
    bodyParams["expectedVersion"] = input.expectedVersion;
  }
  if (input.indexName !== undefined) {
    bodyParams["indexName"] = input.indexName;
  }
  if (input.queryString !== undefined) {
    bodyParams["queryString"] = input.queryString;
  }
  if (input.queryVersion !== undefined) {
    bodyParams["queryVersion"] = input.queryVersion;
  }
  if (input.thingGroupProperties !== undefined) {
    bodyParams[
      "thingGroupProperties"
    ] = serializeAws_restJson1_1ThingGroupProperties(
      input.thingGroupProperties,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateEventConfigurationsCommand(
  input: UpdateEventConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/event-configurations";
  let body: any;
  const bodyParams: any = {};
  if (input.eventConfigurations !== undefined) {
    bodyParams[
      "eventConfigurations"
    ] = serializeAws_restJson1_1EventConfigurations(
      input.eventConfigurations,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateThingCommand(
  input: UpdateThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/things/{thingName}";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace(
      "{thingName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.attributePayload !== undefined) {
    bodyParams["attributePayload"] = serializeAws_restJson1_1AttributePayload(
      input.attributePayload,
      context
    );
  }
  if (input.expectedVersion !== undefined) {
    bodyParams["expectedVersion"] = input.expectedVersion;
  }
  if (input.removeThingType !== undefined) {
    bodyParams["removeThingType"] = input.removeThingType;
  }
  if (input.thingTypeName !== undefined) {
    bodyParams["thingTypeName"] = input.thingTypeName;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateThingGroupCommand(
  input: UpdateThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: thingGroupName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{thingGroupName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.expectedVersion !== undefined) {
    bodyParams["expectedVersion"] = input.expectedVersion;
  }
  if (input.thingGroupProperties !== undefined) {
    bodyParams[
      "thingGroupProperties"
    ] = serializeAws_restJson1_1ThingGroupProperties(
      input.thingGroupProperties,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateThingGroupsForThingCommand(
  input: UpdateThingGroupsForThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/thing-groups/updateThingGroupsForThing";
  let body: any;
  const bodyParams: any = {};
  if (input.overrideDynamicGroups !== undefined) {
    bodyParams["overrideDynamicGroups"] = input.overrideDynamicGroups;
  }
  if (input.thingGroupsToAdd !== undefined) {
    bodyParams["thingGroupsToAdd"] = serializeAws_restJson1_1ThingGroupList(
      input.thingGroupsToAdd,
      context
    );
  }
  if (input.thingGroupsToRemove !== undefined) {
    bodyParams["thingGroupsToRemove"] = serializeAws_restJson1_1ThingGroupList(
      input.thingGroupsToRemove,
      context
    );
  }
  if (input.thingName !== undefined) {
    bodyParams["thingName"] = input.thingName;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1AttachSecurityProfileCommand(
  input: AttachSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/security-profiles/{securityProfileName}/targets";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: securityProfileName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{securityProfileName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: securityProfileName."
    );
  }
  const query: any = {};
  if (input.securityProfileTargetArn !== undefined) {
    query["securityProfileTargetArn"] = input.securityProfileTargetArn;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1CancelAuditMitigationActionsTaskCommand(
  input: CancelAuditMitigationActionsTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/mitigationactions/tasks/{taskId}/cancel";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace(
      "{taskId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1CancelAuditTaskCommand(
  input: CancelAuditTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/tasks/{taskId}/cancel";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace(
      "{taskId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1CreateMitigationActionCommand(
  input: CreateMitigationActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/mitigationactions/actions/{actionName}";
  if (input.actionName !== undefined) {
    const labelValue: string = input.actionName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: actionName.");
    }
    resolvedPath = resolvedPath.replace(
      "{actionName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: actionName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.actionParams !== undefined) {
    bodyParams["actionParams"] = serializeAws_restJson1_1MitigationActionParams(
      input.actionParams,
      context
    );
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateScheduledAuditCommand(
  input: CreateScheduledAuditCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/audit/scheduledaudits/{scheduledAuditName}";
  if (input.scheduledAuditName !== undefined) {
    const labelValue: string = input.scheduledAuditName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: scheduledAuditName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{scheduledAuditName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: scheduledAuditName."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.dayOfMonth !== undefined) {
    bodyParams["dayOfMonth"] = input.dayOfMonth;
  }
  if (input.dayOfWeek !== undefined) {
    bodyParams["dayOfWeek"] = input.dayOfWeek;
  }
  if (input.frequency !== undefined) {
    bodyParams["frequency"] = input.frequency;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  if (input.targetCheckNames !== undefined) {
    bodyParams[
      "targetCheckNames"
    ] = serializeAws_restJson1_1TargetAuditCheckNames(
      input.targetCheckNames,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateSecurityProfileCommand(
  input: CreateSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/security-profiles/{securityProfileName}";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: securityProfileName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{securityProfileName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: securityProfileName."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.additionalMetricsToRetain !== undefined) {
    bodyParams[
      "additionalMetricsToRetain"
    ] = serializeAws_restJson1_1AdditionalMetricsToRetainList(
      input.additionalMetricsToRetain,
      context
    );
  }
  if (input.alertTargets !== undefined) {
    bodyParams["alertTargets"] = serializeAws_restJson1_1AlertTargets(
      input.alertTargets,
      context
    );
  }
  if (input.behaviors !== undefined) {
    bodyParams["behaviors"] = serializeAws_restJson1_1Behaviors(
      input.behaviors,
      context
    );
  }
  if (input.securityProfileDescription !== undefined) {
    bodyParams["securityProfileDescription"] = input.securityProfileDescription;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteAccountAuditConfigurationCommand(
  input: DeleteAccountAuditConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/configuration";
  const query: any = {};
  if (input.deleteScheduledAudits !== undefined) {
    query["deleteScheduledAudits"] = input.deleteScheduledAudits.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DeleteMitigationActionCommand(
  input: DeleteMitigationActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/mitigationactions/actions/{actionName}";
  if (input.actionName !== undefined) {
    const labelValue: string = input.actionName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: actionName.");
    }
    resolvedPath = resolvedPath.replace(
      "{actionName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: actionName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteScheduledAuditCommand(
  input: DeleteScheduledAuditCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/scheduledaudits/{scheduledAuditName}";
  if (input.scheduledAuditName !== undefined) {
    const labelValue: string = input.scheduledAuditName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: scheduledAuditName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{scheduledAuditName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: scheduledAuditName."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DeleteSecurityProfileCommand(
  input: DeleteSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/security-profiles/{securityProfileName}";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: securityProfileName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{securityProfileName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: securityProfileName."
    );
  }
  const query: any = {};
  if (input.expectedVersion !== undefined) {
    query["expectedVersion"] = input.expectedVersion.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1DescribeAccountAuditConfigurationCommand(
  input: DescribeAccountAuditConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/configuration";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeAuditFindingCommand(
  input: DescribeAuditFindingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/findings/{findingId}";
  if (input.findingId !== undefined) {
    const labelValue: string = input.findingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: findingId.");
    }
    resolvedPath = resolvedPath.replace(
      "{findingId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: findingId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeAuditMitigationActionsTaskCommand(
  input: DescribeAuditMitigationActionsTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/mitigationactions/tasks/{taskId}";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace(
      "{taskId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeAuditTaskCommand(
  input: DescribeAuditTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/tasks/{taskId}";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace(
      "{taskId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeMitigationActionCommand(
  input: DescribeMitigationActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/mitigationactions/actions/{actionName}";
  if (input.actionName !== undefined) {
    const labelValue: string = input.actionName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: actionName.");
    }
    resolvedPath = resolvedPath.replace(
      "{actionName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: actionName.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeScheduledAuditCommand(
  input: DescribeScheduledAuditCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/scheduledaudits/{scheduledAuditName}";
  if (input.scheduledAuditName !== undefined) {
    const labelValue: string = input.scheduledAuditName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: scheduledAuditName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{scheduledAuditName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: scheduledAuditName."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeSecurityProfileCommand(
  input: DescribeSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/security-profiles/{securityProfileName}";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: securityProfileName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{securityProfileName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: securityProfileName."
    );
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DetachSecurityProfileCommand(
  input: DetachSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/security-profiles/{securityProfileName}/targets";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: securityProfileName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{securityProfileName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: securityProfileName."
    );
  }
  const query: any = {};
  if (input.securityProfileTargetArn !== undefined) {
    query["securityProfileTargetArn"] = input.securityProfileTargetArn;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListActiveViolationsCommand(
  input: ListActiveViolationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/active-violations";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.securityProfileName !== undefined) {
    query["securityProfileName"] = input.securityProfileName;
  }
  if (input.thingName !== undefined) {
    query["thingName"] = input.thingName;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListAuditFindingsCommand(
  input: ListAuditFindingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/audit/findings";
  let body: any;
  const bodyParams: any = {};
  if (input.checkName !== undefined) {
    bodyParams["checkName"] = input.checkName;
  }
  if (input.endTime !== undefined) {
    bodyParams["endTime"] = Math.round(input.endTime.getTime() / 1000);
  }
  if (input.maxResults !== undefined) {
    bodyParams["maxResults"] = input.maxResults;
  }
  if (input.nextToken !== undefined) {
    bodyParams["nextToken"] = input.nextToken;
  }
  if (input.resourceIdentifier !== undefined) {
    bodyParams[
      "resourceIdentifier"
    ] = serializeAws_restJson1_1ResourceIdentifier(
      input.resourceIdentifier,
      context
    );
  }
  if (input.startTime !== undefined) {
    bodyParams["startTime"] = Math.round(input.startTime.getTime() / 1000);
  }
  if (input.taskId !== undefined) {
    bodyParams["taskId"] = input.taskId;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1ListAuditMitigationActionsExecutionsCommand(
  input: ListAuditMitigationActionsExecutionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/mitigationactions/executions";
  const query: any = {};
  if (input.actionStatus !== undefined) {
    query["actionStatus"] = input.actionStatus;
  }
  if (input.findingId !== undefined) {
    query["findingId"] = input.findingId;
  }
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.taskId !== undefined) {
    query["taskId"] = input.taskId;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListAuditMitigationActionsTasksCommand(
  input: ListAuditMitigationActionsTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/mitigationactions/tasks";
  const query: any = {};
  if (input.auditTaskId !== undefined) {
    query["auditTaskId"] = input.auditTaskId;
  }
  if (input.endTime !== undefined) {
    query["endTime"] = input.endTime.toISOString().toString();
  }
  if (input.findingId !== undefined) {
    query["findingId"] = input.findingId;
  }
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.startTime !== undefined) {
    query["startTime"] = input.startTime.toISOString().toString();
  }
  if (input.taskStatus !== undefined) {
    query["taskStatus"] = input.taskStatus;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListAuditTasksCommand(
  input: ListAuditTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/tasks";
  const query: any = {};
  if (input.endTime !== undefined) {
    query["endTime"] = input.endTime.toISOString().toString();
  }
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.startTime !== undefined) {
    query["startTime"] = input.startTime.toISOString().toString();
  }
  if (input.taskStatus !== undefined) {
    query["taskStatus"] = input.taskStatus;
  }
  if (input.taskType !== undefined) {
    query["taskType"] = input.taskType;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListMitigationActionsCommand(
  input: ListMitigationActionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/mitigationactions/actions";
  const query: any = {};
  if (input.actionType !== undefined) {
    query["actionType"] = input.actionType;
  }
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListScheduledAuditsCommand(
  input: ListScheduledAuditsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/audit/scheduledaudits";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListSecurityProfilesCommand(
  input: ListSecurityProfilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/security-profiles";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListSecurityProfilesForTargetCommand(
  input: ListSecurityProfilesForTargetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/security-profiles-for-target";
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.recursive !== undefined) {
    query["recursive"] = input.recursive.toString();
  }
  if (input.securityProfileTargetArn !== undefined) {
    query["securityProfileTargetArn"] = input.securityProfileTargetArn;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListTargetsForSecurityProfileCommand(
  input: ListTargetsForSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/security-profiles/{securityProfileName}/targets";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: securityProfileName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{securityProfileName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: securityProfileName."
    );
  }
  const query: any = {};
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1ListViolationEventsCommand(
  input: ListViolationEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/violation-events";
  const query: any = {};
  if (input.endTime !== undefined) {
    query["endTime"] = input.endTime.toISOString().toString();
  }
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  if (input.securityProfileName !== undefined) {
    query["securityProfileName"] = input.securityProfileName;
  }
  if (input.startTime !== undefined) {
    query["startTime"] = input.startTime.toISOString().toString();
  }
  if (input.thingName !== undefined) {
    query["thingName"] = input.thingName;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1StartAuditMitigationActionsTaskCommand(
  input: StartAuditMitigationActionsTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/audit/mitigationactions/tasks/{taskId}";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace(
      "{taskId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.auditCheckToActionsMapping !== undefined) {
    bodyParams[
      "auditCheckToActionsMapping"
    ] = serializeAws_restJson1_1AuditCheckToActionsMapping(
      input.auditCheckToActionsMapping,
      context
    );
  }
  if (input.clientRequestToken === undefined) {
    input.clientRequestToken = generateIdempotencyToken();
  }
  if (input.clientRequestToken !== undefined) {
    bodyParams["clientRequestToken"] = input.clientRequestToken;
  }
  if (input.target !== undefined) {
    bodyParams[
      "target"
    ] = serializeAws_restJson1_1AuditMitigationActionsTaskTarget(
      input.target,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1StartOnDemandAuditTaskCommand(
  input: StartOnDemandAuditTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/audit/tasks";
  let body: any;
  const bodyParams: any = {};
  if (input.targetCheckNames !== undefined) {
    bodyParams[
      "targetCheckNames"
    ] = serializeAws_restJson1_1TargetAuditCheckNames(
      input.targetCheckNames,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateAccountAuditConfigurationCommand(
  input: UpdateAccountAuditConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/audit/configuration";
  let body: any;
  const bodyParams: any = {};
  if (input.auditCheckConfigurations !== undefined) {
    bodyParams[
      "auditCheckConfigurations"
    ] = serializeAws_restJson1_1AuditCheckConfigurations(
      input.auditCheckConfigurations,
      context
    );
  }
  if (input.auditNotificationTargetConfigurations !== undefined) {
    bodyParams[
      "auditNotificationTargetConfigurations"
    ] = serializeAws_restJson1_1AuditNotificationTargetConfigurations(
      input.auditNotificationTargetConfigurations,
      context
    );
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateMitigationActionCommand(
  input: UpdateMitigationActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/mitigationactions/actions/{actionName}";
  if (input.actionName !== undefined) {
    const labelValue: string = input.actionName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: actionName.");
    }
    resolvedPath = resolvedPath.replace(
      "{actionName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: actionName.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.actionParams !== undefined) {
    bodyParams["actionParams"] = serializeAws_restJson1_1MitigationActionParams(
      input.actionParams,
      context
    );
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateScheduledAuditCommand(
  input: UpdateScheduledAuditCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/audit/scheduledaudits/{scheduledAuditName}";
  if (input.scheduledAuditName !== undefined) {
    const labelValue: string = input.scheduledAuditName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: scheduledAuditName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{scheduledAuditName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: scheduledAuditName."
    );
  }
  let body: any;
  const bodyParams: any = {};
  if (input.dayOfMonth !== undefined) {
    bodyParams["dayOfMonth"] = input.dayOfMonth;
  }
  if (input.dayOfWeek !== undefined) {
    bodyParams["dayOfWeek"] = input.dayOfWeek;
  }
  if (input.frequency !== undefined) {
    bodyParams["frequency"] = input.frequency;
  }
  if (input.targetCheckNames !== undefined) {
    bodyParams[
      "targetCheckNames"
    ] = serializeAws_restJson1_1TargetAuditCheckNames(
      input.targetCheckNames,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1UpdateSecurityProfileCommand(
  input: UpdateSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/security-profiles/{securityProfileName}";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: securityProfileName."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{securityProfileName}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error(
      "No value provided for input HTTP label: securityProfileName."
    );
  }
  const query: any = {};
  if (input.expectedVersion !== undefined) {
    query["expectedVersion"] = input.expectedVersion.toString();
  }
  let body: any;
  const bodyParams: any = {};
  if (input.additionalMetricsToRetain !== undefined) {
    bodyParams[
      "additionalMetricsToRetain"
    ] = serializeAws_restJson1_1AdditionalMetricsToRetainList(
      input.additionalMetricsToRetain,
      context
    );
  }
  if (input.alertTargets !== undefined) {
    bodyParams["alertTargets"] = serializeAws_restJson1_1AlertTargets(
      input.alertTargets,
      context
    );
  }
  if (input.behaviors !== undefined) {
    bodyParams["behaviors"] = serializeAws_restJson1_1Behaviors(
      input.behaviors,
      context
    );
  }
  if (input.deleteAdditionalMetricsToRetain !== undefined) {
    bodyParams["deleteAdditionalMetricsToRetain"] =
      input.deleteAdditionalMetricsToRetain;
  }
  if (input.deleteAlertTargets !== undefined) {
    bodyParams["deleteAlertTargets"] = input.deleteAlertTargets;
  }
  if (input.deleteBehaviors !== undefined) {
    bodyParams["deleteBehaviors"] = input.deleteBehaviors;
  }
  if (input.securityProfileDescription !== undefined) {
    bodyParams["securityProfileDescription"] = input.securityProfileDescription;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PATCH",
    headers: headers,
    path: resolvedPath,
    query: query,
    body: body
  });
}

export async function serializeAws_restJson1_1ValidateSecurityProfileBehaviorsCommand(
  input: ValidateSecurityProfileBehaviorsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/security-profile-behaviors/validate";
  let body: any;
  const bodyParams: any = {};
  if (input.behaviors !== undefined) {
    bodyParams["behaviors"] = serializeAws_restJson1_1Behaviors(
      input.behaviors,
      context
    );
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1CreateStreamCommand(
  input: CreateStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/streams/{streamId}";
  if (input.streamId !== undefined) {
    const labelValue: string = input.streamId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: streamId.");
    }
    resolvedPath = resolvedPath.replace(
      "{streamId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: streamId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.description !== undefined) {
    bodyParams["description"] = input.description;
  }
  if (input.files !== undefined) {
    bodyParams["files"] = serializeAws_restJson1_1StreamFiles(
      input.files,
      context
    );
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.tags !== undefined) {
    bodyParams["tags"] = serializeAws_restJson1_1TagList(input.tags, context);
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restJson1_1DeleteStreamCommand(
  input: DeleteStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/streams/{streamId}";
  if (input.streamId !== undefined) {
    const labelValue: string = input.streamId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: streamId.");
    }
    resolvedPath = resolvedPath.replace(
      "{streamId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: streamId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1DescribeStreamCommand(
  input: DescribeStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/streams/{streamId}";
  if (input.streamId !== undefined) {
    const labelValue: string = input.streamId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: streamId.");
    }
    resolvedPath = resolvedPath.replace(
      "{streamId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: streamId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restJson1_1ListStreamsCommand(
  input: ListStreamsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/streams";
  const query: any = {};
  if (input.ascendingOrder !== undefined) {
    query["isAscendingOrder"] = input.ascendingOrder.toString();
  }
  if (input.maxResults !== undefined) {
    query["maxResults"] = input.maxResults.toString();
  }
  if (input.nextToken !== undefined) {
    query["nextToken"] = input.nextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restJson1_1UpdateStreamCommand(
  input: UpdateStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/json";
  let resolvedPath = "/streams/{streamId}";
  if (input.streamId !== undefined) {
    const labelValue: string = input.streamId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: streamId.");
    }
    resolvedPath = resolvedPath.replace(
      "{streamId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: streamId.");
  }
  let body: any;
  const bodyParams: any = {};
  if (input.description !== undefined) {
    bodyParams["description"] = input.description;
  }
  if (input.files !== undefined) {
    bodyParams["files"] = serializeAws_restJson1_1StreamFiles(
      input.files,
      context
    );
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  body = JSON.stringify(bodyParams);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "PUT",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function deserializeAws_restJson1_1ConfirmTopicRuleDestinationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmTopicRuleDestinationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ConfirmTopicRuleDestinationCommandError(
      output,
      context
    );
  }
  const contents: ConfirmTopicRuleDestinationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ConfirmTopicRuleDestinationResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ConfirmTopicRuleDestinationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmTopicRuleDestinationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateTopicRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTopicRuleCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateTopicRuleCommandError(
      output,
      context
    );
  }
  const contents: CreateTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateTopicRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTopicRuleCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SqlParseException":
    case "com.amazonaws.iot.common.types#SqlParseException":
      response = {
        ...(await deserializeAws_restJson1_1SqlParseExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateTopicRuleDestinationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTopicRuleDestinationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateTopicRuleDestinationCommandError(
      output,
      context
    );
  }
  const contents: CreateTopicRuleDestinationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTopicRuleDestinationResponse",
    topicRuleDestination: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.topicRuleDestination !== undefined &&
    data.topicRuleDestination !== null
  ) {
    contents.topicRuleDestination = deserializeAws_restJson1_1TopicRuleDestination(
      data.topicRuleDestination,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateTopicRuleDestinationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTopicRuleDestinationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteTopicRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTopicRuleCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteTopicRuleCommandError(
      output,
      context
    );
  }
  const contents: DeleteTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteTopicRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTopicRuleCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteTopicRuleDestinationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTopicRuleDestinationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteTopicRuleDestinationCommandError(
      output,
      context
    );
  }
  const contents: DeleteTopicRuleDestinationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTopicRuleDestinationResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteTopicRuleDestinationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTopicRuleDestinationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteV2LoggingLevelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteV2LoggingLevelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteV2LoggingLevelCommandError(
      output,
      context
    );
  }
  const contents: DeleteV2LoggingLevelCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteV2LoggingLevelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteV2LoggingLevelCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DisableTopicRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableTopicRuleCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DisableTopicRuleCommandError(
      output,
      context
    );
  }
  const contents: DisableTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DisableTopicRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableTopicRuleCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1EnableTopicRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableTopicRuleCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1EnableTopicRuleCommandError(
      output,
      context
    );
  }
  const contents: EnableTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1EnableTopicRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableTopicRuleCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetLoggingOptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggingOptionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetLoggingOptionsCommandError(
      output,
      context
    );
  }
  const contents: GetLoggingOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetLoggingOptionsResponse",
    logLevel: undefined,
    roleArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.logLevel !== undefined && data.logLevel !== null) {
    contents.logLevel = data.logLevel;
  }
  if (data.roleArn !== undefined && data.roleArn !== null) {
    contents.roleArn = data.roleArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetLoggingOptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggingOptionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetTopicRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTopicRuleCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetTopicRuleCommandError(output, context);
  }
  const contents: GetTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTopicRuleResponse",
    rule: undefined,
    ruleArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.rule !== undefined && data.rule !== null) {
    contents.rule = deserializeAws_restJson1_1TopicRule(data.rule, context);
  }
  if (data.ruleArn !== undefined && data.ruleArn !== null) {
    contents.ruleArn = data.ruleArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetTopicRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTopicRuleCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetTopicRuleDestinationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTopicRuleDestinationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetTopicRuleDestinationCommandError(
      output,
      context
    );
  }
  const contents: GetTopicRuleDestinationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTopicRuleDestinationResponse",
    topicRuleDestination: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.topicRuleDestination !== undefined &&
    data.topicRuleDestination !== null
  ) {
    contents.topicRuleDestination = deserializeAws_restJson1_1TopicRuleDestination(
      data.topicRuleDestination,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetTopicRuleDestinationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTopicRuleDestinationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetV2LoggingOptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetV2LoggingOptionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetV2LoggingOptionsCommandError(
      output,
      context
    );
  }
  const contents: GetV2LoggingOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetV2LoggingOptionsResponse",
    defaultLogLevel: undefined,
    disableAllLogs: undefined,
    roleArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.defaultLogLevel !== undefined && data.defaultLogLevel !== null) {
    contents.defaultLogLevel = data.defaultLogLevel;
  }
  if (data.disableAllLogs !== undefined && data.disableAllLogs !== null) {
    contents.disableAllLogs = data.disableAllLogs;
  }
  if (data.roleArn !== undefined && data.roleArn !== null) {
    contents.roleArn = data.roleArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetV2LoggingOptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetV2LoggingOptionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotConfiguredException":
    case "com.amazonaws.iot.common.types#NotConfiguredException":
      response = {
        ...(await deserializeAws_restJson1_1NotConfiguredExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListTopicRuleDestinationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicRuleDestinationsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTopicRuleDestinationsCommandError(
      output,
      context
    );
  }
  const contents: ListTopicRuleDestinationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTopicRuleDestinationsResponse",
    destinationSummaries: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.destinationSummaries !== undefined &&
    data.destinationSummaries !== null
  ) {
    contents.destinationSummaries = deserializeAws_restJson1_1TopicRuleDestinationSummaries(
      data.destinationSummaries,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListTopicRuleDestinationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicRuleDestinationsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListTopicRulesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicRulesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTopicRulesCommandError(
      output,
      context
    );
  }
  const contents: ListTopicRulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTopicRulesResponse",
    nextToken: undefined,
    rules: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.rules !== undefined && data.rules !== null) {
    contents.rules = deserializeAws_restJson1_1TopicRuleList(
      data.rules,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListTopicRulesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicRulesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListV2LoggingLevelsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListV2LoggingLevelsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListV2LoggingLevelsCommandError(
      output,
      context
    );
  }
  const contents: ListV2LoggingLevelsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListV2LoggingLevelsResponse",
    logTargetConfigurations: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.logTargetConfigurations !== undefined &&
    data.logTargetConfigurations !== null
  ) {
    contents.logTargetConfigurations = deserializeAws_restJson1_1LogTargetConfigurations(
      data.logTargetConfigurations,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListV2LoggingLevelsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListV2LoggingLevelsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotConfiguredException":
    case "com.amazonaws.iot.common.types#NotConfiguredException":
      response = {
        ...(await deserializeAws_restJson1_1NotConfiguredExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ReplaceTopicRuleCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceTopicRuleCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ReplaceTopicRuleCommandError(
      output,
      context
    );
  }
  const contents: ReplaceTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ReplaceTopicRuleCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceTopicRuleCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SqlParseException":
    case "com.amazonaws.iot.common.types#SqlParseException":
      response = {
        ...(await deserializeAws_restJson1_1SqlParseExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1SetLoggingOptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetLoggingOptionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1SetLoggingOptionsCommandError(
      output,
      context
    );
  }
  const contents: SetLoggingOptionsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1SetLoggingOptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetLoggingOptionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1SetV2LoggingLevelCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetV2LoggingLevelCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1SetV2LoggingLevelCommandError(
      output,
      context
    );
  }
  const contents: SetV2LoggingLevelCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1SetV2LoggingLevelCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetV2LoggingLevelCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotConfiguredException":
    case "com.amazonaws.iot.common.types#NotConfiguredException":
      response = {
        ...(await deserializeAws_restJson1_1NotConfiguredExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1SetV2LoggingOptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetV2LoggingOptionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1SetV2LoggingOptionsCommandError(
      output,
      context
    );
  }
  const contents: SetV2LoggingOptionsCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1SetV2LoggingOptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetV2LoggingOptionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateTopicRuleDestinationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTopicRuleDestinationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateTopicRuleDestinationCommandError(
      output,
      context
    );
  }
  const contents: UpdateTopicRuleDestinationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTopicRuleDestinationResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateTopicRuleDestinationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTopicRuleDestinationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot.common.types#InternalException":
      response = {
        ...(await deserializeAws_restJson1_1InternalExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AcceptCertificateTransferCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptCertificateTransferCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AcceptCertificateTransferCommandError(
      output,
      context
    );
  }
  const contents: AcceptCertificateTransferCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AcceptCertificateTransferCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptCertificateTransferCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TransferAlreadyCompletedException":
    case "com.amazonaws.iot.common.types#TransferAlreadyCompletedException":
      response = {
        ...(await deserializeAws_restJson1_1TransferAlreadyCompletedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AttachPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AttachPolicyCommandError(output, context);
  }
  const contents: AttachPolicyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AttachPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachPolicyCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AttachPrincipalPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachPrincipalPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AttachPrincipalPolicyCommandError(
      output,
      context
    );
  }
  const contents: AttachPrincipalPolicyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AttachPrincipalPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachPrincipalPolicyCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CancelCertificateTransferCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelCertificateTransferCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CancelCertificateTransferCommandError(
      output,
      context
    );
  }
  const contents: CancelCertificateTransferCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CancelCertificateTransferCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelCertificateTransferCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TransferAlreadyCompletedException":
    case "com.amazonaws.iot.common.types#TransferAlreadyCompletedException":
      response = {
        ...(await deserializeAws_restJson1_1TransferAlreadyCompletedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ClearDefaultAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ClearDefaultAuthorizerCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ClearDefaultAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: ClearDefaultAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ClearDefaultAuthorizerResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ClearDefaultAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ClearDefaultAuthorizerCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAuthorizerCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: CreateAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateAuthorizerResponse",
    authorizerArn: undefined,
    authorizerName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.authorizerArn !== undefined && data.authorizerArn !== null) {
    contents.authorizerArn = data.authorizerArn;
  }
  if (data.authorizerName !== undefined && data.authorizerName !== null) {
    contents.authorizerName = data.authorizerName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAuthorizerCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateCertificateFromCsrCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCertificateFromCsrCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateCertificateFromCsrCommandError(
      output,
      context
    );
  }
  const contents: CreateCertificateFromCsrCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateCertificateFromCsrResponse",
    certificateArn: undefined,
    certificateId: undefined,
    certificatePem: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = data.certificateArn;
  }
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = data.certificateId;
  }
  if (data.certificatePem !== undefined && data.certificatePem !== null) {
    contents.certificatePem = data.certificatePem;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateCertificateFromCsrCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCertificateFromCsrCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateDomainConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDomainConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateDomainConfigurationCommandError(
      output,
      context
    );
  }
  const contents: CreateDomainConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDomainConfigurationResponse",
    domainConfigurationArn: undefined,
    domainConfigurationName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.domainConfigurationArn !== undefined &&
    data.domainConfigurationArn !== null
  ) {
    contents.domainConfigurationArn = data.domainConfigurationArn;
  }
  if (
    data.domainConfigurationName !== undefined &&
    data.domainConfigurationName !== null
  ) {
    contents.domainConfigurationName = data.domainConfigurationName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateDomainConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDomainConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "CertificateValidationException":
    case "com.amazonaws.iot.common.types#CertificateValidationException":
      response = {
        ...(await deserializeAws_restJson1_1CertificateValidationExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateKeysAndCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateKeysAndCertificateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateKeysAndCertificateCommandError(
      output,
      context
    );
  }
  const contents: CreateKeysAndCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateKeysAndCertificateResponse",
    certificateArn: undefined,
    certificateId: undefined,
    certificatePem: undefined,
    keyPair: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = data.certificateArn;
  }
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = data.certificateId;
  }
  if (data.certificatePem !== undefined && data.certificatePem !== null) {
    contents.certificatePem = data.certificatePem;
  }
  if (data.keyPair !== undefined && data.keyPair !== null) {
    contents.keyPair = deserializeAws_restJson1_1KeyPair(data.keyPair, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateKeysAndCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateKeysAndCertificateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreatePolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreatePolicyCommandError(output, context);
  }
  const contents: CreatePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePolicyResponse",
    policyArn: undefined,
    policyDocument: undefined,
    policyName: undefined,
    policyVersionId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.policyArn !== undefined && data.policyArn !== null) {
    contents.policyArn = data.policyArn;
  }
  if (data.policyDocument !== undefined && data.policyDocument !== null) {
    contents.policyDocument = data.policyDocument;
  }
  if (data.policyName !== undefined && data.policyName !== null) {
    contents.policyName = data.policyName;
  }
  if (data.policyVersionId !== undefined && data.policyVersionId !== null) {
    contents.policyVersionId = data.policyVersionId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreatePolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePolicyCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MalformedPolicyException":
    case "com.amazonaws.iot.common.types#MalformedPolicyException":
      response = {
        ...(await deserializeAws_restJson1_1MalformedPolicyExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreatePolicyVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePolicyVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreatePolicyVersionCommandError(
      output,
      context
    );
  }
  const contents: CreatePolicyVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreatePolicyVersionResponse",
    isDefaultVersion: undefined,
    policyArn: undefined,
    policyDocument: undefined,
    policyVersionId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
    contents.isDefaultVersion = data.isDefaultVersion;
  }
  if (data.policyArn !== undefined && data.policyArn !== null) {
    contents.policyArn = data.policyArn;
  }
  if (data.policyDocument !== undefined && data.policyDocument !== null) {
    contents.policyDocument = data.policyDocument;
  }
  if (data.policyVersionId !== undefined && data.policyVersionId !== null) {
    contents.policyVersionId = data.policyVersionId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreatePolicyVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePolicyVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "MalformedPolicyException":
    case "com.amazonaws.iot.common.types#MalformedPolicyException":
      response = {
        ...(await deserializeAws_restJson1_1MalformedPolicyExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionsLimitExceededException":
    case "com.amazonaws.iot.common.types#VersionsLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1VersionsLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateProvisioningClaimCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningClaimCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateProvisioningClaimCommandError(
      output,
      context
    );
  }
  const contents: CreateProvisioningClaimCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateProvisioningClaimResponse",
    certificateId: undefined,
    certificatePem: undefined,
    expiration: undefined,
    keyPair: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = data.certificateId;
  }
  if (data.certificatePem !== undefined && data.certificatePem !== null) {
    contents.certificatePem = data.certificatePem;
  }
  if (data.expiration !== undefined && data.expiration !== null) {
    contents.expiration = new Date(Math.round(data.expiration * 1000));
  }
  if (data.keyPair !== undefined && data.keyPair !== null) {
    contents.keyPair = deserializeAws_restJson1_1KeyPair(data.keyPair, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateProvisioningClaimCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningClaimCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateProvisioningTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningTemplateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateProvisioningTemplateCommandError(
      output,
      context
    );
  }
  const contents: CreateProvisioningTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateProvisioningTemplateResponse",
    defaultVersionId: undefined,
    templateArn: undefined,
    templateName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.defaultVersionId !== undefined && data.defaultVersionId !== null) {
    contents.defaultVersionId = data.defaultVersionId;
  }
  if (data.templateArn !== undefined && data.templateArn !== null) {
    contents.templateArn = data.templateArn;
  }
  if (data.templateName !== undefined && data.templateName !== null) {
    contents.templateName = data.templateName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateProvisioningTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningTemplateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateProvisioningTemplateVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningTemplateVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateProvisioningTemplateVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateProvisioningTemplateVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateProvisioningTemplateVersionResponse",
    isDefaultVersion: undefined,
    templateArn: undefined,
    templateName: undefined,
    versionId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
    contents.isDefaultVersion = data.isDefaultVersion;
  }
  if (data.templateArn !== undefined && data.templateArn !== null) {
    contents.templateArn = data.templateArn;
  }
  if (data.templateName !== undefined && data.templateName !== null) {
    contents.templateName = data.templateName;
  }
  if (data.versionId !== undefined && data.versionId !== null) {
    contents.versionId = data.versionId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateProvisioningTemplateVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningTemplateVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionsLimitExceededException":
    case "com.amazonaws.iot.common.types#VersionsLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1VersionsLimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateRoleAliasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRoleAliasCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateRoleAliasCommandError(
      output,
      context
    );
  }
  const contents: CreateRoleAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateRoleAliasResponse",
    roleAlias: undefined,
    roleAliasArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.roleAlias !== undefined && data.roleAlias !== null) {
    contents.roleAlias = data.roleAlias;
  }
  if (data.roleAliasArn !== undefined && data.roleAliasArn !== null) {
    contents.roleAliasArn = data.roleAliasArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateRoleAliasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRoleAliasCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAuthorizerCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: DeleteAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteAuthorizerResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAuthorizerCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot.common.types#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1_1DeleteConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteCACertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCACertificateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteCACertificateCommandError(
      output,
      context
    );
  }
  const contents: DeleteCACertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteCACertificateResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteCACertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCACertificateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "CertificateStateException":
    case "com.amazonaws.iot.common.types#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1_1CertificateStateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCertificateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteCertificateCommandError(
      output,
      context
    );
  }
  const contents: DeleteCertificateCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCertificateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "CertificateStateException":
    case "com.amazonaws.iot.common.types#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1_1CertificateStateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DeleteConflictException":
    case "com.amazonaws.iot.common.types#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1_1DeleteConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteDomainConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDomainConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteDomainConfigurationCommandError(
      output,
      context
    );
  }
  const contents: DeleteDomainConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDomainConfigurationResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteDomainConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDomainConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeletePolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeletePolicyCommandError(output, context);
  }
  const contents: DeletePolicyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeletePolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePolicyCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot.common.types#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1_1DeleteConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeletePolicyVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePolicyVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeletePolicyVersionCommandError(
      output,
      context
    );
  }
  const contents: DeletePolicyVersionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeletePolicyVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePolicyVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot.common.types#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1_1DeleteConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteProvisioningTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteProvisioningTemplateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteProvisioningTemplateCommandError(
      output,
      context
    );
  }
  const contents: DeleteProvisioningTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteProvisioningTemplateResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteProvisioningTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteProvisioningTemplateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot.common.types#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1_1DeleteConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteProvisioningTemplateVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteProvisioningTemplateVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteProvisioningTemplateVersionCommandError(
      output,
      context
    );
  }
  const contents: DeleteProvisioningTemplateVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteProvisioningTemplateVersionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteProvisioningTemplateVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteProvisioningTemplateVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot.common.types#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1_1DeleteConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteRegistrationCodeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegistrationCodeCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteRegistrationCodeCommandError(
      output,
      context
    );
  }
  const contents: DeleteRegistrationCodeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRegistrationCodeResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteRegistrationCodeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegistrationCodeCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteRoleAliasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoleAliasCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteRoleAliasCommandError(
      output,
      context
    );
  }
  const contents: DeleteRoleAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteRoleAliasResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteRoleAliasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoleAliasCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot.common.types#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1_1DeleteConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuthorizerCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: DescribeAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAuthorizerResponse",
    authorizerDescription: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.authorizerDescription !== undefined &&
    data.authorizerDescription !== null
  ) {
    contents.authorizerDescription = deserializeAws_restJson1_1AuthorizerDescription(
      data.authorizerDescription,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuthorizerCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeCACertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCACertificateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeCACertificateCommandError(
      output,
      context
    );
  }
  const contents: DescribeCACertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCACertificateResponse",
    certificateDescription: undefined,
    registrationConfig: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.certificateDescription !== undefined &&
    data.certificateDescription !== null
  ) {
    contents.certificateDescription = deserializeAws_restJson1_1CACertificateDescription(
      data.certificateDescription,
      context
    );
  }
  if (
    data.registrationConfig !== undefined &&
    data.registrationConfig !== null
  ) {
    contents.registrationConfig = deserializeAws_restJson1_1RegistrationConfig(
      data.registrationConfig,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeCACertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCACertificateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeCertificateCommandError(
      output,
      context
    );
  }
  const contents: DescribeCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCertificateResponse",
    certificateDescription: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.certificateDescription !== undefined &&
    data.certificateDescription !== null
  ) {
    contents.certificateDescription = deserializeAws_restJson1_1CertificateDescription(
      data.certificateDescription,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeDefaultAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDefaultAuthorizerCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeDefaultAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: DescribeDefaultAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDefaultAuthorizerResponse",
    authorizerDescription: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.authorizerDescription !== undefined &&
    data.authorizerDescription !== null
  ) {
    contents.authorizerDescription = deserializeAws_restJson1_1AuthorizerDescription(
      data.authorizerDescription,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeDefaultAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDefaultAuthorizerCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeDomainConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDomainConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeDomainConfigurationCommandError(
      output,
      context
    );
  }
  const contents: DescribeDomainConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeDomainConfigurationResponse",
    authorizerConfig: undefined,
    domainConfigurationArn: undefined,
    domainConfigurationName: undefined,
    domainConfigurationStatus: undefined,
    domainName: undefined,
    domainType: undefined,
    serverCertificates: undefined,
    serviceType: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.authorizerConfig !== undefined && data.authorizerConfig !== null) {
    contents.authorizerConfig = deserializeAws_restJson1_1AuthorizerConfig(
      data.authorizerConfig,
      context
    );
  }
  if (
    data.domainConfigurationArn !== undefined &&
    data.domainConfigurationArn !== null
  ) {
    contents.domainConfigurationArn = data.domainConfigurationArn;
  }
  if (
    data.domainConfigurationName !== undefined &&
    data.domainConfigurationName !== null
  ) {
    contents.domainConfigurationName = data.domainConfigurationName;
  }
  if (
    data.domainConfigurationStatus !== undefined &&
    data.domainConfigurationStatus !== null
  ) {
    contents.domainConfigurationStatus = data.domainConfigurationStatus;
  }
  if (data.domainName !== undefined && data.domainName !== null) {
    contents.domainName = data.domainName;
  }
  if (data.domainType !== undefined && data.domainType !== null) {
    contents.domainType = data.domainType;
  }
  if (
    data.serverCertificates !== undefined &&
    data.serverCertificates !== null
  ) {
    contents.serverCertificates = deserializeAws_restJson1_1ServerCertificates(
      data.serverCertificates,
      context
    );
  }
  if (data.serviceType !== undefined && data.serviceType !== null) {
    contents.serviceType = data.serviceType;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeDomainConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDomainConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeEndpointCommandError(
      output,
      context
    );
  }
  const contents: DescribeEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointResponse",
    endpointAddress: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.endpointAddress !== undefined && data.endpointAddress !== null) {
    contents.endpointAddress = data.endpointAddress;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeProvisioningTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeProvisioningTemplateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeProvisioningTemplateCommandError(
      output,
      context
    );
  }
  const contents: DescribeProvisioningTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeProvisioningTemplateResponse",
    creationDate: undefined,
    defaultVersionId: undefined,
    description: undefined,
    enabled: undefined,
    lastModifiedDate: undefined,
    provisioningRoleArn: undefined,
    templateArn: undefined,
    templateBody: undefined,
    templateName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = new Date(Math.round(data.creationDate * 1000));
  }
  if (data.defaultVersionId !== undefined && data.defaultVersionId !== null) {
    contents.defaultVersionId = data.defaultVersionId;
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.enabled !== undefined && data.enabled !== null) {
    contents.enabled = data.enabled;
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = new Date(
      Math.round(data.lastModifiedDate * 1000)
    );
  }
  if (
    data.provisioningRoleArn !== undefined &&
    data.provisioningRoleArn !== null
  ) {
    contents.provisioningRoleArn = data.provisioningRoleArn;
  }
  if (data.templateArn !== undefined && data.templateArn !== null) {
    contents.templateArn = data.templateArn;
  }
  if (data.templateBody !== undefined && data.templateBody !== null) {
    contents.templateBody = data.templateBody;
  }
  if (data.templateName !== undefined && data.templateName !== null) {
    contents.templateName = data.templateName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeProvisioningTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeProvisioningTemplateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeProvisioningTemplateVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeProvisioningTemplateVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeProvisioningTemplateVersionCommandError(
      output,
      context
    );
  }
  const contents: DescribeProvisioningTemplateVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeProvisioningTemplateVersionResponse",
    creationDate: undefined,
    isDefaultVersion: undefined,
    templateBody: undefined,
    versionId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = new Date(Math.round(data.creationDate * 1000));
  }
  if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
    contents.isDefaultVersion = data.isDefaultVersion;
  }
  if (data.templateBody !== undefined && data.templateBody !== null) {
    contents.templateBody = data.templateBody;
  }
  if (data.versionId !== undefined && data.versionId !== null) {
    contents.versionId = data.versionId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeProvisioningTemplateVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeProvisioningTemplateVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeRoleAliasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRoleAliasCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeRoleAliasCommandError(
      output,
      context
    );
  }
  const contents: DescribeRoleAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeRoleAliasResponse",
    roleAliasDescription: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.roleAliasDescription !== undefined &&
    data.roleAliasDescription !== null
  ) {
    contents.roleAliasDescription = deserializeAws_restJson1_1RoleAliasDescription(
      data.roleAliasDescription,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeRoleAliasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRoleAliasCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DetachPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DetachPolicyCommandError(output, context);
  }
  const contents: DetachPolicyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DetachPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachPolicyCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DetachPrincipalPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachPrincipalPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DetachPrincipalPolicyCommandError(
      output,
      context
    );
  }
  const contents: DetachPrincipalPolicyCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DetachPrincipalPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachPrincipalPolicyCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetEffectivePoliciesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEffectivePoliciesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetEffectivePoliciesCommandError(
      output,
      context
    );
  }
  const contents: GetEffectivePoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetEffectivePoliciesResponse",
    effectivePolicies: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.effectivePolicies !== undefined && data.effectivePolicies !== null) {
    contents.effectivePolicies = deserializeAws_restJson1_1EffectivePolicies(
      data.effectivePolicies,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetEffectivePoliciesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEffectivePoliciesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetPolicyCommandError(output, context);
  }
  const contents: GetPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPolicyResponse",
    creationDate: undefined,
    defaultVersionId: undefined,
    generationId: undefined,
    lastModifiedDate: undefined,
    policyArn: undefined,
    policyDocument: undefined,
    policyName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = new Date(Math.round(data.creationDate * 1000));
  }
  if (data.defaultVersionId !== undefined && data.defaultVersionId !== null) {
    contents.defaultVersionId = data.defaultVersionId;
  }
  if (data.generationId !== undefined && data.generationId !== null) {
    contents.generationId = data.generationId;
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = new Date(
      Math.round(data.lastModifiedDate * 1000)
    );
  }
  if (data.policyArn !== undefined && data.policyArn !== null) {
    contents.policyArn = data.policyArn;
  }
  if (data.policyDocument !== undefined && data.policyDocument !== null) {
    contents.policyDocument = data.policyDocument;
  }
  if (data.policyName !== undefined && data.policyName !== null) {
    contents.policyName = data.policyName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPolicyCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetPolicyVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPolicyVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetPolicyVersionCommandError(
      output,
      context
    );
  }
  const contents: GetPolicyVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPolicyVersionResponse",
    creationDate: undefined,
    generationId: undefined,
    isDefaultVersion: undefined,
    lastModifiedDate: undefined,
    policyArn: undefined,
    policyDocument: undefined,
    policyName: undefined,
    policyVersionId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = new Date(Math.round(data.creationDate * 1000));
  }
  if (data.generationId !== undefined && data.generationId !== null) {
    contents.generationId = data.generationId;
  }
  if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
    contents.isDefaultVersion = data.isDefaultVersion;
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = new Date(
      Math.round(data.lastModifiedDate * 1000)
    );
  }
  if (data.policyArn !== undefined && data.policyArn !== null) {
    contents.policyArn = data.policyArn;
  }
  if (data.policyDocument !== undefined && data.policyDocument !== null) {
    contents.policyDocument = data.policyDocument;
  }
  if (data.policyName !== undefined && data.policyName !== null) {
    contents.policyName = data.policyName;
  }
  if (data.policyVersionId !== undefined && data.policyVersionId !== null) {
    contents.policyVersionId = data.policyVersionId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetPolicyVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPolicyVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetRegistrationCodeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegistrationCodeCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetRegistrationCodeCommandError(
      output,
      context
    );
  }
  const contents: GetRegistrationCodeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetRegistrationCodeResponse",
    registrationCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.registrationCode !== undefined && data.registrationCode !== null) {
    contents.registrationCode = data.registrationCode;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetRegistrationCodeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegistrationCodeCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListAttachedPoliciesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAttachedPoliciesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListAttachedPoliciesCommandError(
      output,
      context
    );
  }
  const contents: ListAttachedPoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAttachedPoliciesResponse",
    nextMarker: undefined,
    policies: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  if (data.policies !== undefined && data.policies !== null) {
    contents.policies = deserializeAws_restJson1_1Policies(
      data.policies,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListAttachedPoliciesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAttachedPoliciesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListAuthorizersCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuthorizersCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListAuthorizersCommandError(
      output,
      context
    );
  }
  const contents: ListAuthorizersCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAuthorizersResponse",
    authorizers: undefined,
    nextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.authorizers !== undefined && data.authorizers !== null) {
    contents.authorizers = deserializeAws_restJson1_1Authorizers(
      data.authorizers,
      context
    );
  }
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListAuthorizersCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuthorizersCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListCACertificatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCACertificatesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListCACertificatesCommandError(
      output,
      context
    );
  }
  const contents: ListCACertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCACertificatesResponse",
    certificates: undefined,
    nextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificates !== undefined && data.certificates !== null) {
    contents.certificates = deserializeAws_restJson1_1CACertificates(
      data.certificates,
      context
    );
  }
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListCACertificatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCACertificatesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListCertificatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCertificatesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListCertificatesCommandError(
      output,
      context
    );
  }
  const contents: ListCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCertificatesResponse",
    certificates: undefined,
    nextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificates !== undefined && data.certificates !== null) {
    contents.certificates = deserializeAws_restJson1_1Certificates(
      data.certificates,
      context
    );
  }
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListCertificatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCertificatesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListCertificatesByCACommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCertificatesByCACommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListCertificatesByCACommandError(
      output,
      context
    );
  }
  const contents: ListCertificatesByCACommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListCertificatesByCAResponse",
    certificates: undefined,
    nextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificates !== undefined && data.certificates !== null) {
    contents.certificates = deserializeAws_restJson1_1Certificates(
      data.certificates,
      context
    );
  }
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListCertificatesByCACommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCertificatesByCACommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListDomainConfigurationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDomainConfigurationsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListDomainConfigurationsCommandError(
      output,
      context
    );
  }
  const contents: ListDomainConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListDomainConfigurationsResponse",
    domainConfigurations: undefined,
    nextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.domainConfigurations !== undefined &&
    data.domainConfigurations !== null
  ) {
    contents.domainConfigurations = deserializeAws_restJson1_1DomainConfigurations(
      data.domainConfigurations,
      context
    );
  }
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListDomainConfigurationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDomainConfigurationsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListOutgoingCertificatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListOutgoingCertificatesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListOutgoingCertificatesCommandError(
      output,
      context
    );
  }
  const contents: ListOutgoingCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListOutgoingCertificatesResponse",
    nextMarker: undefined,
    outgoingCertificates: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  if (
    data.outgoingCertificates !== undefined &&
    data.outgoingCertificates !== null
  ) {
    contents.outgoingCertificates = deserializeAws_restJson1_1OutgoingCertificates(
      data.outgoingCertificates,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListOutgoingCertificatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListOutgoingCertificatesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListPoliciesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPoliciesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListPoliciesCommandError(output, context);
  }
  const contents: ListPoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPoliciesResponse",
    nextMarker: undefined,
    policies: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  if (data.policies !== undefined && data.policies !== null) {
    contents.policies = deserializeAws_restJson1_1Policies(
      data.policies,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListPoliciesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPoliciesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListPolicyPrincipalsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPolicyPrincipalsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListPolicyPrincipalsCommandError(
      output,
      context
    );
  }
  const contents: ListPolicyPrincipalsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPolicyPrincipalsResponse",
    nextMarker: undefined,
    principals: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  if (data.principals !== undefined && data.principals !== null) {
    contents.principals = deserializeAws_restJson1_1Principals(
      data.principals,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListPolicyPrincipalsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPolicyPrincipalsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListPolicyVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPolicyVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListPolicyVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListPolicyVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPolicyVersionsResponse",
    policyVersions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.policyVersions !== undefined && data.policyVersions !== null) {
    contents.policyVersions = deserializeAws_restJson1_1PolicyVersions(
      data.policyVersions,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListPolicyVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPolicyVersionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListPrincipalPoliciesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPrincipalPoliciesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListPrincipalPoliciesCommandError(
      output,
      context
    );
  }
  const contents: ListPrincipalPoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPrincipalPoliciesResponse",
    nextMarker: undefined,
    policies: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  if (data.policies !== undefined && data.policies !== null) {
    contents.policies = deserializeAws_restJson1_1Policies(
      data.policies,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListPrincipalPoliciesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPrincipalPoliciesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListProvisioningTemplateVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListProvisioningTemplateVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListProvisioningTemplateVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListProvisioningTemplateVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListProvisioningTemplateVersionsResponse",
    nextToken: undefined,
    versions: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.versions !== undefined && data.versions !== null) {
    contents.versions = deserializeAws_restJson1_1ProvisioningTemplateVersionListing(
      data.versions,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListProvisioningTemplateVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListProvisioningTemplateVersionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListProvisioningTemplatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListProvisioningTemplatesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListProvisioningTemplatesCommandError(
      output,
      context
    );
  }
  const contents: ListProvisioningTemplatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListProvisioningTemplatesResponse",
    nextToken: undefined,
    templates: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.templates !== undefined && data.templates !== null) {
    contents.templates = deserializeAws_restJson1_1ProvisioningTemplateListing(
      data.templates,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListProvisioningTemplatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListProvisioningTemplatesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListRoleAliasesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRoleAliasesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListRoleAliasesCommandError(
      output,
      context
    );
  }
  const contents: ListRoleAliasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListRoleAliasesResponse",
    nextMarker: undefined,
    roleAliases: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  if (data.roleAliases !== undefined && data.roleAliases !== null) {
    contents.roleAliases = deserializeAws_restJson1_1RoleAliases(
      data.roleAliases,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListRoleAliasesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRoleAliasesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListTargetsForPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTargetsForPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTargetsForPolicyCommandError(
      output,
      context
    );
  }
  const contents: ListTargetsForPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTargetsForPolicyResponse",
    nextMarker: undefined,
    targets: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = data.nextMarker;
  }
  if (data.targets !== undefined && data.targets !== null) {
    contents.targets = deserializeAws_restJson1_1PolicyTargets(
      data.targets,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListTargetsForPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTargetsForPolicyCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1RegisterCACertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCACertificateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1RegisterCACertificateCommandError(
      output,
      context
    );
  }
  const contents: RegisterCACertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterCACertificateResponse",
    certificateArn: undefined,
    certificateId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = data.certificateArn;
  }
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = data.certificateId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1RegisterCACertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCACertificateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "CertificateValidationException":
    case "com.amazonaws.iot.common.types#CertificateValidationException":
      response = {
        ...(await deserializeAws_restJson1_1CertificateValidationExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "RegistrationCodeValidationException":
    case "com.amazonaws.iot.common.types#RegistrationCodeValidationException":
      response = {
        ...(await deserializeAws_restJson1_1RegistrationCodeValidationExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1RegisterCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCertificateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1RegisterCertificateCommandError(
      output,
      context
    );
  }
  const contents: RegisterCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterCertificateResponse",
    certificateArn: undefined,
    certificateId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = data.certificateArn;
  }
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = data.certificateId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1RegisterCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCertificateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "CertificateConflictException":
    case "com.amazonaws.iot.common.types#CertificateConflictException":
      response = {
        ...(await deserializeAws_restJson1_1CertificateConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CertificateStateException":
    case "com.amazonaws.iot.common.types#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1_1CertificateStateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "CertificateValidationException":
    case "com.amazonaws.iot.common.types#CertificateValidationException":
      response = {
        ...(await deserializeAws_restJson1_1CertificateValidationExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1RegisterThingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterThingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1RegisterThingCommandError(output, context);
  }
  const contents: RegisterThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RegisterThingResponse",
    certificatePem: undefined,
    resourceArns: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.certificatePem !== undefined && data.certificatePem !== null) {
    contents.certificatePem = data.certificatePem;
  }
  if (data.resourceArns !== undefined && data.resourceArns !== null) {
    contents.resourceArns = deserializeAws_restJson1_1ResourceArns(
      data.resourceArns,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1RegisterThingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterThingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceRegistrationFailureException":
    case "com.amazonaws.iot.common.types#ResourceRegistrationFailureException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceRegistrationFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1RejectCertificateTransferCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectCertificateTransferCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1RejectCertificateTransferCommandError(
      output,
      context
    );
  }
  const contents: RejectCertificateTransferCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1RejectCertificateTransferCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectCertificateTransferCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TransferAlreadyCompletedException":
    case "com.amazonaws.iot.common.types#TransferAlreadyCompletedException":
      response = {
        ...(await deserializeAws_restJson1_1TransferAlreadyCompletedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1SetDefaultAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetDefaultAuthorizerCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1SetDefaultAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: SetDefaultAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SetDefaultAuthorizerResponse",
    authorizerArn: undefined,
    authorizerName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.authorizerArn !== undefined && data.authorizerArn !== null) {
    contents.authorizerArn = data.authorizerArn;
  }
  if (data.authorizerName !== undefined && data.authorizerName !== null) {
    contents.authorizerName = data.authorizerName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1SetDefaultAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetDefaultAuthorizerCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1SetDefaultPolicyVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetDefaultPolicyVersionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1SetDefaultPolicyVersionCommandError(
      output,
      context
    );
  }
  const contents: SetDefaultPolicyVersionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1SetDefaultPolicyVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetDefaultPolicyVersionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1TestAuthorizationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestAuthorizationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1TestAuthorizationCommandError(
      output,
      context
    );
  }
  const contents: TestAuthorizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestAuthorizationResponse",
    authResults: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.authResults !== undefined && data.authResults !== null) {
    contents.authResults = deserializeAws_restJson1_1AuthResults(
      data.authResults,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1TestAuthorizationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestAuthorizationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1TestInvokeAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestInvokeAuthorizerCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1TestInvokeAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: TestInvokeAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestInvokeAuthorizerResponse",
    disconnectAfterInSeconds: undefined,
    isAuthenticated: undefined,
    policyDocuments: undefined,
    principalId: undefined,
    refreshAfterInSeconds: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.disconnectAfterInSeconds !== undefined &&
    data.disconnectAfterInSeconds !== null
  ) {
    contents.disconnectAfterInSeconds = data.disconnectAfterInSeconds;
  }
  if (data.isAuthenticated !== undefined && data.isAuthenticated !== null) {
    contents.isAuthenticated = data.isAuthenticated;
  }
  if (data.policyDocuments !== undefined && data.policyDocuments !== null) {
    contents.policyDocuments = deserializeAws_restJson1_1PolicyDocuments(
      data.policyDocuments,
      context
    );
  }
  if (data.principalId !== undefined && data.principalId !== null) {
    contents.principalId = data.principalId;
  }
  if (
    data.refreshAfterInSeconds !== undefined &&
    data.refreshAfterInSeconds !== null
  ) {
    contents.refreshAfterInSeconds = data.refreshAfterInSeconds;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1TestInvokeAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestInvokeAuthorizerCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResponseException":
    case "com.amazonaws.iot.common.types#InvalidResponseException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidResponseExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1TransferCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TransferCertificateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1TransferCertificateCommandError(
      output,
      context
    );
  }
  const contents: TransferCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TransferCertificateResponse",
    transferredCertificateArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.transferredCertificateArn !== undefined &&
    data.transferredCertificateArn !== null
  ) {
    contents.transferredCertificateArn = data.transferredCertificateArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1TransferCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TransferCertificateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "CertificateStateException":
    case "com.amazonaws.iot.common.types#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1_1CertificateStateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TransferConflictException":
    case "com.amazonaws.iot.common.types#TransferConflictException":
      response = {
        ...(await deserializeAws_restJson1_1TransferConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateAuthorizerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAuthorizerCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateAuthorizerCommandError(
      output,
      context
    );
  }
  const contents: UpdateAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateAuthorizerResponse",
    authorizerArn: undefined,
    authorizerName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.authorizerArn !== undefined && data.authorizerArn !== null) {
    contents.authorizerArn = data.authorizerArn;
  }
  if (data.authorizerName !== undefined && data.authorizerName !== null) {
    contents.authorizerName = data.authorizerName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateAuthorizerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAuthorizerCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateCACertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCACertificateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateCACertificateCommandError(
      output,
      context
    );
  }
  const contents: UpdateCACertificateCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateCACertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCACertificateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCertificateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateCertificateCommandError(
      output,
      context
    );
  }
  const contents: UpdateCertificateCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCertificateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "CertificateStateException":
    case "com.amazonaws.iot.common.types#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1_1CertificateStateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateDomainConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDomainConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateDomainConfigurationCommandError(
      output,
      context
    );
  }
  const contents: UpdateDomainConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDomainConfigurationResponse",
    domainConfigurationArn: undefined,
    domainConfigurationName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.domainConfigurationArn !== undefined &&
    data.domainConfigurationArn !== null
  ) {
    contents.domainConfigurationArn = data.domainConfigurationArn;
  }
  if (
    data.domainConfigurationName !== undefined &&
    data.domainConfigurationName !== null
  ) {
    contents.domainConfigurationName = data.domainConfigurationName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateDomainConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDomainConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "CertificateValidationException":
    case "com.amazonaws.iot.common.types#CertificateValidationException":
      response = {
        ...(await deserializeAws_restJson1_1CertificateValidationExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateProvisioningTemplateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateProvisioningTemplateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateProvisioningTemplateCommandError(
      output,
      context
    );
  }
  const contents: UpdateProvisioningTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateProvisioningTemplateResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateProvisioningTemplateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateProvisioningTemplateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot.common.types#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateRoleAliasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRoleAliasCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateRoleAliasCommandError(
      output,
      context
    );
  }
  const contents: UpdateRoleAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateRoleAliasResponse",
    roleAlias: undefined,
    roleAliasArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.roleAlias !== undefined && data.roleAlias !== null) {
    contents.roleAlias = data.roleAlias;
  }
  if (data.roleAliasArn !== undefined && data.roleAliasArn !== null) {
    contents.roleAliasArn = data.roleAliasArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateRoleAliasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRoleAliasCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeIndexCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIndexCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeIndexCommandError(output, context);
  }
  const contents: DescribeIndexCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeIndexResponse",
    indexName: undefined,
    indexStatus: undefined,
    schema: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.indexName !== undefined && data.indexName !== null) {
    contents.indexName = data.indexName;
  }
  if (data.indexStatus !== undefined && data.indexStatus !== null) {
    contents.indexStatus = data.indexStatus;
  }
  if (data.schema !== undefined && data.schema !== null) {
    contents.schema = data.schema;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeIndexCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIndexCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetCardinalityCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCardinalityCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetCardinalityCommandError(
      output,
      context
    );
  }
  const contents: GetCardinalityCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCardinalityResponse",
    cardinality: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.cardinality !== undefined && data.cardinality !== null) {
    contents.cardinality = data.cardinality;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetCardinalityCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCardinalityCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAggregationException":
    case "com.amazonaws.iot.common.types#InvalidAggregationException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidAggregationExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot.common.types#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidQueryExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IndexNotReadyException":
    case "com.amazonaws.iot.indexing#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1_1IndexNotReadyExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetIndexingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIndexingConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetIndexingConfigurationCommandError(
      output,
      context
    );
  }
  const contents: GetIndexingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetIndexingConfigurationResponse",
    thingGroupIndexingConfiguration: undefined,
    thingIndexingConfiguration: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.thingGroupIndexingConfiguration !== undefined &&
    data.thingGroupIndexingConfiguration !== null
  ) {
    contents.thingGroupIndexingConfiguration = deserializeAws_restJson1_1ThingGroupIndexingConfiguration(
      data.thingGroupIndexingConfiguration,
      context
    );
  }
  if (
    data.thingIndexingConfiguration !== undefined &&
    data.thingIndexingConfiguration !== null
  ) {
    contents.thingIndexingConfiguration = deserializeAws_restJson1_1ThingIndexingConfiguration(
      data.thingIndexingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetIndexingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIndexingConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetPercentilesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPercentilesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetPercentilesCommandError(
      output,
      context
    );
  }
  const contents: GetPercentilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetPercentilesResponse",
    percentiles: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.percentiles !== undefined && data.percentiles !== null) {
    contents.percentiles = deserializeAws_restJson1_1Percentiles(
      data.percentiles,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetPercentilesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPercentilesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAggregationException":
    case "com.amazonaws.iot.common.types#InvalidAggregationException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidAggregationExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot.common.types#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidQueryExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IndexNotReadyException":
    case "com.amazonaws.iot.indexing#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1_1IndexNotReadyExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetStatisticsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStatisticsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetStatisticsCommandError(output, context);
  }
  const contents: GetStatisticsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetStatisticsResponse",
    statistics: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.statistics !== undefined && data.statistics !== null) {
    contents.statistics = deserializeAws_restJson1_1Statistics(
      data.statistics,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetStatisticsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStatisticsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidAggregationException":
    case "com.amazonaws.iot.common.types#InvalidAggregationException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidAggregationExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot.common.types#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidQueryExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IndexNotReadyException":
    case "com.amazonaws.iot.indexing#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1_1IndexNotReadyExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListIndicesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIndicesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListIndicesCommandError(output, context);
  }
  const contents: ListIndicesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListIndicesResponse",
    indexNames: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.indexNames !== undefined && data.indexNames !== null) {
    contents.indexNames = deserializeAws_restJson1_1IndexNamesList(
      data.indexNames,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListIndicesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIndicesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1SearchIndexCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchIndexCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1SearchIndexCommandError(output, context);
  }
  const contents: SearchIndexCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "SearchIndexResponse",
    nextToken: undefined,
    thingGroups: undefined,
    things: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.thingGroups !== undefined && data.thingGroups !== null) {
    contents.thingGroups = deserializeAws_restJson1_1ThingGroupDocumentList(
      data.thingGroups,
      context
    );
  }
  if (data.things !== undefined && data.things !== null) {
    contents.things = deserializeAws_restJson1_1ThingDocumentList(
      data.things,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1SearchIndexCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchIndexCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot.common.types#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidQueryExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "IndexNotReadyException":
    case "com.amazonaws.iot.indexing#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1_1IndexNotReadyExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateIndexingConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIndexingConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateIndexingConfigurationCommandError(
      output,
      context
    );
  }
  const contents: UpdateIndexingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateIndexingConfigurationResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateIndexingConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIndexingConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AssociateTargetsWithJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateTargetsWithJobCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AssociateTargetsWithJobCommandError(
      output,
      context
    );
  }
  const contents: AssociateTargetsWithJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateTargetsWithJobResponse",
    description: undefined,
    jobArn: undefined,
    jobId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.jobArn !== undefined && data.jobArn !== null) {
    contents.jobArn = data.jobArn;
  }
  if (data.jobId !== undefined && data.jobId !== null) {
    contents.jobId = data.jobId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AssociateTargetsWithJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateTargetsWithJobCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CancelJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelJobCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CancelJobCommandError(output, context);
  }
  const contents: CancelJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelJobResponse",
    description: undefined,
    jobArn: undefined,
    jobId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.jobArn !== undefined && data.jobArn !== null) {
    contents.jobArn = data.jobArn;
  }
  if (data.jobId !== undefined && data.jobId !== null) {
    contents.jobId = data.jobId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CancelJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelJobCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CancelJobExecutionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelJobExecutionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CancelJobExecutionCommandError(
      output,
      context
    );
  }
  const contents: CancelJobExecutionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CancelJobExecutionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelJobExecutionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidStateTransitionException":
    case "com.amazonaws.iot.common.types#InvalidStateTransitionException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidStateTransitionExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateJobCommandError(output, context);
  }
  const contents: CreateJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateJobResponse",
    description: undefined,
    jobArn: undefined,
    jobId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.jobArn !== undefined && data.jobArn !== null) {
    contents.jobArn = data.jobArn;
  }
  if (data.jobId !== undefined && data.jobId !== null) {
    contents.jobId = data.jobId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteJobCommandError(output, context);
  }
  const contents: DeleteJobCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidStateTransitionException":
    case "com.amazonaws.iot.common.types#InvalidStateTransitionException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidStateTransitionExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteJobExecutionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobExecutionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteJobExecutionCommandError(
      output,
      context
    );
  }
  const contents: DeleteJobExecutionCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteJobExecutionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobExecutionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidStateTransitionException":
    case "com.amazonaws.iot.common.types#InvalidStateTransitionException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidStateTransitionExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeJobCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeJobCommandError(output, context);
  }
  const contents: DescribeJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeJobResponse",
    documentSource: undefined,
    job: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.documentSource !== undefined && data.documentSource !== null) {
    contents.documentSource = data.documentSource;
  }
  if (data.job !== undefined && data.job !== null) {
    contents.job = deserializeAws_restJson1_1Job(data.job, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeJobCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeJobExecutionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeJobExecutionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeJobExecutionCommandError(
      output,
      context
    );
  }
  const contents: DescribeJobExecutionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeJobExecutionResponse",
    execution: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.execution !== undefined && data.execution !== null) {
    contents.execution = deserializeAws_restJson1_1JobExecution(
      data.execution,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeJobExecutionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeJobExecutionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetJobDocumentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobDocumentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetJobDocumentCommandError(
      output,
      context
    );
  }
  const contents: GetJobDocumentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetJobDocumentResponse",
    document: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.document !== undefined && data.document !== null) {
    contents.document = data.document;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetJobDocumentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobDocumentCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListJobExecutionsForJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobExecutionsForJobCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListJobExecutionsForJobCommandError(
      output,
      context
    );
  }
  const contents: ListJobExecutionsForJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListJobExecutionsForJobResponse",
    executionSummaries: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.executionSummaries !== undefined &&
    data.executionSummaries !== null
  ) {
    contents.executionSummaries = deserializeAws_restJson1_1JobExecutionSummaryForJobList(
      data.executionSummaries,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListJobExecutionsForJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobExecutionsForJobCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListJobExecutionsForThingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobExecutionsForThingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListJobExecutionsForThingCommandError(
      output,
      context
    );
  }
  const contents: ListJobExecutionsForThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListJobExecutionsForThingResponse",
    executionSummaries: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.executionSummaries !== undefined &&
    data.executionSummaries !== null
  ) {
    contents.executionSummaries = deserializeAws_restJson1_1JobExecutionSummaryForThingList(
      data.executionSummaries,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListJobExecutionsForThingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobExecutionsForThingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListJobsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListJobsCommandError(output, context);
  }
  const contents: ListJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListJobsResponse",
    jobs: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.jobs !== undefined && data.jobs !== null) {
    contents.jobs = deserializeAws_restJson1_1JobSummaryList(
      data.jobs,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListJobsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateJobCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateJobCommandError(output, context);
  }
  const contents: UpdateJobCommandOutput = {
    $metadata: deserializeMetadata(output)
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateJobCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateOTAUpdateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateOTAUpdateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateOTAUpdateCommandError(
      output,
      context
    );
  }
  const contents: CreateOTAUpdateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateOTAUpdateResponse",
    awsIotJobArn: undefined,
    awsIotJobId: undefined,
    otaUpdateArn: undefined,
    otaUpdateId: undefined,
    otaUpdateStatus: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.awsIotJobArn !== undefined && data.awsIotJobArn !== null) {
    contents.awsIotJobArn = data.awsIotJobArn;
  }
  if (data.awsIotJobId !== undefined && data.awsIotJobId !== null) {
    contents.awsIotJobId = data.awsIotJobId;
  }
  if (data.otaUpdateArn !== undefined && data.otaUpdateArn !== null) {
    contents.otaUpdateArn = data.otaUpdateArn;
  }
  if (data.otaUpdateId !== undefined && data.otaUpdateId !== null) {
    contents.otaUpdateId = data.otaUpdateId;
  }
  if (data.otaUpdateStatus !== undefined && data.otaUpdateStatus !== null) {
    contents.otaUpdateStatus = data.otaUpdateStatus;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateOTAUpdateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateOTAUpdateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteOTAUpdateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteOTAUpdateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteOTAUpdateCommandError(
      output,
      context
    );
  }
  const contents: DeleteOTAUpdateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteOTAUpdateResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteOTAUpdateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteOTAUpdateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1GetOTAUpdateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetOTAUpdateCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1GetOTAUpdateCommandError(output, context);
  }
  const contents: GetOTAUpdateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetOTAUpdateResponse",
    otaUpdateInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.otaUpdateInfo !== undefined && data.otaUpdateInfo !== null) {
    contents.otaUpdateInfo = deserializeAws_restJson1_1OTAUpdateInfo(
      data.otaUpdateInfo,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1GetOTAUpdateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetOTAUpdateCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListOTAUpdatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListOTAUpdatesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListOTAUpdatesCommandError(
      output,
      context
    );
  }
  const contents: ListOTAUpdatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListOTAUpdatesResponse",
    nextToken: undefined,
    otaUpdates: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.otaUpdates !== undefined && data.otaUpdates !== null) {
    contents.otaUpdates = deserializeAws_restJson1_1OTAUpdatesSummary(
      data.otaUpdates,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListOTAUpdatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListOTAUpdatesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AddThingToBillingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddThingToBillingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AddThingToBillingGroupCommandError(
      output,
      context
    );
  }
  const contents: AddThingToBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AddThingToBillingGroupResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AddThingToBillingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddThingToBillingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AddThingToThingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddThingToThingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AddThingToThingGroupCommandError(
      output,
      context
    );
  }
  const contents: AddThingToThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AddThingToThingGroupResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AddThingToThingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddThingToThingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AttachThingPrincipalCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachThingPrincipalCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AttachThingPrincipalCommandError(
      output,
      context
    );
  }
  const contents: AttachThingPrincipalCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AttachThingPrincipalResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AttachThingPrincipalCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachThingPrincipalCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateBillingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBillingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateBillingGroupCommandError(
      output,
      context
    );
  }
  const contents: CreateBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateBillingGroupResponse",
    billingGroupArn: undefined,
    billingGroupId: undefined,
    billingGroupName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.billingGroupArn !== undefined && data.billingGroupArn !== null) {
    contents.billingGroupArn = data.billingGroupArn;
  }
  if (data.billingGroupId !== undefined && data.billingGroupId !== null) {
    contents.billingGroupId = data.billingGroupId;
  }
  if (data.billingGroupName !== undefined && data.billingGroupName !== null) {
    contents.billingGroupName = data.billingGroupName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateBillingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBillingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateDynamicThingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDynamicThingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateDynamicThingGroupCommandError(
      output,
      context
    );
  }
  const contents: CreateDynamicThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateDynamicThingGroupResponse",
    indexName: undefined,
    queryString: undefined,
    queryVersion: undefined,
    thingGroupArn: undefined,
    thingGroupId: undefined,
    thingGroupName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.indexName !== undefined && data.indexName !== null) {
    contents.indexName = data.indexName;
  }
  if (data.queryString !== undefined && data.queryString !== null) {
    contents.queryString = data.queryString;
  }
  if (data.queryVersion !== undefined && data.queryVersion !== null) {
    contents.queryVersion = data.queryVersion;
  }
  if (data.thingGroupArn !== undefined && data.thingGroupArn !== null) {
    contents.thingGroupArn = data.thingGroupArn;
  }
  if (data.thingGroupId !== undefined && data.thingGroupId !== null) {
    contents.thingGroupId = data.thingGroupId;
  }
  if (data.thingGroupName !== undefined && data.thingGroupName !== null) {
    contents.thingGroupName = data.thingGroupName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateDynamicThingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDynamicThingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot.common.types#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidQueryExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateThingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateThingCommandError(output, context);
  }
  const contents: CreateThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateThingResponse",
    thingArn: undefined,
    thingId: undefined,
    thingName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.thingArn !== undefined && data.thingArn !== null) {
    contents.thingArn = data.thingArn;
  }
  if (data.thingId !== undefined && data.thingId !== null) {
    contents.thingId = data.thingId;
  }
  if (data.thingName !== undefined && data.thingName !== null) {
    contents.thingName = data.thingName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateThingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateThingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateThingGroupCommandError(
      output,
      context
    );
  }
  const contents: CreateThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateThingGroupResponse",
    thingGroupArn: undefined,
    thingGroupId: undefined,
    thingGroupName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.thingGroupArn !== undefined && data.thingGroupArn !== null) {
    contents.thingGroupArn = data.thingGroupArn;
  }
  if (data.thingGroupId !== undefined && data.thingGroupId !== null) {
    contents.thingGroupId = data.thingGroupId;
  }
  if (data.thingGroupName !== undefined && data.thingGroupName !== null) {
    contents.thingGroupName = data.thingGroupName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateThingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateThingTypeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingTypeCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateThingTypeCommandError(
      output,
      context
    );
  }
  const contents: CreateThingTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateThingTypeResponse",
    thingTypeArn: undefined,
    thingTypeId: undefined,
    thingTypeName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.thingTypeArn !== undefined && data.thingTypeArn !== null) {
    contents.thingTypeArn = data.thingTypeArn;
  }
  if (data.thingTypeId !== undefined && data.thingTypeId !== null) {
    contents.thingTypeId = data.thingTypeId;
  }
  if (data.thingTypeName !== undefined && data.thingTypeName !== null) {
    contents.thingTypeName = data.thingTypeName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateThingTypeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingTypeCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteBillingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBillingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteBillingGroupCommandError(
      output,
      context
    );
  }
  const contents: DeleteBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteBillingGroupResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteBillingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBillingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteDynamicThingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDynamicThingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteDynamicThingGroupCommandError(
      output,
      context
    );
  }
  const contents: DeleteDynamicThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteDynamicThingGroupResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteDynamicThingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDynamicThingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteThingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteThingCommandError(output, context);
  }
  const contents: DeleteThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteThingResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteThingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteThingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteThingGroupCommandError(
      output,
      context
    );
  }
  const contents: DeleteThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteThingGroupResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteThingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteThingTypeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingTypeCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteThingTypeCommandError(
      output,
      context
    );
  }
  const contents: DeleteThingTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteThingTypeResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteThingTypeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingTypeCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeprecateThingTypeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeprecateThingTypeCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeprecateThingTypeCommandError(
      output,
      context
    );
  }
  const contents: DeprecateThingTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeprecateThingTypeResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeprecateThingTypeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeprecateThingTypeCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeBillingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeBillingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeBillingGroupCommandError(
      output,
      context
    );
  }
  const contents: DescribeBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeBillingGroupResponse",
    billingGroupArn: undefined,
    billingGroupId: undefined,
    billingGroupMetadata: undefined,
    billingGroupName: undefined,
    billingGroupProperties: undefined,
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.billingGroupArn !== undefined && data.billingGroupArn !== null) {
    contents.billingGroupArn = data.billingGroupArn;
  }
  if (data.billingGroupId !== undefined && data.billingGroupId !== null) {
    contents.billingGroupId = data.billingGroupId;
  }
  if (
    data.billingGroupMetadata !== undefined &&
    data.billingGroupMetadata !== null
  ) {
    contents.billingGroupMetadata = deserializeAws_restJson1_1BillingGroupMetadata(
      data.billingGroupMetadata,
      context
    );
  }
  if (data.billingGroupName !== undefined && data.billingGroupName !== null) {
    contents.billingGroupName = data.billingGroupName;
  }
  if (
    data.billingGroupProperties !== undefined &&
    data.billingGroupProperties !== null
  ) {
    contents.billingGroupProperties = deserializeAws_restJson1_1BillingGroupProperties(
      data.billingGroupProperties,
      context
    );
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeBillingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeBillingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeEventConfigurationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventConfigurationsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeEventConfigurationsCommandError(
      output,
      context
    );
  }
  const contents: DescribeEventConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventConfigurationsResponse",
    creationDate: undefined,
    eventConfigurations: undefined,
    lastModifiedDate: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = new Date(Math.round(data.creationDate * 1000));
  }
  if (
    data.eventConfigurations !== undefined &&
    data.eventConfigurations !== null
  ) {
    contents.eventConfigurations = deserializeAws_restJson1_1EventConfigurations(
      data.eventConfigurations,
      context
    );
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = new Date(
      Math.round(data.lastModifiedDate * 1000)
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeEventConfigurationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventConfigurationsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeThingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeThingCommandError(output, context);
  }
  const contents: DescribeThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeThingResponse",
    attributes: undefined,
    billingGroupName: undefined,
    defaultClientId: undefined,
    thingArn: undefined,
    thingId: undefined,
    thingName: undefined,
    thingTypeName: undefined,
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.attributes !== undefined && data.attributes !== null) {
    contents.attributes = deserializeAws_restJson1_1Attributes(
      data.attributes,
      context
    );
  }
  if (data.billingGroupName !== undefined && data.billingGroupName !== null) {
    contents.billingGroupName = data.billingGroupName;
  }
  if (data.defaultClientId !== undefined && data.defaultClientId !== null) {
    contents.defaultClientId = data.defaultClientId;
  }
  if (data.thingArn !== undefined && data.thingArn !== null) {
    contents.thingArn = data.thingArn;
  }
  if (data.thingId !== undefined && data.thingId !== null) {
    contents.thingId = data.thingId;
  }
  if (data.thingName !== undefined && data.thingName !== null) {
    contents.thingName = data.thingName;
  }
  if (data.thingTypeName !== undefined && data.thingTypeName !== null) {
    contents.thingTypeName = data.thingTypeName;
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeThingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeThingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeThingGroupCommandError(
      output,
      context
    );
  }
  const contents: DescribeThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeThingGroupResponse",
    indexName: undefined,
    queryString: undefined,
    queryVersion: undefined,
    status: undefined,
    thingGroupArn: undefined,
    thingGroupId: undefined,
    thingGroupMetadata: undefined,
    thingGroupName: undefined,
    thingGroupProperties: undefined,
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.indexName !== undefined && data.indexName !== null) {
    contents.indexName = data.indexName;
  }
  if (data.queryString !== undefined && data.queryString !== null) {
    contents.queryString = data.queryString;
  }
  if (data.queryVersion !== undefined && data.queryVersion !== null) {
    contents.queryVersion = data.queryVersion;
  }
  if (data.status !== undefined && data.status !== null) {
    contents.status = data.status;
  }
  if (data.thingGroupArn !== undefined && data.thingGroupArn !== null) {
    contents.thingGroupArn = data.thingGroupArn;
  }
  if (data.thingGroupId !== undefined && data.thingGroupId !== null) {
    contents.thingGroupId = data.thingGroupId;
  }
  if (
    data.thingGroupMetadata !== undefined &&
    data.thingGroupMetadata !== null
  ) {
    contents.thingGroupMetadata = deserializeAws_restJson1_1ThingGroupMetadata(
      data.thingGroupMetadata,
      context
    );
  }
  if (data.thingGroupName !== undefined && data.thingGroupName !== null) {
    contents.thingGroupName = data.thingGroupName;
  }
  if (
    data.thingGroupProperties !== undefined &&
    data.thingGroupProperties !== null
  ) {
    contents.thingGroupProperties = deserializeAws_restJson1_1ThingGroupProperties(
      data.thingGroupProperties,
      context
    );
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeThingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeThingRegistrationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingRegistrationTaskCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeThingRegistrationTaskCommandError(
      output,
      context
    );
  }
  const contents: DescribeThingRegistrationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeThingRegistrationTaskResponse",
    creationDate: undefined,
    failureCount: undefined,
    inputFileBucket: undefined,
    inputFileKey: undefined,
    lastModifiedDate: undefined,
    message: undefined,
    percentageProgress: undefined,
    roleArn: undefined,
    status: undefined,
    successCount: undefined,
    taskId: undefined,
    templateBody: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = new Date(Math.round(data.creationDate * 1000));
  }
  if (data.failureCount !== undefined && data.failureCount !== null) {
    contents.failureCount = data.failureCount;
  }
  if (data.inputFileBucket !== undefined && data.inputFileBucket !== null) {
    contents.inputFileBucket = data.inputFileBucket;
  }
  if (data.inputFileKey !== undefined && data.inputFileKey !== null) {
    contents.inputFileKey = data.inputFileKey;
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = new Date(
      Math.round(data.lastModifiedDate * 1000)
    );
  }
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  if (
    data.percentageProgress !== undefined &&
    data.percentageProgress !== null
  ) {
    contents.percentageProgress = data.percentageProgress;
  }
  if (data.roleArn !== undefined && data.roleArn !== null) {
    contents.roleArn = data.roleArn;
  }
  if (data.status !== undefined && data.status !== null) {
    contents.status = data.status;
  }
  if (data.successCount !== undefined && data.successCount !== null) {
    contents.successCount = data.successCount;
  }
  if (data.taskId !== undefined && data.taskId !== null) {
    contents.taskId = data.taskId;
  }
  if (data.templateBody !== undefined && data.templateBody !== null) {
    contents.templateBody = data.templateBody;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeThingRegistrationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingRegistrationTaskCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeThingTypeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingTypeCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeThingTypeCommandError(
      output,
      context
    );
  }
  const contents: DescribeThingTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeThingTypeResponse",
    thingTypeArn: undefined,
    thingTypeId: undefined,
    thingTypeMetadata: undefined,
    thingTypeName: undefined,
    thingTypeProperties: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.thingTypeArn !== undefined && data.thingTypeArn !== null) {
    contents.thingTypeArn = data.thingTypeArn;
  }
  if (data.thingTypeId !== undefined && data.thingTypeId !== null) {
    contents.thingTypeId = data.thingTypeId;
  }
  if (data.thingTypeMetadata !== undefined && data.thingTypeMetadata !== null) {
    contents.thingTypeMetadata = deserializeAws_restJson1_1ThingTypeMetadata(
      data.thingTypeMetadata,
      context
    );
  }
  if (data.thingTypeName !== undefined && data.thingTypeName !== null) {
    contents.thingTypeName = data.thingTypeName;
  }
  if (
    data.thingTypeProperties !== undefined &&
    data.thingTypeProperties !== null
  ) {
    contents.thingTypeProperties = deserializeAws_restJson1_1ThingTypeProperties(
      data.thingTypeProperties,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeThingTypeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingTypeCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DetachThingPrincipalCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachThingPrincipalCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DetachThingPrincipalCommandError(
      output,
      context
    );
  }
  const contents: DetachThingPrincipalCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetachThingPrincipalResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DetachThingPrincipalCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachThingPrincipalCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListBillingGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBillingGroupsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListBillingGroupsCommandError(
      output,
      context
    );
  }
  const contents: ListBillingGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListBillingGroupsResponse",
    billingGroups: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.billingGroups !== undefined && data.billingGroups !== null) {
    contents.billingGroups = deserializeAws_restJson1_1BillingGroupNameAndArnList(
      data.billingGroups,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListBillingGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBillingGroupsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListPrincipalThingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPrincipalThingsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListPrincipalThingsCommandError(
      output,
      context
    );
  }
  const contents: ListPrincipalThingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListPrincipalThingsResponse",
    nextToken: undefined,
    things: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.things !== undefined && data.things !== null) {
    contents.things = deserializeAws_restJson1_1ThingNameList(
      data.things,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListPrincipalThingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPrincipalThingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const contents: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    nextToken: undefined,
    tags: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1_1TagList(data.tags, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListThingGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingGroupsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListThingGroupsCommandError(
      output,
      context
    );
  }
  const contents: ListThingGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListThingGroupsResponse",
    nextToken: undefined,
    thingGroups: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.thingGroups !== undefined && data.thingGroups !== null) {
    contents.thingGroups = deserializeAws_restJson1_1ThingGroupNameAndArnList(
      data.thingGroups,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListThingGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingGroupsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListThingGroupsForThingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingGroupsForThingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListThingGroupsForThingCommandError(
      output,
      context
    );
  }
  const contents: ListThingGroupsForThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListThingGroupsForThingResponse",
    nextToken: undefined,
    thingGroups: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.thingGroups !== undefined && data.thingGroups !== null) {
    contents.thingGroups = deserializeAws_restJson1_1ThingGroupNameAndArnList(
      data.thingGroups,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListThingGroupsForThingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingGroupsForThingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListThingPrincipalsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingPrincipalsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListThingPrincipalsCommandError(
      output,
      context
    );
  }
  const contents: ListThingPrincipalsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListThingPrincipalsResponse",
    principals: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.principals !== undefined && data.principals !== null) {
    contents.principals = deserializeAws_restJson1_1Principals(
      data.principals,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListThingPrincipalsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingPrincipalsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListThingRegistrationTaskReportsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingRegistrationTaskReportsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListThingRegistrationTaskReportsCommandError(
      output,
      context
    );
  }
  const contents: ListThingRegistrationTaskReportsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListThingRegistrationTaskReportsResponse",
    nextToken: undefined,
    reportType: undefined,
    resourceLinks: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.reportType !== undefined && data.reportType !== null) {
    contents.reportType = data.reportType;
  }
  if (data.resourceLinks !== undefined && data.resourceLinks !== null) {
    contents.resourceLinks = deserializeAws_restJson1_1S3FileUrlList(
      data.resourceLinks,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListThingRegistrationTaskReportsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingRegistrationTaskReportsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListThingRegistrationTasksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingRegistrationTasksCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListThingRegistrationTasksCommandError(
      output,
      context
    );
  }
  const contents: ListThingRegistrationTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListThingRegistrationTasksResponse",
    nextToken: undefined,
    taskIds: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.taskIds !== undefined && data.taskIds !== null) {
    contents.taskIds = deserializeAws_restJson1_1TaskIdList(
      data.taskIds,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListThingRegistrationTasksCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingRegistrationTasksCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListThingTypesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingTypesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListThingTypesCommandError(
      output,
      context
    );
  }
  const contents: ListThingTypesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListThingTypesResponse",
    nextToken: undefined,
    thingTypes: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.thingTypes !== undefined && data.thingTypes !== null) {
    contents.thingTypes = deserializeAws_restJson1_1ThingTypeList(
      data.thingTypes,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListThingTypesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingTypesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListThingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListThingsCommandError(output, context);
  }
  const contents: ListThingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListThingsResponse",
    nextToken: undefined,
    things: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.things !== undefined && data.things !== null) {
    contents.things = deserializeAws_restJson1_1ThingAttributeList(
      data.things,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListThingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListThingsInBillingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsInBillingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListThingsInBillingGroupCommandError(
      output,
      context
    );
  }
  const contents: ListThingsInBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListThingsInBillingGroupResponse",
    nextToken: undefined,
    things: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.things !== undefined && data.things !== null) {
    contents.things = deserializeAws_restJson1_1ThingNameList(
      data.things,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListThingsInBillingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsInBillingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListThingsInThingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsInThingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListThingsInThingGroupCommandError(
      output,
      context
    );
  }
  const contents: ListThingsInThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListThingsInThingGroupResponse",
    nextToken: undefined,
    things: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.things !== undefined && data.things !== null) {
    contents.things = deserializeAws_restJson1_1ThingNameList(
      data.things,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListThingsInThingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsInThingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1RemoveThingFromBillingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveThingFromBillingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1RemoveThingFromBillingGroupCommandError(
      output,
      context
    );
  }
  const contents: RemoveThingFromBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveThingFromBillingGroupResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1RemoveThingFromBillingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveThingFromBillingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1RemoveThingFromThingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveThingFromThingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1RemoveThingFromThingGroupCommandError(
      output,
      context
    );
  }
  const contents: RemoveThingFromThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveThingFromThingGroupResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1RemoveThingFromThingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveThingFromThingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1StartThingRegistrationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartThingRegistrationTaskCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1StartThingRegistrationTaskCommandError(
      output,
      context
    );
  }
  const contents: StartThingRegistrationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartThingRegistrationTaskResponse",
    taskId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.taskId !== undefined && data.taskId !== null) {
    contents.taskId = data.taskId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1StartThingRegistrationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartThingRegistrationTaskCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1StopThingRegistrationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopThingRegistrationTaskCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1StopThingRegistrationTaskCommandError(
      output,
      context
    );
  }
  const contents: StopThingRegistrationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopThingRegistrationTaskResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1StopThingRegistrationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopThingRegistrationTaskCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1TagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1TagResourceCommandError(output, context);
  }
  const contents: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TagResourceResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1TagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UntagResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UntagResourceCommandError(output, context);
  }
  const contents: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UntagResourceResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UntagResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateBillingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBillingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateBillingGroupCommandError(
      output,
      context
    );
  }
  const contents: UpdateBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateBillingGroupResponse",
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateBillingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBillingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateDynamicThingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDynamicThingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateDynamicThingGroupCommandError(
      output,
      context
    );
  }
  const contents: UpdateDynamicThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateDynamicThingGroupResponse",
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateDynamicThingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDynamicThingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot.common.types#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidQueryExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateEventConfigurationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEventConfigurationsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateEventConfigurationsCommandError(
      output,
      context
    );
  }
  const contents: UpdateEventConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateEventConfigurationsResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateEventConfigurationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEventConfigurationsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateThingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateThingCommandError(output, context);
  }
  const contents: UpdateThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateThingResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateThingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateThingGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingGroupCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateThingGroupCommandError(
      output,
      context
    );
  }
  const contents: UpdateThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateThingGroupResponse",
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateThingGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingGroupCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateThingGroupsForThingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingGroupsForThingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateThingGroupsForThingCommandError(
      output,
      context
    );
  }
  const contents: UpdateThingGroupsForThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateThingGroupsForThingResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateThingGroupsForThingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingGroupsForThingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1AttachSecurityProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachSecurityProfileCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1AttachSecurityProfileCommandError(
      output,
      context
    );
  }
  const contents: AttachSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AttachSecurityProfileResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1AttachSecurityProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachSecurityProfileCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CancelAuditMitigationActionsTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelAuditMitigationActionsTaskCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CancelAuditMitigationActionsTaskCommandError(
      output,
      context
    );
  }
  const contents: CancelAuditMitigationActionsTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelAuditMitigationActionsTaskResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CancelAuditMitigationActionsTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelAuditMitigationActionsTaskCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CancelAuditTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelAuditTaskCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CancelAuditTaskCommandError(
      output,
      context
    );
  }
  const contents: CancelAuditTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CancelAuditTaskResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CancelAuditTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelAuditTaskCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateMitigationActionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMitigationActionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateMitigationActionCommandError(
      output,
      context
    );
  }
  const contents: CreateMitigationActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateMitigationActionResponse",
    actionArn: undefined,
    actionId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.actionArn !== undefined && data.actionArn !== null) {
    contents.actionArn = data.actionArn;
  }
  if (data.actionId !== undefined && data.actionId !== null) {
    contents.actionId = data.actionId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateMitigationActionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMitigationActionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateScheduledAuditCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScheduledAuditCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateScheduledAuditCommandError(
      output,
      context
    );
  }
  const contents: CreateScheduledAuditCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateScheduledAuditResponse",
    scheduledAuditArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.scheduledAuditArn !== undefined && data.scheduledAuditArn !== null) {
    contents.scheduledAuditArn = data.scheduledAuditArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateScheduledAuditCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScheduledAuditCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateSecurityProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityProfileCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateSecurityProfileCommandError(
      output,
      context
    );
  }
  const contents: CreateSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateSecurityProfileResponse",
    securityProfileArn: undefined,
    securityProfileName: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.securityProfileArn !== undefined &&
    data.securityProfileArn !== null
  ) {
    contents.securityProfileArn = data.securityProfileArn;
  }
  if (
    data.securityProfileName !== undefined &&
    data.securityProfileName !== null
  ) {
    contents.securityProfileName = data.securityProfileName;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateSecurityProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityProfileCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteAccountAuditConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAccountAuditConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteAccountAuditConfigurationCommandError(
      output,
      context
    );
  }
  const contents: DeleteAccountAuditConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteAccountAuditConfigurationResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteAccountAuditConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAccountAuditConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteMitigationActionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMitigationActionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteMitigationActionCommandError(
      output,
      context
    );
  }
  const contents: DeleteMitigationActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteMitigationActionResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteMitigationActionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMitigationActionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteScheduledAuditCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteScheduledAuditCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteScheduledAuditCommandError(
      output,
      context
    );
  }
  const contents: DeleteScheduledAuditCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteScheduledAuditResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteScheduledAuditCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteScheduledAuditCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteSecurityProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityProfileCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteSecurityProfileCommandError(
      output,
      context
    );
  }
  const contents: DeleteSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteSecurityProfileResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteSecurityProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityProfileCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeAccountAuditConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAuditConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeAccountAuditConfigurationCommandError(
      output,
      context
    );
  }
  const contents: DescribeAccountAuditConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAccountAuditConfigurationResponse",
    auditCheckConfigurations: undefined,
    auditNotificationTargetConfigurations: undefined,
    roleArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.auditCheckConfigurations !== undefined &&
    data.auditCheckConfigurations !== null
  ) {
    contents.auditCheckConfigurations = deserializeAws_restJson1_1AuditCheckConfigurations(
      data.auditCheckConfigurations,
      context
    );
  }
  if (
    data.auditNotificationTargetConfigurations !== undefined &&
    data.auditNotificationTargetConfigurations !== null
  ) {
    contents.auditNotificationTargetConfigurations = deserializeAws_restJson1_1AuditNotificationTargetConfigurations(
      data.auditNotificationTargetConfigurations,
      context
    );
  }
  if (data.roleArn !== undefined && data.roleArn !== null) {
    contents.roleArn = data.roleArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeAccountAuditConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAuditConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeAuditFindingCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditFindingCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeAuditFindingCommandError(
      output,
      context
    );
  }
  const contents: DescribeAuditFindingCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAuditFindingResponse",
    finding: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.finding !== undefined && data.finding !== null) {
    contents.finding = deserializeAws_restJson1_1AuditFinding(
      data.finding,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeAuditFindingCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditFindingCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeAuditMitigationActionsTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditMitigationActionsTaskCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeAuditMitigationActionsTaskCommandError(
      output,
      context
    );
  }
  const contents: DescribeAuditMitigationActionsTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAuditMitigationActionsTaskResponse",
    actionsDefinition: undefined,
    auditCheckToActionsMapping: undefined,
    endTime: undefined,
    startTime: undefined,
    target: undefined,
    taskStatistics: undefined,
    taskStatus: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.actionsDefinition !== undefined && data.actionsDefinition !== null) {
    contents.actionsDefinition = deserializeAws_restJson1_1MitigationActionList(
      data.actionsDefinition,
      context
    );
  }
  if (
    data.auditCheckToActionsMapping !== undefined &&
    data.auditCheckToActionsMapping !== null
  ) {
    contents.auditCheckToActionsMapping = deserializeAws_restJson1_1AuditCheckToActionsMapping(
      data.auditCheckToActionsMapping,
      context
    );
  }
  if (data.endTime !== undefined && data.endTime !== null) {
    contents.endTime = new Date(Math.round(data.endTime * 1000));
  }
  if (data.startTime !== undefined && data.startTime !== null) {
    contents.startTime = new Date(Math.round(data.startTime * 1000));
  }
  if (data.target !== undefined && data.target !== null) {
    contents.target = deserializeAws_restJson1_1AuditMitigationActionsTaskTarget(
      data.target,
      context
    );
  }
  if (data.taskStatistics !== undefined && data.taskStatistics !== null) {
    contents.taskStatistics = deserializeAws_restJson1_1AuditMitigationActionsTaskStatistics(
      data.taskStatistics,
      context
    );
  }
  if (data.taskStatus !== undefined && data.taskStatus !== null) {
    contents.taskStatus = data.taskStatus;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeAuditMitigationActionsTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditMitigationActionsTaskCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeAuditTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditTaskCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeAuditTaskCommandError(
      output,
      context
    );
  }
  const contents: DescribeAuditTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAuditTaskResponse",
    auditDetails: undefined,
    scheduledAuditName: undefined,
    taskStartTime: undefined,
    taskStatistics: undefined,
    taskStatus: undefined,
    taskType: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.auditDetails !== undefined && data.auditDetails !== null) {
    contents.auditDetails = deserializeAws_restJson1_1AuditDetails(
      data.auditDetails,
      context
    );
  }
  if (
    data.scheduledAuditName !== undefined &&
    data.scheduledAuditName !== null
  ) {
    contents.scheduledAuditName = data.scheduledAuditName;
  }
  if (data.taskStartTime !== undefined && data.taskStartTime !== null) {
    contents.taskStartTime = new Date(Math.round(data.taskStartTime * 1000));
  }
  if (data.taskStatistics !== undefined && data.taskStatistics !== null) {
    contents.taskStatistics = deserializeAws_restJson1_1TaskStatistics(
      data.taskStatistics,
      context
    );
  }
  if (data.taskStatus !== undefined && data.taskStatus !== null) {
    contents.taskStatus = data.taskStatus;
  }
  if (data.taskType !== undefined && data.taskType !== null) {
    contents.taskType = data.taskType;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeAuditTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditTaskCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeMitigationActionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMitigationActionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeMitigationActionCommandError(
      output,
      context
    );
  }
  const contents: DescribeMitigationActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeMitigationActionResponse",
    actionArn: undefined,
    actionId: undefined,
    actionName: undefined,
    actionParams: undefined,
    actionType: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    roleArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.actionArn !== undefined && data.actionArn !== null) {
    contents.actionArn = data.actionArn;
  }
  if (data.actionId !== undefined && data.actionId !== null) {
    contents.actionId = data.actionId;
  }
  if (data.actionName !== undefined && data.actionName !== null) {
    contents.actionName = data.actionName;
  }
  if (data.actionParams !== undefined && data.actionParams !== null) {
    contents.actionParams = deserializeAws_restJson1_1MitigationActionParams(
      data.actionParams,
      context
    );
  }
  if (data.actionType !== undefined && data.actionType !== null) {
    contents.actionType = data.actionType;
  }
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = new Date(Math.round(data.creationDate * 1000));
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = new Date(
      Math.round(data.lastModifiedDate * 1000)
    );
  }
  if (data.roleArn !== undefined && data.roleArn !== null) {
    contents.roleArn = data.roleArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeMitigationActionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMitigationActionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeScheduledAuditCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScheduledAuditCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeScheduledAuditCommandError(
      output,
      context
    );
  }
  const contents: DescribeScheduledAuditCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeScheduledAuditResponse",
    dayOfMonth: undefined,
    dayOfWeek: undefined,
    frequency: undefined,
    scheduledAuditArn: undefined,
    scheduledAuditName: undefined,
    targetCheckNames: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.dayOfMonth !== undefined && data.dayOfMonth !== null) {
    contents.dayOfMonth = data.dayOfMonth;
  }
  if (data.dayOfWeek !== undefined && data.dayOfWeek !== null) {
    contents.dayOfWeek = data.dayOfWeek;
  }
  if (data.frequency !== undefined && data.frequency !== null) {
    contents.frequency = data.frequency;
  }
  if (data.scheduledAuditArn !== undefined && data.scheduledAuditArn !== null) {
    contents.scheduledAuditArn = data.scheduledAuditArn;
  }
  if (
    data.scheduledAuditName !== undefined &&
    data.scheduledAuditName !== null
  ) {
    contents.scheduledAuditName = data.scheduledAuditName;
  }
  if (data.targetCheckNames !== undefined && data.targetCheckNames !== null) {
    contents.targetCheckNames = deserializeAws_restJson1_1TargetAuditCheckNames(
      data.targetCheckNames,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeScheduledAuditCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScheduledAuditCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeSecurityProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSecurityProfileCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeSecurityProfileCommandError(
      output,
      context
    );
  }
  const contents: DescribeSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSecurityProfileResponse",
    additionalMetricsToRetain: undefined,
    alertTargets: undefined,
    behaviors: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    securityProfileArn: undefined,
    securityProfileDescription: undefined,
    securityProfileName: undefined,
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.additionalMetricsToRetain !== undefined &&
    data.additionalMetricsToRetain !== null
  ) {
    contents.additionalMetricsToRetain = deserializeAws_restJson1_1AdditionalMetricsToRetainList(
      data.additionalMetricsToRetain,
      context
    );
  }
  if (data.alertTargets !== undefined && data.alertTargets !== null) {
    contents.alertTargets = deserializeAws_restJson1_1AlertTargets(
      data.alertTargets,
      context
    );
  }
  if (data.behaviors !== undefined && data.behaviors !== null) {
    contents.behaviors = deserializeAws_restJson1_1Behaviors(
      data.behaviors,
      context
    );
  }
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = new Date(Math.round(data.creationDate * 1000));
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = new Date(
      Math.round(data.lastModifiedDate * 1000)
    );
  }
  if (
    data.securityProfileArn !== undefined &&
    data.securityProfileArn !== null
  ) {
    contents.securityProfileArn = data.securityProfileArn;
  }
  if (
    data.securityProfileDescription !== undefined &&
    data.securityProfileDescription !== null
  ) {
    contents.securityProfileDescription = data.securityProfileDescription;
  }
  if (
    data.securityProfileName !== undefined &&
    data.securityProfileName !== null
  ) {
    contents.securityProfileName = data.securityProfileName;
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeSecurityProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSecurityProfileCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DetachSecurityProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachSecurityProfileCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DetachSecurityProfileCommandError(
      output,
      context
    );
  }
  const contents: DetachSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DetachSecurityProfileResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DetachSecurityProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachSecurityProfileCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListActiveViolationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListActiveViolationsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListActiveViolationsCommandError(
      output,
      context
    );
  }
  const contents: ListActiveViolationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListActiveViolationsResponse",
    activeViolations: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.activeViolations !== undefined && data.activeViolations !== null) {
    contents.activeViolations = deserializeAws_restJson1_1ActiveViolations(
      data.activeViolations,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListActiveViolationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListActiveViolationsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListAuditFindingsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditFindingsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListAuditFindingsCommandError(
      output,
      context
    );
  }
  const contents: ListAuditFindingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAuditFindingsResponse",
    findings: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.findings !== undefined && data.findings !== null) {
    contents.findings = deserializeAws_restJson1_1AuditFindings(
      data.findings,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListAuditFindingsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditFindingsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListAuditMitigationActionsExecutionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditMitigationActionsExecutionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListAuditMitigationActionsExecutionsCommandError(
      output,
      context
    );
  }
  const contents: ListAuditMitigationActionsExecutionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAuditMitigationActionsExecutionsResponse",
    actionsExecutions: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.actionsExecutions !== undefined && data.actionsExecutions !== null) {
    contents.actionsExecutions = deserializeAws_restJson1_1AuditMitigationActionExecutionMetadataList(
      data.actionsExecutions,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListAuditMitigationActionsExecutionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditMitigationActionsExecutionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListAuditMitigationActionsTasksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditMitigationActionsTasksCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListAuditMitigationActionsTasksCommandError(
      output,
      context
    );
  }
  const contents: ListAuditMitigationActionsTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAuditMitigationActionsTasksResponse",
    nextToken: undefined,
    tasks: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.tasks !== undefined && data.tasks !== null) {
    contents.tasks = deserializeAws_restJson1_1AuditMitigationActionsTaskMetadataList(
      data.tasks,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListAuditMitigationActionsTasksCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditMitigationActionsTasksCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListAuditTasksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditTasksCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListAuditTasksCommandError(
      output,
      context
    );
  }
  const contents: ListAuditTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListAuditTasksResponse",
    nextToken: undefined,
    tasks: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.tasks !== undefined && data.tasks !== null) {
    contents.tasks = deserializeAws_restJson1_1AuditTaskMetadataList(
      data.tasks,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListAuditTasksCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditTasksCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListMitigationActionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMitigationActionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListMitigationActionsCommandError(
      output,
      context
    );
  }
  const contents: ListMitigationActionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListMitigationActionsResponse",
    actionIdentifiers: undefined,
    nextToken: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.actionIdentifiers !== undefined && data.actionIdentifiers !== null) {
    contents.actionIdentifiers = deserializeAws_restJson1_1MitigationActionIdentifierList(
      data.actionIdentifiers,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListMitigationActionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMitigationActionsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListScheduledAuditsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListScheduledAuditsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListScheduledAuditsCommandError(
      output,
      context
    );
  }
  const contents: ListScheduledAuditsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListScheduledAuditsResponse",
    nextToken: undefined,
    scheduledAudits: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.scheduledAudits !== undefined && data.scheduledAudits !== null) {
    contents.scheduledAudits = deserializeAws_restJson1_1ScheduledAuditMetadataList(
      data.scheduledAudits,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListScheduledAuditsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListScheduledAuditsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListSecurityProfilesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSecurityProfilesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListSecurityProfilesCommandError(
      output,
      context
    );
  }
  const contents: ListSecurityProfilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSecurityProfilesResponse",
    nextToken: undefined,
    securityProfileIdentifiers: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (
    data.securityProfileIdentifiers !== undefined &&
    data.securityProfileIdentifiers !== null
  ) {
    contents.securityProfileIdentifiers = deserializeAws_restJson1_1SecurityProfileIdentifiers(
      data.securityProfileIdentifiers,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListSecurityProfilesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSecurityProfilesCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListSecurityProfilesForTargetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSecurityProfilesForTargetCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListSecurityProfilesForTargetCommandError(
      output,
      context
    );
  }
  const contents: ListSecurityProfilesForTargetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListSecurityProfilesForTargetResponse",
    nextToken: undefined,
    securityProfileTargetMappings: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (
    data.securityProfileTargetMappings !== undefined &&
    data.securityProfileTargetMappings !== null
  ) {
    contents.securityProfileTargetMappings = deserializeAws_restJson1_1SecurityProfileTargetMappings(
      data.securityProfileTargetMappings,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListSecurityProfilesForTargetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSecurityProfilesForTargetCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListTargetsForSecurityProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTargetsForSecurityProfileCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListTargetsForSecurityProfileCommandError(
      output,
      context
    );
  }
  const contents: ListTargetsForSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTargetsForSecurityProfileResponse",
    nextToken: undefined,
    securityProfileTargets: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (
    data.securityProfileTargets !== undefined &&
    data.securityProfileTargets !== null
  ) {
    contents.securityProfileTargets = deserializeAws_restJson1_1SecurityProfileTargets(
      data.securityProfileTargets,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListTargetsForSecurityProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTargetsForSecurityProfileCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListViolationEventsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListViolationEventsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListViolationEventsCommandError(
      output,
      context
    );
  }
  const contents: ListViolationEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListViolationEventsResponse",
    nextToken: undefined,
    violationEvents: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.violationEvents !== undefined && data.violationEvents !== null) {
    contents.violationEvents = deserializeAws_restJson1_1ViolationEvents(
      data.violationEvents,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListViolationEventsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListViolationEventsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1StartAuditMitigationActionsTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartAuditMitigationActionsTaskCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1StartAuditMitigationActionsTaskCommandError(
      output,
      context
    );
  }
  const contents: StartAuditMitigationActionsTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartAuditMitigationActionsTaskResponse",
    taskId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.taskId !== undefined && data.taskId !== null) {
    contents.taskId = data.taskId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1StartAuditMitigationActionsTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartAuditMitigationActionsTaskCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TaskAlreadyExistsException":
    case "com.amazonaws.iot.sepio.types.audit#TaskAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1TaskAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1StartOnDemandAuditTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartOnDemandAuditTaskCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1StartOnDemandAuditTaskCommandError(
      output,
      context
    );
  }
  const contents: StartOnDemandAuditTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartOnDemandAuditTaskResponse",
    taskId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.taskId !== undefined && data.taskId !== null) {
    contents.taskId = data.taskId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1StartOnDemandAuditTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartOnDemandAuditTaskCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateAccountAuditConfigurationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountAuditConfigurationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateAccountAuditConfigurationCommandError(
      output,
      context
    );
  }
  const contents: UpdateAccountAuditConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateAccountAuditConfigurationResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateAccountAuditConfigurationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountAuditConfigurationCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateMitigationActionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMitigationActionCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateMitigationActionCommandError(
      output,
      context
    );
  }
  const contents: UpdateMitigationActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateMitigationActionResponse",
    actionArn: undefined,
    actionId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.actionArn !== undefined && data.actionArn !== null) {
    contents.actionArn = data.actionArn;
  }
  if (data.actionId !== undefined && data.actionId !== null) {
    contents.actionId = data.actionId;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateMitigationActionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMitigationActionCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateScheduledAuditCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateScheduledAuditCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateScheduledAuditCommandError(
      output,
      context
    );
  }
  const contents: UpdateScheduledAuditCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateScheduledAuditResponse",
    scheduledAuditArn: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.scheduledAuditArn !== undefined && data.scheduledAuditArn !== null) {
    contents.scheduledAuditArn = data.scheduledAuditArn;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateScheduledAuditCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateScheduledAuditCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateSecurityProfileCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSecurityProfileCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateSecurityProfileCommandError(
      output,
      context
    );
  }
  const contents: UpdateSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateSecurityProfileResponse",
    additionalMetricsToRetain: undefined,
    alertTargets: undefined,
    behaviors: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    securityProfileArn: undefined,
    securityProfileDescription: undefined,
    securityProfileName: undefined,
    version: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (
    data.additionalMetricsToRetain !== undefined &&
    data.additionalMetricsToRetain !== null
  ) {
    contents.additionalMetricsToRetain = deserializeAws_restJson1_1AdditionalMetricsToRetainList(
      data.additionalMetricsToRetain,
      context
    );
  }
  if (data.alertTargets !== undefined && data.alertTargets !== null) {
    contents.alertTargets = deserializeAws_restJson1_1AlertTargets(
      data.alertTargets,
      context
    );
  }
  if (data.behaviors !== undefined && data.behaviors !== null) {
    contents.behaviors = deserializeAws_restJson1_1Behaviors(
      data.behaviors,
      context
    );
  }
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = new Date(Math.round(data.creationDate * 1000));
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = new Date(
      Math.round(data.lastModifiedDate * 1000)
    );
  }
  if (
    data.securityProfileArn !== undefined &&
    data.securityProfileArn !== null
  ) {
    contents.securityProfileArn = data.securityProfileArn;
  }
  if (
    data.securityProfileDescription !== undefined &&
    data.securityProfileDescription !== null
  ) {
    contents.securityProfileDescription = data.securityProfileDescription;
  }
  if (
    data.securityProfileName !== undefined &&
    data.securityProfileName !== null
  ) {
    contents.securityProfileName = data.securityProfileName;
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = data.version;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateSecurityProfileCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSecurityProfileCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot.common.types#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1_1VersionConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ValidateSecurityProfileBehaviorsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ValidateSecurityProfileBehaviorsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ValidateSecurityProfileBehaviorsCommandError(
      output,
      context
    );
  }
  const contents: ValidateSecurityProfileBehaviorsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ValidateSecurityProfileBehaviorsResponse",
    valid: undefined,
    validationErrors: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.valid !== undefined && data.valid !== null) {
    contents.valid = data.valid;
  }
  if (data.validationErrors !== undefined && data.validationErrors !== null) {
    contents.validationErrors = deserializeAws_restJson1_1ValidationErrors(
      data.validationErrors,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ValidateSecurityProfileBehaviorsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ValidateSecurityProfileBehaviorsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1CreateStreamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1CreateStreamCommandError(output, context);
  }
  const contents: CreateStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateStreamResponse",
    description: undefined,
    streamArn: undefined,
    streamId: undefined,
    streamVersion: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.streamArn !== undefined && data.streamArn !== null) {
    contents.streamArn = data.streamArn;
  }
  if (data.streamId !== undefined && data.streamId !== null) {
    contents.streamId = data.streamId;
  }
  if (data.streamVersion !== undefined && data.streamVersion !== null) {
    contents.streamVersion = data.streamVersion;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1CreateStreamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot.common.types#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1_1LimitExceededExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot.common.types#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DeleteStreamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStreamCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DeleteStreamCommandError(output, context);
  }
  const contents: DeleteStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteStreamResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DeleteStreamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStreamCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot.common.types#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1_1DeleteConflictExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1DescribeStreamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStreamCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1DescribeStreamCommandError(
      output,
      context
    );
  }
  const contents: DescribeStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeStreamResponse",
    streamInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.streamInfo !== undefined && data.streamInfo !== null) {
    contents.streamInfo = deserializeAws_restJson1_1StreamInfo(
      data.streamInfo,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1DescribeStreamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStreamCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1ListStreamsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListStreamsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1ListStreamsCommandError(output, context);
  }
  const contents: ListStreamsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListStreamsResponse",
    nextToken: undefined,
    streams: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = data.nextToken;
  }
  if (data.streams !== undefined && data.streams !== null) {
    contents.streams = deserializeAws_restJson1_1StreamsSummary(
      data.streams,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1ListStreamsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListStreamsCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restJson1_1UpdateStreamCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStreamCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restJson1_1UpdateStreamCommandError(output, context);
  }
  const contents: UpdateStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateStreamResponse",
    description: undefined,
    streamArn: undefined,
    streamId: undefined,
    streamVersion: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.description !== undefined && data.description !== null) {
    contents.description = data.description;
  }
  if (data.streamArn !== undefined && data.streamArn !== null) {
    contents.streamArn = data.streamArn;
  }
  if (data.streamId !== undefined && data.streamId !== null) {
    contents.streamId = data.streamId;
  }
  if (data.streamVersion !== undefined && data.streamVersion !== null) {
    contents.streamVersion = data.streamVersion;
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restJson1_1UpdateStreamCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStreamCommandOutput> {
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  if (output.headers["x-amzn-errortype"]) {
    errorCode = output.headers["x-amzn-errortype"].split(":")[0];
  }
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot.common.types#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1_1InternalFailureExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot.common.types#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1_1InvalidRequestExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot.common.types#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1_1ResourceNotFoundExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot.common.types#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1_1ServiceUnavailableExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot.common.types#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1_1ThrottlingExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot.common.types#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1_1UnauthorizedExceptionResponse(
          output,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = await parseBody(output.body, context);
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_restJson1_1CertificateConflictExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<CertificateConflictException> => {
  const contents: CertificateConflictException = {
    name: "CertificateConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1CertificateStateExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<CertificateStateException> => {
  const contents: CertificateStateException = {
    name: "CertificateStateException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1CertificateValidationExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<CertificateValidationException> => {
  const contents: CertificateValidationException = {
    name: "CertificateValidationException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1ConflictingResourceUpdateExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ConflictingResourceUpdateException> => {
  const contents: ConflictingResourceUpdateException = {
    name: "ConflictingResourceUpdateException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1DeleteConflictExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<DeleteConflictException> => {
  const contents: DeleteConflictException = {
    name: "DeleteConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1InternalExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InternalException> => {
  const contents: InternalException = {
    name: "InternalException",
    $fault: "server",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1InternalFailureExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InternalFailureException> => {
  const contents: InternalFailureException = {
    name: "InternalFailureException",
    $fault: "server",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1InvalidAggregationExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InvalidAggregationException> => {
  const contents: InvalidAggregationException = {
    name: "InvalidAggregationException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1InvalidQueryExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InvalidQueryException> => {
  const contents: InvalidQueryException = {
    name: "InvalidQueryException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1InvalidRequestExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InvalidRequestException> => {
  const contents: InvalidRequestException = {
    name: "InvalidRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1InvalidResponseExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InvalidResponseException> => {
  const contents: InvalidResponseException = {
    name: "InvalidResponseException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1InvalidStateTransitionExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InvalidStateTransitionException> => {
  const contents: InvalidStateTransitionException = {
    name: "InvalidStateTransitionException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1LimitExceededExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<LimitExceededException> => {
  const contents: LimitExceededException = {
    name: "LimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1MalformedPolicyExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<MalformedPolicyException> => {
  const contents: MalformedPolicyException = {
    name: "MalformedPolicyException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1NotConfiguredExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<NotConfiguredException> => {
  const contents: NotConfiguredException = {
    name: "NotConfiguredException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1RegistrationCodeValidationExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<RegistrationCodeValidationException> => {
  const contents: RegistrationCodeValidationException = {
    name: "RegistrationCodeValidationException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceAlreadyExistsExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceAlreadyExistsException> => {
  const contents: ResourceAlreadyExistsException = {
    name: "ResourceAlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined,
    resourceArn: undefined,
    resourceId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  if (data.resourceArn !== undefined && data.resourceArn !== null) {
    contents.resourceArn = data.resourceArn;
  }
  if (data.resourceId !== undefined && data.resourceId !== null) {
    contents.resourceId = data.resourceId;
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceNotFoundExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceNotFoundException> => {
  const contents: ResourceNotFoundException = {
    name: "ResourceNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceRegistrationFailureExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceRegistrationFailureException> => {
  const contents: ResourceRegistrationFailureException = {
    name: "ResourceRegistrationFailureException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1ServiceUnavailableExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ServiceUnavailableException> => {
  const contents: ServiceUnavailableException = {
    name: "ServiceUnavailableException",
    $fault: "server",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1SqlParseExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<SqlParseException> => {
  const contents: SqlParseException = {
    name: "SqlParseException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1ThrottlingExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ThrottlingException> => {
  const contents: ThrottlingException = {
    name: "ThrottlingException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1TransferAlreadyCompletedExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<TransferAlreadyCompletedException> => {
  const contents: TransferAlreadyCompletedException = {
    name: "TransferAlreadyCompletedException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1TransferConflictExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<TransferConflictException> => {
  const contents: TransferConflictException = {
    name: "TransferConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1UnauthorizedExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<UnauthorizedException> => {
  const contents: UnauthorizedException = {
    name: "UnauthorizedException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1VersionConflictExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<VersionConflictException> => {
  const contents: VersionConflictException = {
    name: "VersionConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1VersionsLimitExceededExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<VersionsLimitExceededException> => {
  const contents: VersionsLimitExceededException = {
    name: "VersionsLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1IndexNotReadyExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<IndexNotReadyException> => {
  const contents: IndexNotReadyException = {
    name: "IndexNotReadyException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const deserializeAws_restJson1_1TaskAlreadyExistsExceptionResponse = async (
  output: any,
  context: __SerdeContext
): Promise<TaskAlreadyExistsException> => {
  const contents: TaskAlreadyExistsException = {
    name: "TaskAlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    message: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.message !== undefined && data.message !== null) {
    contents.message = data.message;
  }
  return contents;
};

const serializeAws_restJson1_1Configuration = (
  input: Configuration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  return bodyParams;
};

const serializeAws_restJson1_1EventConfigurations = (
  input: { [key: string]: Configuration },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1Configuration(input[key], context);
  });
  return mapParams;
};

const serializeAws_restJson1_1PolicyNames = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1Tag = (
  input: Tag,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_restJson1_1TagKeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1Tag(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1Action = (
  input: Action,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.cloudwatchAlarm !== undefined) {
    bodyParams[
      "cloudwatchAlarm"
    ] = serializeAws_restJson1_1CloudwatchAlarmAction(
      input.cloudwatchAlarm,
      context
    );
  }
  if (input.cloudwatchMetric !== undefined) {
    bodyParams[
      "cloudwatchMetric"
    ] = serializeAws_restJson1_1CloudwatchMetricAction(
      input.cloudwatchMetric,
      context
    );
  }
  if (input.dynamoDB !== undefined) {
    bodyParams["dynamoDB"] = serializeAws_restJson1_1DynamoDBAction(
      input.dynamoDB,
      context
    );
  }
  if (input.dynamoDBv2 !== undefined) {
    bodyParams["dynamoDBv2"] = serializeAws_restJson1_1DynamoDBv2Action(
      input.dynamoDBv2,
      context
    );
  }
  if (input.elasticsearch !== undefined) {
    bodyParams["elasticsearch"] = serializeAws_restJson1_1ElasticsearchAction(
      input.elasticsearch,
      context
    );
  }
  if (input.firehose !== undefined) {
    bodyParams["firehose"] = serializeAws_restJson1_1FirehoseAction(
      input.firehose,
      context
    );
  }
  if (input.http !== undefined) {
    bodyParams["http"] = serializeAws_restJson1_1HttpAction(
      input.http,
      context
    );
  }
  if (input.iotAnalytics !== undefined) {
    bodyParams["iotAnalytics"] = serializeAws_restJson1_1IotAnalyticsAction(
      input.iotAnalytics,
      context
    );
  }
  if (input.iotEvents !== undefined) {
    bodyParams["iotEvents"] = serializeAws_restJson1_1IotEventsAction(
      input.iotEvents,
      context
    );
  }
  if (input.iotSiteWise !== undefined) {
    bodyParams["iotSiteWise"] = serializeAws_restJson1_1IotSiteWiseAction(
      input.iotSiteWise,
      context
    );
  }
  if (input.kinesis !== undefined) {
    bodyParams["kinesis"] = serializeAws_restJson1_1KinesisAction(
      input.kinesis,
      context
    );
  }
  if (input.lambda !== undefined) {
    bodyParams["lambda"] = serializeAws_restJson1_1LambdaAction(
      input.lambda,
      context
    );
  }
  if (input.republish !== undefined) {
    bodyParams["republish"] = serializeAws_restJson1_1RepublishAction(
      input.republish,
      context
    );
  }
  if (input.s3 !== undefined) {
    bodyParams["s3"] = serializeAws_restJson1_1S3Action(input.s3, context);
  }
  if (input.salesforce !== undefined) {
    bodyParams["salesforce"] = serializeAws_restJson1_1SalesforceAction(
      input.salesforce,
      context
    );
  }
  if (input.sns !== undefined) {
    bodyParams["sns"] = serializeAws_restJson1_1SnsAction(input.sns, context);
  }
  if (input.sqs !== undefined) {
    bodyParams["sqs"] = serializeAws_restJson1_1SqsAction(input.sqs, context);
  }
  if (input.stepFunctions !== undefined) {
    bodyParams["stepFunctions"] = serializeAws_restJson1_1StepFunctionsAction(
      input.stepFunctions,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1ActionList = (
  input: Array<Action>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1Action(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1AssetPropertyTimestamp = (
  input: AssetPropertyTimestamp,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.offsetInNanos !== undefined) {
    bodyParams["offsetInNanos"] = input.offsetInNanos;
  }
  if (input.timeInSeconds !== undefined) {
    bodyParams["timeInSeconds"] = input.timeInSeconds;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AssetPropertyValue = (
  input: AssetPropertyValue,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.quality !== undefined) {
    bodyParams["quality"] = input.quality;
  }
  if (input.timestamp !== undefined) {
    bodyParams["timestamp"] = serializeAws_restJson1_1AssetPropertyTimestamp(
      input.timestamp,
      context
    );
  }
  if (input.value !== undefined) {
    bodyParams["value"] = serializeAws_restJson1_1AssetPropertyVariant(
      input.value,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1AssetPropertyValueList = (
  input: Array<AssetPropertyValue>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1AssetPropertyValue(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1AssetPropertyVariant = (
  input: AssetPropertyVariant,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.booleanValue !== undefined) {
    bodyParams["booleanValue"] = input.booleanValue;
  }
  if (input.doubleValue !== undefined) {
    bodyParams["doubleValue"] = input.doubleValue;
  }
  if (input.integerValue !== undefined) {
    bodyParams["integerValue"] = input.integerValue;
  }
  if (input.stringValue !== undefined) {
    bodyParams["stringValue"] = input.stringValue;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CloudwatchAlarmAction = (
  input: CloudwatchAlarmAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.alarmName !== undefined) {
    bodyParams["alarmName"] = input.alarmName;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.stateReason !== undefined) {
    bodyParams["stateReason"] = input.stateReason;
  }
  if (input.stateValue !== undefined) {
    bodyParams["stateValue"] = input.stateValue;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CloudwatchMetricAction = (
  input: CloudwatchMetricAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.metricName !== undefined) {
    bodyParams["metricName"] = input.metricName;
  }
  if (input.metricNamespace !== undefined) {
    bodyParams["metricNamespace"] = input.metricNamespace;
  }
  if (input.metricTimestamp !== undefined) {
    bodyParams["metricTimestamp"] = input.metricTimestamp;
  }
  if (input.metricUnit !== undefined) {
    bodyParams["metricUnit"] = input.metricUnit;
  }
  if (input.metricValue !== undefined) {
    bodyParams["metricValue"] = input.metricValue;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1DynamoDBAction = (
  input: DynamoDBAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.hashKeyField !== undefined) {
    bodyParams["hashKeyField"] = input.hashKeyField;
  }
  if (input.hashKeyType !== undefined) {
    bodyParams["hashKeyType"] = input.hashKeyType;
  }
  if (input.hashKeyValue !== undefined) {
    bodyParams["hashKeyValue"] = input.hashKeyValue;
  }
  if (input.operation !== undefined) {
    bodyParams["operation"] = input.operation;
  }
  if (input.payloadField !== undefined) {
    bodyParams["payloadField"] = input.payloadField;
  }
  if (input.rangeKeyField !== undefined) {
    bodyParams["rangeKeyField"] = input.rangeKeyField;
  }
  if (input.rangeKeyType !== undefined) {
    bodyParams["rangeKeyType"] = input.rangeKeyType;
  }
  if (input.rangeKeyValue !== undefined) {
    bodyParams["rangeKeyValue"] = input.rangeKeyValue;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.tableName !== undefined) {
    bodyParams["tableName"] = input.tableName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1DynamoDBv2Action = (
  input: DynamoDBv2Action,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.putItem !== undefined) {
    bodyParams["putItem"] = serializeAws_restJson1_1PutItemInput(
      input.putItem,
      context
    );
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ElasticsearchAction = (
  input: ElasticsearchAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.endpoint !== undefined) {
    bodyParams["endpoint"] = input.endpoint;
  }
  if (input.id !== undefined) {
    bodyParams["id"] = input.id;
  }
  if (input.index !== undefined) {
    bodyParams["index"] = input.index;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.type !== undefined) {
    bodyParams["type"] = input.type;
  }
  return bodyParams;
};

const serializeAws_restJson1_1FirehoseAction = (
  input: FirehoseAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.deliveryStreamName !== undefined) {
    bodyParams["deliveryStreamName"] = input.deliveryStreamName;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.separator !== undefined) {
    bodyParams["separator"] = input.separator;
  }
  return bodyParams;
};

const serializeAws_restJson1_1HeaderList = (
  input: Array<HttpActionHeader>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1HttpActionHeader(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1HttpAction = (
  input: HttpAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.auth !== undefined) {
    bodyParams["auth"] = serializeAws_restJson1_1HttpAuthorization(
      input.auth,
      context
    );
  }
  if (input.confirmationUrl !== undefined) {
    bodyParams["confirmationUrl"] = input.confirmationUrl;
  }
  if (input.headers !== undefined) {
    bodyParams["headers"] = serializeAws_restJson1_1HeaderList(
      input.headers,
      context
    );
  }
  if (input.url !== undefined) {
    bodyParams["url"] = input.url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1HttpActionHeader = (
  input: HttpActionHeader,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.key !== undefined) {
    bodyParams["key"] = input.key;
  }
  if (input.value !== undefined) {
    bodyParams["value"] = input.value;
  }
  return bodyParams;
};

const serializeAws_restJson1_1HttpAuthorization = (
  input: HttpAuthorization,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.sigv4 !== undefined) {
    bodyParams["sigv4"] = serializeAws_restJson1_1SigV4Authorization(
      input.sigv4,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1HttpUrlDestinationConfiguration = (
  input: HttpUrlDestinationConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.confirmationUrl !== undefined) {
    bodyParams["confirmationUrl"] = input.confirmationUrl;
  }
  return bodyParams;
};

const serializeAws_restJson1_1IotAnalyticsAction = (
  input: IotAnalyticsAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.channelArn !== undefined) {
    bodyParams["channelArn"] = input.channelArn;
  }
  if (input.channelName !== undefined) {
    bodyParams["channelName"] = input.channelName;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1IotEventsAction = (
  input: IotEventsAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.inputName !== undefined) {
    bodyParams["inputName"] = input.inputName;
  }
  if (input.messageId !== undefined) {
    bodyParams["messageId"] = input.messageId;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1IotSiteWiseAction = (
  input: IotSiteWiseAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.putAssetPropertyValueEntries !== undefined) {
    bodyParams[
      "putAssetPropertyValueEntries"
    ] = serializeAws_restJson1_1PutAssetPropertyValueEntryList(
      input.putAssetPropertyValueEntries,
      context
    );
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1KinesisAction = (
  input: KinesisAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.partitionKey !== undefined) {
    bodyParams["partitionKey"] = input.partitionKey;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.streamName !== undefined) {
    bodyParams["streamName"] = input.streamName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1LambdaAction = (
  input: LambdaAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.functionArn !== undefined) {
    bodyParams["functionArn"] = input.functionArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1LogTarget = (
  input: LogTarget,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.targetName !== undefined) {
    bodyParams["targetName"] = input.targetName;
  }
  if (input.targetType !== undefined) {
    bodyParams["targetType"] = input.targetType;
  }
  return bodyParams;
};

const serializeAws_restJson1_1LoggingOptionsPayload = (
  input: LoggingOptionsPayload,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.logLevel !== undefined) {
    bodyParams["logLevel"] = input.logLevel;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1PutAssetPropertyValueEntry = (
  input: PutAssetPropertyValueEntry,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.assetId !== undefined) {
    bodyParams["assetId"] = input.assetId;
  }
  if (input.entryId !== undefined) {
    bodyParams["entryId"] = input.entryId;
  }
  if (input.propertyAlias !== undefined) {
    bodyParams["propertyAlias"] = input.propertyAlias;
  }
  if (input.propertyId !== undefined) {
    bodyParams["propertyId"] = input.propertyId;
  }
  if (input.propertyValues !== undefined) {
    bodyParams[
      "propertyValues"
    ] = serializeAws_restJson1_1AssetPropertyValueList(
      input.propertyValues,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1PutAssetPropertyValueEntryList = (
  input: Array<PutAssetPropertyValueEntry>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(
      serializeAws_restJson1_1PutAssetPropertyValueEntry(entry, context)
    );
  }
  return contents;
};

const serializeAws_restJson1_1PutItemInput = (
  input: PutItemInput,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.tableName !== undefined) {
    bodyParams["tableName"] = input.tableName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1RepublishAction = (
  input: RepublishAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.qos !== undefined) {
    bodyParams["qos"] = input.qos;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.topic !== undefined) {
    bodyParams["topic"] = input.topic;
  }
  return bodyParams;
};

const serializeAws_restJson1_1S3Action = (
  input: S3Action,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.bucketName !== undefined) {
    bodyParams["bucketName"] = input.bucketName;
  }
  if (input.cannedAcl !== undefined) {
    bodyParams["cannedAcl"] = input.cannedAcl;
  }
  if (input.key !== undefined) {
    bodyParams["key"] = input.key;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SalesforceAction = (
  input: SalesforceAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.token !== undefined) {
    bodyParams["token"] = input.token;
  }
  if (input.url !== undefined) {
    bodyParams["url"] = input.url;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SigV4Authorization = (
  input: SigV4Authorization,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.serviceName !== undefined) {
    bodyParams["serviceName"] = input.serviceName;
  }
  if (input.signingRegion !== undefined) {
    bodyParams["signingRegion"] = input.signingRegion;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SnsAction = (
  input: SnsAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.messageFormat !== undefined) {
    bodyParams["messageFormat"] = input.messageFormat;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.targetArn !== undefined) {
    bodyParams["targetArn"] = input.targetArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SqsAction = (
  input: SqsAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.queueUrl !== undefined) {
    bodyParams["queueUrl"] = input.queueUrl;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.useBase64 !== undefined) {
    bodyParams["useBase64"] = input.useBase64;
  }
  return bodyParams;
};

const serializeAws_restJson1_1StepFunctionsAction = (
  input: StepFunctionsAction,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.executionNamePrefix !== undefined) {
    bodyParams["executionNamePrefix"] = input.executionNamePrefix;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.stateMachineName !== undefined) {
    bodyParams["stateMachineName"] = input.stateMachineName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1TopicRuleDestinationConfiguration = (
  input: TopicRuleDestinationConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.httpUrlConfiguration !== undefined) {
    bodyParams[
      "httpUrlConfiguration"
    ] = serializeAws_restJson1_1HttpUrlDestinationConfiguration(
      input.httpUrlConfiguration,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1TopicRulePayload = (
  input: TopicRulePayload,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.actions !== undefined) {
    bodyParams["actions"] = serializeAws_restJson1_1ActionList(
      input.actions,
      context
    );
  }
  if (input.awsIotSqlVersion !== undefined) {
    bodyParams["awsIotSqlVersion"] = input.awsIotSqlVersion;
  }
  if (input.description !== undefined) {
    bodyParams["description"] = input.description;
  }
  if (input.errorAction !== undefined) {
    bodyParams["errorAction"] = serializeAws_restJson1_1Action(
      input.errorAction,
      context
    );
  }
  if (input.ruleDisabled !== undefined) {
    bodyParams["ruleDisabled"] = input.ruleDisabled;
  }
  if (input.sql !== undefined) {
    bodyParams["sql"] = input.sql;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AuthInfo = (
  input: AuthInfo,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.actionType !== undefined) {
    bodyParams["actionType"] = input.actionType;
  }
  if (input.resources !== undefined) {
    bodyParams["resources"] = serializeAws_restJson1_1Resources(
      input.resources,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1AuthInfos = (
  input: Array<AuthInfo>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1AuthInfo(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1AuthorizerConfig = (
  input: AuthorizerConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.allowAuthorizerOverride !== undefined) {
    bodyParams["allowAuthorizerOverride"] = input.allowAuthorizerOverride;
  }
  if (input.defaultAuthorizerName !== undefined) {
    bodyParams["defaultAuthorizerName"] = input.defaultAuthorizerName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1HttpContext = (
  input: HttpContext,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.headers !== undefined) {
    bodyParams["headers"] = serializeAws_restJson1_1HttpHeaders(
      input.headers,
      context
    );
  }
  if (input.queryString !== undefined) {
    bodyParams["queryString"] = input.queryString;
  }
  return bodyParams;
};

const serializeAws_restJson1_1HttpHeaders = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_restJson1_1MqttContext = (
  input: MqttContext,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.clientId !== undefined) {
    bodyParams["clientId"] = input.clientId;
  }
  if (input.password !== undefined) {
    bodyParams["password"] = context.base64Encoder(input.password);
  }
  if (input.username !== undefined) {
    bodyParams["username"] = input.username;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Parameters = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_restJson1_1PublicKeyMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_restJson1_1RegistrationConfig = (
  input: RegistrationConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.templateBody !== undefined) {
    bodyParams["templateBody"] = input.templateBody;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Resources = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1ServerCertificateArns = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1TlsContext = (
  input: TlsContext,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.serverName !== undefined) {
    bodyParams["serverName"] = input.serverName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Field = (
  input: Field,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.name !== undefined) {
    bodyParams["name"] = input.name;
  }
  if (input.type !== undefined) {
    bodyParams["type"] = input.type;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Fields = (
  input: Array<Field>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1Field(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1PercentList = (
  input: Array<number>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1ThingGroupIndexingConfiguration = (
  input: ThingGroupIndexingConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.customFields !== undefined) {
    bodyParams["customFields"] = serializeAws_restJson1_1Fields(
      input.customFields,
      context
    );
  }
  if (input.managedFields !== undefined) {
    bodyParams["managedFields"] = serializeAws_restJson1_1Fields(
      input.managedFields,
      context
    );
  }
  if (input.thingGroupIndexingMode !== undefined) {
    bodyParams["thingGroupIndexingMode"] = input.thingGroupIndexingMode;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ThingIndexingConfiguration = (
  input: ThingIndexingConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.customFields !== undefined) {
    bodyParams["customFields"] = serializeAws_restJson1_1Fields(
      input.customFields,
      context
    );
  }
  if (input.managedFields !== undefined) {
    bodyParams["managedFields"] = serializeAws_restJson1_1Fields(
      input.managedFields,
      context
    );
  }
  if (input.thingConnectivityIndexingMode !== undefined) {
    bodyParams["thingConnectivityIndexingMode"] =
      input.thingConnectivityIndexingMode;
  }
  if (input.thingIndexingMode !== undefined) {
    bodyParams["thingIndexingMode"] = input.thingIndexingMode;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AbortConfig = (
  input: AbortConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.criteriaList !== undefined) {
    bodyParams["criteriaList"] = serializeAws_restJson1_1AbortCriteriaList(
      input.criteriaList,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1AbortCriteria = (
  input: AbortCriteria,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.action !== undefined) {
    bodyParams["action"] = input.action;
  }
  if (input.failureType !== undefined) {
    bodyParams["failureType"] = input.failureType;
  }
  if (input.minNumberOfExecutedThings !== undefined) {
    bodyParams["minNumberOfExecutedThings"] = input.minNumberOfExecutedThings;
  }
  if (input.thresholdPercentage !== undefined) {
    bodyParams["thresholdPercentage"] = input.thresholdPercentage;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AbortCriteriaList = (
  input: Array<AbortCriteria>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1AbortCriteria(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1ExponentialRolloutRate = (
  input: ExponentialRolloutRate,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.baseRatePerMinute !== undefined) {
    bodyParams["baseRatePerMinute"] = input.baseRatePerMinute;
  }
  if (input.incrementFactor !== undefined) {
    bodyParams["incrementFactor"] = input.incrementFactor;
  }
  if (input.rateIncreaseCriteria !== undefined) {
    bodyParams[
      "rateIncreaseCriteria"
    ] = serializeAws_restJson1_1RateIncreaseCriteria(
      input.rateIncreaseCriteria,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1JobExecutionsRolloutConfig = (
  input: JobExecutionsRolloutConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.exponentialRate !== undefined) {
    bodyParams[
      "exponentialRate"
    ] = serializeAws_restJson1_1ExponentialRolloutRate(
      input.exponentialRate,
      context
    );
  }
  if (input.maximumPerMinute !== undefined) {
    bodyParams["maximumPerMinute"] = input.maximumPerMinute;
  }
  return bodyParams;
};

const serializeAws_restJson1_1JobTargets = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1PresignedUrlConfig = (
  input: PresignedUrlConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.expiresInSec !== undefined) {
    bodyParams["expiresInSec"] = input.expiresInSec;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1RateIncreaseCriteria = (
  input: RateIncreaseCriteria,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.numberOfNotifiedThings !== undefined) {
    bodyParams["numberOfNotifiedThings"] = input.numberOfNotifiedThings;
  }
  if (input.numberOfSucceededThings !== undefined) {
    bodyParams["numberOfSucceededThings"] = input.numberOfSucceededThings;
  }
  return bodyParams;
};

const serializeAws_restJson1_1TimeoutConfig = (
  input: TimeoutConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.inProgressTimeoutInMinutes !== undefined) {
    bodyParams["inProgressTimeoutInMinutes"] = input.inProgressTimeoutInMinutes;
  }
  return bodyParams;
};

const serializeAws_restJson1_1DetailsMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_restJson1_1AdditionalParameterMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_restJson1_1AttributesMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_restJson1_1AwsJobExecutionsRolloutConfig = (
  input: AwsJobExecutionsRolloutConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.maximumPerMinute !== undefined) {
    bodyParams["maximumPerMinute"] = input.maximumPerMinute;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AwsJobPresignedUrlConfig = (
  input: AwsJobPresignedUrlConfig,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.expiresInSec !== undefined) {
    bodyParams["expiresInSec"] = input.expiresInSec;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CodeSigning = (
  input: CodeSigning,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.awsSignerJobId !== undefined) {
    bodyParams["awsSignerJobId"] = input.awsSignerJobId;
  }
  if (input.customCodeSigning !== undefined) {
    bodyParams["customCodeSigning"] = serializeAws_restJson1_1CustomCodeSigning(
      input.customCodeSigning,
      context
    );
  }
  if (input.startSigningJobParameter !== undefined) {
    bodyParams[
      "startSigningJobParameter"
    ] = serializeAws_restJson1_1StartSigningJobParameter(
      input.startSigningJobParameter,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1CodeSigningCertificateChain = (
  input: CodeSigningCertificateChain,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.certificateName !== undefined) {
    bodyParams["certificateName"] = input.certificateName;
  }
  if (input.inlineDocument !== undefined) {
    bodyParams["inlineDocument"] = input.inlineDocument;
  }
  return bodyParams;
};

const serializeAws_restJson1_1CodeSigningSignature = (
  input: CodeSigningSignature,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.inlineDocument !== undefined) {
    bodyParams["inlineDocument"] = context.base64Encoder(input.inlineDocument);
  }
  return bodyParams;
};

const serializeAws_restJson1_1CustomCodeSigning = (
  input: CustomCodeSigning,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.certificateChain !== undefined) {
    bodyParams[
      "certificateChain"
    ] = serializeAws_restJson1_1CodeSigningCertificateChain(
      input.certificateChain,
      context
    );
  }
  if (input.hashAlgorithm !== undefined) {
    bodyParams["hashAlgorithm"] = input.hashAlgorithm;
  }
  if (input.signature !== undefined) {
    bodyParams["signature"] = serializeAws_restJson1_1CodeSigningSignature(
      input.signature,
      context
    );
  }
  if (input.signatureAlgorithm !== undefined) {
    bodyParams["signatureAlgorithm"] = input.signatureAlgorithm;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Destination = (
  input: Destination,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.s3Destination !== undefined) {
    bodyParams["s3Destination"] = serializeAws_restJson1_1S3Destination(
      input.s3Destination,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1FileLocation = (
  input: FileLocation,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.s3Location !== undefined) {
    bodyParams["s3Location"] = serializeAws_restJson1_1S3Location(
      input.s3Location,
      context
    );
  }
  if (input.stream !== undefined) {
    bodyParams["stream"] = serializeAws_restJson1_1_Stream(
      input.stream,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1OTAUpdateFile = (
  input: OTAUpdateFile,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.attributes !== undefined) {
    bodyParams["attributes"] = serializeAws_restJson1_1AttributesMap(
      input.attributes,
      context
    );
  }
  if (input.codeSigning !== undefined) {
    bodyParams["codeSigning"] = serializeAws_restJson1_1CodeSigning(
      input.codeSigning,
      context
    );
  }
  if (input.fileLocation !== undefined) {
    bodyParams["fileLocation"] = serializeAws_restJson1_1FileLocation(
      input.fileLocation,
      context
    );
  }
  if (input.fileName !== undefined) {
    bodyParams["fileName"] = input.fileName;
  }
  if (input.fileVersion !== undefined) {
    bodyParams["fileVersion"] = input.fileVersion;
  }
  return bodyParams;
};

const serializeAws_restJson1_1OTAUpdateFiles = (
  input: Array<OTAUpdateFile>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1OTAUpdateFile(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1Protocols = (
  input: Array<Protocol | string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1S3Destination = (
  input: S3Destination,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.bucket !== undefined) {
    bodyParams["bucket"] = input.bucket;
  }
  if (input.prefix !== undefined) {
    bodyParams["prefix"] = input.prefix;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SigningProfileParameter = (
  input: SigningProfileParameter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.certificateArn !== undefined) {
    bodyParams["certificateArn"] = input.certificateArn;
  }
  if (input.certificatePathOnDevice !== undefined) {
    bodyParams["certificatePathOnDevice"] = input.certificatePathOnDevice;
  }
  if (input.platform !== undefined) {
    bodyParams["platform"] = input.platform;
  }
  return bodyParams;
};

const serializeAws_restJson1_1StartSigningJobParameter = (
  input: StartSigningJobParameter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.destination !== undefined) {
    bodyParams["destination"] = serializeAws_restJson1_1Destination(
      input.destination,
      context
    );
  }
  if (input.signingProfileName !== undefined) {
    bodyParams["signingProfileName"] = input.signingProfileName;
  }
  if (input.signingProfileParameter !== undefined) {
    bodyParams[
      "signingProfileParameter"
    ] = serializeAws_restJson1_1SigningProfileParameter(
      input.signingProfileParameter,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1_Stream = (
  input: _Stream,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.fileId !== undefined) {
    bodyParams["fileId"] = input.fileId;
  }
  if (input.streamId !== undefined) {
    bodyParams["streamId"] = input.streamId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Targets = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1AttributePayload = (
  input: AttributePayload,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.attributes !== undefined) {
    bodyParams["attributes"] = serializeAws_restJson1_1Attributes(
      input.attributes,
      context
    );
  }
  if (input.merge !== undefined) {
    bodyParams["merge"] = input.merge;
  }
  return bodyParams;
};

const serializeAws_restJson1_1Attributes = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = input[key];
  });
  return mapParams;
};

const serializeAws_restJson1_1BillingGroupProperties = (
  input: BillingGroupProperties,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.billingGroupDescription !== undefined) {
    bodyParams["billingGroupDescription"] = input.billingGroupDescription;
  }
  return bodyParams;
};

const serializeAws_restJson1_1SearchableAttributes = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1ThingGroupList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1ThingGroupProperties = (
  input: ThingGroupProperties,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.attributePayload !== undefined) {
    bodyParams["attributePayload"] = serializeAws_restJson1_1AttributePayload(
      input.attributePayload,
      context
    );
  }
  if (input.thingGroupDescription !== undefined) {
    bodyParams["thingGroupDescription"] = input.thingGroupDescription;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ThingTypeProperties = (
  input: ThingTypeProperties,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.searchableAttributes !== undefined) {
    bodyParams[
      "searchableAttributes"
    ] = serializeAws_restJson1_1SearchableAttributes(
      input.searchableAttributes,
      context
    );
  }
  if (input.thingTypeDescription !== undefined) {
    bodyParams["thingTypeDescription"] = input.thingTypeDescription;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AddThingsToThingGroupParams = (
  input: AddThingsToThingGroupParams,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.overrideDynamicGroups !== undefined) {
    bodyParams["overrideDynamicGroups"] = input.overrideDynamicGroups;
  }
  if (input.thingGroupNames !== undefined) {
    bodyParams["thingGroupNames"] = serializeAws_restJson1_1ThingGroupNames(
      input.thingGroupNames,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1EnableIoTLoggingParams = (
  input: EnableIoTLoggingParams,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.logLevel !== undefined) {
    bodyParams["logLevel"] = input.logLevel;
  }
  if (input.roleArnForLogging !== undefined) {
    bodyParams["roleArnForLogging"] = input.roleArnForLogging;
  }
  return bodyParams;
};

const serializeAws_restJson1_1MitigationActionParams = (
  input: MitigationActionParams,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.addThingsToThingGroupParams !== undefined) {
    bodyParams[
      "addThingsToThingGroupParams"
    ] = serializeAws_restJson1_1AddThingsToThingGroupParams(
      input.addThingsToThingGroupParams,
      context
    );
  }
  if (input.enableIoTLoggingParams !== undefined) {
    bodyParams[
      "enableIoTLoggingParams"
    ] = serializeAws_restJson1_1EnableIoTLoggingParams(
      input.enableIoTLoggingParams,
      context
    );
  }
  if (input.publishFindingToSnsParams !== undefined) {
    bodyParams[
      "publishFindingToSnsParams"
    ] = serializeAws_restJson1_1PublishFindingToSnsParams(
      input.publishFindingToSnsParams,
      context
    );
  }
  if (input.replaceDefaultPolicyVersionParams !== undefined) {
    bodyParams[
      "replaceDefaultPolicyVersionParams"
    ] = serializeAws_restJson1_1ReplaceDefaultPolicyVersionParams(
      input.replaceDefaultPolicyVersionParams,
      context
    );
  }
  if (input.updateCACertificateParams !== undefined) {
    bodyParams[
      "updateCACertificateParams"
    ] = serializeAws_restJson1_1UpdateCACertificateParams(
      input.updateCACertificateParams,
      context
    );
  }
  if (input.updateDeviceCertificateParams !== undefined) {
    bodyParams[
      "updateDeviceCertificateParams"
    ] = serializeAws_restJson1_1UpdateDeviceCertificateParams(
      input.updateDeviceCertificateParams,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1PublishFindingToSnsParams = (
  input: PublishFindingToSnsParams,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.topicArn !== undefined) {
    bodyParams["topicArn"] = input.topicArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ReplaceDefaultPolicyVersionParams = (
  input: ReplaceDefaultPolicyVersionParams,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.templateName !== undefined) {
    bodyParams["templateName"] = input.templateName;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ThingGroupNames = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1UpdateCACertificateParams = (
  input: UpdateCACertificateParams,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.action !== undefined) {
    bodyParams["action"] = input.action;
  }
  return bodyParams;
};

const serializeAws_restJson1_1UpdateDeviceCertificateParams = (
  input: UpdateDeviceCertificateParams,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.action !== undefined) {
    bodyParams["action"] = input.action;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AuditCheckConfiguration = (
  input: AuditCheckConfiguration,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.enabled !== undefined) {
    bodyParams["enabled"] = input.enabled;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AuditCheckConfigurations = (
  input: { [key: string]: AuditCheckConfiguration },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1AuditCheckConfiguration(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_restJson1_1AuditCheckToActionsMapping = (
  input: { [key: string]: Array<string> },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1MitigationActionNameList(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_restJson1_1AuditCheckToReasonCodeFilter = (
  input: { [key: string]: Array<string> },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1ReasonForNonComplianceCodes(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_restJson1_1AuditMitigationActionsTaskTarget = (
  input: AuditMitigationActionsTaskTarget,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.auditCheckToReasonCodeFilter !== undefined) {
    bodyParams[
      "auditCheckToReasonCodeFilter"
    ] = serializeAws_restJson1_1AuditCheckToReasonCodeFilter(
      input.auditCheckToReasonCodeFilter,
      context
    );
  }
  if (input.auditTaskId !== undefined) {
    bodyParams["auditTaskId"] = input.auditTaskId;
  }
  if (input.findingIds !== undefined) {
    bodyParams["findingIds"] = serializeAws_restJson1_1FindingIds(
      input.findingIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1AuditNotificationTarget = (
  input: AuditNotificationTarget,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.enabled !== undefined) {
    bodyParams["enabled"] = input.enabled;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  if (input.targetArn !== undefined) {
    bodyParams["targetArn"] = input.targetArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AuditNotificationTargetConfigurations = (
  input: { [key: string]: AuditNotificationTarget },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1AuditNotificationTarget(
      input[key],
      context
    );
  });
  return mapParams;
};

const serializeAws_restJson1_1FindingIds = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1MitigationActionNameList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1PolicyVersionIdentifier = (
  input: PolicyVersionIdentifier,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.policyName !== undefined) {
    bodyParams["policyName"] = input.policyName;
  }
  if (input.policyVersionId !== undefined) {
    bodyParams["policyVersionId"] = input.policyVersionId;
  }
  return bodyParams;
};

const serializeAws_restJson1_1ReasonForNonComplianceCodes = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1ResourceIdentifier = (
  input: ResourceIdentifier,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.account !== undefined) {
    bodyParams["account"] = input.account;
  }
  if (input.caCertificateId !== undefined) {
    bodyParams["caCertificateId"] = input.caCertificateId;
  }
  if (input.clientId !== undefined) {
    bodyParams["clientId"] = input.clientId;
  }
  if (input.cognitoIdentityPoolId !== undefined) {
    bodyParams["cognitoIdentityPoolId"] = input.cognitoIdentityPoolId;
  }
  if (input.deviceCertificateId !== undefined) {
    bodyParams["deviceCertificateId"] = input.deviceCertificateId;
  }
  if (input.iamRoleArn !== undefined) {
    bodyParams["iamRoleArn"] = input.iamRoleArn;
  }
  if (input.policyVersionIdentifier !== undefined) {
    bodyParams[
      "policyVersionIdentifier"
    ] = serializeAws_restJson1_1PolicyVersionIdentifier(
      input.policyVersionIdentifier,
      context
    );
  }
  if (input.roleAliasArn !== undefined) {
    bodyParams["roleAliasArn"] = input.roleAliasArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1TargetAuditCheckNames = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1AdditionalMetricsToRetainList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1AlertTarget = (
  input: AlertTarget,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.alertTargetArn !== undefined) {
    bodyParams["alertTargetArn"] = input.alertTargetArn;
  }
  if (input.roleArn !== undefined) {
    bodyParams["roleArn"] = input.roleArn;
  }
  return bodyParams;
};

const serializeAws_restJson1_1AlertTargets = (
  input: { [key: string]: AlertTarget },
  context: __SerdeContext
): any => {
  const mapParams: any = {};
  Object.keys(input).forEach(key => {
    mapParams[key] = serializeAws_restJson1_1AlertTarget(input[key], context);
  });
  return mapParams;
};

const serializeAws_restJson1_1Behavior = (
  input: Behavior,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.criteria !== undefined) {
    bodyParams["criteria"] = serializeAws_restJson1_1BehaviorCriteria(
      input.criteria,
      context
    );
  }
  if (input.metric !== undefined) {
    bodyParams["metric"] = input.metric;
  }
  if (input.name !== undefined) {
    bodyParams["name"] = input.name;
  }
  return bodyParams;
};

const serializeAws_restJson1_1BehaviorCriteria = (
  input: BehaviorCriteria,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.comparisonOperator !== undefined) {
    bodyParams["comparisonOperator"] = input.comparisonOperator;
  }
  if (input.consecutiveDatapointsToAlarm !== undefined) {
    bodyParams["consecutiveDatapointsToAlarm"] =
      input.consecutiveDatapointsToAlarm;
  }
  if (input.consecutiveDatapointsToClear !== undefined) {
    bodyParams["consecutiveDatapointsToClear"] =
      input.consecutiveDatapointsToClear;
  }
  if (input.durationSeconds !== undefined) {
    bodyParams["durationSeconds"] = input.durationSeconds;
  }
  if (input.statisticalThreshold !== undefined) {
    bodyParams[
      "statisticalThreshold"
    ] = serializeAws_restJson1_1StatisticalThreshold(
      input.statisticalThreshold,
      context
    );
  }
  if (input.value !== undefined) {
    bodyParams["value"] = serializeAws_restJson1_1MetricValue(
      input.value,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1Behaviors = (
  input: Array<Behavior>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1Behavior(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1Cidrs = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1MetricValue = (
  input: MetricValue,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.cidrs !== undefined) {
    bodyParams["cidrs"] = serializeAws_restJson1_1Cidrs(input.cidrs, context);
  }
  if (input.count !== undefined) {
    bodyParams["count"] = input.count;
  }
  if (input.ports !== undefined) {
    bodyParams["ports"] = serializeAws_restJson1_1Ports(input.ports, context);
  }
  return bodyParams;
};

const serializeAws_restJson1_1Ports = (
  input: Array<number>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_restJson1_1StatisticalThreshold = (
  input: StatisticalThreshold,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.statistic !== undefined) {
    bodyParams["statistic"] = input.statistic;
  }
  return bodyParams;
};

const serializeAws_restJson1_1StreamFile = (
  input: StreamFile,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.fileId !== undefined) {
    bodyParams["fileId"] = input.fileId;
  }
  if (input.s3Location !== undefined) {
    bodyParams["s3Location"] = serializeAws_restJson1_1S3Location(
      input.s3Location,
      context
    );
  }
  return bodyParams;
};

const serializeAws_restJson1_1StreamFiles = (
  input: Array<StreamFile>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_restJson1_1StreamFile(entry, context));
  }
  return contents;
};

const serializeAws_restJson1_1S3Location = (
  input: S3Location,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.bucket !== undefined) {
    bodyParams["bucket"] = input.bucket;
  }
  if (input.key !== undefined) {
    bodyParams["key"] = input.key;
  }
  if (input.version !== undefined) {
    bodyParams["version"] = input.version;
  }
  return bodyParams;
};

const deserializeAws_restJson1_1Configuration = (
  output: any,
  context: __SerdeContext
): Configuration => {
  let contents: any = {
    __type: "Configuration",
    Enabled: undefined
  };
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  return contents;
};

const deserializeAws_restJson1_1EventConfigurations = (
  output: any,
  context: __SerdeContext
): { [key: string]: Configuration } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1Configuration(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1PolicyTargets = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1Principals = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_restJson1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Tag(entry, context)
  );
};

const deserializeAws_restJson1_1Action = (
  output: any,
  context: __SerdeContext
): Action => {
  let contents: any = {
    __type: "Action",
    cloudwatchAlarm: undefined,
    cloudwatchMetric: undefined,
    dynamoDB: undefined,
    dynamoDBv2: undefined,
    elasticsearch: undefined,
    firehose: undefined,
    http: undefined,
    iotAnalytics: undefined,
    iotEvents: undefined,
    iotSiteWise: undefined,
    kinesis: undefined,
    lambda: undefined,
    republish: undefined,
    s3: undefined,
    salesforce: undefined,
    sns: undefined,
    sqs: undefined,
    stepFunctions: undefined
  };
  if (output.cloudwatchAlarm !== undefined && output.cloudwatchAlarm !== null) {
    contents.cloudwatchAlarm = deserializeAws_restJson1_1CloudwatchAlarmAction(
      output.cloudwatchAlarm,
      context
    );
  }
  if (
    output.cloudwatchMetric !== undefined &&
    output.cloudwatchMetric !== null
  ) {
    contents.cloudwatchMetric = deserializeAws_restJson1_1CloudwatchMetricAction(
      output.cloudwatchMetric,
      context
    );
  }
  if (output.dynamoDB !== undefined && output.dynamoDB !== null) {
    contents.dynamoDB = deserializeAws_restJson1_1DynamoDBAction(
      output.dynamoDB,
      context
    );
  }
  if (output.dynamoDBv2 !== undefined && output.dynamoDBv2 !== null) {
    contents.dynamoDBv2 = deserializeAws_restJson1_1DynamoDBv2Action(
      output.dynamoDBv2,
      context
    );
  }
  if (output.elasticsearch !== undefined && output.elasticsearch !== null) {
    contents.elasticsearch = deserializeAws_restJson1_1ElasticsearchAction(
      output.elasticsearch,
      context
    );
  }
  if (output.firehose !== undefined && output.firehose !== null) {
    contents.firehose = deserializeAws_restJson1_1FirehoseAction(
      output.firehose,
      context
    );
  }
  if (output.http !== undefined && output.http !== null) {
    contents.http = deserializeAws_restJson1_1HttpAction(output.http, context);
  }
  if (output.iotAnalytics !== undefined && output.iotAnalytics !== null) {
    contents.iotAnalytics = deserializeAws_restJson1_1IotAnalyticsAction(
      output.iotAnalytics,
      context
    );
  }
  if (output.iotEvents !== undefined && output.iotEvents !== null) {
    contents.iotEvents = deserializeAws_restJson1_1IotEventsAction(
      output.iotEvents,
      context
    );
  }
  if (output.iotSiteWise !== undefined && output.iotSiteWise !== null) {
    contents.iotSiteWise = deserializeAws_restJson1_1IotSiteWiseAction(
      output.iotSiteWise,
      context
    );
  }
  if (output.kinesis !== undefined && output.kinesis !== null) {
    contents.kinesis = deserializeAws_restJson1_1KinesisAction(
      output.kinesis,
      context
    );
  }
  if (output.lambda !== undefined && output.lambda !== null) {
    contents.lambda = deserializeAws_restJson1_1LambdaAction(
      output.lambda,
      context
    );
  }
  if (output.republish !== undefined && output.republish !== null) {
    contents.republish = deserializeAws_restJson1_1RepublishAction(
      output.republish,
      context
    );
  }
  if (output.s3 !== undefined && output.s3 !== null) {
    contents.s3 = deserializeAws_restJson1_1S3Action(output.s3, context);
  }
  if (output.salesforce !== undefined && output.salesforce !== null) {
    contents.salesforce = deserializeAws_restJson1_1SalesforceAction(
      output.salesforce,
      context
    );
  }
  if (output.sns !== undefined && output.sns !== null) {
    contents.sns = deserializeAws_restJson1_1SnsAction(output.sns, context);
  }
  if (output.sqs !== undefined && output.sqs !== null) {
    contents.sqs = deserializeAws_restJson1_1SqsAction(output.sqs, context);
  }
  if (output.stepFunctions !== undefined && output.stepFunctions !== null) {
    contents.stepFunctions = deserializeAws_restJson1_1StepFunctionsAction(
      output.stepFunctions,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ActionList = (
  output: any,
  context: __SerdeContext
): Array<Action> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Action(entry, context)
  );
};

const deserializeAws_restJson1_1AssetPropertyTimestamp = (
  output: any,
  context: __SerdeContext
): AssetPropertyTimestamp => {
  let contents: any = {
    __type: "AssetPropertyTimestamp",
    offsetInNanos: undefined,
    timeInSeconds: undefined
  };
  if (output.offsetInNanos !== undefined && output.offsetInNanos !== null) {
    contents.offsetInNanos = output.offsetInNanos;
  }
  if (output.timeInSeconds !== undefined && output.timeInSeconds !== null) {
    contents.timeInSeconds = output.timeInSeconds;
  }
  return contents;
};

const deserializeAws_restJson1_1AssetPropertyValue = (
  output: any,
  context: __SerdeContext
): AssetPropertyValue => {
  let contents: any = {
    __type: "AssetPropertyValue",
    quality: undefined,
    timestamp: undefined,
    value: undefined
  };
  if (output.quality !== undefined && output.quality !== null) {
    contents.quality = output.quality;
  }
  if (output.timestamp !== undefined && output.timestamp !== null) {
    contents.timestamp = deserializeAws_restJson1_1AssetPropertyTimestamp(
      output.timestamp,
      context
    );
  }
  if (output.value !== undefined && output.value !== null) {
    contents.value = deserializeAws_restJson1_1AssetPropertyVariant(
      output.value,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1AssetPropertyValueList = (
  output: any,
  context: __SerdeContext
): Array<AssetPropertyValue> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1AssetPropertyValue(entry, context)
  );
};

const deserializeAws_restJson1_1AssetPropertyVariant = (
  output: any,
  context: __SerdeContext
): AssetPropertyVariant => {
  let contents: any = {
    __type: "AssetPropertyVariant",
    booleanValue: undefined,
    doubleValue: undefined,
    integerValue: undefined,
    stringValue: undefined
  };
  if (output.booleanValue !== undefined && output.booleanValue !== null) {
    contents.booleanValue = output.booleanValue;
  }
  if (output.doubleValue !== undefined && output.doubleValue !== null) {
    contents.doubleValue = output.doubleValue;
  }
  if (output.integerValue !== undefined && output.integerValue !== null) {
    contents.integerValue = output.integerValue;
  }
  if (output.stringValue !== undefined && output.stringValue !== null) {
    contents.stringValue = output.stringValue;
  }
  return contents;
};

const deserializeAws_restJson1_1CloudwatchAlarmAction = (
  output: any,
  context: __SerdeContext
): CloudwatchAlarmAction => {
  let contents: any = {
    __type: "CloudwatchAlarmAction",
    alarmName: undefined,
    roleArn: undefined,
    stateReason: undefined,
    stateValue: undefined
  };
  if (output.alarmName !== undefined && output.alarmName !== null) {
    contents.alarmName = output.alarmName;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.stateReason !== undefined && output.stateReason !== null) {
    contents.stateReason = output.stateReason;
  }
  if (output.stateValue !== undefined && output.stateValue !== null) {
    contents.stateValue = output.stateValue;
  }
  return contents;
};

const deserializeAws_restJson1_1CloudwatchMetricAction = (
  output: any,
  context: __SerdeContext
): CloudwatchMetricAction => {
  let contents: any = {
    __type: "CloudwatchMetricAction",
    metricName: undefined,
    metricNamespace: undefined,
    metricTimestamp: undefined,
    metricUnit: undefined,
    metricValue: undefined,
    roleArn: undefined
  };
  if (output.metricName !== undefined && output.metricName !== null) {
    contents.metricName = output.metricName;
  }
  if (output.metricNamespace !== undefined && output.metricNamespace !== null) {
    contents.metricNamespace = output.metricNamespace;
  }
  if (output.metricTimestamp !== undefined && output.metricTimestamp !== null) {
    contents.metricTimestamp = output.metricTimestamp;
  }
  if (output.metricUnit !== undefined && output.metricUnit !== null) {
    contents.metricUnit = output.metricUnit;
  }
  if (output.metricValue !== undefined && output.metricValue !== null) {
    contents.metricValue = output.metricValue;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1DynamoDBAction = (
  output: any,
  context: __SerdeContext
): DynamoDBAction => {
  let contents: any = {
    __type: "DynamoDBAction",
    hashKeyField: undefined,
    hashKeyType: undefined,
    hashKeyValue: undefined,
    operation: undefined,
    payloadField: undefined,
    rangeKeyField: undefined,
    rangeKeyType: undefined,
    rangeKeyValue: undefined,
    roleArn: undefined,
    tableName: undefined
  };
  if (output.hashKeyField !== undefined && output.hashKeyField !== null) {
    contents.hashKeyField = output.hashKeyField;
  }
  if (output.hashKeyType !== undefined && output.hashKeyType !== null) {
    contents.hashKeyType = output.hashKeyType;
  }
  if (output.hashKeyValue !== undefined && output.hashKeyValue !== null) {
    contents.hashKeyValue = output.hashKeyValue;
  }
  if (output.operation !== undefined && output.operation !== null) {
    contents.operation = output.operation;
  }
  if (output.payloadField !== undefined && output.payloadField !== null) {
    contents.payloadField = output.payloadField;
  }
  if (output.rangeKeyField !== undefined && output.rangeKeyField !== null) {
    contents.rangeKeyField = output.rangeKeyField;
  }
  if (output.rangeKeyType !== undefined && output.rangeKeyType !== null) {
    contents.rangeKeyType = output.rangeKeyType;
  }
  if (output.rangeKeyValue !== undefined && output.rangeKeyValue !== null) {
    contents.rangeKeyValue = output.rangeKeyValue;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.tableName !== undefined && output.tableName !== null) {
    contents.tableName = output.tableName;
  }
  return contents;
};

const deserializeAws_restJson1_1DynamoDBv2Action = (
  output: any,
  context: __SerdeContext
): DynamoDBv2Action => {
  let contents: any = {
    __type: "DynamoDBv2Action",
    putItem: undefined,
    roleArn: undefined
  };
  if (output.putItem !== undefined && output.putItem !== null) {
    contents.putItem = deserializeAws_restJson1_1PutItemInput(
      output.putItem,
      context
    );
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1ElasticsearchAction = (
  output: any,
  context: __SerdeContext
): ElasticsearchAction => {
  let contents: any = {
    __type: "ElasticsearchAction",
    endpoint: undefined,
    id: undefined,
    index: undefined,
    roleArn: undefined,
    type: undefined
  };
  if (output.endpoint !== undefined && output.endpoint !== null) {
    contents.endpoint = output.endpoint;
  }
  if (output.id !== undefined && output.id !== null) {
    contents.id = output.id;
  }
  if (output.index !== undefined && output.index !== null) {
    contents.index = output.index;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.type !== undefined && output.type !== null) {
    contents.type = output.type;
  }
  return contents;
};

const deserializeAws_restJson1_1FirehoseAction = (
  output: any,
  context: __SerdeContext
): FirehoseAction => {
  let contents: any = {
    __type: "FirehoseAction",
    deliveryStreamName: undefined,
    roleArn: undefined,
    separator: undefined
  };
  if (
    output.deliveryStreamName !== undefined &&
    output.deliveryStreamName !== null
  ) {
    contents.deliveryStreamName = output.deliveryStreamName;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.separator !== undefined && output.separator !== null) {
    contents.separator = output.separator;
  }
  return contents;
};

const deserializeAws_restJson1_1HeaderList = (
  output: any,
  context: __SerdeContext
): Array<HttpActionHeader> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1HttpActionHeader(entry, context)
  );
};

const deserializeAws_restJson1_1HttpAction = (
  output: any,
  context: __SerdeContext
): HttpAction => {
  let contents: any = {
    __type: "HttpAction",
    auth: undefined,
    confirmationUrl: undefined,
    headers: undefined,
    url: undefined
  };
  if (output.auth !== undefined && output.auth !== null) {
    contents.auth = deserializeAws_restJson1_1HttpAuthorization(
      output.auth,
      context
    );
  }
  if (output.confirmationUrl !== undefined && output.confirmationUrl !== null) {
    contents.confirmationUrl = output.confirmationUrl;
  }
  if (output.headers !== undefined && output.headers !== null) {
    contents.headers = deserializeAws_restJson1_1HeaderList(
      output.headers,
      context
    );
  }
  if (output.url !== undefined && output.url !== null) {
    contents.url = output.url;
  }
  return contents;
};

const deserializeAws_restJson1_1HttpActionHeader = (
  output: any,
  context: __SerdeContext
): HttpActionHeader => {
  let contents: any = {
    __type: "HttpActionHeader",
    key: undefined,
    value: undefined
  };
  if (output.key !== undefined && output.key !== null) {
    contents.key = output.key;
  }
  if (output.value !== undefined && output.value !== null) {
    contents.value = output.value;
  }
  return contents;
};

const deserializeAws_restJson1_1HttpAuthorization = (
  output: any,
  context: __SerdeContext
): HttpAuthorization => {
  let contents: any = {
    __type: "HttpAuthorization",
    sigv4: undefined
  };
  if (output.sigv4 !== undefined && output.sigv4 !== null) {
    contents.sigv4 = deserializeAws_restJson1_1SigV4Authorization(
      output.sigv4,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1HttpUrlDestinationProperties = (
  output: any,
  context: __SerdeContext
): HttpUrlDestinationProperties => {
  let contents: any = {
    __type: "HttpUrlDestinationProperties",
    confirmationUrl: undefined
  };
  if (output.confirmationUrl !== undefined && output.confirmationUrl !== null) {
    contents.confirmationUrl = output.confirmationUrl;
  }
  return contents;
};

const deserializeAws_restJson1_1HttpUrlDestinationSummary = (
  output: any,
  context: __SerdeContext
): HttpUrlDestinationSummary => {
  let contents: any = {
    __type: "HttpUrlDestinationSummary",
    confirmationUrl: undefined
  };
  if (output.confirmationUrl !== undefined && output.confirmationUrl !== null) {
    contents.confirmationUrl = output.confirmationUrl;
  }
  return contents;
};

const deserializeAws_restJson1_1IotAnalyticsAction = (
  output: any,
  context: __SerdeContext
): IotAnalyticsAction => {
  let contents: any = {
    __type: "IotAnalyticsAction",
    channelArn: undefined,
    channelName: undefined,
    roleArn: undefined
  };
  if (output.channelArn !== undefined && output.channelArn !== null) {
    contents.channelArn = output.channelArn;
  }
  if (output.channelName !== undefined && output.channelName !== null) {
    contents.channelName = output.channelName;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1IotEventsAction = (
  output: any,
  context: __SerdeContext
): IotEventsAction => {
  let contents: any = {
    __type: "IotEventsAction",
    inputName: undefined,
    messageId: undefined,
    roleArn: undefined
  };
  if (output.inputName !== undefined && output.inputName !== null) {
    contents.inputName = output.inputName;
  }
  if (output.messageId !== undefined && output.messageId !== null) {
    contents.messageId = output.messageId;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1IotSiteWiseAction = (
  output: any,
  context: __SerdeContext
): IotSiteWiseAction => {
  let contents: any = {
    __type: "IotSiteWiseAction",
    putAssetPropertyValueEntries: undefined,
    roleArn: undefined
  };
  if (
    output.putAssetPropertyValueEntries !== undefined &&
    output.putAssetPropertyValueEntries !== null
  ) {
    contents.putAssetPropertyValueEntries = deserializeAws_restJson1_1PutAssetPropertyValueEntryList(
      output.putAssetPropertyValueEntries,
      context
    );
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1KinesisAction = (
  output: any,
  context: __SerdeContext
): KinesisAction => {
  let contents: any = {
    __type: "KinesisAction",
    partitionKey: undefined,
    roleArn: undefined,
    streamName: undefined
  };
  if (output.partitionKey !== undefined && output.partitionKey !== null) {
    contents.partitionKey = output.partitionKey;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.streamName !== undefined && output.streamName !== null) {
    contents.streamName = output.streamName;
  }
  return contents;
};

const deserializeAws_restJson1_1LambdaAction = (
  output: any,
  context: __SerdeContext
): LambdaAction => {
  let contents: any = {
    __type: "LambdaAction",
    functionArn: undefined
  };
  if (output.functionArn !== undefined && output.functionArn !== null) {
    contents.functionArn = output.functionArn;
  }
  return contents;
};

const deserializeAws_restJson1_1LogTarget = (
  output: any,
  context: __SerdeContext
): LogTarget => {
  let contents: any = {
    __type: "LogTarget",
    targetName: undefined,
    targetType: undefined
  };
  if (output.targetName !== undefined && output.targetName !== null) {
    contents.targetName = output.targetName;
  }
  if (output.targetType !== undefined && output.targetType !== null) {
    contents.targetType = output.targetType;
  }
  return contents;
};

const deserializeAws_restJson1_1LogTargetConfiguration = (
  output: any,
  context: __SerdeContext
): LogTargetConfiguration => {
  let contents: any = {
    __type: "LogTargetConfiguration",
    logLevel: undefined,
    logTarget: undefined
  };
  if (output.logLevel !== undefined && output.logLevel !== null) {
    contents.logLevel = output.logLevel;
  }
  if (output.logTarget !== undefined && output.logTarget !== null) {
    contents.logTarget = deserializeAws_restJson1_1LogTarget(
      output.logTarget,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1LogTargetConfigurations = (
  output: any,
  context: __SerdeContext
): Array<LogTargetConfiguration> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1LogTargetConfiguration(entry, context)
  );
};

const deserializeAws_restJson1_1PutAssetPropertyValueEntry = (
  output: any,
  context: __SerdeContext
): PutAssetPropertyValueEntry => {
  let contents: any = {
    __type: "PutAssetPropertyValueEntry",
    assetId: undefined,
    entryId: undefined,
    propertyAlias: undefined,
    propertyId: undefined,
    propertyValues: undefined
  };
  if (output.assetId !== undefined && output.assetId !== null) {
    contents.assetId = output.assetId;
  }
  if (output.entryId !== undefined && output.entryId !== null) {
    contents.entryId = output.entryId;
  }
  if (output.propertyAlias !== undefined && output.propertyAlias !== null) {
    contents.propertyAlias = output.propertyAlias;
  }
  if (output.propertyId !== undefined && output.propertyId !== null) {
    contents.propertyId = output.propertyId;
  }
  if (output.propertyValues !== undefined && output.propertyValues !== null) {
    contents.propertyValues = deserializeAws_restJson1_1AssetPropertyValueList(
      output.propertyValues,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1PutAssetPropertyValueEntryList = (
  output: any,
  context: __SerdeContext
): Array<PutAssetPropertyValueEntry> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1PutAssetPropertyValueEntry(entry, context)
  );
};

const deserializeAws_restJson1_1PutItemInput = (
  output: any,
  context: __SerdeContext
): PutItemInput => {
  let contents: any = {
    __type: "PutItemInput",
    tableName: undefined
  };
  if (output.tableName !== undefined && output.tableName !== null) {
    contents.tableName = output.tableName;
  }
  return contents;
};

const deserializeAws_restJson1_1RepublishAction = (
  output: any,
  context: __SerdeContext
): RepublishAction => {
  let contents: any = {
    __type: "RepublishAction",
    qos: undefined,
    roleArn: undefined,
    topic: undefined
  };
  if (output.qos !== undefined && output.qos !== null) {
    contents.qos = output.qos;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.topic !== undefined && output.topic !== null) {
    contents.topic = output.topic;
  }
  return contents;
};

const deserializeAws_restJson1_1S3Action = (
  output: any,
  context: __SerdeContext
): S3Action => {
  let contents: any = {
    __type: "S3Action",
    bucketName: undefined,
    cannedAcl: undefined,
    key: undefined,
    roleArn: undefined
  };
  if (output.bucketName !== undefined && output.bucketName !== null) {
    contents.bucketName = output.bucketName;
  }
  if (output.cannedAcl !== undefined && output.cannedAcl !== null) {
    contents.cannedAcl = output.cannedAcl;
  }
  if (output.key !== undefined && output.key !== null) {
    contents.key = output.key;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1SalesforceAction = (
  output: any,
  context: __SerdeContext
): SalesforceAction => {
  let contents: any = {
    __type: "SalesforceAction",
    token: undefined,
    url: undefined
  };
  if (output.token !== undefined && output.token !== null) {
    contents.token = output.token;
  }
  if (output.url !== undefined && output.url !== null) {
    contents.url = output.url;
  }
  return contents;
};

const deserializeAws_restJson1_1SigV4Authorization = (
  output: any,
  context: __SerdeContext
): SigV4Authorization => {
  let contents: any = {
    __type: "SigV4Authorization",
    roleArn: undefined,
    serviceName: undefined,
    signingRegion: undefined
  };
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.serviceName !== undefined && output.serviceName !== null) {
    contents.serviceName = output.serviceName;
  }
  if (output.signingRegion !== undefined && output.signingRegion !== null) {
    contents.signingRegion = output.signingRegion;
  }
  return contents;
};

const deserializeAws_restJson1_1SnsAction = (
  output: any,
  context: __SerdeContext
): SnsAction => {
  let contents: any = {
    __type: "SnsAction",
    messageFormat: undefined,
    roleArn: undefined,
    targetArn: undefined
  };
  if (output.messageFormat !== undefined && output.messageFormat !== null) {
    contents.messageFormat = output.messageFormat;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.targetArn !== undefined && output.targetArn !== null) {
    contents.targetArn = output.targetArn;
  }
  return contents;
};

const deserializeAws_restJson1_1SqsAction = (
  output: any,
  context: __SerdeContext
): SqsAction => {
  let contents: any = {
    __type: "SqsAction",
    queueUrl: undefined,
    roleArn: undefined,
    useBase64: undefined
  };
  if (output.queueUrl !== undefined && output.queueUrl !== null) {
    contents.queueUrl = output.queueUrl;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.useBase64 !== undefined && output.useBase64 !== null) {
    contents.useBase64 = output.useBase64;
  }
  return contents;
};

const deserializeAws_restJson1_1StepFunctionsAction = (
  output: any,
  context: __SerdeContext
): StepFunctionsAction => {
  let contents: any = {
    __type: "StepFunctionsAction",
    executionNamePrefix: undefined,
    roleArn: undefined,
    stateMachineName: undefined
  };
  if (
    output.executionNamePrefix !== undefined &&
    output.executionNamePrefix !== null
  ) {
    contents.executionNamePrefix = output.executionNamePrefix;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (
    output.stateMachineName !== undefined &&
    output.stateMachineName !== null
  ) {
    contents.stateMachineName = output.stateMachineName;
  }
  return contents;
};

const deserializeAws_restJson1_1TopicRule = (
  output: any,
  context: __SerdeContext
): TopicRule => {
  let contents: any = {
    __type: "TopicRule",
    actions: undefined,
    awsIotSqlVersion: undefined,
    createdAt: undefined,
    description: undefined,
    errorAction: undefined,
    ruleDisabled: undefined,
    ruleName: undefined,
    sql: undefined
  };
  if (output.actions !== undefined && output.actions !== null) {
    contents.actions = deserializeAws_restJson1_1ActionList(
      output.actions,
      context
    );
  }
  if (
    output.awsIotSqlVersion !== undefined &&
    output.awsIotSqlVersion !== null
  ) {
    contents.awsIotSqlVersion = output.awsIotSqlVersion;
  }
  if (output.createdAt !== undefined && output.createdAt !== null) {
    contents.createdAt = new Date(Math.round(output.createdAt * 1000));
  }
  if (output.description !== undefined && output.description !== null) {
    contents.description = output.description;
  }
  if (output.errorAction !== undefined && output.errorAction !== null) {
    contents.errorAction = deserializeAws_restJson1_1Action(
      output.errorAction,
      context
    );
  }
  if (output.ruleDisabled !== undefined && output.ruleDisabled !== null) {
    contents.ruleDisabled = output.ruleDisabled;
  }
  if (output.ruleName !== undefined && output.ruleName !== null) {
    contents.ruleName = output.ruleName;
  }
  if (output.sql !== undefined && output.sql !== null) {
    contents.sql = output.sql;
  }
  return contents;
};

const deserializeAws_restJson1_1TopicRuleDestination = (
  output: any,
  context: __SerdeContext
): TopicRuleDestination => {
  let contents: any = {
    __type: "TopicRuleDestination",
    arn: undefined,
    httpUrlProperties: undefined,
    status: undefined,
    statusReason: undefined
  };
  if (output.arn !== undefined && output.arn !== null) {
    contents.arn = output.arn;
  }
  if (
    output.httpUrlProperties !== undefined &&
    output.httpUrlProperties !== null
  ) {
    contents.httpUrlProperties = deserializeAws_restJson1_1HttpUrlDestinationProperties(
      output.httpUrlProperties,
      context
    );
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  if (output.statusReason !== undefined && output.statusReason !== null) {
    contents.statusReason = output.statusReason;
  }
  return contents;
};

const deserializeAws_restJson1_1TopicRuleDestinationSummaries = (
  output: any,
  context: __SerdeContext
): Array<TopicRuleDestinationSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1TopicRuleDestinationSummary(entry, context)
  );
};

const deserializeAws_restJson1_1TopicRuleDestinationSummary = (
  output: any,
  context: __SerdeContext
): TopicRuleDestinationSummary => {
  let contents: any = {
    __type: "TopicRuleDestinationSummary",
    arn: undefined,
    httpUrlSummary: undefined,
    status: undefined,
    statusReason: undefined
  };
  if (output.arn !== undefined && output.arn !== null) {
    contents.arn = output.arn;
  }
  if (output.httpUrlSummary !== undefined && output.httpUrlSummary !== null) {
    contents.httpUrlSummary = deserializeAws_restJson1_1HttpUrlDestinationSummary(
      output.httpUrlSummary,
      context
    );
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  if (output.statusReason !== undefined && output.statusReason !== null) {
    contents.statusReason = output.statusReason;
  }
  return contents;
};

const deserializeAws_restJson1_1TopicRuleList = (
  output: any,
  context: __SerdeContext
): Array<TopicRuleListItem> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1TopicRuleListItem(entry, context)
  );
};

const deserializeAws_restJson1_1TopicRuleListItem = (
  output: any,
  context: __SerdeContext
): TopicRuleListItem => {
  let contents: any = {
    __type: "TopicRuleListItem",
    createdAt: undefined,
    ruleArn: undefined,
    ruleDisabled: undefined,
    ruleName: undefined,
    topicPattern: undefined
  };
  if (output.createdAt !== undefined && output.createdAt !== null) {
    contents.createdAt = new Date(Math.round(output.createdAt * 1000));
  }
  if (output.ruleArn !== undefined && output.ruleArn !== null) {
    contents.ruleArn = output.ruleArn;
  }
  if (output.ruleDisabled !== undefined && output.ruleDisabled !== null) {
    contents.ruleDisabled = output.ruleDisabled;
  }
  if (output.ruleName !== undefined && output.ruleName !== null) {
    contents.ruleName = output.ruleName;
  }
  if (output.topicPattern !== undefined && output.topicPattern !== null) {
    contents.topicPattern = output.topicPattern;
  }
  return contents;
};

const deserializeAws_restJson1_1Allowed = (
  output: any,
  context: __SerdeContext
): Allowed => {
  let contents: any = {
    __type: "Allowed",
    policies: undefined
  };
  if (output.policies !== undefined && output.policies !== null) {
    contents.policies = deserializeAws_restJson1_1Policies(
      output.policies,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1AuthInfo = (
  output: any,
  context: __SerdeContext
): AuthInfo => {
  let contents: any = {
    __type: "AuthInfo",
    actionType: undefined,
    resources: undefined
  };
  if (output.actionType !== undefined && output.actionType !== null) {
    contents.actionType = output.actionType;
  }
  if (output.resources !== undefined && output.resources !== null) {
    contents.resources = deserializeAws_restJson1_1Resources(
      output.resources,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1AuthResult = (
  output: any,
  context: __SerdeContext
): AuthResult => {
  let contents: any = {
    __type: "AuthResult",
    allowed: undefined,
    authDecision: undefined,
    authInfo: undefined,
    denied: undefined,
    missingContextValues: undefined
  };
  if (output.allowed !== undefined && output.allowed !== null) {
    contents.allowed = deserializeAws_restJson1_1Allowed(
      output.allowed,
      context
    );
  }
  if (output.authDecision !== undefined && output.authDecision !== null) {
    contents.authDecision = output.authDecision;
  }
  if (output.authInfo !== undefined && output.authInfo !== null) {
    contents.authInfo = deserializeAws_restJson1_1AuthInfo(
      output.authInfo,
      context
    );
  }
  if (output.denied !== undefined && output.denied !== null) {
    contents.denied = deserializeAws_restJson1_1Denied(output.denied, context);
  }
  if (
    output.missingContextValues !== undefined &&
    output.missingContextValues !== null
  ) {
    contents.missingContextValues = deserializeAws_restJson1_1MissingContextValues(
      output.missingContextValues,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1AuthResults = (
  output: any,
  context: __SerdeContext
): Array<AuthResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1AuthResult(entry, context)
  );
};

const deserializeAws_restJson1_1AuthorizerConfig = (
  output: any,
  context: __SerdeContext
): AuthorizerConfig => {
  let contents: any = {
    __type: "AuthorizerConfig",
    allowAuthorizerOverride: undefined,
    defaultAuthorizerName: undefined
  };
  if (
    output.allowAuthorizerOverride !== undefined &&
    output.allowAuthorizerOverride !== null
  ) {
    contents.allowAuthorizerOverride = output.allowAuthorizerOverride;
  }
  if (
    output.defaultAuthorizerName !== undefined &&
    output.defaultAuthorizerName !== null
  ) {
    contents.defaultAuthorizerName = output.defaultAuthorizerName;
  }
  return contents;
};

const deserializeAws_restJson1_1AuthorizerDescription = (
  output: any,
  context: __SerdeContext
): AuthorizerDescription => {
  let contents: any = {
    __type: "AuthorizerDescription",
    authorizerArn: undefined,
    authorizerFunctionArn: undefined,
    authorizerName: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    signingDisabled: undefined,
    status: undefined,
    tokenKeyName: undefined,
    tokenSigningPublicKeys: undefined
  };
  if (output.authorizerArn !== undefined && output.authorizerArn !== null) {
    contents.authorizerArn = output.authorizerArn;
  }
  if (
    output.authorizerFunctionArn !== undefined &&
    output.authorizerFunctionArn !== null
  ) {
    contents.authorizerFunctionArn = output.authorizerFunctionArn;
  }
  if (output.authorizerName !== undefined && output.authorizerName !== null) {
    contents.authorizerName = output.authorizerName;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (
    output.lastModifiedDate !== undefined &&
    output.lastModifiedDate !== null
  ) {
    contents.lastModifiedDate = new Date(
      Math.round(output.lastModifiedDate * 1000)
    );
  }
  if (output.signingDisabled !== undefined && output.signingDisabled !== null) {
    contents.signingDisabled = output.signingDisabled;
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  if (output.tokenKeyName !== undefined && output.tokenKeyName !== null) {
    contents.tokenKeyName = output.tokenKeyName;
  }
  if (
    output.tokenSigningPublicKeys !== undefined &&
    output.tokenSigningPublicKeys !== null
  ) {
    contents.tokenSigningPublicKeys = deserializeAws_restJson1_1PublicKeyMap(
      output.tokenSigningPublicKeys,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1AuthorizerSummary = (
  output: any,
  context: __SerdeContext
): AuthorizerSummary => {
  let contents: any = {
    __type: "AuthorizerSummary",
    authorizerArn: undefined,
    authorizerName: undefined
  };
  if (output.authorizerArn !== undefined && output.authorizerArn !== null) {
    contents.authorizerArn = output.authorizerArn;
  }
  if (output.authorizerName !== undefined && output.authorizerName !== null) {
    contents.authorizerName = output.authorizerName;
  }
  return contents;
};

const deserializeAws_restJson1_1Authorizers = (
  output: any,
  context: __SerdeContext
): Array<AuthorizerSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1AuthorizerSummary(entry, context)
  );
};

const deserializeAws_restJson1_1CACertificate = (
  output: any,
  context: __SerdeContext
): CACertificate => {
  let contents: any = {
    __type: "CACertificate",
    certificateArn: undefined,
    certificateId: undefined,
    creationDate: undefined,
    status: undefined
  };
  if (output.certificateArn !== undefined && output.certificateArn !== null) {
    contents.certificateArn = output.certificateArn;
  }
  if (output.certificateId !== undefined && output.certificateId !== null) {
    contents.certificateId = output.certificateId;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  return contents;
};

const deserializeAws_restJson1_1CACertificateDescription = (
  output: any,
  context: __SerdeContext
): CACertificateDescription => {
  let contents: any = {
    __type: "CACertificateDescription",
    autoRegistrationStatus: undefined,
    certificateArn: undefined,
    certificateId: undefined,
    certificatePem: undefined,
    creationDate: undefined,
    customerVersion: undefined,
    generationId: undefined,
    lastModifiedDate: undefined,
    ownedBy: undefined,
    status: undefined,
    validity: undefined
  };
  if (
    output.autoRegistrationStatus !== undefined &&
    output.autoRegistrationStatus !== null
  ) {
    contents.autoRegistrationStatus = output.autoRegistrationStatus;
  }
  if (output.certificateArn !== undefined && output.certificateArn !== null) {
    contents.certificateArn = output.certificateArn;
  }
  if (output.certificateId !== undefined && output.certificateId !== null) {
    contents.certificateId = output.certificateId;
  }
  if (output.certificatePem !== undefined && output.certificatePem !== null) {
    contents.certificatePem = output.certificatePem;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.customerVersion !== undefined && output.customerVersion !== null) {
    contents.customerVersion = output.customerVersion;
  }
  if (output.generationId !== undefined && output.generationId !== null) {
    contents.generationId = output.generationId;
  }
  if (
    output.lastModifiedDate !== undefined &&
    output.lastModifiedDate !== null
  ) {
    contents.lastModifiedDate = new Date(
      Math.round(output.lastModifiedDate * 1000)
    );
  }
  if (output.ownedBy !== undefined && output.ownedBy !== null) {
    contents.ownedBy = output.ownedBy;
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  if (output.validity !== undefined && output.validity !== null) {
    contents.validity = deserializeAws_restJson1_1CertificateValidity(
      output.validity,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1CACertificates = (
  output: any,
  context: __SerdeContext
): Array<CACertificate> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1CACertificate(entry, context)
  );
};

const deserializeAws_restJson1_1Certificate = (
  output: any,
  context: __SerdeContext
): Certificate => {
  let contents: any = {
    __type: "Certificate",
    certificateArn: undefined,
    certificateId: undefined,
    creationDate: undefined,
    status: undefined
  };
  if (output.certificateArn !== undefined && output.certificateArn !== null) {
    contents.certificateArn = output.certificateArn;
  }
  if (output.certificateId !== undefined && output.certificateId !== null) {
    contents.certificateId = output.certificateId;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  return contents;
};

const deserializeAws_restJson1_1CertificateDescription = (
  output: any,
  context: __SerdeContext
): CertificateDescription => {
  let contents: any = {
    __type: "CertificateDescription",
    caCertificateId: undefined,
    certificateArn: undefined,
    certificateId: undefined,
    certificatePem: undefined,
    creationDate: undefined,
    customerVersion: undefined,
    generationId: undefined,
    lastModifiedDate: undefined,
    ownedBy: undefined,
    previousOwnedBy: undefined,
    status: undefined,
    transferData: undefined,
    validity: undefined
  };
  if (output.caCertificateId !== undefined && output.caCertificateId !== null) {
    contents.caCertificateId = output.caCertificateId;
  }
  if (output.certificateArn !== undefined && output.certificateArn !== null) {
    contents.certificateArn = output.certificateArn;
  }
  if (output.certificateId !== undefined && output.certificateId !== null) {
    contents.certificateId = output.certificateId;
  }
  if (output.certificatePem !== undefined && output.certificatePem !== null) {
    contents.certificatePem = output.certificatePem;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.customerVersion !== undefined && output.customerVersion !== null) {
    contents.customerVersion = output.customerVersion;
  }
  if (output.generationId !== undefined && output.generationId !== null) {
    contents.generationId = output.generationId;
  }
  if (
    output.lastModifiedDate !== undefined &&
    output.lastModifiedDate !== null
  ) {
    contents.lastModifiedDate = new Date(
      Math.round(output.lastModifiedDate * 1000)
    );
  }
  if (output.ownedBy !== undefined && output.ownedBy !== null) {
    contents.ownedBy = output.ownedBy;
  }
  if (output.previousOwnedBy !== undefined && output.previousOwnedBy !== null) {
    contents.previousOwnedBy = output.previousOwnedBy;
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  if (output.transferData !== undefined && output.transferData !== null) {
    contents.transferData = deserializeAws_restJson1_1TransferData(
      output.transferData,
      context
    );
  }
  if (output.validity !== undefined && output.validity !== null) {
    contents.validity = deserializeAws_restJson1_1CertificateValidity(
      output.validity,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1CertificateValidity = (
  output: any,
  context: __SerdeContext
): CertificateValidity => {
  let contents: any = {
    __type: "CertificateValidity",
    notAfter: undefined,
    notBefore: undefined
  };
  if (output.notAfter !== undefined && output.notAfter !== null) {
    contents.notAfter = new Date(Math.round(output.notAfter * 1000));
  }
  if (output.notBefore !== undefined && output.notBefore !== null) {
    contents.notBefore = new Date(Math.round(output.notBefore * 1000));
  }
  return contents;
};

const deserializeAws_restJson1_1Certificates = (
  output: any,
  context: __SerdeContext
): Array<Certificate> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Certificate(entry, context)
  );
};

const deserializeAws_restJson1_1Denied = (
  output: any,
  context: __SerdeContext
): Denied => {
  let contents: any = {
    __type: "Denied",
    explicitDeny: undefined,
    implicitDeny: undefined
  };
  if (output.explicitDeny !== undefined && output.explicitDeny !== null) {
    contents.explicitDeny = deserializeAws_restJson1_1ExplicitDeny(
      output.explicitDeny,
      context
    );
  }
  if (output.implicitDeny !== undefined && output.implicitDeny !== null) {
    contents.implicitDeny = deserializeAws_restJson1_1ImplicitDeny(
      output.implicitDeny,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1DomainConfigurationSummary = (
  output: any,
  context: __SerdeContext
): DomainConfigurationSummary => {
  let contents: any = {
    __type: "DomainConfigurationSummary",
    domainConfigurationArn: undefined,
    domainConfigurationName: undefined,
    serviceType: undefined
  };
  if (
    output.domainConfigurationArn !== undefined &&
    output.domainConfigurationArn !== null
  ) {
    contents.domainConfigurationArn = output.domainConfigurationArn;
  }
  if (
    output.domainConfigurationName !== undefined &&
    output.domainConfigurationName !== null
  ) {
    contents.domainConfigurationName = output.domainConfigurationName;
  }
  if (output.serviceType !== undefined && output.serviceType !== null) {
    contents.serviceType = output.serviceType;
  }
  return contents;
};

const deserializeAws_restJson1_1DomainConfigurations = (
  output: any,
  context: __SerdeContext
): Array<DomainConfigurationSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1DomainConfigurationSummary(entry, context)
  );
};

const deserializeAws_restJson1_1EffectivePolicies = (
  output: any,
  context: __SerdeContext
): Array<EffectivePolicy> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1EffectivePolicy(entry, context)
  );
};

const deserializeAws_restJson1_1EffectivePolicy = (
  output: any,
  context: __SerdeContext
): EffectivePolicy => {
  let contents: any = {
    __type: "EffectivePolicy",
    policyArn: undefined,
    policyDocument: undefined,
    policyName: undefined
  };
  if (output.policyArn !== undefined && output.policyArn !== null) {
    contents.policyArn = output.policyArn;
  }
  if (output.policyDocument !== undefined && output.policyDocument !== null) {
    contents.policyDocument = output.policyDocument;
  }
  if (output.policyName !== undefined && output.policyName !== null) {
    contents.policyName = output.policyName;
  }
  return contents;
};

const deserializeAws_restJson1_1ExplicitDeny = (
  output: any,
  context: __SerdeContext
): ExplicitDeny => {
  let contents: any = {
    __type: "ExplicitDeny",
    policies: undefined
  };
  if (output.policies !== undefined && output.policies !== null) {
    contents.policies = deserializeAws_restJson1_1Policies(
      output.policies,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ImplicitDeny = (
  output: any,
  context: __SerdeContext
): ImplicitDeny => {
  let contents: any = {
    __type: "ImplicitDeny",
    policies: undefined
  };
  if (output.policies !== undefined && output.policies !== null) {
    contents.policies = deserializeAws_restJson1_1Policies(
      output.policies,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1KeyPair = (
  output: any,
  context: __SerdeContext
): KeyPair => {
  let contents: any = {
    __type: "KeyPair",
    PrivateKey: undefined,
    PublicKey: undefined
  };
  if (output.PrivateKey !== undefined && output.PrivateKey !== null) {
    contents.PrivateKey = output.PrivateKey;
  }
  if (output.PublicKey !== undefined && output.PublicKey !== null) {
    contents.PublicKey = output.PublicKey;
  }
  return contents;
};

const deserializeAws_restJson1_1MissingContextValues = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1OutgoingCertificate = (
  output: any,
  context: __SerdeContext
): OutgoingCertificate => {
  let contents: any = {
    __type: "OutgoingCertificate",
    certificateArn: undefined,
    certificateId: undefined,
    creationDate: undefined,
    transferDate: undefined,
    transferMessage: undefined,
    transferredTo: undefined
  };
  if (output.certificateArn !== undefined && output.certificateArn !== null) {
    contents.certificateArn = output.certificateArn;
  }
  if (output.certificateId !== undefined && output.certificateId !== null) {
    contents.certificateId = output.certificateId;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.transferDate !== undefined && output.transferDate !== null) {
    contents.transferDate = new Date(Math.round(output.transferDate * 1000));
  }
  if (output.transferMessage !== undefined && output.transferMessage !== null) {
    contents.transferMessage = output.transferMessage;
  }
  if (output.transferredTo !== undefined && output.transferredTo !== null) {
    contents.transferredTo = output.transferredTo;
  }
  return contents;
};

const deserializeAws_restJson1_1OutgoingCertificates = (
  output: any,
  context: __SerdeContext
): Array<OutgoingCertificate> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1OutgoingCertificate(entry, context)
  );
};

const deserializeAws_restJson1_1Policies = (
  output: any,
  context: __SerdeContext
): Array<Policy> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Policy(entry, context)
  );
};

const deserializeAws_restJson1_1Policy = (
  output: any,
  context: __SerdeContext
): Policy => {
  let contents: any = {
    __type: "Policy",
    policyArn: undefined,
    policyName: undefined
  };
  if (output.policyArn !== undefined && output.policyArn !== null) {
    contents.policyArn = output.policyArn;
  }
  if (output.policyName !== undefined && output.policyName !== null) {
    contents.policyName = output.policyName;
  }
  return contents;
};

const deserializeAws_restJson1_1PolicyDocuments = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1PolicyVersion = (
  output: any,
  context: __SerdeContext
): PolicyVersion => {
  let contents: any = {
    __type: "PolicyVersion",
    createDate: undefined,
    isDefaultVersion: undefined,
    versionId: undefined
  };
  if (output.createDate !== undefined && output.createDate !== null) {
    contents.createDate = new Date(Math.round(output.createDate * 1000));
  }
  if (
    output.isDefaultVersion !== undefined &&
    output.isDefaultVersion !== null
  ) {
    contents.isDefaultVersion = output.isDefaultVersion;
  }
  if (output.versionId !== undefined && output.versionId !== null) {
    contents.versionId = output.versionId;
  }
  return contents;
};

const deserializeAws_restJson1_1PolicyVersions = (
  output: any,
  context: __SerdeContext
): Array<PolicyVersion> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1PolicyVersion(entry, context)
  );
};

const deserializeAws_restJson1_1ProvisioningTemplateListing = (
  output: any,
  context: __SerdeContext
): Array<ProvisioningTemplateSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ProvisioningTemplateSummary(entry, context)
  );
};

const deserializeAws_restJson1_1ProvisioningTemplateSummary = (
  output: any,
  context: __SerdeContext
): ProvisioningTemplateSummary => {
  let contents: any = {
    __type: "ProvisioningTemplateSummary",
    creationDate: undefined,
    description: undefined,
    enabled: undefined,
    lastModifiedDate: undefined,
    templateArn: undefined,
    templateName: undefined
  };
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.description !== undefined && output.description !== null) {
    contents.description = output.description;
  }
  if (output.enabled !== undefined && output.enabled !== null) {
    contents.enabled = output.enabled;
  }
  if (
    output.lastModifiedDate !== undefined &&
    output.lastModifiedDate !== null
  ) {
    contents.lastModifiedDate = new Date(
      Math.round(output.lastModifiedDate * 1000)
    );
  }
  if (output.templateArn !== undefined && output.templateArn !== null) {
    contents.templateArn = output.templateArn;
  }
  if (output.templateName !== undefined && output.templateName !== null) {
    contents.templateName = output.templateName;
  }
  return contents;
};

const deserializeAws_restJson1_1ProvisioningTemplateVersionListing = (
  output: any,
  context: __SerdeContext
): Array<ProvisioningTemplateVersionSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ProvisioningTemplateVersionSummary(entry, context)
  );
};

const deserializeAws_restJson1_1ProvisioningTemplateVersionSummary = (
  output: any,
  context: __SerdeContext
): ProvisioningTemplateVersionSummary => {
  let contents: any = {
    __type: "ProvisioningTemplateVersionSummary",
    creationDate: undefined,
    isDefaultVersion: undefined,
    versionId: undefined
  };
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (
    output.isDefaultVersion !== undefined &&
    output.isDefaultVersion !== null
  ) {
    contents.isDefaultVersion = output.isDefaultVersion;
  }
  if (output.versionId !== undefined && output.versionId !== null) {
    contents.versionId = output.versionId;
  }
  return contents;
};

const deserializeAws_restJson1_1PublicKeyMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1RegistrationConfig = (
  output: any,
  context: __SerdeContext
): RegistrationConfig => {
  let contents: any = {
    __type: "RegistrationConfig",
    roleArn: undefined,
    templateBody: undefined
  };
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.templateBody !== undefined && output.templateBody !== null) {
    contents.templateBody = output.templateBody;
  }
  return contents;
};

const deserializeAws_restJson1_1ResourceArns = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1Resources = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1RoleAliasDescription = (
  output: any,
  context: __SerdeContext
): RoleAliasDescription => {
  let contents: any = {
    __type: "RoleAliasDescription",
    creationDate: undefined,
    credentialDurationSeconds: undefined,
    lastModifiedDate: undefined,
    owner: undefined,
    roleAlias: undefined,
    roleAliasArn: undefined,
    roleArn: undefined
  };
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (
    output.credentialDurationSeconds !== undefined &&
    output.credentialDurationSeconds !== null
  ) {
    contents.credentialDurationSeconds = output.credentialDurationSeconds;
  }
  if (
    output.lastModifiedDate !== undefined &&
    output.lastModifiedDate !== null
  ) {
    contents.lastModifiedDate = new Date(
      Math.round(output.lastModifiedDate * 1000)
    );
  }
  if (output.owner !== undefined && output.owner !== null) {
    contents.owner = output.owner;
  }
  if (output.roleAlias !== undefined && output.roleAlias !== null) {
    contents.roleAlias = output.roleAlias;
  }
  if (output.roleAliasArn !== undefined && output.roleAliasArn !== null) {
    contents.roleAliasArn = output.roleAliasArn;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1RoleAliases = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1ServerCertificateSummary = (
  output: any,
  context: __SerdeContext
): ServerCertificateSummary => {
  let contents: any = {
    __type: "ServerCertificateSummary",
    serverCertificateArn: undefined,
    serverCertificateStatus: undefined,
    serverCertificateStatusDetail: undefined
  };
  if (
    output.serverCertificateArn !== undefined &&
    output.serverCertificateArn !== null
  ) {
    contents.serverCertificateArn = output.serverCertificateArn;
  }
  if (
    output.serverCertificateStatus !== undefined &&
    output.serverCertificateStatus !== null
  ) {
    contents.serverCertificateStatus = output.serverCertificateStatus;
  }
  if (
    output.serverCertificateStatusDetail !== undefined &&
    output.serverCertificateStatusDetail !== null
  ) {
    contents.serverCertificateStatusDetail =
      output.serverCertificateStatusDetail;
  }
  return contents;
};

const deserializeAws_restJson1_1ServerCertificates = (
  output: any,
  context: __SerdeContext
): Array<ServerCertificateSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ServerCertificateSummary(entry, context)
  );
};

const deserializeAws_restJson1_1TransferData = (
  output: any,
  context: __SerdeContext
): TransferData => {
  let contents: any = {
    __type: "TransferData",
    acceptDate: undefined,
    rejectDate: undefined,
    rejectReason: undefined,
    transferDate: undefined,
    transferMessage: undefined
  };
  if (output.acceptDate !== undefined && output.acceptDate !== null) {
    contents.acceptDate = new Date(Math.round(output.acceptDate * 1000));
  }
  if (output.rejectDate !== undefined && output.rejectDate !== null) {
    contents.rejectDate = new Date(Math.round(output.rejectDate * 1000));
  }
  if (output.rejectReason !== undefined && output.rejectReason !== null) {
    contents.rejectReason = output.rejectReason;
  }
  if (output.transferDate !== undefined && output.transferDate !== null) {
    contents.transferDate = new Date(Math.round(output.transferDate * 1000));
  }
  if (output.transferMessage !== undefined && output.transferMessage !== null) {
    contents.transferMessage = output.transferMessage;
  }
  return contents;
};

const deserializeAws_restJson1_1Field = (
  output: any,
  context: __SerdeContext
): Field => {
  let contents: any = {
    __type: "Field",
    name: undefined,
    type: undefined
  };
  if (output.name !== undefined && output.name !== null) {
    contents.name = output.name;
  }
  if (output.type !== undefined && output.type !== null) {
    contents.type = output.type;
  }
  return contents;
};

const deserializeAws_restJson1_1Fields = (
  output: any,
  context: __SerdeContext
): Array<Field> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Field(entry, context)
  );
};

const deserializeAws_restJson1_1IndexNamesList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1PercentPair = (
  output: any,
  context: __SerdeContext
): PercentPair => {
  let contents: any = {
    __type: "PercentPair",
    percent: undefined,
    value: undefined
  };
  if (output.percent !== undefined && output.percent !== null) {
    contents.percent = output.percent;
  }
  if (output.value !== undefined && output.value !== null) {
    contents.value = output.value;
  }
  return contents;
};

const deserializeAws_restJson1_1Percentiles = (
  output: any,
  context: __SerdeContext
): Array<PercentPair> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1PercentPair(entry, context)
  );
};

const deserializeAws_restJson1_1Statistics = (
  output: any,
  context: __SerdeContext
): Statistics => {
  let contents: any = {
    __type: "Statistics",
    average: undefined,
    count: undefined,
    maximum: undefined,
    minimum: undefined,
    stdDeviation: undefined,
    sum: undefined,
    sumOfSquares: undefined,
    variance: undefined
  };
  if (output.average !== undefined && output.average !== null) {
    contents.average = output.average;
  }
  if (output.count !== undefined && output.count !== null) {
    contents.count = output.count;
  }
  if (output.maximum !== undefined && output.maximum !== null) {
    contents.maximum = output.maximum;
  }
  if (output.minimum !== undefined && output.minimum !== null) {
    contents.minimum = output.minimum;
  }
  if (output.stdDeviation !== undefined && output.stdDeviation !== null) {
    contents.stdDeviation = output.stdDeviation;
  }
  if (output.sum !== undefined && output.sum !== null) {
    contents.sum = output.sum;
  }
  if (output.sumOfSquares !== undefined && output.sumOfSquares !== null) {
    contents.sumOfSquares = output.sumOfSquares;
  }
  if (output.variance !== undefined && output.variance !== null) {
    contents.variance = output.variance;
  }
  return contents;
};

const deserializeAws_restJson1_1ThingConnectivity = (
  output: any,
  context: __SerdeContext
): ThingConnectivity => {
  let contents: any = {
    __type: "ThingConnectivity",
    connected: undefined,
    timestamp: undefined
  };
  if (output.connected !== undefined && output.connected !== null) {
    contents.connected = output.connected;
  }
  if (output.timestamp !== undefined && output.timestamp !== null) {
    contents.timestamp = output.timestamp;
  }
  return contents;
};

const deserializeAws_restJson1_1ThingDocument = (
  output: any,
  context: __SerdeContext
): ThingDocument => {
  let contents: any = {
    __type: "ThingDocument",
    attributes: undefined,
    connectivity: undefined,
    shadow: undefined,
    thingGroupNames: undefined,
    thingId: undefined,
    thingName: undefined,
    thingTypeName: undefined
  };
  if (output.attributes !== undefined && output.attributes !== null) {
    contents.attributes = deserializeAws_restJson1_1Attributes(
      output.attributes,
      context
    );
  }
  if (output.connectivity !== undefined && output.connectivity !== null) {
    contents.connectivity = deserializeAws_restJson1_1ThingConnectivity(
      output.connectivity,
      context
    );
  }
  if (output.shadow !== undefined && output.shadow !== null) {
    contents.shadow = output.shadow;
  }
  if (output.thingGroupNames !== undefined && output.thingGroupNames !== null) {
    contents.thingGroupNames = deserializeAws_restJson1_1ThingGroupNameList(
      output.thingGroupNames,
      context
    );
  }
  if (output.thingId !== undefined && output.thingId !== null) {
    contents.thingId = output.thingId;
  }
  if (output.thingName !== undefined && output.thingName !== null) {
    contents.thingName = output.thingName;
  }
  if (output.thingTypeName !== undefined && output.thingTypeName !== null) {
    contents.thingTypeName = output.thingTypeName;
  }
  return contents;
};

const deserializeAws_restJson1_1ThingDocumentList = (
  output: any,
  context: __SerdeContext
): Array<ThingDocument> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ThingDocument(entry, context)
  );
};

const deserializeAws_restJson1_1ThingGroupDocument = (
  output: any,
  context: __SerdeContext
): ThingGroupDocument => {
  let contents: any = {
    __type: "ThingGroupDocument",
    attributes: undefined,
    parentGroupNames: undefined,
    thingGroupDescription: undefined,
    thingGroupId: undefined,
    thingGroupName: undefined
  };
  if (output.attributes !== undefined && output.attributes !== null) {
    contents.attributes = deserializeAws_restJson1_1Attributes(
      output.attributes,
      context
    );
  }
  if (
    output.parentGroupNames !== undefined &&
    output.parentGroupNames !== null
  ) {
    contents.parentGroupNames = deserializeAws_restJson1_1ThingGroupNameList(
      output.parentGroupNames,
      context
    );
  }
  if (
    output.thingGroupDescription !== undefined &&
    output.thingGroupDescription !== null
  ) {
    contents.thingGroupDescription = output.thingGroupDescription;
  }
  if (output.thingGroupId !== undefined && output.thingGroupId !== null) {
    contents.thingGroupId = output.thingGroupId;
  }
  if (output.thingGroupName !== undefined && output.thingGroupName !== null) {
    contents.thingGroupName = output.thingGroupName;
  }
  return contents;
};

const deserializeAws_restJson1_1ThingGroupDocumentList = (
  output: any,
  context: __SerdeContext
): Array<ThingGroupDocument> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ThingGroupDocument(entry, context)
  );
};

const deserializeAws_restJson1_1ThingGroupIndexingConfiguration = (
  output: any,
  context: __SerdeContext
): ThingGroupIndexingConfiguration => {
  let contents: any = {
    __type: "ThingGroupIndexingConfiguration",
    customFields: undefined,
    managedFields: undefined,
    thingGroupIndexingMode: undefined
  };
  if (output.customFields !== undefined && output.customFields !== null) {
    contents.customFields = deserializeAws_restJson1_1Fields(
      output.customFields,
      context
    );
  }
  if (output.managedFields !== undefined && output.managedFields !== null) {
    contents.managedFields = deserializeAws_restJson1_1Fields(
      output.managedFields,
      context
    );
  }
  if (
    output.thingGroupIndexingMode !== undefined &&
    output.thingGroupIndexingMode !== null
  ) {
    contents.thingGroupIndexingMode = output.thingGroupIndexingMode;
  }
  return contents;
};

const deserializeAws_restJson1_1ThingGroupNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1ThingIndexingConfiguration = (
  output: any,
  context: __SerdeContext
): ThingIndexingConfiguration => {
  let contents: any = {
    __type: "ThingIndexingConfiguration",
    customFields: undefined,
    managedFields: undefined,
    thingConnectivityIndexingMode: undefined,
    thingIndexingMode: undefined
  };
  if (output.customFields !== undefined && output.customFields !== null) {
    contents.customFields = deserializeAws_restJson1_1Fields(
      output.customFields,
      context
    );
  }
  if (output.managedFields !== undefined && output.managedFields !== null) {
    contents.managedFields = deserializeAws_restJson1_1Fields(
      output.managedFields,
      context
    );
  }
  if (
    output.thingConnectivityIndexingMode !== undefined &&
    output.thingConnectivityIndexingMode !== null
  ) {
    contents.thingConnectivityIndexingMode =
      output.thingConnectivityIndexingMode;
  }
  if (
    output.thingIndexingMode !== undefined &&
    output.thingIndexingMode !== null
  ) {
    contents.thingIndexingMode = output.thingIndexingMode;
  }
  return contents;
};

const deserializeAws_restJson1_1AbortConfig = (
  output: any,
  context: __SerdeContext
): AbortConfig => {
  let contents: any = {
    __type: "AbortConfig",
    criteriaList: undefined
  };
  if (output.criteriaList !== undefined && output.criteriaList !== null) {
    contents.criteriaList = deserializeAws_restJson1_1AbortCriteriaList(
      output.criteriaList,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1AbortCriteria = (
  output: any,
  context: __SerdeContext
): AbortCriteria => {
  let contents: any = {
    __type: "AbortCriteria",
    action: undefined,
    failureType: undefined,
    minNumberOfExecutedThings: undefined,
    thresholdPercentage: undefined
  };
  if (output.action !== undefined && output.action !== null) {
    contents.action = output.action;
  }
  if (output.failureType !== undefined && output.failureType !== null) {
    contents.failureType = output.failureType;
  }
  if (
    output.minNumberOfExecutedThings !== undefined &&
    output.minNumberOfExecutedThings !== null
  ) {
    contents.minNumberOfExecutedThings = output.minNumberOfExecutedThings;
  }
  if (
    output.thresholdPercentage !== undefined &&
    output.thresholdPercentage !== null
  ) {
    contents.thresholdPercentage = output.thresholdPercentage;
  }
  return contents;
};

const deserializeAws_restJson1_1AbortCriteriaList = (
  output: any,
  context: __SerdeContext
): Array<AbortCriteria> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1AbortCriteria(entry, context)
  );
};

const deserializeAws_restJson1_1ExponentialRolloutRate = (
  output: any,
  context: __SerdeContext
): ExponentialRolloutRate => {
  let contents: any = {
    __type: "ExponentialRolloutRate",
    baseRatePerMinute: undefined,
    incrementFactor: undefined,
    rateIncreaseCriteria: undefined
  };
  if (
    output.baseRatePerMinute !== undefined &&
    output.baseRatePerMinute !== null
  ) {
    contents.baseRatePerMinute = output.baseRatePerMinute;
  }
  if (output.incrementFactor !== undefined && output.incrementFactor !== null) {
    contents.incrementFactor = output.incrementFactor;
  }
  if (
    output.rateIncreaseCriteria !== undefined &&
    output.rateIncreaseCriteria !== null
  ) {
    contents.rateIncreaseCriteria = deserializeAws_restJson1_1RateIncreaseCriteria(
      output.rateIncreaseCriteria,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Job = (
  output: any,
  context: __SerdeContext
): Job => {
  let contents: any = {
    __type: "Job",
    abortConfig: undefined,
    comment: undefined,
    completedAt: undefined,
    createdAt: undefined,
    description: undefined,
    forceCanceled: undefined,
    jobArn: undefined,
    jobExecutionsRolloutConfig: undefined,
    jobId: undefined,
    jobProcessDetails: undefined,
    lastUpdatedAt: undefined,
    presignedUrlConfig: undefined,
    reasonCode: undefined,
    status: undefined,
    targetSelection: undefined,
    targets: undefined,
    timeoutConfig: undefined
  };
  if (output.abortConfig !== undefined && output.abortConfig !== null) {
    contents.abortConfig = deserializeAws_restJson1_1AbortConfig(
      output.abortConfig,
      context
    );
  }
  if (output.comment !== undefined && output.comment !== null) {
    contents.comment = output.comment;
  }
  if (output.completedAt !== undefined && output.completedAt !== null) {
    contents.completedAt = new Date(Math.round(output.completedAt * 1000));
  }
  if (output.createdAt !== undefined && output.createdAt !== null) {
    contents.createdAt = new Date(Math.round(output.createdAt * 1000));
  }
  if (output.description !== undefined && output.description !== null) {
    contents.description = output.description;
  }
  if (output.forceCanceled !== undefined && output.forceCanceled !== null) {
    contents.forceCanceled = output.forceCanceled;
  }
  if (output.jobArn !== undefined && output.jobArn !== null) {
    contents.jobArn = output.jobArn;
  }
  if (
    output.jobExecutionsRolloutConfig !== undefined &&
    output.jobExecutionsRolloutConfig !== null
  ) {
    contents.jobExecutionsRolloutConfig = deserializeAws_restJson1_1JobExecutionsRolloutConfig(
      output.jobExecutionsRolloutConfig,
      context
    );
  }
  if (output.jobId !== undefined && output.jobId !== null) {
    contents.jobId = output.jobId;
  }
  if (
    output.jobProcessDetails !== undefined &&
    output.jobProcessDetails !== null
  ) {
    contents.jobProcessDetails = deserializeAws_restJson1_1JobProcessDetails(
      output.jobProcessDetails,
      context
    );
  }
  if (output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null) {
    contents.lastUpdatedAt = new Date(Math.round(output.lastUpdatedAt * 1000));
  }
  if (
    output.presignedUrlConfig !== undefined &&
    output.presignedUrlConfig !== null
  ) {
    contents.presignedUrlConfig = deserializeAws_restJson1_1PresignedUrlConfig(
      output.presignedUrlConfig,
      context
    );
  }
  if (output.reasonCode !== undefined && output.reasonCode !== null) {
    contents.reasonCode = output.reasonCode;
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  if (output.targetSelection !== undefined && output.targetSelection !== null) {
    contents.targetSelection = output.targetSelection;
  }
  if (output.targets !== undefined && output.targets !== null) {
    contents.targets = deserializeAws_restJson1_1JobTargets(
      output.targets,
      context
    );
  }
  if (output.timeoutConfig !== undefined && output.timeoutConfig !== null) {
    contents.timeoutConfig = deserializeAws_restJson1_1TimeoutConfig(
      output.timeoutConfig,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1JobExecution = (
  output: any,
  context: __SerdeContext
): JobExecution => {
  let contents: any = {
    __type: "JobExecution",
    approximateSecondsBeforeTimedOut: undefined,
    executionNumber: undefined,
    forceCanceled: undefined,
    jobId: undefined,
    lastUpdatedAt: undefined,
    queuedAt: undefined,
    startedAt: undefined,
    status: undefined,
    statusDetails: undefined,
    thingArn: undefined,
    versionNumber: undefined
  };
  if (
    output.approximateSecondsBeforeTimedOut !== undefined &&
    output.approximateSecondsBeforeTimedOut !== null
  ) {
    contents.approximateSecondsBeforeTimedOut =
      output.approximateSecondsBeforeTimedOut;
  }
  if (output.executionNumber !== undefined && output.executionNumber !== null) {
    contents.executionNumber = output.executionNumber;
  }
  if (output.forceCanceled !== undefined && output.forceCanceled !== null) {
    contents.forceCanceled = output.forceCanceled;
  }
  if (output.jobId !== undefined && output.jobId !== null) {
    contents.jobId = output.jobId;
  }
  if (output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null) {
    contents.lastUpdatedAt = new Date(Math.round(output.lastUpdatedAt * 1000));
  }
  if (output.queuedAt !== undefined && output.queuedAt !== null) {
    contents.queuedAt = new Date(Math.round(output.queuedAt * 1000));
  }
  if (output.startedAt !== undefined && output.startedAt !== null) {
    contents.startedAt = new Date(Math.round(output.startedAt * 1000));
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  if (output.statusDetails !== undefined && output.statusDetails !== null) {
    contents.statusDetails = deserializeAws_restJson1_1JobExecutionStatusDetails(
      output.statusDetails,
      context
    );
  }
  if (output.thingArn !== undefined && output.thingArn !== null) {
    contents.thingArn = output.thingArn;
  }
  if (output.versionNumber !== undefined && output.versionNumber !== null) {
    contents.versionNumber = output.versionNumber;
  }
  return contents;
};

const deserializeAws_restJson1_1JobExecutionStatusDetails = (
  output: any,
  context: __SerdeContext
): JobExecutionStatusDetails => {
  let contents: any = {
    __type: "JobExecutionStatusDetails",
    detailsMap: undefined
  };
  if (output.detailsMap !== undefined && output.detailsMap !== null) {
    contents.detailsMap = deserializeAws_restJson1_1DetailsMap(
      output.detailsMap,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1JobExecutionSummary = (
  output: any,
  context: __SerdeContext
): JobExecutionSummary => {
  let contents: any = {
    __type: "JobExecutionSummary",
    executionNumber: undefined,
    lastUpdatedAt: undefined,
    queuedAt: undefined,
    startedAt: undefined,
    status: undefined
  };
  if (output.executionNumber !== undefined && output.executionNumber !== null) {
    contents.executionNumber = output.executionNumber;
  }
  if (output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null) {
    contents.lastUpdatedAt = new Date(Math.round(output.lastUpdatedAt * 1000));
  }
  if (output.queuedAt !== undefined && output.queuedAt !== null) {
    contents.queuedAt = new Date(Math.round(output.queuedAt * 1000));
  }
  if (output.startedAt !== undefined && output.startedAt !== null) {
    contents.startedAt = new Date(Math.round(output.startedAt * 1000));
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  return contents;
};

const deserializeAws_restJson1_1JobExecutionSummaryForJob = (
  output: any,
  context: __SerdeContext
): JobExecutionSummaryForJob => {
  let contents: any = {
    __type: "JobExecutionSummaryForJob",
    jobExecutionSummary: undefined,
    thingArn: undefined
  };
  if (
    output.jobExecutionSummary !== undefined &&
    output.jobExecutionSummary !== null
  ) {
    contents.jobExecutionSummary = deserializeAws_restJson1_1JobExecutionSummary(
      output.jobExecutionSummary,
      context
    );
  }
  if (output.thingArn !== undefined && output.thingArn !== null) {
    contents.thingArn = output.thingArn;
  }
  return contents;
};

const deserializeAws_restJson1_1JobExecutionSummaryForJobList = (
  output: any,
  context: __SerdeContext
): Array<JobExecutionSummaryForJob> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1JobExecutionSummaryForJob(entry, context)
  );
};

const deserializeAws_restJson1_1JobExecutionSummaryForThing = (
  output: any,
  context: __SerdeContext
): JobExecutionSummaryForThing => {
  let contents: any = {
    __type: "JobExecutionSummaryForThing",
    jobExecutionSummary: undefined,
    jobId: undefined
  };
  if (
    output.jobExecutionSummary !== undefined &&
    output.jobExecutionSummary !== null
  ) {
    contents.jobExecutionSummary = deserializeAws_restJson1_1JobExecutionSummary(
      output.jobExecutionSummary,
      context
    );
  }
  if (output.jobId !== undefined && output.jobId !== null) {
    contents.jobId = output.jobId;
  }
  return contents;
};

const deserializeAws_restJson1_1JobExecutionSummaryForThingList = (
  output: any,
  context: __SerdeContext
): Array<JobExecutionSummaryForThing> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1JobExecutionSummaryForThing(entry, context)
  );
};

const deserializeAws_restJson1_1JobExecutionsRolloutConfig = (
  output: any,
  context: __SerdeContext
): JobExecutionsRolloutConfig => {
  let contents: any = {
    __type: "JobExecutionsRolloutConfig",
    exponentialRate: undefined,
    maximumPerMinute: undefined
  };
  if (output.exponentialRate !== undefined && output.exponentialRate !== null) {
    contents.exponentialRate = deserializeAws_restJson1_1ExponentialRolloutRate(
      output.exponentialRate,
      context
    );
  }
  if (
    output.maximumPerMinute !== undefined &&
    output.maximumPerMinute !== null
  ) {
    contents.maximumPerMinute = output.maximumPerMinute;
  }
  return contents;
};

const deserializeAws_restJson1_1JobProcessDetails = (
  output: any,
  context: __SerdeContext
): JobProcessDetails => {
  let contents: any = {
    __type: "JobProcessDetails",
    numberOfCanceledThings: undefined,
    numberOfFailedThings: undefined,
    numberOfInProgressThings: undefined,
    numberOfQueuedThings: undefined,
    numberOfRejectedThings: undefined,
    numberOfRemovedThings: undefined,
    numberOfSucceededThings: undefined,
    numberOfTimedOutThings: undefined,
    processingTargets: undefined
  };
  if (
    output.numberOfCanceledThings !== undefined &&
    output.numberOfCanceledThings !== null
  ) {
    contents.numberOfCanceledThings = output.numberOfCanceledThings;
  }
  if (
    output.numberOfFailedThings !== undefined &&
    output.numberOfFailedThings !== null
  ) {
    contents.numberOfFailedThings = output.numberOfFailedThings;
  }
  if (
    output.numberOfInProgressThings !== undefined &&
    output.numberOfInProgressThings !== null
  ) {
    contents.numberOfInProgressThings = output.numberOfInProgressThings;
  }
  if (
    output.numberOfQueuedThings !== undefined &&
    output.numberOfQueuedThings !== null
  ) {
    contents.numberOfQueuedThings = output.numberOfQueuedThings;
  }
  if (
    output.numberOfRejectedThings !== undefined &&
    output.numberOfRejectedThings !== null
  ) {
    contents.numberOfRejectedThings = output.numberOfRejectedThings;
  }
  if (
    output.numberOfRemovedThings !== undefined &&
    output.numberOfRemovedThings !== null
  ) {
    contents.numberOfRemovedThings = output.numberOfRemovedThings;
  }
  if (
    output.numberOfSucceededThings !== undefined &&
    output.numberOfSucceededThings !== null
  ) {
    contents.numberOfSucceededThings = output.numberOfSucceededThings;
  }
  if (
    output.numberOfTimedOutThings !== undefined &&
    output.numberOfTimedOutThings !== null
  ) {
    contents.numberOfTimedOutThings = output.numberOfTimedOutThings;
  }
  if (
    output.processingTargets !== undefined &&
    output.processingTargets !== null
  ) {
    contents.processingTargets = deserializeAws_restJson1_1ProcessingTargetNameList(
      output.processingTargets,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1JobSummary = (
  output: any,
  context: __SerdeContext
): JobSummary => {
  let contents: any = {
    __type: "JobSummary",
    completedAt: undefined,
    createdAt: undefined,
    jobArn: undefined,
    jobId: undefined,
    lastUpdatedAt: undefined,
    status: undefined,
    targetSelection: undefined,
    thingGroupId: undefined
  };
  if (output.completedAt !== undefined && output.completedAt !== null) {
    contents.completedAt = new Date(Math.round(output.completedAt * 1000));
  }
  if (output.createdAt !== undefined && output.createdAt !== null) {
    contents.createdAt = new Date(Math.round(output.createdAt * 1000));
  }
  if (output.jobArn !== undefined && output.jobArn !== null) {
    contents.jobArn = output.jobArn;
  }
  if (output.jobId !== undefined && output.jobId !== null) {
    contents.jobId = output.jobId;
  }
  if (output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null) {
    contents.lastUpdatedAt = new Date(Math.round(output.lastUpdatedAt * 1000));
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  if (output.targetSelection !== undefined && output.targetSelection !== null) {
    contents.targetSelection = output.targetSelection;
  }
  if (output.thingGroupId !== undefined && output.thingGroupId !== null) {
    contents.thingGroupId = output.thingGroupId;
  }
  return contents;
};

const deserializeAws_restJson1_1JobSummaryList = (
  output: any,
  context: __SerdeContext
): Array<JobSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1JobSummary(entry, context)
  );
};

const deserializeAws_restJson1_1JobTargets = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1PresignedUrlConfig = (
  output: any,
  context: __SerdeContext
): PresignedUrlConfig => {
  let contents: any = {
    __type: "PresignedUrlConfig",
    expiresInSec: undefined,
    roleArn: undefined
  };
  if (output.expiresInSec !== undefined && output.expiresInSec !== null) {
    contents.expiresInSec = output.expiresInSec;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1ProcessingTargetNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1RateIncreaseCriteria = (
  output: any,
  context: __SerdeContext
): RateIncreaseCriteria => {
  let contents: any = {
    __type: "RateIncreaseCriteria",
    numberOfNotifiedThings: undefined,
    numberOfSucceededThings: undefined
  };
  if (
    output.numberOfNotifiedThings !== undefined &&
    output.numberOfNotifiedThings !== null
  ) {
    contents.numberOfNotifiedThings = output.numberOfNotifiedThings;
  }
  if (
    output.numberOfSucceededThings !== undefined &&
    output.numberOfSucceededThings !== null
  ) {
    contents.numberOfSucceededThings = output.numberOfSucceededThings;
  }
  return contents;
};

const deserializeAws_restJson1_1TimeoutConfig = (
  output: any,
  context: __SerdeContext
): TimeoutConfig => {
  let contents: any = {
    __type: "TimeoutConfig",
    inProgressTimeoutInMinutes: undefined
  };
  if (
    output.inProgressTimeoutInMinutes !== undefined &&
    output.inProgressTimeoutInMinutes !== null
  ) {
    contents.inProgressTimeoutInMinutes = output.inProgressTimeoutInMinutes;
  }
  return contents;
};

const deserializeAws_restJson1_1DetailsMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1AdditionalParameterMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1AttributesMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1AwsJobExecutionsRolloutConfig = (
  output: any,
  context: __SerdeContext
): AwsJobExecutionsRolloutConfig => {
  let contents: any = {
    __type: "AwsJobExecutionsRolloutConfig",
    maximumPerMinute: undefined
  };
  if (
    output.maximumPerMinute !== undefined &&
    output.maximumPerMinute !== null
  ) {
    contents.maximumPerMinute = output.maximumPerMinute;
  }
  return contents;
};

const deserializeAws_restJson1_1AwsJobPresignedUrlConfig = (
  output: any,
  context: __SerdeContext
): AwsJobPresignedUrlConfig => {
  let contents: any = {
    __type: "AwsJobPresignedUrlConfig",
    expiresInSec: undefined
  };
  if (output.expiresInSec !== undefined && output.expiresInSec !== null) {
    contents.expiresInSec = output.expiresInSec;
  }
  return contents;
};

const deserializeAws_restJson1_1CodeSigning = (
  output: any,
  context: __SerdeContext
): CodeSigning => {
  let contents: any = {
    __type: "CodeSigning",
    awsSignerJobId: undefined,
    customCodeSigning: undefined,
    startSigningJobParameter: undefined
  };
  if (output.awsSignerJobId !== undefined && output.awsSignerJobId !== null) {
    contents.awsSignerJobId = output.awsSignerJobId;
  }
  if (
    output.customCodeSigning !== undefined &&
    output.customCodeSigning !== null
  ) {
    contents.customCodeSigning = deserializeAws_restJson1_1CustomCodeSigning(
      output.customCodeSigning,
      context
    );
  }
  if (
    output.startSigningJobParameter !== undefined &&
    output.startSigningJobParameter !== null
  ) {
    contents.startSigningJobParameter = deserializeAws_restJson1_1StartSigningJobParameter(
      output.startSigningJobParameter,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1CodeSigningCertificateChain = (
  output: any,
  context: __SerdeContext
): CodeSigningCertificateChain => {
  let contents: any = {
    __type: "CodeSigningCertificateChain",
    certificateName: undefined,
    inlineDocument: undefined
  };
  if (output.certificateName !== undefined && output.certificateName !== null) {
    contents.certificateName = output.certificateName;
  }
  if (output.inlineDocument !== undefined && output.inlineDocument !== null) {
    contents.inlineDocument = output.inlineDocument;
  }
  return contents;
};

const deserializeAws_restJson1_1CodeSigningSignature = (
  output: any,
  context: __SerdeContext
): CodeSigningSignature => {
  let contents: any = {
    __type: "CodeSigningSignature",
    inlineDocument: undefined
  };
  if (output.inlineDocument !== undefined && output.inlineDocument !== null) {
    contents.inlineDocument = context.base64Decoder(output.inlineDocument);
  }
  return contents;
};

const deserializeAws_restJson1_1CustomCodeSigning = (
  output: any,
  context: __SerdeContext
): CustomCodeSigning => {
  let contents: any = {
    __type: "CustomCodeSigning",
    certificateChain: undefined,
    hashAlgorithm: undefined,
    signature: undefined,
    signatureAlgorithm: undefined
  };
  if (
    output.certificateChain !== undefined &&
    output.certificateChain !== null
  ) {
    contents.certificateChain = deserializeAws_restJson1_1CodeSigningCertificateChain(
      output.certificateChain,
      context
    );
  }
  if (output.hashAlgorithm !== undefined && output.hashAlgorithm !== null) {
    contents.hashAlgorithm = output.hashAlgorithm;
  }
  if (output.signature !== undefined && output.signature !== null) {
    contents.signature = deserializeAws_restJson1_1CodeSigningSignature(
      output.signature,
      context
    );
  }
  if (
    output.signatureAlgorithm !== undefined &&
    output.signatureAlgorithm !== null
  ) {
    contents.signatureAlgorithm = output.signatureAlgorithm;
  }
  return contents;
};

const deserializeAws_restJson1_1Destination = (
  output: any,
  context: __SerdeContext
): Destination => {
  let contents: any = {
    __type: "Destination",
    s3Destination: undefined
  };
  if (output.s3Destination !== undefined && output.s3Destination !== null) {
    contents.s3Destination = deserializeAws_restJson1_1S3Destination(
      output.s3Destination,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ErrorInfo = (
  output: any,
  context: __SerdeContext
): ErrorInfo => {
  let contents: any = {
    __type: "ErrorInfo",
    code: undefined,
    message: undefined
  };
  if (output.code !== undefined && output.code !== null) {
    contents.code = output.code;
  }
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_restJson1_1FileLocation = (
  output: any,
  context: __SerdeContext
): FileLocation => {
  let contents: any = {
    __type: "FileLocation",
    s3Location: undefined,
    stream: undefined
  };
  if (output.s3Location !== undefined && output.s3Location !== null) {
    contents.s3Location = deserializeAws_restJson1_1S3Location(
      output.s3Location,
      context
    );
  }
  if (output.stream !== undefined && output.stream !== null) {
    contents.stream = deserializeAws_restJson1_1_Stream(output.stream, context);
  }
  return contents;
};

const deserializeAws_restJson1_1OTAUpdateFile = (
  output: any,
  context: __SerdeContext
): OTAUpdateFile => {
  let contents: any = {
    __type: "OTAUpdateFile",
    attributes: undefined,
    codeSigning: undefined,
    fileLocation: undefined,
    fileName: undefined,
    fileVersion: undefined
  };
  if (output.attributes !== undefined && output.attributes !== null) {
    contents.attributes = deserializeAws_restJson1_1AttributesMap(
      output.attributes,
      context
    );
  }
  if (output.codeSigning !== undefined && output.codeSigning !== null) {
    contents.codeSigning = deserializeAws_restJson1_1CodeSigning(
      output.codeSigning,
      context
    );
  }
  if (output.fileLocation !== undefined && output.fileLocation !== null) {
    contents.fileLocation = deserializeAws_restJson1_1FileLocation(
      output.fileLocation,
      context
    );
  }
  if (output.fileName !== undefined && output.fileName !== null) {
    contents.fileName = output.fileName;
  }
  if (output.fileVersion !== undefined && output.fileVersion !== null) {
    contents.fileVersion = output.fileVersion;
  }
  return contents;
};

const deserializeAws_restJson1_1OTAUpdateFiles = (
  output: any,
  context: __SerdeContext
): Array<OTAUpdateFile> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1OTAUpdateFile(entry, context)
  );
};

const deserializeAws_restJson1_1OTAUpdateInfo = (
  output: any,
  context: __SerdeContext
): OTAUpdateInfo => {
  let contents: any = {
    __type: "OTAUpdateInfo",
    additionalParameters: undefined,
    awsIotJobArn: undefined,
    awsIotJobId: undefined,
    awsJobExecutionsRolloutConfig: undefined,
    awsJobPresignedUrlConfig: undefined,
    creationDate: undefined,
    description: undefined,
    errorInfo: undefined,
    lastModifiedDate: undefined,
    otaUpdateArn: undefined,
    otaUpdateFiles: undefined,
    otaUpdateId: undefined,
    otaUpdateStatus: undefined,
    protocols: undefined,
    targetSelection: undefined,
    targets: undefined
  };
  if (
    output.additionalParameters !== undefined &&
    output.additionalParameters !== null
  ) {
    contents.additionalParameters = deserializeAws_restJson1_1AdditionalParameterMap(
      output.additionalParameters,
      context
    );
  }
  if (output.awsIotJobArn !== undefined && output.awsIotJobArn !== null) {
    contents.awsIotJobArn = output.awsIotJobArn;
  }
  if (output.awsIotJobId !== undefined && output.awsIotJobId !== null) {
    contents.awsIotJobId = output.awsIotJobId;
  }
  if (
    output.awsJobExecutionsRolloutConfig !== undefined &&
    output.awsJobExecutionsRolloutConfig !== null
  ) {
    contents.awsJobExecutionsRolloutConfig = deserializeAws_restJson1_1AwsJobExecutionsRolloutConfig(
      output.awsJobExecutionsRolloutConfig,
      context
    );
  }
  if (
    output.awsJobPresignedUrlConfig !== undefined &&
    output.awsJobPresignedUrlConfig !== null
  ) {
    contents.awsJobPresignedUrlConfig = deserializeAws_restJson1_1AwsJobPresignedUrlConfig(
      output.awsJobPresignedUrlConfig,
      context
    );
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.description !== undefined && output.description !== null) {
    contents.description = output.description;
  }
  if (output.errorInfo !== undefined && output.errorInfo !== null) {
    contents.errorInfo = deserializeAws_restJson1_1ErrorInfo(
      output.errorInfo,
      context
    );
  }
  if (
    output.lastModifiedDate !== undefined &&
    output.lastModifiedDate !== null
  ) {
    contents.lastModifiedDate = new Date(
      Math.round(output.lastModifiedDate * 1000)
    );
  }
  if (output.otaUpdateArn !== undefined && output.otaUpdateArn !== null) {
    contents.otaUpdateArn = output.otaUpdateArn;
  }
  if (output.otaUpdateFiles !== undefined && output.otaUpdateFiles !== null) {
    contents.otaUpdateFiles = deserializeAws_restJson1_1OTAUpdateFiles(
      output.otaUpdateFiles,
      context
    );
  }
  if (output.otaUpdateId !== undefined && output.otaUpdateId !== null) {
    contents.otaUpdateId = output.otaUpdateId;
  }
  if (output.otaUpdateStatus !== undefined && output.otaUpdateStatus !== null) {
    contents.otaUpdateStatus = output.otaUpdateStatus;
  }
  if (output.protocols !== undefined && output.protocols !== null) {
    contents.protocols = deserializeAws_restJson1_1Protocols(
      output.protocols,
      context
    );
  }
  if (output.targetSelection !== undefined && output.targetSelection !== null) {
    contents.targetSelection = output.targetSelection;
  }
  if (output.targets !== undefined && output.targets !== null) {
    contents.targets = deserializeAws_restJson1_1Targets(
      output.targets,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1OTAUpdateSummary = (
  output: any,
  context: __SerdeContext
): OTAUpdateSummary => {
  let contents: any = {
    __type: "OTAUpdateSummary",
    creationDate: undefined,
    otaUpdateArn: undefined,
    otaUpdateId: undefined
  };
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.otaUpdateArn !== undefined && output.otaUpdateArn !== null) {
    contents.otaUpdateArn = output.otaUpdateArn;
  }
  if (output.otaUpdateId !== undefined && output.otaUpdateId !== null) {
    contents.otaUpdateId = output.otaUpdateId;
  }
  return contents;
};

const deserializeAws_restJson1_1OTAUpdatesSummary = (
  output: any,
  context: __SerdeContext
): Array<OTAUpdateSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1OTAUpdateSummary(entry, context)
  );
};

const deserializeAws_restJson1_1Protocols = (
  output: any,
  context: __SerdeContext
): Array<Protocol | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1S3Destination = (
  output: any,
  context: __SerdeContext
): S3Destination => {
  let contents: any = {
    __type: "S3Destination",
    bucket: undefined,
    prefix: undefined
  };
  if (output.bucket !== undefined && output.bucket !== null) {
    contents.bucket = output.bucket;
  }
  if (output.prefix !== undefined && output.prefix !== null) {
    contents.prefix = output.prefix;
  }
  return contents;
};

const deserializeAws_restJson1_1SigningProfileParameter = (
  output: any,
  context: __SerdeContext
): SigningProfileParameter => {
  let contents: any = {
    __type: "SigningProfileParameter",
    certificateArn: undefined,
    certificatePathOnDevice: undefined,
    platform: undefined
  };
  if (output.certificateArn !== undefined && output.certificateArn !== null) {
    contents.certificateArn = output.certificateArn;
  }
  if (
    output.certificatePathOnDevice !== undefined &&
    output.certificatePathOnDevice !== null
  ) {
    contents.certificatePathOnDevice = output.certificatePathOnDevice;
  }
  if (output.platform !== undefined && output.platform !== null) {
    contents.platform = output.platform;
  }
  return contents;
};

const deserializeAws_restJson1_1StartSigningJobParameter = (
  output: any,
  context: __SerdeContext
): StartSigningJobParameter => {
  let contents: any = {
    __type: "StartSigningJobParameter",
    destination: undefined,
    signingProfileName: undefined,
    signingProfileParameter: undefined
  };
  if (output.destination !== undefined && output.destination !== null) {
    contents.destination = deserializeAws_restJson1_1Destination(
      output.destination,
      context
    );
  }
  if (
    output.signingProfileName !== undefined &&
    output.signingProfileName !== null
  ) {
    contents.signingProfileName = output.signingProfileName;
  }
  if (
    output.signingProfileParameter !== undefined &&
    output.signingProfileParameter !== null
  ) {
    contents.signingProfileParameter = deserializeAws_restJson1_1SigningProfileParameter(
      output.signingProfileParameter,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1_Stream = (
  output: any,
  context: __SerdeContext
): _Stream => {
  let contents: any = {
    __type: "Stream",
    fileId: undefined,
    streamId: undefined
  };
  if (output.fileId !== undefined && output.fileId !== null) {
    contents.fileId = output.fileId;
  }
  if (output.streamId !== undefined && output.streamId !== null) {
    contents.streamId = output.streamId;
  }
  return contents;
};

const deserializeAws_restJson1_1Targets = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1AttributePayload = (
  output: any,
  context: __SerdeContext
): AttributePayload => {
  let contents: any = {
    __type: "AttributePayload",
    attributes: undefined,
    merge: undefined
  };
  if (output.attributes !== undefined && output.attributes !== null) {
    contents.attributes = deserializeAws_restJson1_1Attributes(
      output.attributes,
      context
    );
  }
  if (output.merge !== undefined && output.merge !== null) {
    contents.merge = output.merge;
  }
  return contents;
};

const deserializeAws_restJson1_1Attributes = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1BillingGroupMetadata = (
  output: any,
  context: __SerdeContext
): BillingGroupMetadata => {
  let contents: any = {
    __type: "BillingGroupMetadata",
    creationDate: undefined
  };
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  return contents;
};

const deserializeAws_restJson1_1BillingGroupNameAndArnList = (
  output: any,
  context: __SerdeContext
): Array<GroupNameAndArn> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1GroupNameAndArn(entry, context)
  );
};

const deserializeAws_restJson1_1BillingGroupProperties = (
  output: any,
  context: __SerdeContext
): BillingGroupProperties => {
  let contents: any = {
    __type: "BillingGroupProperties",
    billingGroupDescription: undefined
  };
  if (
    output.billingGroupDescription !== undefined &&
    output.billingGroupDescription !== null
  ) {
    contents.billingGroupDescription = output.billingGroupDescription;
  }
  return contents;
};

const deserializeAws_restJson1_1GroupNameAndArn = (
  output: any,
  context: __SerdeContext
): GroupNameAndArn => {
  let contents: any = {
    __type: "GroupNameAndArn",
    groupArn: undefined,
    groupName: undefined
  };
  if (output.groupArn !== undefined && output.groupArn !== null) {
    contents.groupArn = output.groupArn;
  }
  if (output.groupName !== undefined && output.groupName !== null) {
    contents.groupName = output.groupName;
  }
  return contents;
};

const deserializeAws_restJson1_1S3FileUrlList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1SearchableAttributes = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1TaskIdList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1ThingAttribute = (
  output: any,
  context: __SerdeContext
): ThingAttribute => {
  let contents: any = {
    __type: "ThingAttribute",
    attributes: undefined,
    thingArn: undefined,
    thingName: undefined,
    thingTypeName: undefined,
    version: undefined
  };
  if (output.attributes !== undefined && output.attributes !== null) {
    contents.attributes = deserializeAws_restJson1_1Attributes(
      output.attributes,
      context
    );
  }
  if (output.thingArn !== undefined && output.thingArn !== null) {
    contents.thingArn = output.thingArn;
  }
  if (output.thingName !== undefined && output.thingName !== null) {
    contents.thingName = output.thingName;
  }
  if (output.thingTypeName !== undefined && output.thingTypeName !== null) {
    contents.thingTypeName = output.thingTypeName;
  }
  if (output.version !== undefined && output.version !== null) {
    contents.version = output.version;
  }
  return contents;
};

const deserializeAws_restJson1_1ThingAttributeList = (
  output: any,
  context: __SerdeContext
): Array<ThingAttribute> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ThingAttribute(entry, context)
  );
};

const deserializeAws_restJson1_1ThingGroupMetadata = (
  output: any,
  context: __SerdeContext
): ThingGroupMetadata => {
  let contents: any = {
    __type: "ThingGroupMetadata",
    creationDate: undefined,
    parentGroupName: undefined,
    rootToParentThingGroups: undefined
  };
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.parentGroupName !== undefined && output.parentGroupName !== null) {
    contents.parentGroupName = output.parentGroupName;
  }
  if (
    output.rootToParentThingGroups !== undefined &&
    output.rootToParentThingGroups !== null
  ) {
    contents.rootToParentThingGroups = deserializeAws_restJson1_1ThingGroupNameAndArnList(
      output.rootToParentThingGroups,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ThingGroupNameAndArnList = (
  output: any,
  context: __SerdeContext
): Array<GroupNameAndArn> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1GroupNameAndArn(entry, context)
  );
};

const deserializeAws_restJson1_1ThingGroupProperties = (
  output: any,
  context: __SerdeContext
): ThingGroupProperties => {
  let contents: any = {
    __type: "ThingGroupProperties",
    attributePayload: undefined,
    thingGroupDescription: undefined
  };
  if (
    output.attributePayload !== undefined &&
    output.attributePayload !== null
  ) {
    contents.attributePayload = deserializeAws_restJson1_1AttributePayload(
      output.attributePayload,
      context
    );
  }
  if (
    output.thingGroupDescription !== undefined &&
    output.thingGroupDescription !== null
  ) {
    contents.thingGroupDescription = output.thingGroupDescription;
  }
  return contents;
};

const deserializeAws_restJson1_1ThingNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1ThingTypeDefinition = (
  output: any,
  context: __SerdeContext
): ThingTypeDefinition => {
  let contents: any = {
    __type: "ThingTypeDefinition",
    thingTypeArn: undefined,
    thingTypeMetadata: undefined,
    thingTypeName: undefined,
    thingTypeProperties: undefined
  };
  if (output.thingTypeArn !== undefined && output.thingTypeArn !== null) {
    contents.thingTypeArn = output.thingTypeArn;
  }
  if (
    output.thingTypeMetadata !== undefined &&
    output.thingTypeMetadata !== null
  ) {
    contents.thingTypeMetadata = deserializeAws_restJson1_1ThingTypeMetadata(
      output.thingTypeMetadata,
      context
    );
  }
  if (output.thingTypeName !== undefined && output.thingTypeName !== null) {
    contents.thingTypeName = output.thingTypeName;
  }
  if (
    output.thingTypeProperties !== undefined &&
    output.thingTypeProperties !== null
  ) {
    contents.thingTypeProperties = deserializeAws_restJson1_1ThingTypeProperties(
      output.thingTypeProperties,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ThingTypeList = (
  output: any,
  context: __SerdeContext
): Array<ThingTypeDefinition> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ThingTypeDefinition(entry, context)
  );
};

const deserializeAws_restJson1_1ThingTypeMetadata = (
  output: any,
  context: __SerdeContext
): ThingTypeMetadata => {
  let contents: any = {
    __type: "ThingTypeMetadata",
    creationDate: undefined,
    deprecated: undefined,
    deprecationDate: undefined
  };
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  if (output.deprecated !== undefined && output.deprecated !== null) {
    contents.deprecated = output.deprecated;
  }
  if (output.deprecationDate !== undefined && output.deprecationDate !== null) {
    contents.deprecationDate = new Date(
      Math.round(output.deprecationDate * 1000)
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ThingTypeProperties = (
  output: any,
  context: __SerdeContext
): ThingTypeProperties => {
  let contents: any = {
    __type: "ThingTypeProperties",
    searchableAttributes: undefined,
    thingTypeDescription: undefined
  };
  if (
    output.searchableAttributes !== undefined &&
    output.searchableAttributes !== null
  ) {
    contents.searchableAttributes = deserializeAws_restJson1_1SearchableAttributes(
      output.searchableAttributes,
      context
    );
  }
  if (
    output.thingTypeDescription !== undefined &&
    output.thingTypeDescription !== null
  ) {
    contents.thingTypeDescription = output.thingTypeDescription;
  }
  return contents;
};

const deserializeAws_restJson1_1AddThingsToThingGroupParams = (
  output: any,
  context: __SerdeContext
): AddThingsToThingGroupParams => {
  let contents: any = {
    __type: "AddThingsToThingGroupParams",
    overrideDynamicGroups: undefined,
    thingGroupNames: undefined
  };
  if (
    output.overrideDynamicGroups !== undefined &&
    output.overrideDynamicGroups !== null
  ) {
    contents.overrideDynamicGroups = output.overrideDynamicGroups;
  }
  if (output.thingGroupNames !== undefined && output.thingGroupNames !== null) {
    contents.thingGroupNames = deserializeAws_restJson1_1ThingGroupNames(
      output.thingGroupNames,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1EnableIoTLoggingParams = (
  output: any,
  context: __SerdeContext
): EnableIoTLoggingParams => {
  let contents: any = {
    __type: "EnableIoTLoggingParams",
    logLevel: undefined,
    roleArnForLogging: undefined
  };
  if (output.logLevel !== undefined && output.logLevel !== null) {
    contents.logLevel = output.logLevel;
  }
  if (
    output.roleArnForLogging !== undefined &&
    output.roleArnForLogging !== null
  ) {
    contents.roleArnForLogging = output.roleArnForLogging;
  }
  return contents;
};

const deserializeAws_restJson1_1MitigationAction = (
  output: any,
  context: __SerdeContext
): MitigationAction => {
  let contents: any = {
    __type: "MitigationAction",
    actionParams: undefined,
    id: undefined,
    name: undefined,
    roleArn: undefined
  };
  if (output.actionParams !== undefined && output.actionParams !== null) {
    contents.actionParams = deserializeAws_restJson1_1MitigationActionParams(
      output.actionParams,
      context
    );
  }
  if (output.id !== undefined && output.id !== null) {
    contents.id = output.id;
  }
  if (output.name !== undefined && output.name !== null) {
    contents.name = output.name;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1MitigationActionIdentifier = (
  output: any,
  context: __SerdeContext
): MitigationActionIdentifier => {
  let contents: any = {
    __type: "MitigationActionIdentifier",
    actionArn: undefined,
    actionName: undefined,
    creationDate: undefined
  };
  if (output.actionArn !== undefined && output.actionArn !== null) {
    contents.actionArn = output.actionArn;
  }
  if (output.actionName !== undefined && output.actionName !== null) {
    contents.actionName = output.actionName;
  }
  if (output.creationDate !== undefined && output.creationDate !== null) {
    contents.creationDate = new Date(Math.round(output.creationDate * 1000));
  }
  return contents;
};

const deserializeAws_restJson1_1MitigationActionIdentifierList = (
  output: any,
  context: __SerdeContext
): Array<MitigationActionIdentifier> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1MitigationActionIdentifier(entry, context)
  );
};

const deserializeAws_restJson1_1MitigationActionList = (
  output: any,
  context: __SerdeContext
): Array<MitigationAction> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1MitigationAction(entry, context)
  );
};

const deserializeAws_restJson1_1MitigationActionParams = (
  output: any,
  context: __SerdeContext
): MitigationActionParams => {
  let contents: any = {
    __type: "MitigationActionParams",
    addThingsToThingGroupParams: undefined,
    enableIoTLoggingParams: undefined,
    publishFindingToSnsParams: undefined,
    replaceDefaultPolicyVersionParams: undefined,
    updateCACertificateParams: undefined,
    updateDeviceCertificateParams: undefined
  };
  if (
    output.addThingsToThingGroupParams !== undefined &&
    output.addThingsToThingGroupParams !== null
  ) {
    contents.addThingsToThingGroupParams = deserializeAws_restJson1_1AddThingsToThingGroupParams(
      output.addThingsToThingGroupParams,
      context
    );
  }
  if (
    output.enableIoTLoggingParams !== undefined &&
    output.enableIoTLoggingParams !== null
  ) {
    contents.enableIoTLoggingParams = deserializeAws_restJson1_1EnableIoTLoggingParams(
      output.enableIoTLoggingParams,
      context
    );
  }
  if (
    output.publishFindingToSnsParams !== undefined &&
    output.publishFindingToSnsParams !== null
  ) {
    contents.publishFindingToSnsParams = deserializeAws_restJson1_1PublishFindingToSnsParams(
      output.publishFindingToSnsParams,
      context
    );
  }
  if (
    output.replaceDefaultPolicyVersionParams !== undefined &&
    output.replaceDefaultPolicyVersionParams !== null
  ) {
    contents.replaceDefaultPolicyVersionParams = deserializeAws_restJson1_1ReplaceDefaultPolicyVersionParams(
      output.replaceDefaultPolicyVersionParams,
      context
    );
  }
  if (
    output.updateCACertificateParams !== undefined &&
    output.updateCACertificateParams !== null
  ) {
    contents.updateCACertificateParams = deserializeAws_restJson1_1UpdateCACertificateParams(
      output.updateCACertificateParams,
      context
    );
  }
  if (
    output.updateDeviceCertificateParams !== undefined &&
    output.updateDeviceCertificateParams !== null
  ) {
    contents.updateDeviceCertificateParams = deserializeAws_restJson1_1UpdateDeviceCertificateParams(
      output.updateDeviceCertificateParams,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1PublishFindingToSnsParams = (
  output: any,
  context: __SerdeContext
): PublishFindingToSnsParams => {
  let contents: any = {
    __type: "PublishFindingToSnsParams",
    topicArn: undefined
  };
  if (output.topicArn !== undefined && output.topicArn !== null) {
    contents.topicArn = output.topicArn;
  }
  return contents;
};

const deserializeAws_restJson1_1ReplaceDefaultPolicyVersionParams = (
  output: any,
  context: __SerdeContext
): ReplaceDefaultPolicyVersionParams => {
  let contents: any = {
    __type: "ReplaceDefaultPolicyVersionParams",
    templateName: undefined
  };
  if (output.templateName !== undefined && output.templateName !== null) {
    contents.templateName = output.templateName;
  }
  return contents;
};

const deserializeAws_restJson1_1ThingGroupNames = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1UpdateCACertificateParams = (
  output: any,
  context: __SerdeContext
): UpdateCACertificateParams => {
  let contents: any = {
    __type: "UpdateCACertificateParams",
    action: undefined
  };
  if (output.action !== undefined && output.action !== null) {
    contents.action = output.action;
  }
  return contents;
};

const deserializeAws_restJson1_1UpdateDeviceCertificateParams = (
  output: any,
  context: __SerdeContext
): UpdateDeviceCertificateParams => {
  let contents: any = {
    __type: "UpdateDeviceCertificateParams",
    action: undefined
  };
  if (output.action !== undefined && output.action !== null) {
    contents.action = output.action;
  }
  return contents;
};

const deserializeAws_restJson1_1AuditCheckConfiguration = (
  output: any,
  context: __SerdeContext
): AuditCheckConfiguration => {
  let contents: any = {
    __type: "AuditCheckConfiguration",
    enabled: undefined
  };
  if (output.enabled !== undefined && output.enabled !== null) {
    contents.enabled = output.enabled;
  }
  return contents;
};

const deserializeAws_restJson1_1AuditCheckConfigurations = (
  output: any,
  context: __SerdeContext
): { [key: string]: AuditCheckConfiguration } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1AuditCheckConfiguration(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1AuditCheckDetails = (
  output: any,
  context: __SerdeContext
): AuditCheckDetails => {
  let contents: any = {
    __type: "AuditCheckDetails",
    checkCompliant: undefined,
    checkRunStatus: undefined,
    errorCode: undefined,
    message: undefined,
    nonCompliantResourcesCount: undefined,
    totalResourcesCount: undefined
  };
  if (output.checkCompliant !== undefined && output.checkCompliant !== null) {
    contents.checkCompliant = output.checkCompliant;
  }
  if (output.checkRunStatus !== undefined && output.checkRunStatus !== null) {
    contents.checkRunStatus = output.checkRunStatus;
  }
  if (output.errorCode !== undefined && output.errorCode !== null) {
    contents.errorCode = output.errorCode;
  }
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  if (
    output.nonCompliantResourcesCount !== undefined &&
    output.nonCompliantResourcesCount !== null
  ) {
    contents.nonCompliantResourcesCount = output.nonCompliantResourcesCount;
  }
  if (
    output.totalResourcesCount !== undefined &&
    output.totalResourcesCount !== null
  ) {
    contents.totalResourcesCount = output.totalResourcesCount;
  }
  return contents;
};

const deserializeAws_restJson1_1AuditCheckToActionsMapping = (
  output: any,
  context: __SerdeContext
): { [key: string]: Array<string> } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1MitigationActionNameList(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1AuditCheckToReasonCodeFilter = (
  output: any,
  context: __SerdeContext
): { [key: string]: Array<string> } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1ReasonForNonComplianceCodes(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1AuditDetails = (
  output: any,
  context: __SerdeContext
): { [key: string]: AuditCheckDetails } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1AuditCheckDetails(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1AuditFinding = (
  output: any,
  context: __SerdeContext
): AuditFinding => {
  let contents: any = {
    __type: "AuditFinding",
    checkName: undefined,
    findingId: undefined,
    findingTime: undefined,
    nonCompliantResource: undefined,
    reasonForNonCompliance: undefined,
    reasonForNonComplianceCode: undefined,
    relatedResources: undefined,
    severity: undefined,
    taskId: undefined,
    taskStartTime: undefined
  };
  if (output.checkName !== undefined && output.checkName !== null) {
    contents.checkName = output.checkName;
  }
  if (output.findingId !== undefined && output.findingId !== null) {
    contents.findingId = output.findingId;
  }
  if (output.findingTime !== undefined && output.findingTime !== null) {
    contents.findingTime = new Date(Math.round(output.findingTime * 1000));
  }
  if (
    output.nonCompliantResource !== undefined &&
    output.nonCompliantResource !== null
  ) {
    contents.nonCompliantResource = deserializeAws_restJson1_1NonCompliantResource(
      output.nonCompliantResource,
      context
    );
  }
  if (
    output.reasonForNonCompliance !== undefined &&
    output.reasonForNonCompliance !== null
  ) {
    contents.reasonForNonCompliance = output.reasonForNonCompliance;
  }
  if (
    output.reasonForNonComplianceCode !== undefined &&
    output.reasonForNonComplianceCode !== null
  ) {
    contents.reasonForNonComplianceCode = output.reasonForNonComplianceCode;
  }
  if (
    output.relatedResources !== undefined &&
    output.relatedResources !== null
  ) {
    contents.relatedResources = deserializeAws_restJson1_1RelatedResources(
      output.relatedResources,
      context
    );
  }
  if (output.severity !== undefined && output.severity !== null) {
    contents.severity = output.severity;
  }
  if (output.taskId !== undefined && output.taskId !== null) {
    contents.taskId = output.taskId;
  }
  if (output.taskStartTime !== undefined && output.taskStartTime !== null) {
    contents.taskStartTime = new Date(Math.round(output.taskStartTime * 1000));
  }
  return contents;
};

const deserializeAws_restJson1_1AuditFindings = (
  output: any,
  context: __SerdeContext
): Array<AuditFinding> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1AuditFinding(entry, context)
  );
};

const deserializeAws_restJson1_1AuditMitigationActionExecutionMetadata = (
  output: any,
  context: __SerdeContext
): AuditMitigationActionExecutionMetadata => {
  let contents: any = {
    __type: "AuditMitigationActionExecutionMetadata",
    actionId: undefined,
    actionName: undefined,
    endTime: undefined,
    errorCode: undefined,
    findingId: undefined,
    message: undefined,
    startTime: undefined,
    status: undefined,
    taskId: undefined
  };
  if (output.actionId !== undefined && output.actionId !== null) {
    contents.actionId = output.actionId;
  }
  if (output.actionName !== undefined && output.actionName !== null) {
    contents.actionName = output.actionName;
  }
  if (output.endTime !== undefined && output.endTime !== null) {
    contents.endTime = new Date(Math.round(output.endTime * 1000));
  }
  if (output.errorCode !== undefined && output.errorCode !== null) {
    contents.errorCode = output.errorCode;
  }
  if (output.findingId !== undefined && output.findingId !== null) {
    contents.findingId = output.findingId;
  }
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  if (output.startTime !== undefined && output.startTime !== null) {
    contents.startTime = new Date(Math.round(output.startTime * 1000));
  }
  if (output.status !== undefined && output.status !== null) {
    contents.status = output.status;
  }
  if (output.taskId !== undefined && output.taskId !== null) {
    contents.taskId = output.taskId;
  }
  return contents;
};

const deserializeAws_restJson1_1AuditMitigationActionExecutionMetadataList = (
  output: any,
  context: __SerdeContext
): Array<AuditMitigationActionExecutionMetadata> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1AuditMitigationActionExecutionMetadata(
      entry,
      context
    )
  );
};

const deserializeAws_restJson1_1AuditMitigationActionsTaskMetadata = (
  output: any,
  context: __SerdeContext
): AuditMitigationActionsTaskMetadata => {
  let contents: any = {
    __type: "AuditMitigationActionsTaskMetadata",
    startTime: undefined,
    taskId: undefined,
    taskStatus: undefined
  };
  if (output.startTime !== undefined && output.startTime !== null) {
    contents.startTime = new Date(Math.round(output.startTime * 1000));
  }
  if (output.taskId !== undefined && output.taskId !== null) {
    contents.taskId = output.taskId;
  }
  if (output.taskStatus !== undefined && output.taskStatus !== null) {
    contents.taskStatus = output.taskStatus;
  }
  return contents;
};

const deserializeAws_restJson1_1AuditMitigationActionsTaskMetadataList = (
  output: any,
  context: __SerdeContext
): Array<AuditMitigationActionsTaskMetadata> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1AuditMitigationActionsTaskMetadata(entry, context)
  );
};

const deserializeAws_restJson1_1AuditMitigationActionsTaskStatistics = (
  output: any,
  context: __SerdeContext
): { [key: string]: TaskStatisticsForAuditCheck } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1TaskStatisticsForAuditCheck(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1AuditMitigationActionsTaskTarget = (
  output: any,
  context: __SerdeContext
): AuditMitigationActionsTaskTarget => {
  let contents: any = {
    __type: "AuditMitigationActionsTaskTarget",
    auditCheckToReasonCodeFilter: undefined,
    auditTaskId: undefined,
    findingIds: undefined
  };
  if (
    output.auditCheckToReasonCodeFilter !== undefined &&
    output.auditCheckToReasonCodeFilter !== null
  ) {
    contents.auditCheckToReasonCodeFilter = deserializeAws_restJson1_1AuditCheckToReasonCodeFilter(
      output.auditCheckToReasonCodeFilter,
      context
    );
  }
  if (output.auditTaskId !== undefined && output.auditTaskId !== null) {
    contents.auditTaskId = output.auditTaskId;
  }
  if (output.findingIds !== undefined && output.findingIds !== null) {
    contents.findingIds = deserializeAws_restJson1_1FindingIds(
      output.findingIds,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1AuditNotificationTarget = (
  output: any,
  context: __SerdeContext
): AuditNotificationTarget => {
  let contents: any = {
    __type: "AuditNotificationTarget",
    enabled: undefined,
    roleArn: undefined,
    targetArn: undefined
  };
  if (output.enabled !== undefined && output.enabled !== null) {
    contents.enabled = output.enabled;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.targetArn !== undefined && output.targetArn !== null) {
    contents.targetArn = output.targetArn;
  }
  return contents;
};

const deserializeAws_restJson1_1AuditNotificationTargetConfigurations = (
  output: any,
  context: __SerdeContext
): { [key: string]: AuditNotificationTarget } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1AuditNotificationTarget(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1AuditTaskMetadata = (
  output: any,
  context: __SerdeContext
): AuditTaskMetadata => {
  let contents: any = {
    __type: "AuditTaskMetadata",
    taskId: undefined,
    taskStatus: undefined,
    taskType: undefined
  };
  if (output.taskId !== undefined && output.taskId !== null) {
    contents.taskId = output.taskId;
  }
  if (output.taskStatus !== undefined && output.taskStatus !== null) {
    contents.taskStatus = output.taskStatus;
  }
  if (output.taskType !== undefined && output.taskType !== null) {
    contents.taskType = output.taskType;
  }
  return contents;
};

const deserializeAws_restJson1_1AuditTaskMetadataList = (
  output: any,
  context: __SerdeContext
): Array<AuditTaskMetadata> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1AuditTaskMetadata(entry, context)
  );
};

const deserializeAws_restJson1_1FindingIds = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1MitigationActionNameList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1NonCompliantResource = (
  output: any,
  context: __SerdeContext
): NonCompliantResource => {
  let contents: any = {
    __type: "NonCompliantResource",
    additionalInfo: undefined,
    resourceIdentifier: undefined,
    resourceType: undefined
  };
  if (output.additionalInfo !== undefined && output.additionalInfo !== null) {
    contents.additionalInfo = deserializeAws_restJson1_1StringMap(
      output.additionalInfo,
      context
    );
  }
  if (
    output.resourceIdentifier !== undefined &&
    output.resourceIdentifier !== null
  ) {
    contents.resourceIdentifier = deserializeAws_restJson1_1ResourceIdentifier(
      output.resourceIdentifier,
      context
    );
  }
  if (output.resourceType !== undefined && output.resourceType !== null) {
    contents.resourceType = output.resourceType;
  }
  return contents;
};

const deserializeAws_restJson1_1PolicyVersionIdentifier = (
  output: any,
  context: __SerdeContext
): PolicyVersionIdentifier => {
  let contents: any = {
    __type: "PolicyVersionIdentifier",
    policyName: undefined,
    policyVersionId: undefined
  };
  if (output.policyName !== undefined && output.policyName !== null) {
    contents.policyName = output.policyName;
  }
  if (output.policyVersionId !== undefined && output.policyVersionId !== null) {
    contents.policyVersionId = output.policyVersionId;
  }
  return contents;
};

const deserializeAws_restJson1_1ReasonForNonComplianceCodes = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1RelatedResource = (
  output: any,
  context: __SerdeContext
): RelatedResource => {
  let contents: any = {
    __type: "RelatedResource",
    additionalInfo: undefined,
    resourceIdentifier: undefined,
    resourceType: undefined
  };
  if (output.additionalInfo !== undefined && output.additionalInfo !== null) {
    contents.additionalInfo = deserializeAws_restJson1_1StringMap(
      output.additionalInfo,
      context
    );
  }
  if (
    output.resourceIdentifier !== undefined &&
    output.resourceIdentifier !== null
  ) {
    contents.resourceIdentifier = deserializeAws_restJson1_1ResourceIdentifier(
      output.resourceIdentifier,
      context
    );
  }
  if (output.resourceType !== undefined && output.resourceType !== null) {
    contents.resourceType = output.resourceType;
  }
  return contents;
};

const deserializeAws_restJson1_1RelatedResources = (
  output: any,
  context: __SerdeContext
): Array<RelatedResource> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1RelatedResource(entry, context)
  );
};

const deserializeAws_restJson1_1ResourceIdentifier = (
  output: any,
  context: __SerdeContext
): ResourceIdentifier => {
  let contents: any = {
    __type: "ResourceIdentifier",
    account: undefined,
    caCertificateId: undefined,
    clientId: undefined,
    cognitoIdentityPoolId: undefined,
    deviceCertificateId: undefined,
    iamRoleArn: undefined,
    policyVersionIdentifier: undefined,
    roleAliasArn: undefined
  };
  if (output.account !== undefined && output.account !== null) {
    contents.account = output.account;
  }
  if (output.caCertificateId !== undefined && output.caCertificateId !== null) {
    contents.caCertificateId = output.caCertificateId;
  }
  if (output.clientId !== undefined && output.clientId !== null) {
    contents.clientId = output.clientId;
  }
  if (
    output.cognitoIdentityPoolId !== undefined &&
    output.cognitoIdentityPoolId !== null
  ) {
    contents.cognitoIdentityPoolId = output.cognitoIdentityPoolId;
  }
  if (
    output.deviceCertificateId !== undefined &&
    output.deviceCertificateId !== null
  ) {
    contents.deviceCertificateId = output.deviceCertificateId;
  }
  if (output.iamRoleArn !== undefined && output.iamRoleArn !== null) {
    contents.iamRoleArn = output.iamRoleArn;
  }
  if (
    output.policyVersionIdentifier !== undefined &&
    output.policyVersionIdentifier !== null
  ) {
    contents.policyVersionIdentifier = deserializeAws_restJson1_1PolicyVersionIdentifier(
      output.policyVersionIdentifier,
      context
    );
  }
  if (output.roleAliasArn !== undefined && output.roleAliasArn !== null) {
    contents.roleAliasArn = output.roleAliasArn;
  }
  return contents;
};

const deserializeAws_restJson1_1ScheduledAuditMetadata = (
  output: any,
  context: __SerdeContext
): ScheduledAuditMetadata => {
  let contents: any = {
    __type: "ScheduledAuditMetadata",
    dayOfMonth: undefined,
    dayOfWeek: undefined,
    frequency: undefined,
    scheduledAuditArn: undefined,
    scheduledAuditName: undefined
  };
  if (output.dayOfMonth !== undefined && output.dayOfMonth !== null) {
    contents.dayOfMonth = output.dayOfMonth;
  }
  if (output.dayOfWeek !== undefined && output.dayOfWeek !== null) {
    contents.dayOfWeek = output.dayOfWeek;
  }
  if (output.frequency !== undefined && output.frequency !== null) {
    contents.frequency = output.frequency;
  }
  if (
    output.scheduledAuditArn !== undefined &&
    output.scheduledAuditArn !== null
  ) {
    contents.scheduledAuditArn = output.scheduledAuditArn;
  }
  if (
    output.scheduledAuditName !== undefined &&
    output.scheduledAuditName !== null
  ) {
    contents.scheduledAuditName = output.scheduledAuditName;
  }
  return contents;
};

const deserializeAws_restJson1_1ScheduledAuditMetadataList = (
  output: any,
  context: __SerdeContext
): Array<ScheduledAuditMetadata> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ScheduledAuditMetadata(entry, context)
  );
};

const deserializeAws_restJson1_1StringMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = output[key];
  });
  return mapParams;
};

const deserializeAws_restJson1_1TargetAuditCheckNames = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1TaskStatistics = (
  output: any,
  context: __SerdeContext
): TaskStatistics => {
  let contents: any = {
    __type: "TaskStatistics",
    canceledChecks: undefined,
    compliantChecks: undefined,
    failedChecks: undefined,
    inProgressChecks: undefined,
    nonCompliantChecks: undefined,
    totalChecks: undefined,
    waitingForDataCollectionChecks: undefined
  };
  if (output.canceledChecks !== undefined && output.canceledChecks !== null) {
    contents.canceledChecks = output.canceledChecks;
  }
  if (output.compliantChecks !== undefined && output.compliantChecks !== null) {
    contents.compliantChecks = output.compliantChecks;
  }
  if (output.failedChecks !== undefined && output.failedChecks !== null) {
    contents.failedChecks = output.failedChecks;
  }
  if (
    output.inProgressChecks !== undefined &&
    output.inProgressChecks !== null
  ) {
    contents.inProgressChecks = output.inProgressChecks;
  }
  if (
    output.nonCompliantChecks !== undefined &&
    output.nonCompliantChecks !== null
  ) {
    contents.nonCompliantChecks = output.nonCompliantChecks;
  }
  if (output.totalChecks !== undefined && output.totalChecks !== null) {
    contents.totalChecks = output.totalChecks;
  }
  if (
    output.waitingForDataCollectionChecks !== undefined &&
    output.waitingForDataCollectionChecks !== null
  ) {
    contents.waitingForDataCollectionChecks =
      output.waitingForDataCollectionChecks;
  }
  return contents;
};

const deserializeAws_restJson1_1TaskStatisticsForAuditCheck = (
  output: any,
  context: __SerdeContext
): TaskStatisticsForAuditCheck => {
  let contents: any = {
    __type: "TaskStatisticsForAuditCheck",
    canceledFindingsCount: undefined,
    failedFindingsCount: undefined,
    skippedFindingsCount: undefined,
    succeededFindingsCount: undefined,
    totalFindingsCount: undefined
  };
  if (
    output.canceledFindingsCount !== undefined &&
    output.canceledFindingsCount !== null
  ) {
    contents.canceledFindingsCount = output.canceledFindingsCount;
  }
  if (
    output.failedFindingsCount !== undefined &&
    output.failedFindingsCount !== null
  ) {
    contents.failedFindingsCount = output.failedFindingsCount;
  }
  if (
    output.skippedFindingsCount !== undefined &&
    output.skippedFindingsCount !== null
  ) {
    contents.skippedFindingsCount = output.skippedFindingsCount;
  }
  if (
    output.succeededFindingsCount !== undefined &&
    output.succeededFindingsCount !== null
  ) {
    contents.succeededFindingsCount = output.succeededFindingsCount;
  }
  if (
    output.totalFindingsCount !== undefined &&
    output.totalFindingsCount !== null
  ) {
    contents.totalFindingsCount = output.totalFindingsCount;
  }
  return contents;
};

const deserializeAws_restJson1_1ActiveViolation = (
  output: any,
  context: __SerdeContext
): ActiveViolation => {
  let contents: any = {
    __type: "ActiveViolation",
    behavior: undefined,
    lastViolationTime: undefined,
    lastViolationValue: undefined,
    securityProfileName: undefined,
    thingName: undefined,
    violationId: undefined,
    violationStartTime: undefined
  };
  if (output.behavior !== undefined && output.behavior !== null) {
    contents.behavior = deserializeAws_restJson1_1Behavior(
      output.behavior,
      context
    );
  }
  if (
    output.lastViolationTime !== undefined &&
    output.lastViolationTime !== null
  ) {
    contents.lastViolationTime = new Date(
      Math.round(output.lastViolationTime * 1000)
    );
  }
  if (
    output.lastViolationValue !== undefined &&
    output.lastViolationValue !== null
  ) {
    contents.lastViolationValue = deserializeAws_restJson1_1MetricValue(
      output.lastViolationValue,
      context
    );
  }
  if (
    output.securityProfileName !== undefined &&
    output.securityProfileName !== null
  ) {
    contents.securityProfileName = output.securityProfileName;
  }
  if (output.thingName !== undefined && output.thingName !== null) {
    contents.thingName = output.thingName;
  }
  if (output.violationId !== undefined && output.violationId !== null) {
    contents.violationId = output.violationId;
  }
  if (
    output.violationStartTime !== undefined &&
    output.violationStartTime !== null
  ) {
    contents.violationStartTime = new Date(
      Math.round(output.violationStartTime * 1000)
    );
  }
  return contents;
};

const deserializeAws_restJson1_1ActiveViolations = (
  output: any,
  context: __SerdeContext
): Array<ActiveViolation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ActiveViolation(entry, context)
  );
};

const deserializeAws_restJson1_1AdditionalMetricsToRetainList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1AlertTarget = (
  output: any,
  context: __SerdeContext
): AlertTarget => {
  let contents: any = {
    __type: "AlertTarget",
    alertTargetArn: undefined,
    roleArn: undefined
  };
  if (output.alertTargetArn !== undefined && output.alertTargetArn !== null) {
    contents.alertTargetArn = output.alertTargetArn;
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  return contents;
};

const deserializeAws_restJson1_1AlertTargets = (
  output: any,
  context: __SerdeContext
): { [key: string]: AlertTarget } => {
  const mapParams: any = {};
  Object.keys(output).forEach(key => {
    mapParams[key] = deserializeAws_restJson1_1AlertTarget(
      output[key],
      context
    );
  });
  return mapParams;
};

const deserializeAws_restJson1_1Behavior = (
  output: any,
  context: __SerdeContext
): Behavior => {
  let contents: any = {
    __type: "Behavior",
    criteria: undefined,
    metric: undefined,
    name: undefined
  };
  if (output.criteria !== undefined && output.criteria !== null) {
    contents.criteria = deserializeAws_restJson1_1BehaviorCriteria(
      output.criteria,
      context
    );
  }
  if (output.metric !== undefined && output.metric !== null) {
    contents.metric = output.metric;
  }
  if (output.name !== undefined && output.name !== null) {
    contents.name = output.name;
  }
  return contents;
};

const deserializeAws_restJson1_1BehaviorCriteria = (
  output: any,
  context: __SerdeContext
): BehaviorCriteria => {
  let contents: any = {
    __type: "BehaviorCriteria",
    comparisonOperator: undefined,
    consecutiveDatapointsToAlarm: undefined,
    consecutiveDatapointsToClear: undefined,
    durationSeconds: undefined,
    statisticalThreshold: undefined,
    value: undefined
  };
  if (
    output.comparisonOperator !== undefined &&
    output.comparisonOperator !== null
  ) {
    contents.comparisonOperator = output.comparisonOperator;
  }
  if (
    output.consecutiveDatapointsToAlarm !== undefined &&
    output.consecutiveDatapointsToAlarm !== null
  ) {
    contents.consecutiveDatapointsToAlarm = output.consecutiveDatapointsToAlarm;
  }
  if (
    output.consecutiveDatapointsToClear !== undefined &&
    output.consecutiveDatapointsToClear !== null
  ) {
    contents.consecutiveDatapointsToClear = output.consecutiveDatapointsToClear;
  }
  if (output.durationSeconds !== undefined && output.durationSeconds !== null) {
    contents.durationSeconds = output.durationSeconds;
  }
  if (
    output.statisticalThreshold !== undefined &&
    output.statisticalThreshold !== null
  ) {
    contents.statisticalThreshold = deserializeAws_restJson1_1StatisticalThreshold(
      output.statisticalThreshold,
      context
    );
  }
  if (output.value !== undefined && output.value !== null) {
    contents.value = deserializeAws_restJson1_1MetricValue(
      output.value,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1Behaviors = (
  output: any,
  context: __SerdeContext
): Array<Behavior> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1Behavior(entry, context)
  );
};

const deserializeAws_restJson1_1Cidrs = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1MetricValue = (
  output: any,
  context: __SerdeContext
): MetricValue => {
  let contents: any = {
    __type: "MetricValue",
    cidrs: undefined,
    count: undefined,
    ports: undefined
  };
  if (output.cidrs !== undefined && output.cidrs !== null) {
    contents.cidrs = deserializeAws_restJson1_1Cidrs(output.cidrs, context);
  }
  if (output.count !== undefined && output.count !== null) {
    contents.count = output.count;
  }
  if (output.ports !== undefined && output.ports !== null) {
    contents.ports = deserializeAws_restJson1_1Ports(output.ports, context);
  }
  return contents;
};

const deserializeAws_restJson1_1Ports = (
  output: any,
  context: __SerdeContext
): Array<number> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restJson1_1SecurityProfileIdentifier = (
  output: any,
  context: __SerdeContext
): SecurityProfileIdentifier => {
  let contents: any = {
    __type: "SecurityProfileIdentifier",
    arn: undefined,
    name: undefined
  };
  if (output.arn !== undefined && output.arn !== null) {
    contents.arn = output.arn;
  }
  if (output.name !== undefined && output.name !== null) {
    contents.name = output.name;
  }
  return contents;
};

const deserializeAws_restJson1_1SecurityProfileIdentifiers = (
  output: any,
  context: __SerdeContext
): Array<SecurityProfileIdentifier> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SecurityProfileIdentifier(entry, context)
  );
};

const deserializeAws_restJson1_1SecurityProfileTarget = (
  output: any,
  context: __SerdeContext
): SecurityProfileTarget => {
  let contents: any = {
    __type: "SecurityProfileTarget",
    arn: undefined
  };
  if (output.arn !== undefined && output.arn !== null) {
    contents.arn = output.arn;
  }
  return contents;
};

const deserializeAws_restJson1_1SecurityProfileTargetMapping = (
  output: any,
  context: __SerdeContext
): SecurityProfileTargetMapping => {
  let contents: any = {
    __type: "SecurityProfileTargetMapping",
    securityProfileIdentifier: undefined,
    target: undefined
  };
  if (
    output.securityProfileIdentifier !== undefined &&
    output.securityProfileIdentifier !== null
  ) {
    contents.securityProfileIdentifier = deserializeAws_restJson1_1SecurityProfileIdentifier(
      output.securityProfileIdentifier,
      context
    );
  }
  if (output.target !== undefined && output.target !== null) {
    contents.target = deserializeAws_restJson1_1SecurityProfileTarget(
      output.target,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1SecurityProfileTargetMappings = (
  output: any,
  context: __SerdeContext
): Array<SecurityProfileTargetMapping> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SecurityProfileTargetMapping(entry, context)
  );
};

const deserializeAws_restJson1_1SecurityProfileTargets = (
  output: any,
  context: __SerdeContext
): Array<SecurityProfileTarget> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1SecurityProfileTarget(entry, context)
  );
};

const deserializeAws_restJson1_1StatisticalThreshold = (
  output: any,
  context: __SerdeContext
): StatisticalThreshold => {
  let contents: any = {
    __type: "StatisticalThreshold",
    statistic: undefined
  };
  if (output.statistic !== undefined && output.statistic !== null) {
    contents.statistic = output.statistic;
  }
  return contents;
};

const deserializeAws_restJson1_1ValidationError = (
  output: any,
  context: __SerdeContext
): ValidationError => {
  let contents: any = {
    __type: "ValidationError",
    errorMessage: undefined
  };
  if (output.errorMessage !== undefined && output.errorMessage !== null) {
    contents.errorMessage = output.errorMessage;
  }
  return contents;
};

const deserializeAws_restJson1_1ValidationErrors = (
  output: any,
  context: __SerdeContext
): Array<ValidationError> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ValidationError(entry, context)
  );
};

const deserializeAws_restJson1_1ViolationEvent = (
  output: any,
  context: __SerdeContext
): ViolationEvent => {
  let contents: any = {
    __type: "ViolationEvent",
    behavior: undefined,
    metricValue: undefined,
    securityProfileName: undefined,
    thingName: undefined,
    violationEventTime: undefined,
    violationEventType: undefined,
    violationId: undefined
  };
  if (output.behavior !== undefined && output.behavior !== null) {
    contents.behavior = deserializeAws_restJson1_1Behavior(
      output.behavior,
      context
    );
  }
  if (output.metricValue !== undefined && output.metricValue !== null) {
    contents.metricValue = deserializeAws_restJson1_1MetricValue(
      output.metricValue,
      context
    );
  }
  if (
    output.securityProfileName !== undefined &&
    output.securityProfileName !== null
  ) {
    contents.securityProfileName = output.securityProfileName;
  }
  if (output.thingName !== undefined && output.thingName !== null) {
    contents.thingName = output.thingName;
  }
  if (
    output.violationEventTime !== undefined &&
    output.violationEventTime !== null
  ) {
    contents.violationEventTime = new Date(
      Math.round(output.violationEventTime * 1000)
    );
  }
  if (
    output.violationEventType !== undefined &&
    output.violationEventType !== null
  ) {
    contents.violationEventType = output.violationEventType;
  }
  if (output.violationId !== undefined && output.violationId !== null) {
    contents.violationId = output.violationId;
  }
  return contents;
};

const deserializeAws_restJson1_1ViolationEvents = (
  output: any,
  context: __SerdeContext
): Array<ViolationEvent> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1ViolationEvent(entry, context)
  );
};

const deserializeAws_restJson1_1StreamFile = (
  output: any,
  context: __SerdeContext
): StreamFile => {
  let contents: any = {
    __type: "StreamFile",
    fileId: undefined,
    s3Location: undefined
  };
  if (output.fileId !== undefined && output.fileId !== null) {
    contents.fileId = output.fileId;
  }
  if (output.s3Location !== undefined && output.s3Location !== null) {
    contents.s3Location = deserializeAws_restJson1_1S3Location(
      output.s3Location,
      context
    );
  }
  return contents;
};

const deserializeAws_restJson1_1StreamFiles = (
  output: any,
  context: __SerdeContext
): Array<StreamFile> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1StreamFile(entry, context)
  );
};

const deserializeAws_restJson1_1StreamInfo = (
  output: any,
  context: __SerdeContext
): StreamInfo => {
  let contents: any = {
    __type: "StreamInfo",
    createdAt: undefined,
    description: undefined,
    files: undefined,
    lastUpdatedAt: undefined,
    roleArn: undefined,
    streamArn: undefined,
    streamId: undefined,
    streamVersion: undefined
  };
  if (output.createdAt !== undefined && output.createdAt !== null) {
    contents.createdAt = new Date(Math.round(output.createdAt * 1000));
  }
  if (output.description !== undefined && output.description !== null) {
    contents.description = output.description;
  }
  if (output.files !== undefined && output.files !== null) {
    contents.files = deserializeAws_restJson1_1StreamFiles(
      output.files,
      context
    );
  }
  if (output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null) {
    contents.lastUpdatedAt = new Date(Math.round(output.lastUpdatedAt * 1000));
  }
  if (output.roleArn !== undefined && output.roleArn !== null) {
    contents.roleArn = output.roleArn;
  }
  if (output.streamArn !== undefined && output.streamArn !== null) {
    contents.streamArn = output.streamArn;
  }
  if (output.streamId !== undefined && output.streamId !== null) {
    contents.streamId = output.streamId;
  }
  if (output.streamVersion !== undefined && output.streamVersion !== null) {
    contents.streamVersion = output.streamVersion;
  }
  return contents;
};

const deserializeAws_restJson1_1StreamSummary = (
  output: any,
  context: __SerdeContext
): StreamSummary => {
  let contents: any = {
    __type: "StreamSummary",
    description: undefined,
    streamArn: undefined,
    streamId: undefined,
    streamVersion: undefined
  };
  if (output.description !== undefined && output.description !== null) {
    contents.description = output.description;
  }
  if (output.streamArn !== undefined && output.streamArn !== null) {
    contents.streamArn = output.streamArn;
  }
  if (output.streamId !== undefined && output.streamId !== null) {
    contents.streamId = output.streamId;
  }
  if (output.streamVersion !== undefined && output.streamVersion !== null) {
    contents.streamVersion = output.streamVersion;
  }
  return contents;
};

const deserializeAws_restJson1_1StreamsSummary = (
  output: any,
  context: __SerdeContext
): Array<StreamSummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restJson1_1StreamSummary(entry, context)
  );
};

const deserializeAws_restJson1_1S3Location = (
  output: any,
  context: __SerdeContext
): S3Location => {
  let contents: any = {
    __type: "S3Location",
    bucket: undefined,
    key: undefined,
    version: undefined
  };
  if (output.bucket !== undefined && output.bucket !== null) {
    contents.bucket = output.bucket;
  }
  if (output.key !== undefined && output.key !== null) {
    contents.key = output.key;
  }
  if (output.version !== undefined && output.version !== null) {
    contents.version = output.version;
  }
  return contents;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
