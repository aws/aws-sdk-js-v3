import {
  AcceptCertificateTransferCommandInput,
  AcceptCertificateTransferCommandOutput,
} from "../commands/AcceptCertificateTransferCommand";
import {
  AddThingToBillingGroupCommandInput,
  AddThingToBillingGroupCommandOutput,
} from "../commands/AddThingToBillingGroupCommand";
import {
  AddThingToThingGroupCommandInput,
  AddThingToThingGroupCommandOutput,
} from "../commands/AddThingToThingGroupCommand";
import {
  AssociateTargetsWithJobCommandInput,
  AssociateTargetsWithJobCommandOutput,
} from "../commands/AssociateTargetsWithJobCommand";
import { AttachPolicyCommandInput, AttachPolicyCommandOutput } from "../commands/AttachPolicyCommand";
import {
  AttachPrincipalPolicyCommandInput,
  AttachPrincipalPolicyCommandOutput,
} from "../commands/AttachPrincipalPolicyCommand";
import {
  AttachSecurityProfileCommandInput,
  AttachSecurityProfileCommandOutput,
} from "../commands/AttachSecurityProfileCommand";
import {
  AttachThingPrincipalCommandInput,
  AttachThingPrincipalCommandOutput,
} from "../commands/AttachThingPrincipalCommand";
import {
  CancelAuditMitigationActionsTaskCommandInput,
  CancelAuditMitigationActionsTaskCommandOutput,
} from "../commands/CancelAuditMitigationActionsTaskCommand";
import { CancelAuditTaskCommandInput, CancelAuditTaskCommandOutput } from "../commands/CancelAuditTaskCommand";
import {
  CancelCertificateTransferCommandInput,
  CancelCertificateTransferCommandOutput,
} from "../commands/CancelCertificateTransferCommand";
import {
  CancelDetectMitigationActionsTaskCommandInput,
  CancelDetectMitigationActionsTaskCommandOutput,
} from "../commands/CancelDetectMitigationActionsTaskCommand";
import { CancelJobCommandInput, CancelJobCommandOutput } from "../commands/CancelJobCommand";
import { CancelJobExecutionCommandInput, CancelJobExecutionCommandOutput } from "../commands/CancelJobExecutionCommand";
import {
  ClearDefaultAuthorizerCommandInput,
  ClearDefaultAuthorizerCommandOutput,
} from "../commands/ClearDefaultAuthorizerCommand";
import {
  ConfirmTopicRuleDestinationCommandInput,
  ConfirmTopicRuleDestinationCommandOutput,
} from "../commands/ConfirmTopicRuleDestinationCommand";
import {
  CreateAuditSuppressionCommandInput,
  CreateAuditSuppressionCommandOutput,
} from "../commands/CreateAuditSuppressionCommand";
import { CreateAuthorizerCommandInput, CreateAuthorizerCommandOutput } from "../commands/CreateAuthorizerCommand";
import { CreateBillingGroupCommandInput, CreateBillingGroupCommandOutput } from "../commands/CreateBillingGroupCommand";
import {
  CreateCertificateFromCsrCommandInput,
  CreateCertificateFromCsrCommandOutput,
} from "../commands/CreateCertificateFromCsrCommand";
import { CreateCustomMetricCommandInput, CreateCustomMetricCommandOutput } from "../commands/CreateCustomMetricCommand";
import { CreateDimensionCommandInput, CreateDimensionCommandOutput } from "../commands/CreateDimensionCommand";
import {
  CreateDomainConfigurationCommandInput,
  CreateDomainConfigurationCommandOutput,
} from "../commands/CreateDomainConfigurationCommand";
import {
  CreateDynamicThingGroupCommandInput,
  CreateDynamicThingGroupCommandOutput,
} from "../commands/CreateDynamicThingGroupCommand";
import { CreateFleetMetricCommandInput, CreateFleetMetricCommandOutput } from "../commands/CreateFleetMetricCommand";
import { CreateJobCommandInput, CreateJobCommandOutput } from "../commands/CreateJobCommand";
import { CreateJobTemplateCommandInput, CreateJobTemplateCommandOutput } from "../commands/CreateJobTemplateCommand";
import {
  CreateKeysAndCertificateCommandInput,
  CreateKeysAndCertificateCommandOutput,
} from "../commands/CreateKeysAndCertificateCommand";
import {
  CreateMitigationActionCommandInput,
  CreateMitigationActionCommandOutput,
} from "../commands/CreateMitigationActionCommand";
import { CreateOTAUpdateCommandInput, CreateOTAUpdateCommandOutput } from "../commands/CreateOTAUpdateCommand";
import { CreatePolicyCommandInput, CreatePolicyCommandOutput } from "../commands/CreatePolicyCommand";
import {
  CreatePolicyVersionCommandInput,
  CreatePolicyVersionCommandOutput,
} from "../commands/CreatePolicyVersionCommand";
import {
  CreateProvisioningClaimCommandInput,
  CreateProvisioningClaimCommandOutput,
} from "../commands/CreateProvisioningClaimCommand";
import {
  CreateProvisioningTemplateCommandInput,
  CreateProvisioningTemplateCommandOutput,
} from "../commands/CreateProvisioningTemplateCommand";
import {
  CreateProvisioningTemplateVersionCommandInput,
  CreateProvisioningTemplateVersionCommandOutput,
} from "../commands/CreateProvisioningTemplateVersionCommand";
import { CreateRoleAliasCommandInput, CreateRoleAliasCommandOutput } from "../commands/CreateRoleAliasCommand";
import {
  CreateScheduledAuditCommandInput,
  CreateScheduledAuditCommandOutput,
} from "../commands/CreateScheduledAuditCommand";
import {
  CreateSecurityProfileCommandInput,
  CreateSecurityProfileCommandOutput,
} from "../commands/CreateSecurityProfileCommand";
import { CreateStreamCommandInput, CreateStreamCommandOutput } from "../commands/CreateStreamCommand";
import { CreateThingCommandInput, CreateThingCommandOutput } from "../commands/CreateThingCommand";
import { CreateThingGroupCommandInput, CreateThingGroupCommandOutput } from "../commands/CreateThingGroupCommand";
import { CreateThingTypeCommandInput, CreateThingTypeCommandOutput } from "../commands/CreateThingTypeCommand";
import { CreateTopicRuleCommandInput, CreateTopicRuleCommandOutput } from "../commands/CreateTopicRuleCommand";
import {
  CreateTopicRuleDestinationCommandInput,
  CreateTopicRuleDestinationCommandOutput,
} from "../commands/CreateTopicRuleDestinationCommand";
import {
  DeleteAccountAuditConfigurationCommandInput,
  DeleteAccountAuditConfigurationCommandOutput,
} from "../commands/DeleteAccountAuditConfigurationCommand";
import {
  DeleteAuditSuppressionCommandInput,
  DeleteAuditSuppressionCommandOutput,
} from "../commands/DeleteAuditSuppressionCommand";
import { DeleteAuthorizerCommandInput, DeleteAuthorizerCommandOutput } from "../commands/DeleteAuthorizerCommand";
import { DeleteBillingGroupCommandInput, DeleteBillingGroupCommandOutput } from "../commands/DeleteBillingGroupCommand";
import {
  DeleteCACertificateCommandInput,
  DeleteCACertificateCommandOutput,
} from "../commands/DeleteCACertificateCommand";
import { DeleteCertificateCommandInput, DeleteCertificateCommandOutput } from "../commands/DeleteCertificateCommand";
import { DeleteCustomMetricCommandInput, DeleteCustomMetricCommandOutput } from "../commands/DeleteCustomMetricCommand";
import { DeleteDimensionCommandInput, DeleteDimensionCommandOutput } from "../commands/DeleteDimensionCommand";
import {
  DeleteDomainConfigurationCommandInput,
  DeleteDomainConfigurationCommandOutput,
} from "../commands/DeleteDomainConfigurationCommand";
import {
  DeleteDynamicThingGroupCommandInput,
  DeleteDynamicThingGroupCommandOutput,
} from "../commands/DeleteDynamicThingGroupCommand";
import { DeleteFleetMetricCommandInput, DeleteFleetMetricCommandOutput } from "../commands/DeleteFleetMetricCommand";
import { DeleteJobCommandInput, DeleteJobCommandOutput } from "../commands/DeleteJobCommand";
import { DeleteJobExecutionCommandInput, DeleteJobExecutionCommandOutput } from "../commands/DeleteJobExecutionCommand";
import { DeleteJobTemplateCommandInput, DeleteJobTemplateCommandOutput } from "../commands/DeleteJobTemplateCommand";
import {
  DeleteMitigationActionCommandInput,
  DeleteMitigationActionCommandOutput,
} from "../commands/DeleteMitigationActionCommand";
import { DeleteOTAUpdateCommandInput, DeleteOTAUpdateCommandOutput } from "../commands/DeleteOTAUpdateCommand";
import { DeletePolicyCommandInput, DeletePolicyCommandOutput } from "../commands/DeletePolicyCommand";
import {
  DeletePolicyVersionCommandInput,
  DeletePolicyVersionCommandOutput,
} from "../commands/DeletePolicyVersionCommand";
import {
  DeleteProvisioningTemplateCommandInput,
  DeleteProvisioningTemplateCommandOutput,
} from "../commands/DeleteProvisioningTemplateCommand";
import {
  DeleteProvisioningTemplateVersionCommandInput,
  DeleteProvisioningTemplateVersionCommandOutput,
} from "../commands/DeleteProvisioningTemplateVersionCommand";
import {
  DeleteRegistrationCodeCommandInput,
  DeleteRegistrationCodeCommandOutput,
} from "../commands/DeleteRegistrationCodeCommand";
import { DeleteRoleAliasCommandInput, DeleteRoleAliasCommandOutput } from "../commands/DeleteRoleAliasCommand";
import {
  DeleteScheduledAuditCommandInput,
  DeleteScheduledAuditCommandOutput,
} from "../commands/DeleteScheduledAuditCommand";
import {
  DeleteSecurityProfileCommandInput,
  DeleteSecurityProfileCommandOutput,
} from "../commands/DeleteSecurityProfileCommand";
import { DeleteStreamCommandInput, DeleteStreamCommandOutput } from "../commands/DeleteStreamCommand";
import { DeleteThingCommandInput, DeleteThingCommandOutput } from "../commands/DeleteThingCommand";
import { DeleteThingGroupCommandInput, DeleteThingGroupCommandOutput } from "../commands/DeleteThingGroupCommand";
import { DeleteThingTypeCommandInput, DeleteThingTypeCommandOutput } from "../commands/DeleteThingTypeCommand";
import { DeleteTopicRuleCommandInput, DeleteTopicRuleCommandOutput } from "../commands/DeleteTopicRuleCommand";
import {
  DeleteTopicRuleDestinationCommandInput,
  DeleteTopicRuleDestinationCommandOutput,
} from "../commands/DeleteTopicRuleDestinationCommand";
import {
  DeleteV2LoggingLevelCommandInput,
  DeleteV2LoggingLevelCommandOutput,
} from "../commands/DeleteV2LoggingLevelCommand";
import { DeprecateThingTypeCommandInput, DeprecateThingTypeCommandOutput } from "../commands/DeprecateThingTypeCommand";
import {
  DescribeAccountAuditConfigurationCommandInput,
  DescribeAccountAuditConfigurationCommandOutput,
} from "../commands/DescribeAccountAuditConfigurationCommand";
import {
  DescribeAuditFindingCommandInput,
  DescribeAuditFindingCommandOutput,
} from "../commands/DescribeAuditFindingCommand";
import {
  DescribeAuditMitigationActionsTaskCommandInput,
  DescribeAuditMitigationActionsTaskCommandOutput,
} from "../commands/DescribeAuditMitigationActionsTaskCommand";
import {
  DescribeAuditSuppressionCommandInput,
  DescribeAuditSuppressionCommandOutput,
} from "../commands/DescribeAuditSuppressionCommand";
import { DescribeAuditTaskCommandInput, DescribeAuditTaskCommandOutput } from "../commands/DescribeAuditTaskCommand";
import { DescribeAuthorizerCommandInput, DescribeAuthorizerCommandOutput } from "../commands/DescribeAuthorizerCommand";
import {
  DescribeBillingGroupCommandInput,
  DescribeBillingGroupCommandOutput,
} from "../commands/DescribeBillingGroupCommand";
import {
  DescribeCACertificateCommandInput,
  DescribeCACertificateCommandOutput,
} from "../commands/DescribeCACertificateCommand";
import {
  DescribeCertificateCommandInput,
  DescribeCertificateCommandOutput,
} from "../commands/DescribeCertificateCommand";
import {
  DescribeCustomMetricCommandInput,
  DescribeCustomMetricCommandOutput,
} from "../commands/DescribeCustomMetricCommand";
import {
  DescribeDefaultAuthorizerCommandInput,
  DescribeDefaultAuthorizerCommandOutput,
} from "../commands/DescribeDefaultAuthorizerCommand";
import {
  DescribeDetectMitigationActionsTaskCommandInput,
  DescribeDetectMitigationActionsTaskCommandOutput,
} from "../commands/DescribeDetectMitigationActionsTaskCommand";
import { DescribeDimensionCommandInput, DescribeDimensionCommandOutput } from "../commands/DescribeDimensionCommand";
import {
  DescribeDomainConfigurationCommandInput,
  DescribeDomainConfigurationCommandOutput,
} from "../commands/DescribeDomainConfigurationCommand";
import { DescribeEndpointCommandInput, DescribeEndpointCommandOutput } from "../commands/DescribeEndpointCommand";
import {
  DescribeEventConfigurationsCommandInput,
  DescribeEventConfigurationsCommandOutput,
} from "../commands/DescribeEventConfigurationsCommand";
import {
  DescribeFleetMetricCommandInput,
  DescribeFleetMetricCommandOutput,
} from "../commands/DescribeFleetMetricCommand";
import { DescribeIndexCommandInput, DescribeIndexCommandOutput } from "../commands/DescribeIndexCommand";
import { DescribeJobCommandInput, DescribeJobCommandOutput } from "../commands/DescribeJobCommand";
import {
  DescribeJobExecutionCommandInput,
  DescribeJobExecutionCommandOutput,
} from "../commands/DescribeJobExecutionCommand";
import {
  DescribeJobTemplateCommandInput,
  DescribeJobTemplateCommandOutput,
} from "../commands/DescribeJobTemplateCommand";
import {
  DescribeMitigationActionCommandInput,
  DescribeMitigationActionCommandOutput,
} from "../commands/DescribeMitigationActionCommand";
import {
  DescribeProvisioningTemplateCommandInput,
  DescribeProvisioningTemplateCommandOutput,
} from "../commands/DescribeProvisioningTemplateCommand";
import {
  DescribeProvisioningTemplateVersionCommandInput,
  DescribeProvisioningTemplateVersionCommandOutput,
} from "../commands/DescribeProvisioningTemplateVersionCommand";
import { DescribeRoleAliasCommandInput, DescribeRoleAliasCommandOutput } from "../commands/DescribeRoleAliasCommand";
import {
  DescribeScheduledAuditCommandInput,
  DescribeScheduledAuditCommandOutput,
} from "../commands/DescribeScheduledAuditCommand";
import {
  DescribeSecurityProfileCommandInput,
  DescribeSecurityProfileCommandOutput,
} from "../commands/DescribeSecurityProfileCommand";
import { DescribeStreamCommandInput, DescribeStreamCommandOutput } from "../commands/DescribeStreamCommand";
import { DescribeThingCommandInput, DescribeThingCommandOutput } from "../commands/DescribeThingCommand";
import { DescribeThingGroupCommandInput, DescribeThingGroupCommandOutput } from "../commands/DescribeThingGroupCommand";
import {
  DescribeThingRegistrationTaskCommandInput,
  DescribeThingRegistrationTaskCommandOutput,
} from "../commands/DescribeThingRegistrationTaskCommand";
import { DescribeThingTypeCommandInput, DescribeThingTypeCommandOutput } from "../commands/DescribeThingTypeCommand";
import { DetachPolicyCommandInput, DetachPolicyCommandOutput } from "../commands/DetachPolicyCommand";
import {
  DetachPrincipalPolicyCommandInput,
  DetachPrincipalPolicyCommandOutput,
} from "../commands/DetachPrincipalPolicyCommand";
import {
  DetachSecurityProfileCommandInput,
  DetachSecurityProfileCommandOutput,
} from "../commands/DetachSecurityProfileCommand";
import {
  DetachThingPrincipalCommandInput,
  DetachThingPrincipalCommandOutput,
} from "../commands/DetachThingPrincipalCommand";
import { DisableTopicRuleCommandInput, DisableTopicRuleCommandOutput } from "../commands/DisableTopicRuleCommand";
import { EnableTopicRuleCommandInput, EnableTopicRuleCommandOutput } from "../commands/EnableTopicRuleCommand";
import {
  GetBehaviorModelTrainingSummariesCommandInput,
  GetBehaviorModelTrainingSummariesCommandOutput,
} from "../commands/GetBehaviorModelTrainingSummariesCommand";
import {
  GetBucketsAggregationCommandInput,
  GetBucketsAggregationCommandOutput,
} from "../commands/GetBucketsAggregationCommand";
import { GetCardinalityCommandInput, GetCardinalityCommandOutput } from "../commands/GetCardinalityCommand";
import {
  GetEffectivePoliciesCommandInput,
  GetEffectivePoliciesCommandOutput,
} from "../commands/GetEffectivePoliciesCommand";
import {
  GetIndexingConfigurationCommandInput,
  GetIndexingConfigurationCommandOutput,
} from "../commands/GetIndexingConfigurationCommand";
import { GetJobDocumentCommandInput, GetJobDocumentCommandOutput } from "../commands/GetJobDocumentCommand";
import { GetLoggingOptionsCommandInput, GetLoggingOptionsCommandOutput } from "../commands/GetLoggingOptionsCommand";
import { GetOTAUpdateCommandInput, GetOTAUpdateCommandOutput } from "../commands/GetOTAUpdateCommand";
import { GetPercentilesCommandInput, GetPercentilesCommandOutput } from "../commands/GetPercentilesCommand";
import { GetPolicyCommandInput, GetPolicyCommandOutput } from "../commands/GetPolicyCommand";
import { GetPolicyVersionCommandInput, GetPolicyVersionCommandOutput } from "../commands/GetPolicyVersionCommand";
import {
  GetRegistrationCodeCommandInput,
  GetRegistrationCodeCommandOutput,
} from "../commands/GetRegistrationCodeCommand";
import { GetStatisticsCommandInput, GetStatisticsCommandOutput } from "../commands/GetStatisticsCommand";
import { GetTopicRuleCommandInput, GetTopicRuleCommandOutput } from "../commands/GetTopicRuleCommand";
import {
  GetTopicRuleDestinationCommandInput,
  GetTopicRuleDestinationCommandOutput,
} from "../commands/GetTopicRuleDestinationCommand";
import {
  GetV2LoggingOptionsCommandInput,
  GetV2LoggingOptionsCommandOutput,
} from "../commands/GetV2LoggingOptionsCommand";
import {
  ListActiveViolationsCommandInput,
  ListActiveViolationsCommandOutput,
} from "../commands/ListActiveViolationsCommand";
import {
  ListAttachedPoliciesCommandInput,
  ListAttachedPoliciesCommandOutput,
} from "../commands/ListAttachedPoliciesCommand";
import { ListAuditFindingsCommandInput, ListAuditFindingsCommandOutput } from "../commands/ListAuditFindingsCommand";
import {
  ListAuditMitigationActionsExecutionsCommandInput,
  ListAuditMitigationActionsExecutionsCommandOutput,
} from "../commands/ListAuditMitigationActionsExecutionsCommand";
import {
  ListAuditMitigationActionsTasksCommandInput,
  ListAuditMitigationActionsTasksCommandOutput,
} from "../commands/ListAuditMitigationActionsTasksCommand";
import {
  ListAuditSuppressionsCommandInput,
  ListAuditSuppressionsCommandOutput,
} from "../commands/ListAuditSuppressionsCommand";
import { ListAuditTasksCommandInput, ListAuditTasksCommandOutput } from "../commands/ListAuditTasksCommand";
import { ListAuthorizersCommandInput, ListAuthorizersCommandOutput } from "../commands/ListAuthorizersCommand";
import { ListBillingGroupsCommandInput, ListBillingGroupsCommandOutput } from "../commands/ListBillingGroupsCommand";
import { ListCACertificatesCommandInput, ListCACertificatesCommandOutput } from "../commands/ListCACertificatesCommand";
import {
  ListCertificatesByCACommandInput,
  ListCertificatesByCACommandOutput,
} from "../commands/ListCertificatesByCACommand";
import { ListCertificatesCommandInput, ListCertificatesCommandOutput } from "../commands/ListCertificatesCommand";
import { ListCustomMetricsCommandInput, ListCustomMetricsCommandOutput } from "../commands/ListCustomMetricsCommand";
import {
  ListDetectMitigationActionsExecutionsCommandInput,
  ListDetectMitigationActionsExecutionsCommandOutput,
} from "../commands/ListDetectMitigationActionsExecutionsCommand";
import {
  ListDetectMitigationActionsTasksCommandInput,
  ListDetectMitigationActionsTasksCommandOutput,
} from "../commands/ListDetectMitigationActionsTasksCommand";
import { ListDimensionsCommandInput, ListDimensionsCommandOutput } from "../commands/ListDimensionsCommand";
import {
  ListDomainConfigurationsCommandInput,
  ListDomainConfigurationsCommandOutput,
} from "../commands/ListDomainConfigurationsCommand";
import { ListFleetMetricsCommandInput, ListFleetMetricsCommandOutput } from "../commands/ListFleetMetricsCommand";
import { ListIndicesCommandInput, ListIndicesCommandOutput } from "../commands/ListIndicesCommand";
import {
  ListJobExecutionsForJobCommandInput,
  ListJobExecutionsForJobCommandOutput,
} from "../commands/ListJobExecutionsForJobCommand";
import {
  ListJobExecutionsForThingCommandInput,
  ListJobExecutionsForThingCommandOutput,
} from "../commands/ListJobExecutionsForThingCommand";
import { ListJobTemplatesCommandInput, ListJobTemplatesCommandOutput } from "../commands/ListJobTemplatesCommand";
import { ListJobsCommandInput, ListJobsCommandOutput } from "../commands/ListJobsCommand";
import {
  ListMitigationActionsCommandInput,
  ListMitigationActionsCommandOutput,
} from "../commands/ListMitigationActionsCommand";
import { ListOTAUpdatesCommandInput, ListOTAUpdatesCommandOutput } from "../commands/ListOTAUpdatesCommand";
import {
  ListOutgoingCertificatesCommandInput,
  ListOutgoingCertificatesCommandOutput,
} from "../commands/ListOutgoingCertificatesCommand";
import { ListPoliciesCommandInput, ListPoliciesCommandOutput } from "../commands/ListPoliciesCommand";
import {
  ListPolicyPrincipalsCommandInput,
  ListPolicyPrincipalsCommandOutput,
} from "../commands/ListPolicyPrincipalsCommand";
import { ListPolicyVersionsCommandInput, ListPolicyVersionsCommandOutput } from "../commands/ListPolicyVersionsCommand";
import {
  ListPrincipalPoliciesCommandInput,
  ListPrincipalPoliciesCommandOutput,
} from "../commands/ListPrincipalPoliciesCommand";
import {
  ListPrincipalThingsCommandInput,
  ListPrincipalThingsCommandOutput,
} from "../commands/ListPrincipalThingsCommand";
import {
  ListProvisioningTemplateVersionsCommandInput,
  ListProvisioningTemplateVersionsCommandOutput,
} from "../commands/ListProvisioningTemplateVersionsCommand";
import {
  ListProvisioningTemplatesCommandInput,
  ListProvisioningTemplatesCommandOutput,
} from "../commands/ListProvisioningTemplatesCommand";
import { ListRoleAliasesCommandInput, ListRoleAliasesCommandOutput } from "../commands/ListRoleAliasesCommand";
import {
  ListScheduledAuditsCommandInput,
  ListScheduledAuditsCommandOutput,
} from "../commands/ListScheduledAuditsCommand";
import {
  ListSecurityProfilesCommandInput,
  ListSecurityProfilesCommandOutput,
} from "../commands/ListSecurityProfilesCommand";
import {
  ListSecurityProfilesForTargetCommandInput,
  ListSecurityProfilesForTargetCommandOutput,
} from "../commands/ListSecurityProfilesForTargetCommand";
import { ListStreamsCommandInput, ListStreamsCommandOutput } from "../commands/ListStreamsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput,
} from "../commands/ListTagsForResourceCommand";
import {
  ListTargetsForPolicyCommandInput,
  ListTargetsForPolicyCommandOutput,
} from "../commands/ListTargetsForPolicyCommand";
import {
  ListTargetsForSecurityProfileCommandInput,
  ListTargetsForSecurityProfileCommandOutput,
} from "../commands/ListTargetsForSecurityProfileCommand";
import { ListThingGroupsCommandInput, ListThingGroupsCommandOutput } from "../commands/ListThingGroupsCommand";
import {
  ListThingGroupsForThingCommandInput,
  ListThingGroupsForThingCommandOutput,
} from "../commands/ListThingGroupsForThingCommand";
import {
  ListThingPrincipalsCommandInput,
  ListThingPrincipalsCommandOutput,
} from "../commands/ListThingPrincipalsCommand";
import {
  ListThingRegistrationTaskReportsCommandInput,
  ListThingRegistrationTaskReportsCommandOutput,
} from "../commands/ListThingRegistrationTaskReportsCommand";
import {
  ListThingRegistrationTasksCommandInput,
  ListThingRegistrationTasksCommandOutput,
} from "../commands/ListThingRegistrationTasksCommand";
import { ListThingTypesCommandInput, ListThingTypesCommandOutput } from "../commands/ListThingTypesCommand";
import { ListThingsCommandInput, ListThingsCommandOutput } from "../commands/ListThingsCommand";
import {
  ListThingsInBillingGroupCommandInput,
  ListThingsInBillingGroupCommandOutput,
} from "../commands/ListThingsInBillingGroupCommand";
import {
  ListThingsInThingGroupCommandInput,
  ListThingsInThingGroupCommandOutput,
} from "../commands/ListThingsInThingGroupCommand";
import {
  ListTopicRuleDestinationsCommandInput,
  ListTopicRuleDestinationsCommandOutput,
} from "../commands/ListTopicRuleDestinationsCommand";
import { ListTopicRulesCommandInput, ListTopicRulesCommandOutput } from "../commands/ListTopicRulesCommand";
import {
  ListV2LoggingLevelsCommandInput,
  ListV2LoggingLevelsCommandOutput,
} from "../commands/ListV2LoggingLevelsCommand";
import {
  ListViolationEventsCommandInput,
  ListViolationEventsCommandOutput,
} from "../commands/ListViolationEventsCommand";
import {
  RegisterCACertificateCommandInput,
  RegisterCACertificateCommandOutput,
} from "../commands/RegisterCACertificateCommand";
import {
  RegisterCertificateCommandInput,
  RegisterCertificateCommandOutput,
} from "../commands/RegisterCertificateCommand";
import {
  RegisterCertificateWithoutCACommandInput,
  RegisterCertificateWithoutCACommandOutput,
} from "../commands/RegisterCertificateWithoutCACommand";
import { RegisterThingCommandInput, RegisterThingCommandOutput } from "../commands/RegisterThingCommand";
import {
  RejectCertificateTransferCommandInput,
  RejectCertificateTransferCommandOutput,
} from "../commands/RejectCertificateTransferCommand";
import {
  RemoveThingFromBillingGroupCommandInput,
  RemoveThingFromBillingGroupCommandOutput,
} from "../commands/RemoveThingFromBillingGroupCommand";
import {
  RemoveThingFromThingGroupCommandInput,
  RemoveThingFromThingGroupCommandOutput,
} from "../commands/RemoveThingFromThingGroupCommand";
import { ReplaceTopicRuleCommandInput, ReplaceTopicRuleCommandOutput } from "../commands/ReplaceTopicRuleCommand";
import { SearchIndexCommandInput, SearchIndexCommandOutput } from "../commands/SearchIndexCommand";
import {
  SetDefaultAuthorizerCommandInput,
  SetDefaultAuthorizerCommandOutput,
} from "../commands/SetDefaultAuthorizerCommand";
import {
  SetDefaultPolicyVersionCommandInput,
  SetDefaultPolicyVersionCommandOutput,
} from "../commands/SetDefaultPolicyVersionCommand";
import { SetLoggingOptionsCommandInput, SetLoggingOptionsCommandOutput } from "../commands/SetLoggingOptionsCommand";
import { SetV2LoggingLevelCommandInput, SetV2LoggingLevelCommandOutput } from "../commands/SetV2LoggingLevelCommand";
import {
  SetV2LoggingOptionsCommandInput,
  SetV2LoggingOptionsCommandOutput,
} from "../commands/SetV2LoggingOptionsCommand";
import {
  StartAuditMitigationActionsTaskCommandInput,
  StartAuditMitigationActionsTaskCommandOutput,
} from "../commands/StartAuditMitigationActionsTaskCommand";
import {
  StartDetectMitigationActionsTaskCommandInput,
  StartDetectMitigationActionsTaskCommandOutput,
} from "../commands/StartDetectMitigationActionsTaskCommand";
import {
  StartOnDemandAuditTaskCommandInput,
  StartOnDemandAuditTaskCommandOutput,
} from "../commands/StartOnDemandAuditTaskCommand";
import {
  StartThingRegistrationTaskCommandInput,
  StartThingRegistrationTaskCommandOutput,
} from "../commands/StartThingRegistrationTaskCommand";
import {
  StopThingRegistrationTaskCommandInput,
  StopThingRegistrationTaskCommandOutput,
} from "../commands/StopThingRegistrationTaskCommand";
import { TagResourceCommandInput, TagResourceCommandOutput } from "../commands/TagResourceCommand";
import { TestAuthorizationCommandInput, TestAuthorizationCommandOutput } from "../commands/TestAuthorizationCommand";
import {
  TestInvokeAuthorizerCommandInput,
  TestInvokeAuthorizerCommandOutput,
} from "../commands/TestInvokeAuthorizerCommand";
import {
  TransferCertificateCommandInput,
  TransferCertificateCommandOutput,
} from "../commands/TransferCertificateCommand";
import { UntagResourceCommandInput, UntagResourceCommandOutput } from "../commands/UntagResourceCommand";
import {
  UpdateAccountAuditConfigurationCommandInput,
  UpdateAccountAuditConfigurationCommandOutput,
} from "../commands/UpdateAccountAuditConfigurationCommand";
import {
  UpdateAuditSuppressionCommandInput,
  UpdateAuditSuppressionCommandOutput,
} from "../commands/UpdateAuditSuppressionCommand";
import { UpdateAuthorizerCommandInput, UpdateAuthorizerCommandOutput } from "../commands/UpdateAuthorizerCommand";
import { UpdateBillingGroupCommandInput, UpdateBillingGroupCommandOutput } from "../commands/UpdateBillingGroupCommand";
import {
  UpdateCACertificateCommandInput,
  UpdateCACertificateCommandOutput,
} from "../commands/UpdateCACertificateCommand";
import { UpdateCertificateCommandInput, UpdateCertificateCommandOutput } from "../commands/UpdateCertificateCommand";
import { UpdateCustomMetricCommandInput, UpdateCustomMetricCommandOutput } from "../commands/UpdateCustomMetricCommand";
import { UpdateDimensionCommandInput, UpdateDimensionCommandOutput } from "../commands/UpdateDimensionCommand";
import {
  UpdateDomainConfigurationCommandInput,
  UpdateDomainConfigurationCommandOutput,
} from "../commands/UpdateDomainConfigurationCommand";
import {
  UpdateDynamicThingGroupCommandInput,
  UpdateDynamicThingGroupCommandOutput,
} from "../commands/UpdateDynamicThingGroupCommand";
import {
  UpdateEventConfigurationsCommandInput,
  UpdateEventConfigurationsCommandOutput,
} from "../commands/UpdateEventConfigurationsCommand";
import { UpdateFleetMetricCommandInput, UpdateFleetMetricCommandOutput } from "../commands/UpdateFleetMetricCommand";
import {
  UpdateIndexingConfigurationCommandInput,
  UpdateIndexingConfigurationCommandOutput,
} from "../commands/UpdateIndexingConfigurationCommand";
import { UpdateJobCommandInput, UpdateJobCommandOutput } from "../commands/UpdateJobCommand";
import {
  UpdateMitigationActionCommandInput,
  UpdateMitigationActionCommandOutput,
} from "../commands/UpdateMitigationActionCommand";
import {
  UpdateProvisioningTemplateCommandInput,
  UpdateProvisioningTemplateCommandOutput,
} from "../commands/UpdateProvisioningTemplateCommand";
import { UpdateRoleAliasCommandInput, UpdateRoleAliasCommandOutput } from "../commands/UpdateRoleAliasCommand";
import {
  UpdateScheduledAuditCommandInput,
  UpdateScheduledAuditCommandOutput,
} from "../commands/UpdateScheduledAuditCommand";
import {
  UpdateSecurityProfileCommandInput,
  UpdateSecurityProfileCommandOutput,
} from "../commands/UpdateSecurityProfileCommand";
import { UpdateStreamCommandInput, UpdateStreamCommandOutput } from "../commands/UpdateStreamCommand";
import { UpdateThingCommandInput, UpdateThingCommandOutput } from "../commands/UpdateThingCommand";
import { UpdateThingGroupCommandInput, UpdateThingGroupCommandOutput } from "../commands/UpdateThingGroupCommand";
import {
  UpdateThingGroupsForThingCommandInput,
  UpdateThingGroupsForThingCommandOutput,
} from "../commands/UpdateThingGroupsForThingCommand";
import {
  UpdateTopicRuleDestinationCommandInput,
  UpdateTopicRuleDestinationCommandOutput,
} from "../commands/UpdateTopicRuleDestinationCommand";
import {
  ValidateSecurityProfileBehaviorsCommandInput,
  ValidateSecurityProfileBehaviorsCommandOutput,
} from "../commands/ValidateSecurityProfileBehaviorsCommand";
import {
  AbortConfig,
  AbortCriteria,
  Action,
  ActiveViolation,
  AddThingsToThingGroupParams,
  AggregationType,
  AlertTarget,
  AlertTargetType,
  Allowed,
  AssetPropertyTimestamp,
  AssetPropertyValue,
  AssetPropertyVariant,
  AttributePayload,
  AuditCheckConfiguration,
  AuditCheckDetails,
  AuditFinding,
  AuditMitigationActionExecutionMetadata,
  AuditMitigationActionsTaskMetadata,
  AuditMitigationActionsTaskTarget,
  AuditNotificationTarget,
  AuditNotificationType,
  AuditSuppression,
  AuditTaskMetadata,
  AuthInfo,
  AuthResult,
  AuthorizerConfig,
  AuthorizerDescription,
  AuthorizerSummary,
  AwsJobAbortConfig,
  AwsJobAbortCriteria,
  AwsJobExecutionsRolloutConfig,
  AwsJobExponentialRolloutRate,
  AwsJobPresignedUrlConfig,
  AwsJobRateIncreaseCriteria,
  AwsJobTimeoutConfig,
  Behavior,
  BehaviorCriteria,
  BillingGroupProperties,
  CertificateStateException,
  CertificateValidationException,
  CloudwatchAlarmAction,
  CloudwatchLogsAction,
  CloudwatchMetricAction,
  CodeSigning,
  CodeSigningCertificateChain,
  CodeSigningSignature,
  ConflictException,
  ConflictingResourceUpdateException,
  CustomCodeSigning,
  DeleteConflictException,
  Denied,
  Destination,
  DynamoDBAction,
  DynamoDBv2Action,
  ElasticsearchAction,
  EnableIoTLoggingParams,
  ExplicitDeny,
  ExponentialRolloutRate,
  FileLocation,
  FirehoseAction,
  HttpAction,
  HttpActionHeader,
  HttpAuthorization,
  HttpUrlDestinationConfiguration,
  HttpUrlDestinationProperties,
  ImplicitDeny,
  IndexNotReadyException,
  InternalException,
  InternalFailureException,
  InvalidAggregationException,
  InvalidQueryException,
  InvalidRequestException,
  InvalidStateTransitionException,
  IotAnalyticsAction,
  IotEventsAction,
  IotSiteWiseAction,
  JobExecutionsRolloutConfig,
  KafkaAction,
  KeyPair,
  KinesisAction,
  LambdaAction,
  LimitExceededException,
  MachineLearningDetectionConfig,
  MalformedPolicyException,
  MetricDimension,
  MetricToRetain,
  MetricValue,
  MitigationActionParams,
  NonCompliantResource,
  OTAUpdateFile,
  OpenSearchAction,
  Policy,
  PolicyVersionIdentifier,
  PresignedUrlConfig,
  Protocol,
  ProvisioningHook,
  PublishFindingToSnsParams,
  PutAssetPropertyValueEntry,
  PutItemInput,
  RateIncreaseCriteria,
  RelatedResource,
  ReplaceDefaultPolicyVersionParams,
  RepublishAction,
  ResourceAlreadyExistsException,
  ResourceIdentifier,
  ResourceNotFoundException,
  S3Action,
  S3Destination,
  S3Location,
  SalesforceAction,
  ServiceUnavailableException,
  SigV4Authorization,
  SigningProfileParameter,
  SnsAction,
  SqlParseException,
  SqsAction,
  StartSigningJobParameter,
  StatisticalThreshold,
  StepFunctionsAction,
  StreamFile,
  Tag,
  TaskStatisticsForAuditCheck,
  ThingGroupProperties,
  ThingTypeProperties,
  ThrottlingException,
  TimeoutConfig,
  TimestreamAction,
  TimestreamDimension,
  TimestreamTimestamp,
  TopicRuleDestination,
  TopicRuleDestinationConfiguration,
  TopicRulePayload,
  TransferAlreadyCompletedException,
  UnauthorizedException,
  UpdateCACertificateParams,
  UpdateDeviceCertificateParams,
  VersionConflictException,
  VersionsLimitExceededException,
  ViolationEventAdditionalInfo,
  VpcDestinationConfiguration,
  VpcDestinationProperties,
  _Stream,
} from "../models/models_0";
import {
  BehaviorModelTrainingSummary,
  BillingGroupMetadata,
  Bucket,
  BucketsAggregationType,
  CACertificate,
  CACertificateDescription,
  Certificate,
  CertificateDescription,
  CertificateValidity,
  Configuration,
  DetectMitigationActionExecution,
  DetectMitigationActionsTaskStatistics,
  DetectMitigationActionsTaskSummary,
  DetectMitigationActionsTaskTarget,
  DomainConfigurationSummary,
  EffectivePolicy,
  ErrorInfo,
  EventType,
  Field,
  FleetMetricNameAndArn,
  GroupNameAndArn,
  Job,
  JobExecution,
  JobExecutionStatusDetails,
  JobExecutionSummary,
  JobExecutionSummaryForJob,
  JobExecutionSummaryForThing,
  JobProcessDetails,
  JobSummary,
  JobTemplateSummary,
  MitigationAction,
  MitigationActionIdentifier,
  NotConfiguredException,
  OTAUpdateInfo,
  OTAUpdateSummary,
  OutgoingCertificate,
  PercentPair,
  PolicyVersion,
  ProvisioningTemplateSummary,
  ProvisioningTemplateVersionSummary,
  RegistrationConfig,
  RoleAliasDescription,
  ScheduledAuditMetadata,
  SecurityProfileIdentifier,
  SecurityProfileTarget,
  SecurityProfileTargetMapping,
  ServerCertificateSummary,
  Statistics,
  StreamInfo,
  StreamSummary,
  TaskStatistics,
  TermsAggregation,
  ThingAttribute,
  ThingGroupIndexingConfiguration,
  ThingGroupMetadata,
  ThingIndexingConfiguration,
  ThingTypeDefinition,
  ThingTypeMetadata,
  TopicRule,
  TransferData,
  ViolationEventOccurrenceRange,
} from "../models/models_1";
import {
  CertificateConflictException,
  HttpContext,
  HttpUrlDestinationSummary,
  InvalidResponseException,
  LogTarget,
  LogTargetConfiguration,
  LoggingOptionsPayload,
  MqttContext,
  RegistrationCodeValidationException,
  ResourceRegistrationFailureException,
  TaskAlreadyExistsException,
  ThingConnectivity,
  ThingDocument,
  ThingGroupDocument,
  TlsContext,
  TopicRuleDestinationSummary,
  TopicRuleListItem,
  TransferConflictException,
  ValidationError,
  ViolationEvent,
  VpcDestinationSummary,
} from "../models/models_2";
import { HttpRequest as __HttpRequest, HttpResponse as __HttpResponse } from "@aws-sdk/protocol-http";
import {
  expectBoolean as __expectBoolean,
  expectInt32 as __expectInt32,
  expectLong as __expectLong,
  expectNonNull as __expectNonNull,
  expectNumber as __expectNumber,
  expectObject as __expectObject,
  expectString as __expectString,
  expectUnion as __expectUnion,
  extendedEncodeURIComponent as __extendedEncodeURIComponent,
  limitedParseDouble as __limitedParseDouble,
  parseEpochTimestamp as __parseEpochTimestamp,
  serializeFloat as __serializeFloat,
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext,
  SmithyException as __SmithyException,
} from "@aws-sdk/types";
import { v4 as generateIdempotencyToken } from "uuid";

export const serializeAws_restJson1AcceptCertificateTransferCommand = async (
  input: AcceptCertificateTransferCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/accept-certificate-transfer/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: certificateId.");
    }
    resolvedPath = resolvedPath.replace("{certificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  const query: any = {
    ...(input.setAsActive !== undefined && { setAsActive: input.setAsActive.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1AddThingToBillingGroupCommand = async (
  input: AddThingToBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/addThingToBillingGroup";
  let body: any;
  body = JSON.stringify({
    ...(input.billingGroupArn !== undefined &&
      input.billingGroupArn !== null && { billingGroupArn: input.billingGroupArn }),
    ...(input.billingGroupName !== undefined &&
      input.billingGroupName !== null && { billingGroupName: input.billingGroupName }),
    ...(input.thingArn !== undefined && input.thingArn !== null && { thingArn: input.thingArn }),
    ...(input.thingName !== undefined && input.thingName !== null && { thingName: input.thingName }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1AddThingToThingGroupCommand = async (
  input: AddThingToThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/addThingToThingGroup";
  let body: any;
  body = JSON.stringify({
    ...(input.overrideDynamicGroups !== undefined &&
      input.overrideDynamicGroups !== null && { overrideDynamicGroups: input.overrideDynamicGroups }),
    ...(input.thingArn !== undefined && input.thingArn !== null && { thingArn: input.thingArn }),
    ...(input.thingGroupArn !== undefined && input.thingGroupArn !== null && { thingGroupArn: input.thingGroupArn }),
    ...(input.thingGroupName !== undefined &&
      input.thingGroupName !== null && { thingGroupName: input.thingGroupName }),
    ...(input.thingName !== undefined && input.thingName !== null && { thingName: input.thingName }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1AssociateTargetsWithJobCommand = async (
  input: AssociateTargetsWithJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/targets";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  const query: any = {
    ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.comment !== undefined && input.comment !== null && { comment: input.comment }),
    ...(input.targets !== undefined &&
      input.targets !== null && { targets: serializeAws_restJson1JobTargets(input.targets, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1AttachPolicyCommand = async (
  input: AttachPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/target-policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.target !== undefined && input.target !== null && { target: input.target }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1AttachPrincipalPolicyCommand = async (
  input: AttachPrincipalPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    ...(isSerializableHeaderValue(input.principal) && { "x-amzn-iot-principal": input.principal! }),
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principal-policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1AttachSecurityProfileCommand = async (
  input: AttachSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/security-profiles/{securityProfileName}/targets";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: securityProfileName.");
    }
    resolvedPath = resolvedPath.replace("{securityProfileName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: securityProfileName.");
  }
  const query: any = {
    ...(input.securityProfileTargetArn !== undefined && { securityProfileTargetArn: input.securityProfileTargetArn }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1AttachThingPrincipalCommand = async (
  input: AttachThingPrincipalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    ...(isSerializableHeaderValue(input.principal) && { "x-amzn-principal": input.principal! }),
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/principals";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CancelAuditMitigationActionsTaskCommand = async (
  input: CancelAuditMitigationActionsTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/audit/mitigationactions/tasks/{taskId}/cancel";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CancelAuditTaskCommand = async (
  input: CancelAuditTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks/{taskId}/cancel";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CancelCertificateTransferCommand = async (
  input: CancelCertificateTransferCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/cancel-certificate-transfer/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: certificateId.");
    }
    resolvedPath = resolvedPath.replace("{certificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CancelDetectMitigationActionsTaskCommand = async (
  input: CancelDetectMitigationActionsTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/detect/mitigationactions/tasks/{taskId}/cancel";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CancelJobCommand = async (
  input: CancelJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/cancel";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  const query: any = {
    ...(input.force !== undefined && { force: input.force.toString() }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.comment !== undefined && input.comment !== null && { comment: input.comment }),
    ...(input.reasonCode !== undefined && input.reasonCode !== null && { reasonCode: input.reasonCode }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1CancelJobExecutionCommand = async (
  input: CancelJobExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/jobs/{jobId}/cancel";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {
    ...(input.force !== undefined && { force: input.force.toString() }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.expectedVersion !== undefined &&
      input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
    ...(input.statusDetails !== undefined &&
      input.statusDetails !== null && {
        statusDetails: serializeAws_restJson1DetailsMap(input.statusDetails, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ClearDefaultAuthorizerCommand = async (
  input: ClearDefaultAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/default-authorizer";
  let body: any;
  body = "";
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1ConfirmTopicRuleDestinationCommand = async (
  input: ConfirmTopicRuleDestinationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/confirmdestination/{confirmationToken+}";
  if (input.confirmationToken !== undefined) {
    const labelValue: string = input.confirmationToken;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: confirmationToken.");
    }
    resolvedPath = resolvedPath.replace(
      "{confirmationToken+}",
      labelValue
        .split("/")
        .map((segment) => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: confirmationToken.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateAuditSuppressionCommand = async (
  input: CreateAuditSuppressionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/create";
  let body: any;
  body = JSON.stringify({
    ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
    clientRequestToken: input.clientRequestToken ?? generateIdempotencyToken(),
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.expirationDate !== undefined &&
      input.expirationDate !== null && { expirationDate: Math.round(input.expirationDate.getTime() / 1000) }),
    ...(input.resourceIdentifier !== undefined &&
      input.resourceIdentifier !== null && {
        resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
      }),
    ...(input.suppressIndefinitely !== undefined &&
      input.suppressIndefinitely !== null && { suppressIndefinitely: input.suppressIndefinitely }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateAuthorizerCommand = async (
  input: CreateAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
  if (input.authorizerName !== undefined) {
    const labelValue: string = input.authorizerName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: authorizerName.");
    }
    resolvedPath = resolvedPath.replace("{authorizerName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: authorizerName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.authorizerFunctionArn !== undefined &&
      input.authorizerFunctionArn !== null && { authorizerFunctionArn: input.authorizerFunctionArn }),
    ...(input.signingDisabled !== undefined &&
      input.signingDisabled !== null && { signingDisabled: input.signingDisabled }),
    ...(input.status !== undefined && input.status !== null && { status: input.status }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.tokenKeyName !== undefined && input.tokenKeyName !== null && { tokenKeyName: input.tokenKeyName }),
    ...(input.tokenSigningPublicKeys !== undefined &&
      input.tokenSigningPublicKeys !== null && {
        tokenSigningPublicKeys: serializeAws_restJson1PublicKeyMap(input.tokenSigningPublicKeys, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateBillingGroupCommand = async (
  input: CreateBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
  if (input.billingGroupName !== undefined) {
    const labelValue: string = input.billingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: billingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{billingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: billingGroupName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.billingGroupProperties !== undefined &&
      input.billingGroupProperties !== null && {
        billingGroupProperties: serializeAws_restJson1BillingGroupProperties(input.billingGroupProperties, context),
      }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateCertificateFromCsrCommand = async (
  input: CreateCertificateFromCsrCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates";
  const query: any = {
    ...(input.setAsActive !== undefined && { setAsActive: input.setAsActive.toString() }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.certificateSigningRequest !== undefined &&
      input.certificateSigningRequest !== null && { certificateSigningRequest: input.certificateSigningRequest }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1CreateCustomMetricCommand = async (
  input: CreateCustomMetricCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
  if (input.metricName !== undefined) {
    const labelValue: string = input.metricName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: metricName.");
    }
    resolvedPath = resolvedPath.replace("{metricName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: metricName.");
  }
  let body: any;
  body = JSON.stringify({
    clientRequestToken: input.clientRequestToken ?? generateIdempotencyToken(),
    ...(input.displayName !== undefined && input.displayName !== null && { displayName: input.displayName }),
    ...(input.metricType !== undefined && input.metricType !== null && { metricType: input.metricType }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateDimensionCommand = async (
  input: CreateDimensionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
  if (input.name !== undefined) {
    const labelValue: string = input.name;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: name.");
    }
    resolvedPath = resolvedPath.replace("{name}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: name.");
  }
  let body: any;
  body = JSON.stringify({
    clientRequestToken: input.clientRequestToken ?? generateIdempotencyToken(),
    ...(input.stringValues !== undefined &&
      input.stringValues !== null && {
        stringValues: serializeAws_restJson1DimensionStringValues(input.stringValues, context),
      }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.type !== undefined && input.type !== null && { type: input.type }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateDomainConfigurationCommand = async (
  input: CreateDomainConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/domainConfigurations/{domainConfigurationName}";
  if (input.domainConfigurationName !== undefined) {
    const labelValue: string = input.domainConfigurationName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainConfigurationName.");
    }
    resolvedPath = resolvedPath.replace("{domainConfigurationName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: domainConfigurationName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.authorizerConfig !== undefined &&
      input.authorizerConfig !== null && {
        authorizerConfig: serializeAws_restJson1AuthorizerConfig(input.authorizerConfig, context),
      }),
    ...(input.domainName !== undefined && input.domainName !== null && { domainName: input.domainName }),
    ...(input.serverCertificateArns !== undefined &&
      input.serverCertificateArns !== null && {
        serverCertificateArns: serializeAws_restJson1ServerCertificateArns(input.serverCertificateArns, context),
      }),
    ...(input.serviceType !== undefined && input.serviceType !== null && { serviceType: input.serviceType }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.validationCertificateArn !== undefined &&
      input.validationCertificateArn !== null && { validationCertificateArn: input.validationCertificateArn }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateDynamicThingGroupCommand = async (
  input: CreateDynamicThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dynamic-thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{thingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
    ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
    ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.thingGroupProperties !== undefined &&
      input.thingGroupProperties !== null && {
        thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateFleetMetricCommand = async (
  input: CreateFleetMetricCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
  if (input.metricName !== undefined) {
    const labelValue: string = input.metricName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: metricName.");
    }
    resolvedPath = resolvedPath.replace("{metricName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: metricName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.aggregationField !== undefined &&
      input.aggregationField !== null && { aggregationField: input.aggregationField }),
    ...(input.aggregationType !== undefined &&
      input.aggregationType !== null && {
        aggregationType: serializeAws_restJson1AggregationType(input.aggregationType, context),
      }),
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
    ...(input.period !== undefined && input.period !== null && { period: input.period }),
    ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
    ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.unit !== undefined && input.unit !== null && { unit: input.unit }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateJobCommand = async (
  input: CreateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.abortConfig !== undefined &&
      input.abortConfig !== null && { abortConfig: serializeAws_restJson1AbortConfig(input.abortConfig, context) }),
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.document !== undefined && input.document !== null && { document: input.document }),
    ...(input.documentSource !== undefined &&
      input.documentSource !== null && { documentSource: input.documentSource }),
    ...(input.jobExecutionsRolloutConfig !== undefined &&
      input.jobExecutionsRolloutConfig !== null && {
        jobExecutionsRolloutConfig: serializeAws_restJson1JobExecutionsRolloutConfig(
          input.jobExecutionsRolloutConfig,
          context
        ),
      }),
    ...(input.jobTemplateArn !== undefined &&
      input.jobTemplateArn !== null && { jobTemplateArn: input.jobTemplateArn }),
    ...(input.namespaceId !== undefined && input.namespaceId !== null && { namespaceId: input.namespaceId }),
    ...(input.presignedUrlConfig !== undefined &&
      input.presignedUrlConfig !== null && {
        presignedUrlConfig: serializeAws_restJson1PresignedUrlConfig(input.presignedUrlConfig, context),
      }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.targetSelection !== undefined &&
      input.targetSelection !== null && { targetSelection: input.targetSelection }),
    ...(input.targets !== undefined &&
      input.targets !== null && { targets: serializeAws_restJson1JobTargets(input.targets, context) }),
    ...(input.timeoutConfig !== undefined &&
      input.timeoutConfig !== null && {
        timeoutConfig: serializeAws_restJson1TimeoutConfig(input.timeoutConfig, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateJobTemplateCommand = async (
  input: CreateJobTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates/{jobTemplateId}";
  if (input.jobTemplateId !== undefined) {
    const labelValue: string = input.jobTemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobTemplateId.");
    }
    resolvedPath = resolvedPath.replace("{jobTemplateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobTemplateId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.abortConfig !== undefined &&
      input.abortConfig !== null && { abortConfig: serializeAws_restJson1AbortConfig(input.abortConfig, context) }),
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.document !== undefined && input.document !== null && { document: input.document }),
    ...(input.documentSource !== undefined &&
      input.documentSource !== null && { documentSource: input.documentSource }),
    ...(input.jobArn !== undefined && input.jobArn !== null && { jobArn: input.jobArn }),
    ...(input.jobExecutionsRolloutConfig !== undefined &&
      input.jobExecutionsRolloutConfig !== null && {
        jobExecutionsRolloutConfig: serializeAws_restJson1JobExecutionsRolloutConfig(
          input.jobExecutionsRolloutConfig,
          context
        ),
      }),
    ...(input.presignedUrlConfig !== undefined &&
      input.presignedUrlConfig !== null && {
        presignedUrlConfig: serializeAws_restJson1PresignedUrlConfig(input.presignedUrlConfig, context),
      }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.timeoutConfig !== undefined &&
      input.timeoutConfig !== null && {
        timeoutConfig: serializeAws_restJson1TimeoutConfig(input.timeoutConfig, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateKeysAndCertificateCommand = async (
  input: CreateKeysAndCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/keys-and-certificate";
  const query: any = {
    ...(input.setAsActive !== undefined && { setAsActive: input.setAsActive.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1CreateMitigationActionCommand = async (
  input: CreateMitigationActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
  if (input.actionName !== undefined) {
    const labelValue: string = input.actionName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: actionName.");
    }
    resolvedPath = resolvedPath.replace("{actionName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: actionName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.actionParams !== undefined &&
      input.actionParams !== null && {
        actionParams: serializeAws_restJson1MitigationActionParams(input.actionParams, context),
      }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateOTAUpdateCommand = async (
  input: CreateOTAUpdateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates/{otaUpdateId}";
  if (input.otaUpdateId !== undefined) {
    const labelValue: string = input.otaUpdateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: otaUpdateId.");
    }
    resolvedPath = resolvedPath.replace("{otaUpdateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: otaUpdateId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.additionalParameters !== undefined &&
      input.additionalParameters !== null && {
        additionalParameters: serializeAws_restJson1AdditionalParameterMap(input.additionalParameters, context),
      }),
    ...(input.awsJobAbortConfig !== undefined &&
      input.awsJobAbortConfig !== null && {
        awsJobAbortConfig: serializeAws_restJson1AwsJobAbortConfig(input.awsJobAbortConfig, context),
      }),
    ...(input.awsJobExecutionsRolloutConfig !== undefined &&
      input.awsJobExecutionsRolloutConfig !== null && {
        awsJobExecutionsRolloutConfig: serializeAws_restJson1AwsJobExecutionsRolloutConfig(
          input.awsJobExecutionsRolloutConfig,
          context
        ),
      }),
    ...(input.awsJobPresignedUrlConfig !== undefined &&
      input.awsJobPresignedUrlConfig !== null && {
        awsJobPresignedUrlConfig: serializeAws_restJson1AwsJobPresignedUrlConfig(
          input.awsJobPresignedUrlConfig,
          context
        ),
      }),
    ...(input.awsJobTimeoutConfig !== undefined &&
      input.awsJobTimeoutConfig !== null && {
        awsJobTimeoutConfig: serializeAws_restJson1AwsJobTimeoutConfig(input.awsJobTimeoutConfig, context),
      }),
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.files !== undefined &&
      input.files !== null && { files: serializeAws_restJson1OTAUpdateFiles(input.files, context) }),
    ...(input.protocols !== undefined &&
      input.protocols !== null && { protocols: serializeAws_restJson1Protocols(input.protocols, context) }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.targetSelection !== undefined &&
      input.targetSelection !== null && { targetSelection: input.targetSelection }),
    ...(input.targets !== undefined &&
      input.targets !== null && { targets: serializeAws_restJson1Targets(input.targets, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreatePolicyCommand = async (
  input: CreatePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.policyDocument !== undefined &&
      input.policyDocument !== null && { policyDocument: input.policyDocument }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreatePolicyVersionCommand = async (
  input: CreatePolicyVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}/version";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  const query: any = {
    ...(input.setAsDefault !== undefined && { setAsDefault: input.setAsDefault.toString() }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.policyDocument !== undefined &&
      input.policyDocument !== null && { policyDocument: input.policyDocument }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1CreateProvisioningClaimCommand = async (
  input: CreateProvisioningClaimCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/provisioning-templates/{templateName}/provisioning-claim";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: templateName.");
    }
    resolvedPath = resolvedPath.replace("{templateName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateProvisioningTemplateCommand = async (
  input: CreateProvisioningTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates";
  let body: any;
  body = JSON.stringify({
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.enabled !== undefined && input.enabled !== null && { enabled: input.enabled }),
    ...(input.preProvisioningHook !== undefined &&
      input.preProvisioningHook !== null && {
        preProvisioningHook: serializeAws_restJson1ProvisioningHook(input.preProvisioningHook, context),
      }),
    ...(input.provisioningRoleArn !== undefined &&
      input.provisioningRoleArn !== null && { provisioningRoleArn: input.provisioningRoleArn }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.templateBody !== undefined && input.templateBody !== null && { templateBody: input.templateBody }),
    ...(input.templateName !== undefined && input.templateName !== null && { templateName: input.templateName }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateProvisioningTemplateVersionCommand = async (
  input: CreateProvisioningTemplateVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/provisioning-templates/{templateName}/versions";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: templateName.");
    }
    resolvedPath = resolvedPath.replace("{templateName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  const query: any = {
    ...(input.setAsDefault !== undefined && { setAsDefault: input.setAsDefault.toString() }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.templateBody !== undefined && input.templateBody !== null && { templateBody: input.templateBody }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1CreateRoleAliasCommand = async (
  input: CreateRoleAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
  if (input.roleAlias !== undefined) {
    const labelValue: string = input.roleAlias;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: roleAlias.");
    }
    resolvedPath = resolvedPath.replace("{roleAlias}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: roleAlias.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.credentialDurationSeconds !== undefined &&
      input.credentialDurationSeconds !== null && { credentialDurationSeconds: input.credentialDurationSeconds }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateScheduledAuditCommand = async (
  input: CreateScheduledAuditCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/audit/scheduledaudits/{scheduledAuditName}";
  if (input.scheduledAuditName !== undefined) {
    const labelValue: string = input.scheduledAuditName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: scheduledAuditName.");
    }
    resolvedPath = resolvedPath.replace("{scheduledAuditName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: scheduledAuditName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.dayOfMonth !== undefined && input.dayOfMonth !== null && { dayOfMonth: input.dayOfMonth }),
    ...(input.dayOfWeek !== undefined && input.dayOfWeek !== null && { dayOfWeek: input.dayOfWeek }),
    ...(input.frequency !== undefined && input.frequency !== null && { frequency: input.frequency }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.targetCheckNames !== undefined &&
      input.targetCheckNames !== null && {
        targetCheckNames: serializeAws_restJson1TargetAuditCheckNames(input.targetCheckNames, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateSecurityProfileCommand = async (
  input: CreateSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: securityProfileName.");
    }
    resolvedPath = resolvedPath.replace("{securityProfileName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: securityProfileName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.additionalMetricsToRetain !== undefined &&
      input.additionalMetricsToRetain !== null && {
        additionalMetricsToRetain: serializeAws_restJson1AdditionalMetricsToRetainList(
          input.additionalMetricsToRetain,
          context
        ),
      }),
    ...(input.additionalMetricsToRetainV2 !== undefined &&
      input.additionalMetricsToRetainV2 !== null && {
        additionalMetricsToRetainV2: serializeAws_restJson1AdditionalMetricsToRetainV2List(
          input.additionalMetricsToRetainV2,
          context
        ),
      }),
    ...(input.alertTargets !== undefined &&
      input.alertTargets !== null && { alertTargets: serializeAws_restJson1AlertTargets(input.alertTargets, context) }),
    ...(input.behaviors !== undefined &&
      input.behaviors !== null && { behaviors: serializeAws_restJson1Behaviors(input.behaviors, context) }),
    ...(input.securityProfileDescription !== undefined &&
      input.securityProfileDescription !== null && { securityProfileDescription: input.securityProfileDescription }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateStreamCommand = async (
  input: CreateStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
  if (input.streamId !== undefined) {
    const labelValue: string = input.streamId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: streamId.");
    }
    resolvedPath = resolvedPath.replace("{streamId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: streamId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.files !== undefined &&
      input.files !== null && { files: serializeAws_restJson1StreamFiles(input.files, context) }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateThingCommand = async (
  input: CreateThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.attributePayload !== undefined &&
      input.attributePayload !== null && {
        attributePayload: serializeAws_restJson1AttributePayload(input.attributePayload, context),
      }),
    ...(input.billingGroupName !== undefined &&
      input.billingGroupName !== null && { billingGroupName: input.billingGroupName }),
    ...(input.thingTypeName !== undefined && input.thingTypeName !== null && { thingTypeName: input.thingTypeName }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateThingGroupCommand = async (
  input: CreateThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{thingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.parentGroupName !== undefined &&
      input.parentGroupName !== null && { parentGroupName: input.parentGroupName }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.thingGroupProperties !== undefined &&
      input.thingGroupProperties !== null && {
        thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateThingTypeCommand = async (
  input: CreateThingTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}";
  if (input.thingTypeName !== undefined) {
    const labelValue: string = input.thingTypeName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingTypeName.");
    }
    resolvedPath = resolvedPath.replace("{thingTypeName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingTypeName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.thingTypeProperties !== undefined &&
      input.thingTypeProperties !== null && {
        thingTypeProperties: serializeAws_restJson1ThingTypeProperties(input.thingTypeProperties, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateTopicRuleCommand = async (
  input: CreateTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
    ...(isSerializableHeaderValue(input.tags) && { "x-amz-tagging": input.tags! }),
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace("{ruleName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  let body: any;
  if (input.topicRulePayload !== undefined) {
    body = serializeAws_restJson1TopicRulePayload(input.topicRulePayload, context);
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1CreateTopicRuleDestinationCommand = async (
  input: CreateTopicRuleDestinationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations";
  let body: any;
  body = JSON.stringify({
    ...(input.destinationConfiguration !== undefined &&
      input.destinationConfiguration !== null && {
        destinationConfiguration: serializeAws_restJson1TopicRuleDestinationConfiguration(
          input.destinationConfiguration,
          context
        ),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteAccountAuditConfigurationCommand = async (
  input: DeleteAccountAuditConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/configuration";
  const query: any = {
    ...(input.deleteScheduledAudits !== undefined && { deleteScheduledAudits: input.deleteScheduledAudits.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeleteAuditSuppressionCommand = async (
  input: DeleteAuditSuppressionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/delete";
  let body: any;
  body = JSON.stringify({
    ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
    ...(input.resourceIdentifier !== undefined &&
      input.resourceIdentifier !== null && {
        resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteAuthorizerCommand = async (
  input: DeleteAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
  if (input.authorizerName !== undefined) {
    const labelValue: string = input.authorizerName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: authorizerName.");
    }
    resolvedPath = resolvedPath.replace("{authorizerName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: authorizerName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteBillingGroupCommand = async (
  input: DeleteBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
  if (input.billingGroupName !== undefined) {
    const labelValue: string = input.billingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: billingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{billingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: billingGroupName.");
  }
  const query: any = {
    ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeleteCACertificateCommand = async (
  input: DeleteCACertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: certificateId.");
    }
    resolvedPath = resolvedPath.replace("{certificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteCertificateCommand = async (
  input: DeleteCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: certificateId.");
    }
    resolvedPath = resolvedPath.replace("{certificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  const query: any = {
    ...(input.forceDelete !== undefined && { forceDelete: input.forceDelete.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeleteCustomMetricCommand = async (
  input: DeleteCustomMetricCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
  if (input.metricName !== undefined) {
    const labelValue: string = input.metricName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: metricName.");
    }
    resolvedPath = resolvedPath.replace("{metricName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: metricName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteDimensionCommand = async (
  input: DeleteDimensionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
  if (input.name !== undefined) {
    const labelValue: string = input.name;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: name.");
    }
    resolvedPath = resolvedPath.replace("{name}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: name.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteDomainConfigurationCommand = async (
  input: DeleteDomainConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/domainConfigurations/{domainConfigurationName}";
  if (input.domainConfigurationName !== undefined) {
    const labelValue: string = input.domainConfigurationName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainConfigurationName.");
    }
    resolvedPath = resolvedPath.replace("{domainConfigurationName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: domainConfigurationName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteDynamicThingGroupCommand = async (
  input: DeleteDynamicThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dynamic-thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{thingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  const query: any = {
    ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeleteFleetMetricCommand = async (
  input: DeleteFleetMetricCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
  if (input.metricName !== undefined) {
    const labelValue: string = input.metricName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: metricName.");
    }
    resolvedPath = resolvedPath.replace("{metricName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: metricName.");
  }
  const query: any = {
    ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeleteJobCommand = async (
  input: DeleteJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  const query: any = {
    ...(input.force !== undefined && { force: input.force.toString() }),
    ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeleteJobExecutionCommand = async (
  input: DeleteJobExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  if (input.executionNumber !== undefined) {
    const labelValue: string = input.executionNumber.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: executionNumber.");
    }
    resolvedPath = resolvedPath.replace("{executionNumber}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: executionNumber.");
  }
  const query: any = {
    ...(input.force !== undefined && { force: input.force.toString() }),
    ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeleteJobTemplateCommand = async (
  input: DeleteJobTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates/{jobTemplateId}";
  if (input.jobTemplateId !== undefined) {
    const labelValue: string = input.jobTemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobTemplateId.");
    }
    resolvedPath = resolvedPath.replace("{jobTemplateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobTemplateId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteMitigationActionCommand = async (
  input: DeleteMitigationActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
  if (input.actionName !== undefined) {
    const labelValue: string = input.actionName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: actionName.");
    }
    resolvedPath = resolvedPath.replace("{actionName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: actionName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteOTAUpdateCommand = async (
  input: DeleteOTAUpdateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates/{otaUpdateId}";
  if (input.otaUpdateId !== undefined) {
    const labelValue: string = input.otaUpdateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: otaUpdateId.");
    }
    resolvedPath = resolvedPath.replace("{otaUpdateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: otaUpdateId.");
  }
  const query: any = {
    ...(input.deleteStream !== undefined && { deleteStream: input.deleteStream.toString() }),
    ...(input.forceDeleteAWSJob !== undefined && { forceDeleteAWSJob: input.forceDeleteAWSJob.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeletePolicyCommand = async (
  input: DeletePolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeletePolicyVersionCommand = async (
  input: DeletePolicyVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/policies/{policyName}/version/{policyVersionId}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  if (input.policyVersionId !== undefined) {
    const labelValue: string = input.policyVersionId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyVersionId.");
    }
    resolvedPath = resolvedPath.replace("{policyVersionId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyVersionId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteProvisioningTemplateCommand = async (
  input: DeleteProvisioningTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates/{templateName}";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: templateName.");
    }
    resolvedPath = resolvedPath.replace("{templateName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteProvisioningTemplateVersionCommand = async (
  input: DeleteProvisioningTemplateVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/provisioning-templates/{templateName}/versions/{versionId}";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: templateName.");
    }
    resolvedPath = resolvedPath.replace("{templateName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  if (input.versionId !== undefined) {
    const labelValue: string = input.versionId.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: versionId.");
    }
    resolvedPath = resolvedPath.replace("{versionId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: versionId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteRegistrationCodeCommand = async (
  input: DeleteRegistrationCodeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/registrationcode";
  let body: any;
  body = "";
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteRoleAliasCommand = async (
  input: DeleteRoleAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
  if (input.roleAlias !== undefined) {
    const labelValue: string = input.roleAlias;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: roleAlias.");
    }
    resolvedPath = resolvedPath.replace("{roleAlias}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: roleAlias.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteScheduledAuditCommand = async (
  input: DeleteScheduledAuditCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/audit/scheduledaudits/{scheduledAuditName}";
  if (input.scheduledAuditName !== undefined) {
    const labelValue: string = input.scheduledAuditName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: scheduledAuditName.");
    }
    resolvedPath = resolvedPath.replace("{scheduledAuditName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: scheduledAuditName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteSecurityProfileCommand = async (
  input: DeleteSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: securityProfileName.");
    }
    resolvedPath = resolvedPath.replace("{securityProfileName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: securityProfileName.");
  }
  const query: any = {
    ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeleteStreamCommand = async (
  input: DeleteStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
  if (input.streamId !== undefined) {
    const labelValue: string = input.streamId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: streamId.");
    }
    resolvedPath = resolvedPath.replace("{streamId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: streamId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteThingCommand = async (
  input: DeleteThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {
    ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeleteThingGroupCommand = async (
  input: DeleteThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{thingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  const query: any = {
    ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeleteThingTypeCommand = async (
  input: DeleteThingTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}";
  if (input.thingTypeName !== undefined) {
    const labelValue: string = input.thingTypeName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingTypeName.");
    }
    resolvedPath = resolvedPath.replace("{thingTypeName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingTypeName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteTopicRuleCommand = async (
  input: DeleteTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace("{ruleName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteTopicRuleDestinationCommand = async (
  input: DeleteTopicRuleDestinationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations/{arn+}";
  if (input.arn !== undefined) {
    const labelValue: string = input.arn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: arn.");
    }
    resolvedPath = resolvedPath.replace(
      "{arn+}",
      labelValue
        .split("/")
        .map((segment) => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: arn.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DeleteV2LoggingLevelCommand = async (
  input: DeleteV2LoggingLevelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingLevel";
  const query: any = {
    ...(input.targetType !== undefined && { targetType: input.targetType }),
    ...(input.targetName !== undefined && { targetName: input.targetName }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DeprecateThingTypeCommand = async (
  input: DeprecateThingTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}/deprecate";
  if (input.thingTypeName !== undefined) {
    const labelValue: string = input.thingTypeName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingTypeName.");
    }
    resolvedPath = resolvedPath.replace("{thingTypeName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingTypeName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.undoDeprecate !== undefined && input.undoDeprecate !== null && { undoDeprecate: input.undoDeprecate }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeAccountAuditConfigurationCommand = async (
  input: DescribeAccountAuditConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/configuration";
  let body: any;
  body = "";
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeAuditFindingCommand = async (
  input: DescribeAuditFindingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/findings/{findingId}";
  if (input.findingId !== undefined) {
    const labelValue: string = input.findingId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: findingId.");
    }
    resolvedPath = resolvedPath.replace("{findingId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: findingId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeAuditMitigationActionsTaskCommand = async (
  input: DescribeAuditMitigationActionsTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/tasks/{taskId}";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeAuditSuppressionCommand = async (
  input: DescribeAuditSuppressionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/describe";
  let body: any;
  body = JSON.stringify({
    ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
    ...(input.resourceIdentifier !== undefined &&
      input.resourceIdentifier !== null && {
        resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeAuditTaskCommand = async (
  input: DescribeAuditTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks/{taskId}";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeAuthorizerCommand = async (
  input: DescribeAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
  if (input.authorizerName !== undefined) {
    const labelValue: string = input.authorizerName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: authorizerName.");
    }
    resolvedPath = resolvedPath.replace("{authorizerName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: authorizerName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeBillingGroupCommand = async (
  input: DescribeBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
  if (input.billingGroupName !== undefined) {
    const labelValue: string = input.billingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: billingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{billingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: billingGroupName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeCACertificateCommand = async (
  input: DescribeCACertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: certificateId.");
    }
    resolvedPath = resolvedPath.replace("{certificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeCertificateCommand = async (
  input: DescribeCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: certificateId.");
    }
    resolvedPath = resolvedPath.replace("{certificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeCustomMetricCommand = async (
  input: DescribeCustomMetricCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
  if (input.metricName !== undefined) {
    const labelValue: string = input.metricName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: metricName.");
    }
    resolvedPath = resolvedPath.replace("{metricName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: metricName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeDefaultAuthorizerCommand = async (
  input: DescribeDefaultAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/default-authorizer";
  let body: any;
  body = "";
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeDetectMitigationActionsTaskCommand = async (
  input: DescribeDetectMitigationActionsTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/tasks/{taskId}";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeDimensionCommand = async (
  input: DescribeDimensionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
  if (input.name !== undefined) {
    const labelValue: string = input.name;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: name.");
    }
    resolvedPath = resolvedPath.replace("{name}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: name.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeDomainConfigurationCommand = async (
  input: DescribeDomainConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/domainConfigurations/{domainConfigurationName}";
  if (input.domainConfigurationName !== undefined) {
    const labelValue: string = input.domainConfigurationName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainConfigurationName.");
    }
    resolvedPath = resolvedPath.replace("{domainConfigurationName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: domainConfigurationName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeEndpointCommand = async (
  input: DescribeEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/endpoint";
  const query: any = {
    ...(input.endpointType !== undefined && { endpointType: input.endpointType }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DescribeEventConfigurationsCommand = async (
  input: DescribeEventConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/event-configurations";
  let body: any;
  body = "";
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeFleetMetricCommand = async (
  input: DescribeFleetMetricCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
  if (input.metricName !== undefined) {
    const labelValue: string = input.metricName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: metricName.");
    }
    resolvedPath = resolvedPath.replace("{metricName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: metricName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeIndexCommand = async (
  input: DescribeIndexCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/{indexName}";
  if (input.indexName !== undefined) {
    const labelValue: string = input.indexName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: indexName.");
    }
    resolvedPath = resolvedPath.replace("{indexName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: indexName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeJobCommand = async (
  input: DescribeJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeJobExecutionCommand = async (
  input: DescribeJobExecutionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/jobs/{jobId}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {
    ...(input.executionNumber !== undefined && { executionNumber: input.executionNumber.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DescribeJobTemplateCommand = async (
  input: DescribeJobTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates/{jobTemplateId}";
  if (input.jobTemplateId !== undefined) {
    const labelValue: string = input.jobTemplateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobTemplateId.");
    }
    resolvedPath = resolvedPath.replace("{jobTemplateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobTemplateId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeMitigationActionCommand = async (
  input: DescribeMitigationActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
  if (input.actionName !== undefined) {
    const labelValue: string = input.actionName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: actionName.");
    }
    resolvedPath = resolvedPath.replace("{actionName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: actionName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeProvisioningTemplateCommand = async (
  input: DescribeProvisioningTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates/{templateName}";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: templateName.");
    }
    resolvedPath = resolvedPath.replace("{templateName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeProvisioningTemplateVersionCommand = async (
  input: DescribeProvisioningTemplateVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/provisioning-templates/{templateName}/versions/{versionId}";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: templateName.");
    }
    resolvedPath = resolvedPath.replace("{templateName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  if (input.versionId !== undefined) {
    const labelValue: string = input.versionId.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: versionId.");
    }
    resolvedPath = resolvedPath.replace("{versionId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: versionId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeRoleAliasCommand = async (
  input: DescribeRoleAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
  if (input.roleAlias !== undefined) {
    const labelValue: string = input.roleAlias;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: roleAlias.");
    }
    resolvedPath = resolvedPath.replace("{roleAlias}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: roleAlias.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeScheduledAuditCommand = async (
  input: DescribeScheduledAuditCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/audit/scheduledaudits/{scheduledAuditName}";
  if (input.scheduledAuditName !== undefined) {
    const labelValue: string = input.scheduledAuditName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: scheduledAuditName.");
    }
    resolvedPath = resolvedPath.replace("{scheduledAuditName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: scheduledAuditName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeSecurityProfileCommand = async (
  input: DescribeSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: securityProfileName.");
    }
    resolvedPath = resolvedPath.replace("{securityProfileName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: securityProfileName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeStreamCommand = async (
  input: DescribeStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
  if (input.streamId !== undefined) {
    const labelValue: string = input.streamId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: streamId.");
    }
    resolvedPath = resolvedPath.replace("{streamId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: streamId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeThingCommand = async (
  input: DescribeThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeThingGroupCommand = async (
  input: DescribeThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{thingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeThingRegistrationTaskCommand = async (
  input: DescribeThingRegistrationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks/{taskId}";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DescribeThingTypeCommand = async (
  input: DescribeThingTypeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}";
  if (input.thingTypeName !== undefined) {
    const labelValue: string = input.thingTypeName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingTypeName.");
    }
    resolvedPath = resolvedPath.replace("{thingTypeName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingTypeName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DetachPolicyCommand = async (
  input: DetachPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/target-policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.target !== undefined && input.target !== null && { target: input.target }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DetachPrincipalPolicyCommand = async (
  input: DetachPrincipalPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    ...(isSerializableHeaderValue(input.principal) && { "x-amzn-iot-principal": input.principal! }),
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principal-policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DetachSecurityProfileCommand = async (
  input: DetachSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/security-profiles/{securityProfileName}/targets";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: securityProfileName.");
    }
    resolvedPath = resolvedPath.replace("{securityProfileName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: securityProfileName.");
  }
  const query: any = {
    ...(input.securityProfileTargetArn !== undefined && { securityProfileTargetArn: input.securityProfileTargetArn }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1DetachThingPrincipalCommand = async (
  input: DetachThingPrincipalCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    ...(isSerializableHeaderValue(input.principal) && { "x-amzn-principal": input.principal! }),
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/principals";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1DisableTopicRuleCommand = async (
  input: DisableTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}/disable";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace("{ruleName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1EnableTopicRuleCommand = async (
  input: EnableTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}/enable";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace("{ruleName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetBehaviorModelTrainingSummariesCommand = async (
  input: GetBehaviorModelTrainingSummariesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/behavior-model-training/summaries";
  const query: any = {
    ...(input.securityProfileName !== undefined && { securityProfileName: input.securityProfileName }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1GetBucketsAggregationCommand = async (
  input: GetBucketsAggregationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/buckets";
  let body: any;
  body = JSON.stringify({
    ...(input.aggregationField !== undefined &&
      input.aggregationField !== null && { aggregationField: input.aggregationField }),
    ...(input.bucketsAggregationType !== undefined &&
      input.bucketsAggregationType !== null && {
        bucketsAggregationType: serializeAws_restJson1BucketsAggregationType(input.bucketsAggregationType, context),
      }),
    ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
    ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
    ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetCardinalityCommand = async (
  input: GetCardinalityCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/cardinality";
  let body: any;
  body = JSON.stringify({
    ...(input.aggregationField !== undefined &&
      input.aggregationField !== null && { aggregationField: input.aggregationField }),
    ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
    ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
    ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetEffectivePoliciesCommand = async (
  input: GetEffectivePoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/effective-policies";
  const query: any = {
    ...(input.thingName !== undefined && { thingName: input.thingName }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.cognitoIdentityPoolId !== undefined &&
      input.cognitoIdentityPoolId !== null && { cognitoIdentityPoolId: input.cognitoIdentityPoolId }),
    ...(input.principal !== undefined && input.principal !== null && { principal: input.principal }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1GetIndexingConfigurationCommand = async (
  input: GetIndexingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indexing/config";
  let body: any;
  body = "";
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetJobDocumentCommand = async (
  input: GetJobDocumentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/job-document";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetLoggingOptionsCommand = async (
  input: GetLoggingOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/loggingOptions";
  let body: any;
  body = "";
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetOTAUpdateCommand = async (
  input: GetOTAUpdateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates/{otaUpdateId}";
  if (input.otaUpdateId !== undefined) {
    const labelValue: string = input.otaUpdateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: otaUpdateId.");
    }
    resolvedPath = resolvedPath.replace("{otaUpdateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: otaUpdateId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetPercentilesCommand = async (
  input: GetPercentilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/percentiles";
  let body: any;
  body = JSON.stringify({
    ...(input.aggregationField !== undefined &&
      input.aggregationField !== null && { aggregationField: input.aggregationField }),
    ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
    ...(input.percents !== undefined &&
      input.percents !== null && { percents: serializeAws_restJson1PercentList(input.percents, context) }),
    ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
    ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetPolicyCommand = async (
  input: GetPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetPolicyVersionCommand = async (
  input: GetPolicyVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/policies/{policyName}/version/{policyVersionId}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  if (input.policyVersionId !== undefined) {
    const labelValue: string = input.policyVersionId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyVersionId.");
    }
    resolvedPath = resolvedPath.replace("{policyVersionId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyVersionId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetRegistrationCodeCommand = async (
  input: GetRegistrationCodeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/registrationcode";
  let body: any;
  body = "";
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetStatisticsCommand = async (
  input: GetStatisticsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/statistics";
  let body: any;
  body = JSON.stringify({
    ...(input.aggregationField !== undefined &&
      input.aggregationField !== null && { aggregationField: input.aggregationField }),
    ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
    ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
    ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetTopicRuleCommand = async (
  input: GetTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace("{ruleName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetTopicRuleDestinationCommand = async (
  input: GetTopicRuleDestinationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations/{arn+}";
  if (input.arn !== undefined) {
    const labelValue: string = input.arn;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: arn.");
    }
    resolvedPath = resolvedPath.replace(
      "{arn+}",
      labelValue
        .split("/")
        .map((segment) => __extendedEncodeURIComponent(segment))
        .join("/")
    );
  } else {
    throw new Error("No value provided for input HTTP label: arn.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1GetV2LoggingOptionsCommand = async (
  input: GetV2LoggingOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingOptions";
  let body: any;
  body = "";
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1ListActiveViolationsCommand = async (
  input: ListActiveViolationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/active-violations";
  const query: any = {
    ...(input.thingName !== undefined && { thingName: input.thingName }),
    ...(input.securityProfileName !== undefined && { securityProfileName: input.securityProfileName }),
    ...(input.behaviorCriteriaType !== undefined && { behaviorCriteriaType: input.behaviorCriteriaType }),
    ...(input.listSuppressedAlerts !== undefined && { listSuppressedAlerts: input.listSuppressedAlerts.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListAttachedPoliciesCommand = async (
  input: ListAttachedPoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/attached-policies/{target}";
  if (input.target !== undefined) {
    const labelValue: string = input.target;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: target.");
    }
    resolvedPath = resolvedPath.replace("{target}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: target.");
  }
  const query: any = {
    ...(input.recursive !== undefined && { recursive: input.recursive.toString() }),
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListAuditFindingsCommand = async (
  input: ListAuditFindingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/findings";
  let body: any;
  body = JSON.stringify({
    ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
    ...(input.endTime !== undefined &&
      input.endTime !== null && { endTime: Math.round(input.endTime.getTime() / 1000) }),
    ...(input.listSuppressedFindings !== undefined &&
      input.listSuppressedFindings !== null && { listSuppressedFindings: input.listSuppressedFindings }),
    ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
    ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
    ...(input.resourceIdentifier !== undefined &&
      input.resourceIdentifier !== null && {
        resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
      }),
    ...(input.startTime !== undefined &&
      input.startTime !== null && { startTime: Math.round(input.startTime.getTime() / 1000) }),
    ...(input.taskId !== undefined && input.taskId !== null && { taskId: input.taskId }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1ListAuditMitigationActionsExecutionsCommand = async (
  input: ListAuditMitigationActionsExecutionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/executions";
  const query: any = {
    ...(input.taskId !== undefined && { taskId: input.taskId }),
    ...(input.actionStatus !== undefined && { actionStatus: input.actionStatus }),
    ...(input.findingId !== undefined && { findingId: input.findingId }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListAuditMitigationActionsTasksCommand = async (
  input: ListAuditMitigationActionsTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/tasks";
  const query: any = {
    ...(input.auditTaskId !== undefined && { auditTaskId: input.auditTaskId }),
    ...(input.findingId !== undefined && { findingId: input.findingId }),
    ...(input.taskStatus !== undefined && { taskStatus: input.taskStatus }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.startTime !== undefined && { startTime: (input.startTime.toISOString().split(".")[0] + "Z").toString() }),
    ...(input.endTime !== undefined && { endTime: (input.endTime.toISOString().split(".")[0] + "Z").toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListAuditSuppressionsCommand = async (
  input: ListAuditSuppressionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/list";
  let body: any;
  body = JSON.stringify({
    ...(input.ascendingOrder !== undefined &&
      input.ascendingOrder !== null && { ascendingOrder: input.ascendingOrder }),
    ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
    ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
    ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
    ...(input.resourceIdentifier !== undefined &&
      input.resourceIdentifier !== null && {
        resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1ListAuditTasksCommand = async (
  input: ListAuditTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks";
  const query: any = {
    ...(input.startTime !== undefined && { startTime: (input.startTime.toISOString().split(".")[0] + "Z").toString() }),
    ...(input.endTime !== undefined && { endTime: (input.endTime.toISOString().split(".")[0] + "Z").toString() }),
    ...(input.taskType !== undefined && { taskType: input.taskType }),
    ...(input.taskStatus !== undefined && { taskStatus: input.taskStatus }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListAuthorizersCommand = async (
  input: ListAuthorizersCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizers";
  const query: any = {
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
    ...(input.status !== undefined && { status: input.status }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListBillingGroupsCommand = async (
  input: ListBillingGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.namePrefixFilter !== undefined && { namePrefixFilter: input.namePrefixFilter }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListCACertificatesCommand = async (
  input: ListCACertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificates";
  const query: any = {
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListCertificatesCommand = async (
  input: ListCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates";
  const query: any = {
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListCertificatesByCACommand = async (
  input: ListCertificatesByCACommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates-by-ca/{caCertificateId}";
  if (input.caCertificateId !== undefined) {
    const labelValue: string = input.caCertificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: caCertificateId.");
    }
    resolvedPath = resolvedPath.replace("{caCertificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: caCertificateId.");
  }
  const query: any = {
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListCustomMetricsCommand = async (
  input: ListCustomMetricsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metrics";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListDetectMitigationActionsExecutionsCommand = async (
  input: ListDetectMitigationActionsExecutionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/executions";
  const query: any = {
    ...(input.taskId !== undefined && { taskId: input.taskId }),
    ...(input.violationId !== undefined && { violationId: input.violationId }),
    ...(input.thingName !== undefined && { thingName: input.thingName }),
    ...(input.startTime !== undefined && { startTime: (input.startTime.toISOString().split(".")[0] + "Z").toString() }),
    ...(input.endTime !== undefined && { endTime: (input.endTime.toISOString().split(".")[0] + "Z").toString() }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListDetectMitigationActionsTasksCommand = async (
  input: ListDetectMitigationActionsTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/tasks";
  const query: any = {
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.startTime !== undefined && { startTime: (input.startTime.toISOString().split(".")[0] + "Z").toString() }),
    ...(input.endTime !== undefined && { endTime: (input.endTime.toISOString().split(".")[0] + "Z").toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListDimensionsCommand = async (
  input: ListDimensionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListDomainConfigurationsCommand = async (
  input: ListDomainConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainConfigurations";
  const query: any = {
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    ...(input.serviceType !== undefined && { serviceType: input.serviceType }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListFleetMetricsCommand = async (
  input: ListFleetMetricsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metrics";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListIndicesCommand = async (
  input: ListIndicesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListJobExecutionsForJobCommand = async (
  input: ListJobExecutionsForJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/things";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  const query: any = {
    ...(input.status !== undefined && { status: input.status }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListJobExecutionsForThingCommand = async (
  input: ListJobExecutionsForThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/jobs";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {
    ...(input.status !== undefined && { status: input.status }),
    ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListJobsCommand = async (
  input: ListJobsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs";
  const query: any = {
    ...(input.status !== undefined && { status: input.status }),
    ...(input.targetSelection !== undefined && { targetSelection: input.targetSelection }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.thingGroupName !== undefined && { thingGroupName: input.thingGroupName }),
    ...(input.thingGroupId !== undefined && { thingGroupId: input.thingGroupId }),
    ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListJobTemplatesCommand = async (
  input: ListJobTemplatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates";
  const query: any = {
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListMitigationActionsCommand = async (
  input: ListMitigationActionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions";
  const query: any = {
    ...(input.actionType !== undefined && { actionType: input.actionType }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListOTAUpdatesCommand = async (
  input: ListOTAUpdatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates";
  const query: any = {
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.otaUpdateStatus !== undefined && { otaUpdateStatus: input.otaUpdateStatus }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListOutgoingCertificatesCommand = async (
  input: ListOutgoingCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates-out-going";
  const query: any = {
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListPoliciesCommand = async (
  input: ListPoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies";
  const query: any = {
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListPolicyPrincipalsCommand = async (
  input: ListPolicyPrincipalsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    ...(isSerializableHeaderValue(input.policyName) && { "x-amzn-iot-policy": input.policyName! }),
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policy-principals";
  const query: any = {
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListPolicyVersionsCommand = async (
  input: ListPolicyVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}/version";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1ListPrincipalPoliciesCommand = async (
  input: ListPrincipalPoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    ...(isSerializableHeaderValue(input.principal) && { "x-amzn-iot-principal": input.principal! }),
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principal-policies";
  const query: any = {
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListPrincipalThingsCommand = async (
  input: ListPrincipalThingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    ...(isSerializableHeaderValue(input.principal) && { "x-amzn-principal": input.principal! }),
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principals/things";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListProvisioningTemplatesCommand = async (
  input: ListProvisioningTemplatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates";
  const query: any = {
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListProvisioningTemplateVersionsCommand = async (
  input: ListProvisioningTemplateVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/provisioning-templates/{templateName}/versions";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: templateName.");
    }
    resolvedPath = resolvedPath.replace("{templateName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  const query: any = {
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListRoleAliasesCommand = async (
  input: ListRoleAliasesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases";
  const query: any = {
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListScheduledAuditsCommand = async (
  input: ListScheduledAuditsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/scheduledaudits";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListSecurityProfilesCommand = async (
  input: ListSecurityProfilesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.dimensionName !== undefined && { dimensionName: input.dimensionName }),
    ...(input.metricName !== undefined && { metricName: input.metricName }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListSecurityProfilesForTargetCommand = async (
  input: ListSecurityProfilesForTargetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles-for-target";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.recursive !== undefined && { recursive: input.recursive.toString() }),
    ...(input.securityProfileTargetArn !== undefined && { securityProfileTargetArn: input.securityProfileTargetArn }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListStreamsCommand = async (
  input: ListStreamsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams";
  const query: any = {
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.ascendingOrder !== undefined && { isAscendingOrder: input.ascendingOrder.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListTagsForResourceCommand = async (
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags";
  const query: any = {
    ...(input.resourceArn !== undefined && { resourceArn: input.resourceArn }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListTargetsForPolicyCommand = async (
  input: ListTargetsForPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policy-targets/{policyName}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  const query: any = {
    ...(input.marker !== undefined && { marker: input.marker }),
    ...(input.pageSize !== undefined && { pageSize: input.pageSize.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListTargetsForSecurityProfileCommand = async (
  input: ListTargetsForSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/security-profiles/{securityProfileName}/targets";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: securityProfileName.");
    }
    resolvedPath = resolvedPath.replace("{securityProfileName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: securityProfileName.");
  }
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListThingGroupsCommand = async (
  input: ListThingGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.parentGroup !== undefined && { parentGroup: input.parentGroup }),
    ...(input.namePrefixFilter !== undefined && { namePrefixFilter: input.namePrefixFilter }),
    ...(input.recursive !== undefined && { recursive: input.recursive.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListThingGroupsForThingCommand = async (
  input: ListThingGroupsForThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/thing-groups";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListThingPrincipalsCommand = async (
  input: ListThingPrincipalsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/principals";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListThingRegistrationTaskReportsCommand = async (
  input: ListThingRegistrationTaskReportsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/thing-registration-tasks/{taskId}/reports";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  const query: any = {
    ...(input.reportType !== undefined && { reportType: input.reportType }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListThingRegistrationTasksCommand = async (
  input: ListThingRegistrationTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.status !== undefined && { status: input.status }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListThingsCommand = async (
  input: ListThingsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.attributeName !== undefined && { attributeName: input.attributeName }),
    ...(input.attributeValue !== undefined && { attributeValue: input.attributeValue }),
    ...(input.thingTypeName !== undefined && { thingTypeName: input.thingTypeName }),
    ...(input.usePrefixAttributeValue !== undefined && {
      usePrefixAttributeValue: input.usePrefixAttributeValue.toString(),
    }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListThingsInBillingGroupCommand = async (
  input: ListThingsInBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}/things";
  if (input.billingGroupName !== undefined) {
    const labelValue: string = input.billingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: billingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{billingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: billingGroupName.");
  }
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListThingsInThingGroupCommand = async (
  input: ListThingsInThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}/things";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{thingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  const query: any = {
    ...(input.recursive !== undefined && { recursive: input.recursive.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListThingTypesCommand = async (
  input: ListThingTypesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types";
  const query: any = {
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.thingTypeName !== undefined && { thingTypeName: input.thingTypeName }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListTopicRuleDestinationsCommand = async (
  input: ListTopicRuleDestinationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations";
  const query: any = {
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListTopicRulesCommand = async (
  input: ListTopicRulesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules";
  const query: any = {
    ...(input.topic !== undefined && { topic: input.topic }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.ruleDisabled !== undefined && { ruleDisabled: input.ruleDisabled.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListV2LoggingLevelsCommand = async (
  input: ListV2LoggingLevelsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingLevel";
  const query: any = {
    ...(input.targetType !== undefined && { targetType: input.targetType }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1ListViolationEventsCommand = async (
  input: ListViolationEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/violation-events";
  const query: any = {
    ...(input.startTime !== undefined && { startTime: (input.startTime.toISOString().split(".")[0] + "Z").toString() }),
    ...(input.endTime !== undefined && { endTime: (input.endTime.toISOString().split(".")[0] + "Z").toString() }),
    ...(input.thingName !== undefined && { thingName: input.thingName }),
    ...(input.securityProfileName !== undefined && { securityProfileName: input.securityProfileName }),
    ...(input.behaviorCriteriaType !== undefined && { behaviorCriteriaType: input.behaviorCriteriaType }),
    ...(input.listSuppressedAlerts !== undefined && { listSuppressedAlerts: input.listSuppressedAlerts.toString() }),
    ...(input.nextToken !== undefined && { nextToken: input.nextToken }),
    ...(input.maxResults !== undefined && { maxResults: input.maxResults.toString() }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1RegisterCACertificateCommand = async (
  input: RegisterCACertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate";
  const query: any = {
    ...(input.setAsActive !== undefined && { setAsActive: input.setAsActive.toString() }),
    ...(input.allowAutoRegistration !== undefined && { allowAutoRegistration: input.allowAutoRegistration.toString() }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.caCertificate !== undefined && input.caCertificate !== null && { caCertificate: input.caCertificate }),
    ...(input.registrationConfig !== undefined &&
      input.registrationConfig !== null && {
        registrationConfig: serializeAws_restJson1RegistrationConfig(input.registrationConfig, context),
      }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    ...(input.verificationCertificate !== undefined &&
      input.verificationCertificate !== null && { verificationCertificate: input.verificationCertificate }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1RegisterCertificateCommand = async (
  input: RegisterCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificate/register";
  const query: any = {
    ...(input.setAsActive !== undefined && { setAsActive: input.setAsActive.toString() }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.caCertificatePem !== undefined &&
      input.caCertificatePem !== null && { caCertificatePem: input.caCertificatePem }),
    ...(input.certificatePem !== undefined &&
      input.certificatePem !== null && { certificatePem: input.certificatePem }),
    ...(input.status !== undefined && input.status !== null && { status: input.status }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1RegisterCertificateWithoutCACommand = async (
  input: RegisterCertificateWithoutCACommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificate/register-no-ca";
  let body: any;
  body = JSON.stringify({
    ...(input.certificatePem !== undefined &&
      input.certificatePem !== null && { certificatePem: input.certificatePem }),
    ...(input.status !== undefined && input.status !== null && { status: input.status }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1RegisterThingCommand = async (
  input: RegisterThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things";
  let body: any;
  body = JSON.stringify({
    ...(input.parameters !== undefined &&
      input.parameters !== null && { parameters: serializeAws_restJson1Parameters(input.parameters, context) }),
    ...(input.templateBody !== undefined && input.templateBody !== null && { templateBody: input.templateBody }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1RejectCertificateTransferCommand = async (
  input: RejectCertificateTransferCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/reject-certificate-transfer/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: certificateId.");
    }
    resolvedPath = resolvedPath.replace("{certificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.rejectReason !== undefined && input.rejectReason !== null && { rejectReason: input.rejectReason }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1RemoveThingFromBillingGroupCommand = async (
  input: RemoveThingFromBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/billing-groups/removeThingFromBillingGroup";
  let body: any;
  body = JSON.stringify({
    ...(input.billingGroupArn !== undefined &&
      input.billingGroupArn !== null && { billingGroupArn: input.billingGroupArn }),
    ...(input.billingGroupName !== undefined &&
      input.billingGroupName !== null && { billingGroupName: input.billingGroupName }),
    ...(input.thingArn !== undefined && input.thingArn !== null && { thingArn: input.thingArn }),
    ...(input.thingName !== undefined && input.thingName !== null && { thingName: input.thingName }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1RemoveThingFromThingGroupCommand = async (
  input: RemoveThingFromThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/removeThingFromThingGroup";
  let body: any;
  body = JSON.stringify({
    ...(input.thingArn !== undefined && input.thingArn !== null && { thingArn: input.thingArn }),
    ...(input.thingGroupArn !== undefined && input.thingGroupArn !== null && { thingGroupArn: input.thingGroupArn }),
    ...(input.thingGroupName !== undefined &&
      input.thingGroupName !== null && { thingGroupName: input.thingGroupName }),
    ...(input.thingName !== undefined && input.thingName !== null && { thingName: input.thingName }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1ReplaceTopicRuleCommand = async (
  input: ReplaceTopicRuleCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
  if (input.ruleName !== undefined) {
    const labelValue: string = input.ruleName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ruleName.");
    }
    resolvedPath = resolvedPath.replace("{ruleName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: ruleName.");
  }
  let body: any;
  if (input.topicRulePayload !== undefined) {
    body = serializeAws_restJson1TopicRulePayload(input.topicRulePayload, context);
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1SearchIndexCommand = async (
  input: SearchIndexCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/search";
  let body: any;
  body = JSON.stringify({
    ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
    ...(input.maxResults !== undefined && input.maxResults !== null && { maxResults: input.maxResults }),
    ...(input.nextToken !== undefined && input.nextToken !== null && { nextToken: input.nextToken }),
    ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
    ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1SetDefaultAuthorizerCommand = async (
  input: SetDefaultAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/default-authorizer";
  let body: any;
  body = JSON.stringify({
    ...(input.authorizerName !== undefined &&
      input.authorizerName !== null && { authorizerName: input.authorizerName }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1SetDefaultPolicyVersionCommand = async (
  input: SetDefaultPolicyVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/policies/{policyName}/version/{policyVersionId}";
  if (input.policyName !== undefined) {
    const labelValue: string = input.policyName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyName.");
    }
    resolvedPath = resolvedPath.replace("{policyName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyName.");
  }
  if (input.policyVersionId !== undefined) {
    const labelValue: string = input.policyVersionId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: policyVersionId.");
    }
    resolvedPath = resolvedPath.replace("{policyVersionId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: policyVersionId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1SetLoggingOptionsCommand = async (
  input: SetLoggingOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/loggingOptions";
  let body: any;
  if (input.loggingOptionsPayload !== undefined) {
    body = serializeAws_restJson1LoggingOptionsPayload(input.loggingOptionsPayload, context);
  }
  if (body === undefined) {
    body = {};
  }
  body = JSON.stringify(body);
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1SetV2LoggingLevelCommand = async (
  input: SetV2LoggingLevelCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingLevel";
  let body: any;
  body = JSON.stringify({
    ...(input.logLevel !== undefined && input.logLevel !== null && { logLevel: input.logLevel }),
    ...(input.logTarget !== undefined &&
      input.logTarget !== null && { logTarget: serializeAws_restJson1LogTarget(input.logTarget, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1SetV2LoggingOptionsCommand = async (
  input: SetV2LoggingOptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingOptions";
  let body: any;
  body = JSON.stringify({
    ...(input.defaultLogLevel !== undefined &&
      input.defaultLogLevel !== null && { defaultLogLevel: input.defaultLogLevel }),
    ...(input.disableAllLogs !== undefined &&
      input.disableAllLogs !== null && { disableAllLogs: input.disableAllLogs }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1StartAuditMitigationActionsTaskCommand = async (
  input: StartAuditMitigationActionsTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/tasks/{taskId}";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.auditCheckToActionsMapping !== undefined &&
      input.auditCheckToActionsMapping !== null && {
        auditCheckToActionsMapping: serializeAws_restJson1AuditCheckToActionsMapping(
          input.auditCheckToActionsMapping,
          context
        ),
      }),
    clientRequestToken: input.clientRequestToken ?? generateIdempotencyToken(),
    ...(input.target !== undefined &&
      input.target !== null && {
        target: serializeAws_restJson1AuditMitigationActionsTaskTarget(input.target, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1StartDetectMitigationActionsTaskCommand = async (
  input: StartDetectMitigationActionsTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/tasks/{taskId}";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.actions !== undefined &&
      input.actions !== null && {
        actions: serializeAws_restJson1DetectMitigationActionsToExecuteList(input.actions, context),
      }),
    clientRequestToken: input.clientRequestToken ?? generateIdempotencyToken(),
    ...(input.includeOnlyActiveViolations !== undefined &&
      input.includeOnlyActiveViolations !== null && { includeOnlyActiveViolations: input.includeOnlyActiveViolations }),
    ...(input.includeSuppressedAlerts !== undefined &&
      input.includeSuppressedAlerts !== null && { includeSuppressedAlerts: input.includeSuppressedAlerts }),
    ...(input.target !== undefined &&
      input.target !== null && {
        target: serializeAws_restJson1DetectMitigationActionsTaskTarget(input.target, context),
      }),
    ...(input.violationEventOccurrenceRange !== undefined &&
      input.violationEventOccurrenceRange !== null && {
        violationEventOccurrenceRange: serializeAws_restJson1ViolationEventOccurrenceRange(
          input.violationEventOccurrenceRange,
          context
        ),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1StartOnDemandAuditTaskCommand = async (
  input: StartOnDemandAuditTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks";
  let body: any;
  body = JSON.stringify({
    ...(input.targetCheckNames !== undefined &&
      input.targetCheckNames !== null && {
        targetCheckNames: serializeAws_restJson1TargetAuditCheckNames(input.targetCheckNames, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1StartThingRegistrationTaskCommand = async (
  input: StartThingRegistrationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks";
  let body: any;
  body = JSON.stringify({
    ...(input.inputFileBucket !== undefined &&
      input.inputFileBucket !== null && { inputFileBucket: input.inputFileBucket }),
    ...(input.inputFileKey !== undefined && input.inputFileKey !== null && { inputFileKey: input.inputFileKey }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.templateBody !== undefined && input.templateBody !== null && { templateBody: input.templateBody }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1StopThingRegistrationTaskCommand = async (
  input: StopThingRegistrationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks/{taskId}/cancel";
  if (input.taskId !== undefined) {
    const labelValue: string = input.taskId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: taskId.");
    }
    resolvedPath = resolvedPath.replace("{taskId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: taskId.");
  }
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1TagResourceCommand = async (
  input: TagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags";
  let body: any;
  body = JSON.stringify({
    ...(input.resourceArn !== undefined && input.resourceArn !== null && { resourceArn: input.resourceArn }),
    ...(input.tags !== undefined &&
      input.tags !== null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1TestAuthorizationCommand = async (
  input: TestAuthorizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/test-authorization";
  const query: any = {
    ...(input.clientId !== undefined && { clientId: input.clientId }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.authInfos !== undefined &&
      input.authInfos !== null && { authInfos: serializeAws_restJson1AuthInfos(input.authInfos, context) }),
    ...(input.cognitoIdentityPoolId !== undefined &&
      input.cognitoIdentityPoolId !== null && { cognitoIdentityPoolId: input.cognitoIdentityPoolId }),
    ...(input.policyNamesToAdd !== undefined &&
      input.policyNamesToAdd !== null && {
        policyNamesToAdd: serializeAws_restJson1PolicyNames(input.policyNamesToAdd, context),
      }),
    ...(input.policyNamesToSkip !== undefined &&
      input.policyNamesToSkip !== null && {
        policyNamesToSkip: serializeAws_restJson1PolicyNames(input.policyNamesToSkip, context),
      }),
    ...(input.principal !== undefined && input.principal !== null && { principal: input.principal }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1TestInvokeAuthorizerCommand = async (
  input: TestInvokeAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}/test";
  if (input.authorizerName !== undefined) {
    const labelValue: string = input.authorizerName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: authorizerName.");
    }
    resolvedPath = resolvedPath.replace("{authorizerName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: authorizerName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.httpContext !== undefined &&
      input.httpContext !== null && { httpContext: serializeAws_restJson1HttpContext(input.httpContext, context) }),
    ...(input.mqttContext !== undefined &&
      input.mqttContext !== null && { mqttContext: serializeAws_restJson1MqttContext(input.mqttContext, context) }),
    ...(input.tlsContext !== undefined &&
      input.tlsContext !== null && { tlsContext: serializeAws_restJson1TlsContext(input.tlsContext, context) }),
    ...(input.token !== undefined && input.token !== null && { token: input.token }),
    ...(input.tokenSignature !== undefined &&
      input.tokenSignature !== null && { tokenSignature: input.tokenSignature }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1TransferCertificateCommand = async (
  input: TransferCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/transfer-certificate/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: certificateId.");
    }
    resolvedPath = resolvedPath.replace("{certificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  const query: any = {
    ...(input.targetAwsAccount !== undefined && { targetAwsAccount: input.targetAwsAccount }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.transferMessage !== undefined &&
      input.transferMessage !== null && { transferMessage: input.transferMessage }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1UntagResourceCommand = async (
  input: UntagResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/untag";
  let body: any;
  body = JSON.stringify({
    ...(input.resourceArn !== undefined && input.resourceArn !== null && { resourceArn: input.resourceArn }),
    ...(input.tagKeys !== undefined &&
      input.tagKeys !== null && { tagKeys: serializeAws_restJson1TagKeyList(input.tagKeys, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateAccountAuditConfigurationCommand = async (
  input: UpdateAccountAuditConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/configuration";
  let body: any;
  body = JSON.stringify({
    ...(input.auditCheckConfigurations !== undefined &&
      input.auditCheckConfigurations !== null && {
        auditCheckConfigurations: serializeAws_restJson1AuditCheckConfigurations(
          input.auditCheckConfigurations,
          context
        ),
      }),
    ...(input.auditNotificationTargetConfigurations !== undefined &&
      input.auditNotificationTargetConfigurations !== null && {
        auditNotificationTargetConfigurations: serializeAws_restJson1AuditNotificationTargetConfigurations(
          input.auditNotificationTargetConfigurations,
          context
        ),
      }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateAuditSuppressionCommand = async (
  input: UpdateAuditSuppressionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/update";
  let body: any;
  body = JSON.stringify({
    ...(input.checkName !== undefined && input.checkName !== null && { checkName: input.checkName }),
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.expirationDate !== undefined &&
      input.expirationDate !== null && { expirationDate: Math.round(input.expirationDate.getTime() / 1000) }),
    ...(input.resourceIdentifier !== undefined &&
      input.resourceIdentifier !== null && {
        resourceIdentifier: serializeAws_restJson1ResourceIdentifier(input.resourceIdentifier, context),
      }),
    ...(input.suppressIndefinitely !== undefined &&
      input.suppressIndefinitely !== null && { suppressIndefinitely: input.suppressIndefinitely }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateAuthorizerCommand = async (
  input: UpdateAuthorizerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
  if (input.authorizerName !== undefined) {
    const labelValue: string = input.authorizerName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: authorizerName.");
    }
    resolvedPath = resolvedPath.replace("{authorizerName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: authorizerName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.authorizerFunctionArn !== undefined &&
      input.authorizerFunctionArn !== null && { authorizerFunctionArn: input.authorizerFunctionArn }),
    ...(input.status !== undefined && input.status !== null && { status: input.status }),
    ...(input.tokenKeyName !== undefined && input.tokenKeyName !== null && { tokenKeyName: input.tokenKeyName }),
    ...(input.tokenSigningPublicKeys !== undefined &&
      input.tokenSigningPublicKeys !== null && {
        tokenSigningPublicKeys: serializeAws_restJson1PublicKeyMap(input.tokenSigningPublicKeys, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateBillingGroupCommand = async (
  input: UpdateBillingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
  if (input.billingGroupName !== undefined) {
    const labelValue: string = input.billingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: billingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{billingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: billingGroupName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.billingGroupProperties !== undefined &&
      input.billingGroupProperties !== null && {
        billingGroupProperties: serializeAws_restJson1BillingGroupProperties(input.billingGroupProperties, context),
      }),
    ...(input.expectedVersion !== undefined &&
      input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateCACertificateCommand = async (
  input: UpdateCACertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: certificateId.");
    }
    resolvedPath = resolvedPath.replace("{certificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  const query: any = {
    ...(input.newStatus !== undefined && { newStatus: input.newStatus }),
    ...(input.newAutoRegistrationStatus !== undefined && {
      newAutoRegistrationStatus: input.newAutoRegistrationStatus,
    }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.registrationConfig !== undefined &&
      input.registrationConfig !== null && {
        registrationConfig: serializeAws_restJson1RegistrationConfig(input.registrationConfig, context),
      }),
    ...(input.removeAutoRegistration !== undefined &&
      input.removeAutoRegistration !== null && { removeAutoRegistration: input.removeAutoRegistration }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1UpdateCertificateCommand = async (
  input: UpdateCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {};
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates/{certificateId}";
  if (input.certificateId !== undefined) {
    const labelValue: string = input.certificateId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: certificateId.");
    }
    resolvedPath = resolvedPath.replace("{certificateId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: certificateId.");
  }
  const query: any = {
    ...(input.newStatus !== undefined && { newStatus: input.newStatus }),
  };
  let body: any;
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1UpdateCustomMetricCommand = async (
  input: UpdateCustomMetricCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
  if (input.metricName !== undefined) {
    const labelValue: string = input.metricName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: metricName.");
    }
    resolvedPath = resolvedPath.replace("{metricName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: metricName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.displayName !== undefined && input.displayName !== null && { displayName: input.displayName }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateDimensionCommand = async (
  input: UpdateDimensionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
  if (input.name !== undefined) {
    const labelValue: string = input.name;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: name.");
    }
    resolvedPath = resolvedPath.replace("{name}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: name.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.stringValues !== undefined &&
      input.stringValues !== null && {
        stringValues: serializeAws_restJson1DimensionStringValues(input.stringValues, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateDomainConfigurationCommand = async (
  input: UpdateDomainConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/domainConfigurations/{domainConfigurationName}";
  if (input.domainConfigurationName !== undefined) {
    const labelValue: string = input.domainConfigurationName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: domainConfigurationName.");
    }
    resolvedPath = resolvedPath.replace("{domainConfigurationName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: domainConfigurationName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.authorizerConfig !== undefined &&
      input.authorizerConfig !== null && {
        authorizerConfig: serializeAws_restJson1AuthorizerConfig(input.authorizerConfig, context),
      }),
    ...(input.domainConfigurationStatus !== undefined &&
      input.domainConfigurationStatus !== null && { domainConfigurationStatus: input.domainConfigurationStatus }),
    ...(input.removeAuthorizerConfig !== undefined &&
      input.removeAuthorizerConfig !== null && { removeAuthorizerConfig: input.removeAuthorizerConfig }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateDynamicThingGroupCommand = async (
  input: UpdateDynamicThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dynamic-thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{thingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.expectedVersion !== undefined &&
      input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
    ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
    ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
    ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
    ...(input.thingGroupProperties !== undefined &&
      input.thingGroupProperties !== null && {
        thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateEventConfigurationsCommand = async (
  input: UpdateEventConfigurationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/event-configurations";
  let body: any;
  body = JSON.stringify({
    ...(input.eventConfigurations !== undefined &&
      input.eventConfigurations !== null && {
        eventConfigurations: serializeAws_restJson1EventConfigurations(input.eventConfigurations, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateFleetMetricCommand = async (
  input: UpdateFleetMetricCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
  if (input.metricName !== undefined) {
    const labelValue: string = input.metricName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: metricName.");
    }
    resolvedPath = resolvedPath.replace("{metricName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: metricName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.aggregationField !== undefined &&
      input.aggregationField !== null && { aggregationField: input.aggregationField }),
    ...(input.aggregationType !== undefined &&
      input.aggregationType !== null && {
        aggregationType: serializeAws_restJson1AggregationType(input.aggregationType, context),
      }),
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.expectedVersion !== undefined &&
      input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
    ...(input.indexName !== undefined && input.indexName !== null && { indexName: input.indexName }),
    ...(input.period !== undefined && input.period !== null && { period: input.period }),
    ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
    ...(input.queryVersion !== undefined && input.queryVersion !== null && { queryVersion: input.queryVersion }),
    ...(input.unit !== undefined && input.unit !== null && { unit: input.unit }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateIndexingConfigurationCommand = async (
  input: UpdateIndexingConfigurationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indexing/config";
  let body: any;
  body = JSON.stringify({
    ...(input.thingGroupIndexingConfiguration !== undefined &&
      input.thingGroupIndexingConfiguration !== null && {
        thingGroupIndexingConfiguration: serializeAws_restJson1ThingGroupIndexingConfiguration(
          input.thingGroupIndexingConfiguration,
          context
        ),
      }),
    ...(input.thingIndexingConfiguration !== undefined &&
      input.thingIndexingConfiguration !== null && {
        thingIndexingConfiguration: serializeAws_restJson1ThingIndexingConfiguration(
          input.thingIndexingConfiguration,
          context
        ),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateJobCommand = async (
  input: UpdateJobCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
  if (input.jobId !== undefined) {
    const labelValue: string = input.jobId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: jobId.");
    }
    resolvedPath = resolvedPath.replace("{jobId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: jobId.");
  }
  const query: any = {
    ...(input.namespaceId !== undefined && { namespaceId: input.namespaceId }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.abortConfig !== undefined &&
      input.abortConfig !== null && { abortConfig: serializeAws_restJson1AbortConfig(input.abortConfig, context) }),
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.jobExecutionsRolloutConfig !== undefined &&
      input.jobExecutionsRolloutConfig !== null && {
        jobExecutionsRolloutConfig: serializeAws_restJson1JobExecutionsRolloutConfig(
          input.jobExecutionsRolloutConfig,
          context
        ),
      }),
    ...(input.presignedUrlConfig !== undefined &&
      input.presignedUrlConfig !== null && {
        presignedUrlConfig: serializeAws_restJson1PresignedUrlConfig(input.presignedUrlConfig, context),
      }),
    ...(input.timeoutConfig !== undefined &&
      input.timeoutConfig !== null && {
        timeoutConfig: serializeAws_restJson1TimeoutConfig(input.timeoutConfig, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1UpdateMitigationActionCommand = async (
  input: UpdateMitigationActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
  if (input.actionName !== undefined) {
    const labelValue: string = input.actionName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: actionName.");
    }
    resolvedPath = resolvedPath.replace("{actionName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: actionName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.actionParams !== undefined &&
      input.actionParams !== null && {
        actionParams: serializeAws_restJson1MitigationActionParams(input.actionParams, context),
      }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateProvisioningTemplateCommand = async (
  input: UpdateProvisioningTemplateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates/{templateName}";
  if (input.templateName !== undefined) {
    const labelValue: string = input.templateName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: templateName.");
    }
    resolvedPath = resolvedPath.replace("{templateName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: templateName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.defaultVersionId !== undefined &&
      input.defaultVersionId !== null && { defaultVersionId: input.defaultVersionId }),
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.enabled !== undefined && input.enabled !== null && { enabled: input.enabled }),
    ...(input.preProvisioningHook !== undefined &&
      input.preProvisioningHook !== null && {
        preProvisioningHook: serializeAws_restJson1ProvisioningHook(input.preProvisioningHook, context),
      }),
    ...(input.provisioningRoleArn !== undefined &&
      input.provisioningRoleArn !== null && { provisioningRoleArn: input.provisioningRoleArn }),
    ...(input.removePreProvisioningHook !== undefined &&
      input.removePreProvisioningHook !== null && { removePreProvisioningHook: input.removePreProvisioningHook }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateRoleAliasCommand = async (
  input: UpdateRoleAliasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
  if (input.roleAlias !== undefined) {
    const labelValue: string = input.roleAlias;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: roleAlias.");
    }
    resolvedPath = resolvedPath.replace("{roleAlias}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: roleAlias.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.credentialDurationSeconds !== undefined &&
      input.credentialDurationSeconds !== null && { credentialDurationSeconds: input.credentialDurationSeconds }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateScheduledAuditCommand = async (
  input: UpdateScheduledAuditCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
    "/audit/scheduledaudits/{scheduledAuditName}";
  if (input.scheduledAuditName !== undefined) {
    const labelValue: string = input.scheduledAuditName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: scheduledAuditName.");
    }
    resolvedPath = resolvedPath.replace("{scheduledAuditName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: scheduledAuditName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.dayOfMonth !== undefined && input.dayOfMonth !== null && { dayOfMonth: input.dayOfMonth }),
    ...(input.dayOfWeek !== undefined && input.dayOfWeek !== null && { dayOfWeek: input.dayOfWeek }),
    ...(input.frequency !== undefined && input.frequency !== null && { frequency: input.frequency }),
    ...(input.targetCheckNames !== undefined &&
      input.targetCheckNames !== null && {
        targetCheckNames: serializeAws_restJson1TargetAuditCheckNames(input.targetCheckNames, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateSecurityProfileCommand = async (
  input: UpdateSecurityProfileCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
  if (input.securityProfileName !== undefined) {
    const labelValue: string = input.securityProfileName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: securityProfileName.");
    }
    resolvedPath = resolvedPath.replace("{securityProfileName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: securityProfileName.");
  }
  const query: any = {
    ...(input.expectedVersion !== undefined && { expectedVersion: input.expectedVersion.toString() }),
  };
  let body: any;
  body = JSON.stringify({
    ...(input.additionalMetricsToRetain !== undefined &&
      input.additionalMetricsToRetain !== null && {
        additionalMetricsToRetain: serializeAws_restJson1AdditionalMetricsToRetainList(
          input.additionalMetricsToRetain,
          context
        ),
      }),
    ...(input.additionalMetricsToRetainV2 !== undefined &&
      input.additionalMetricsToRetainV2 !== null && {
        additionalMetricsToRetainV2: serializeAws_restJson1AdditionalMetricsToRetainV2List(
          input.additionalMetricsToRetainV2,
          context
        ),
      }),
    ...(input.alertTargets !== undefined &&
      input.alertTargets !== null && { alertTargets: serializeAws_restJson1AlertTargets(input.alertTargets, context) }),
    ...(input.behaviors !== undefined &&
      input.behaviors !== null && { behaviors: serializeAws_restJson1Behaviors(input.behaviors, context) }),
    ...(input.deleteAdditionalMetricsToRetain !== undefined &&
      input.deleteAdditionalMetricsToRetain !== null && {
        deleteAdditionalMetricsToRetain: input.deleteAdditionalMetricsToRetain,
      }),
    ...(input.deleteAlertTargets !== undefined &&
      input.deleteAlertTargets !== null && { deleteAlertTargets: input.deleteAlertTargets }),
    ...(input.deleteBehaviors !== undefined &&
      input.deleteBehaviors !== null && { deleteBehaviors: input.deleteBehaviors }),
    ...(input.securityProfileDescription !== undefined &&
      input.securityProfileDescription !== null && { securityProfileDescription: input.securityProfileDescription }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    query,
    body,
  });
};

export const serializeAws_restJson1UpdateStreamCommand = async (
  input: UpdateStreamCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
  if (input.streamId !== undefined) {
    const labelValue: string = input.streamId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: streamId.");
    }
    resolvedPath = resolvedPath.replace("{streamId}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: streamId.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.files !== undefined &&
      input.files !== null && { files: serializeAws_restJson1StreamFiles(input.files, context) }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateThingCommand = async (
  input: UpdateThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
  if (input.thingName !== undefined) {
    const labelValue: string = input.thingName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingName.");
    }
    resolvedPath = resolvedPath.replace("{thingName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.attributePayload !== undefined &&
      input.attributePayload !== null && {
        attributePayload: serializeAws_restJson1AttributePayload(input.attributePayload, context),
      }),
    ...(input.expectedVersion !== undefined &&
      input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
    ...(input.removeThingType !== undefined &&
      input.removeThingType !== null && { removeThingType: input.removeThingType }),
    ...(input.thingTypeName !== undefined && input.thingTypeName !== null && { thingTypeName: input.thingTypeName }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateThingGroupCommand = async (
  input: UpdateThingGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
  if (input.thingGroupName !== undefined) {
    const labelValue: string = input.thingGroupName;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: thingGroupName.");
    }
    resolvedPath = resolvedPath.replace("{thingGroupName}", __extendedEncodeURIComponent(labelValue));
  } else {
    throw new Error("No value provided for input HTTP label: thingGroupName.");
  }
  let body: any;
  body = JSON.stringify({
    ...(input.expectedVersion !== undefined &&
      input.expectedVersion !== null && { expectedVersion: input.expectedVersion }),
    ...(input.thingGroupProperties !== undefined &&
      input.thingGroupProperties !== null && {
        thingGroupProperties: serializeAws_restJson1ThingGroupProperties(input.thingGroupProperties, context),
      }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateThingGroupsForThingCommand = async (
  input: UpdateThingGroupsForThingCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/updateThingGroupsForThing";
  let body: any;
  body = JSON.stringify({
    ...(input.overrideDynamicGroups !== undefined &&
      input.overrideDynamicGroups !== null && { overrideDynamicGroups: input.overrideDynamicGroups }),
    ...(input.thingGroupsToAdd !== undefined &&
      input.thingGroupsToAdd !== null && {
        thingGroupsToAdd: serializeAws_restJson1ThingGroupList(input.thingGroupsToAdd, context),
      }),
    ...(input.thingGroupsToRemove !== undefined &&
      input.thingGroupsToRemove !== null && {
        thingGroupsToRemove: serializeAws_restJson1ThingGroupList(input.thingGroupsToRemove, context),
      }),
    ...(input.thingName !== undefined && input.thingName !== null && { thingName: input.thingName }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PUT",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1UpdateTopicRuleDestinationCommand = async (
  input: UpdateTopicRuleDestinationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations";
  let body: any;
  body = JSON.stringify({
    ...(input.arn !== undefined && input.arn !== null && { arn: input.arn }),
    ...(input.status !== undefined && input.status !== null && { status: input.status }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "PATCH",
    headers,
    path: resolvedPath,
    body,
  });
};

export const serializeAws_restJson1ValidateSecurityProfileBehaviorsCommand = async (
  input: ValidateSecurityProfileBehaviorsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
  const headers: any = {
    "content-type": "application/json",
  };
  let resolvedPath =
    `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profile-behaviors/validate";
  let body: any;
  body = JSON.stringify({
    ...(input.behaviors !== undefined &&
      input.behaviors !== null && { behaviors: serializeAws_restJson1Behaviors(input.behaviors, context) }),
  });
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body,
  });
};

export const deserializeAws_restJson1AcceptCertificateTransferCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptCertificateTransferCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AcceptCertificateTransferCommandError(output, context);
  }
  const contents: AcceptCertificateTransferCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1AcceptCertificateTransferCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AcceptCertificateTransferCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TransferAlreadyCompletedException":
    case "com.amazonaws.iot#TransferAlreadyCompletedException":
      response = {
        ...(await deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1AddThingToBillingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddThingToBillingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AddThingToBillingGroupCommandError(output, context);
  }
  const contents: AddThingToBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1AddThingToBillingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddThingToBillingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1AddThingToThingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddThingToThingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AddThingToThingGroupCommandError(output, context);
  }
  const contents: AddThingToThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1AddThingToThingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddThingToThingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1AssociateTargetsWithJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateTargetsWithJobCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AssociateTargetsWithJobCommandError(output, context);
  }
  const contents: AssociateTargetsWithJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    description: undefined,
    jobArn: undefined,
    jobId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.description !== undefined && data.description !== null) {
    contents.description = __expectString(data.description);
  }
  if (data.jobArn !== undefined && data.jobArn !== null) {
    contents.jobArn = __expectString(data.jobArn);
  }
  if (data.jobId !== undefined && data.jobId !== null) {
    contents.jobId = __expectString(data.jobId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1AssociateTargetsWithJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateTargetsWithJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1AttachPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachPolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AttachPolicyCommandError(output, context);
  }
  const contents: AttachPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1AttachPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1AttachPrincipalPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachPrincipalPolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AttachPrincipalPolicyCommandError(output, context);
  }
  const contents: AttachPrincipalPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1AttachPrincipalPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachPrincipalPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1AttachSecurityProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachSecurityProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AttachSecurityProfileCommandError(output, context);
  }
  const contents: AttachSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1AttachSecurityProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachSecurityProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1AttachThingPrincipalCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachThingPrincipalCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1AttachThingPrincipalCommandError(output, context);
  }
  const contents: AttachThingPrincipalCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1AttachThingPrincipalCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AttachThingPrincipalCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CancelAuditMitigationActionsTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelAuditMitigationActionsTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CancelAuditMitigationActionsTaskCommandError(output, context);
  }
  const contents: CancelAuditMitigationActionsTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CancelAuditMitigationActionsTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelAuditMitigationActionsTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CancelAuditTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelAuditTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CancelAuditTaskCommandError(output, context);
  }
  const contents: CancelAuditTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CancelAuditTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelAuditTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CancelCertificateTransferCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelCertificateTransferCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CancelCertificateTransferCommandError(output, context);
  }
  const contents: CancelCertificateTransferCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CancelCertificateTransferCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelCertificateTransferCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TransferAlreadyCompletedException":
    case "com.amazonaws.iot#TransferAlreadyCompletedException":
      response = {
        ...(await deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CancelDetectMitigationActionsTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelDetectMitigationActionsTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CancelDetectMitigationActionsTaskCommandError(output, context);
  }
  const contents: CancelDetectMitigationActionsTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CancelDetectMitigationActionsTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelDetectMitigationActionsTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CancelJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelJobCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CancelJobCommandError(output, context);
  }
  const contents: CancelJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    description: undefined,
    jobArn: undefined,
    jobId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.description !== undefined && data.description !== null) {
    contents.description = __expectString(data.description);
  }
  if (data.jobArn !== undefined && data.jobArn !== null) {
    contents.jobArn = __expectString(data.jobArn);
  }
  if (data.jobId !== undefined && data.jobId !== null) {
    contents.jobId = __expectString(data.jobId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CancelJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CancelJobExecutionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelJobExecutionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CancelJobExecutionCommandError(output, context);
  }
  const contents: CancelJobExecutionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CancelJobExecutionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CancelJobExecutionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidStateTransitionException":
    case "com.amazonaws.iot#InvalidStateTransitionException":
      response = {
        ...(await deserializeAws_restJson1InvalidStateTransitionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ClearDefaultAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ClearDefaultAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ClearDefaultAuthorizerCommandError(output, context);
  }
  const contents: ClearDefaultAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ClearDefaultAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ClearDefaultAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ConfirmTopicRuleDestinationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmTopicRuleDestinationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ConfirmTopicRuleDestinationCommandError(output, context);
  }
  const contents: ConfirmTopicRuleDestinationCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ConfirmTopicRuleDestinationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ConfirmTopicRuleDestinationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateAuditSuppressionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAuditSuppressionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateAuditSuppressionCommandError(output, context);
  }
  const contents: CreateAuditSuppressionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateAuditSuppressionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAuditSuppressionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateAuthorizerCommandError(output, context);
  }
  const contents: CreateAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    authorizerArn: undefined,
    authorizerName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.authorizerArn !== undefined && data.authorizerArn !== null) {
    contents.authorizerArn = __expectString(data.authorizerArn);
  }
  if (data.authorizerName !== undefined && data.authorizerName !== null) {
    contents.authorizerName = __expectString(data.authorizerName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateBillingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBillingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateBillingGroupCommandError(output, context);
  }
  const contents: CreateBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    billingGroupArn: undefined,
    billingGroupId: undefined,
    billingGroupName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.billingGroupArn !== undefined && data.billingGroupArn !== null) {
    contents.billingGroupArn = __expectString(data.billingGroupArn);
  }
  if (data.billingGroupId !== undefined && data.billingGroupId !== null) {
    contents.billingGroupId = __expectString(data.billingGroupId);
  }
  if (data.billingGroupName !== undefined && data.billingGroupName !== null) {
    contents.billingGroupName = __expectString(data.billingGroupName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateBillingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateBillingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateCertificateFromCsrCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCertificateFromCsrCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateCertificateFromCsrCommandError(output, context);
  }
  const contents: CreateCertificateFromCsrCommandOutput = {
    $metadata: deserializeMetadata(output),
    certificateArn: undefined,
    certificateId: undefined,
    certificatePem: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = __expectString(data.certificateArn);
  }
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = __expectString(data.certificateId);
  }
  if (data.certificatePem !== undefined && data.certificatePem !== null) {
    contents.certificatePem = __expectString(data.certificatePem);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateCertificateFromCsrCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCertificateFromCsrCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateCustomMetricCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCustomMetricCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateCustomMetricCommandError(output, context);
  }
  const contents: CreateCustomMetricCommandOutput = {
    $metadata: deserializeMetadata(output),
    metricArn: undefined,
    metricName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.metricArn !== undefined && data.metricArn !== null) {
    contents.metricArn = __expectString(data.metricArn);
  }
  if (data.metricName !== undefined && data.metricName !== null) {
    contents.metricName = __expectString(data.metricName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateCustomMetricCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateCustomMetricCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateDimensionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDimensionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateDimensionCommandError(output, context);
  }
  const contents: CreateDimensionCommandOutput = {
    $metadata: deserializeMetadata(output),
    arn: undefined,
    name: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.arn !== undefined && data.arn !== null) {
    contents.arn = __expectString(data.arn);
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = __expectString(data.name);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateDimensionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDimensionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateDomainConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDomainConfigurationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateDomainConfigurationCommandError(output, context);
  }
  const contents: CreateDomainConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    domainConfigurationArn: undefined,
    domainConfigurationName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.domainConfigurationArn !== undefined && data.domainConfigurationArn !== null) {
    contents.domainConfigurationArn = __expectString(data.domainConfigurationArn);
  }
  if (data.domainConfigurationName !== undefined && data.domainConfigurationName !== null) {
    contents.domainConfigurationName = __expectString(data.domainConfigurationName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateDomainConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDomainConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateValidationException":
    case "com.amazonaws.iot#CertificateValidationException":
      response = {
        ...(await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateDynamicThingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDynamicThingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateDynamicThingGroupCommandError(output, context);
  }
  const contents: CreateDynamicThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    indexName: undefined,
    queryString: undefined,
    queryVersion: undefined,
    thingGroupArn: undefined,
    thingGroupId: undefined,
    thingGroupName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.indexName !== undefined && data.indexName !== null) {
    contents.indexName = __expectString(data.indexName);
  }
  if (data.queryString !== undefined && data.queryString !== null) {
    contents.queryString = __expectString(data.queryString);
  }
  if (data.queryVersion !== undefined && data.queryVersion !== null) {
    contents.queryVersion = __expectString(data.queryVersion);
  }
  if (data.thingGroupArn !== undefined && data.thingGroupArn !== null) {
    contents.thingGroupArn = __expectString(data.thingGroupArn);
  }
  if (data.thingGroupId !== undefined && data.thingGroupId !== null) {
    contents.thingGroupId = __expectString(data.thingGroupId);
  }
  if (data.thingGroupName !== undefined && data.thingGroupName !== null) {
    contents.thingGroupName = __expectString(data.thingGroupName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateDynamicThingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateDynamicThingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateFleetMetricCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFleetMetricCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateFleetMetricCommandError(output, context);
  }
  const contents: CreateFleetMetricCommandOutput = {
    $metadata: deserializeMetadata(output),
    metricArn: undefined,
    metricName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.metricArn !== undefined && data.metricArn !== null) {
    contents.metricArn = __expectString(data.metricArn);
  }
  if (data.metricName !== undefined && data.metricName !== null) {
    contents.metricName = __expectString(data.metricName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateFleetMetricCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateFleetMetricCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IndexNotReadyException":
    case "com.amazonaws.iot#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidAggregationException":
    case "com.amazonaws.iot#InvalidAggregationException":
      response = {
        ...(await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateJobCommandError(output, context);
  }
  const contents: CreateJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    description: undefined,
    jobArn: undefined,
    jobId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.description !== undefined && data.description !== null) {
    contents.description = __expectString(data.description);
  }
  if (data.jobArn !== undefined && data.jobArn !== null) {
    contents.jobArn = __expectString(data.jobArn);
  }
  if (data.jobId !== undefined && data.jobId !== null) {
    contents.jobId = __expectString(data.jobId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateJobTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateJobTemplateCommandError(output, context);
  }
  const contents: CreateJobTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    jobTemplateArn: undefined,
    jobTemplateId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.jobTemplateArn !== undefined && data.jobTemplateArn !== null) {
    contents.jobTemplateArn = __expectString(data.jobTemplateArn);
  }
  if (data.jobTemplateId !== undefined && data.jobTemplateId !== null) {
    contents.jobTemplateId = __expectString(data.jobTemplateId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateJobTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateJobTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictException":
    case "com.amazonaws.iot#ConflictException":
      response = {
        ...(await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateKeysAndCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateKeysAndCertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateKeysAndCertificateCommandError(output, context);
  }
  const contents: CreateKeysAndCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    certificateArn: undefined,
    certificateId: undefined,
    certificatePem: undefined,
    keyPair: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = __expectString(data.certificateArn);
  }
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = __expectString(data.certificateId);
  }
  if (data.certificatePem !== undefined && data.certificatePem !== null) {
    contents.certificatePem = __expectString(data.certificatePem);
  }
  if (data.keyPair !== undefined && data.keyPair !== null) {
    contents.keyPair = deserializeAws_restJson1KeyPair(data.keyPair, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateKeysAndCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateKeysAndCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateMitigationActionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMitigationActionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateMitigationActionCommandError(output, context);
  }
  const contents: CreateMitigationActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    actionArn: undefined,
    actionId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.actionArn !== undefined && data.actionArn !== null) {
    contents.actionArn = __expectString(data.actionArn);
  }
  if (data.actionId !== undefined && data.actionId !== null) {
    contents.actionId = __expectString(data.actionId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateMitigationActionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateMitigationActionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateOTAUpdateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateOTAUpdateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateOTAUpdateCommandError(output, context);
  }
  const contents: CreateOTAUpdateCommandOutput = {
    $metadata: deserializeMetadata(output),
    awsIotJobArn: undefined,
    awsIotJobId: undefined,
    otaUpdateArn: undefined,
    otaUpdateId: undefined,
    otaUpdateStatus: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.awsIotJobArn !== undefined && data.awsIotJobArn !== null) {
    contents.awsIotJobArn = __expectString(data.awsIotJobArn);
  }
  if (data.awsIotJobId !== undefined && data.awsIotJobId !== null) {
    contents.awsIotJobId = __expectString(data.awsIotJobId);
  }
  if (data.otaUpdateArn !== undefined && data.otaUpdateArn !== null) {
    contents.otaUpdateArn = __expectString(data.otaUpdateArn);
  }
  if (data.otaUpdateId !== undefined && data.otaUpdateId !== null) {
    contents.otaUpdateId = __expectString(data.otaUpdateId);
  }
  if (data.otaUpdateStatus !== undefined && data.otaUpdateStatus !== null) {
    contents.otaUpdateStatus = __expectString(data.otaUpdateStatus);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateOTAUpdateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateOTAUpdateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreatePolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreatePolicyCommandError(output, context);
  }
  const contents: CreatePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    policyArn: undefined,
    policyDocument: undefined,
    policyName: undefined,
    policyVersionId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.policyArn !== undefined && data.policyArn !== null) {
    contents.policyArn = __expectString(data.policyArn);
  }
  if (data.policyDocument !== undefined && data.policyDocument !== null) {
    contents.policyDocument = __expectString(data.policyDocument);
  }
  if (data.policyName !== undefined && data.policyName !== null) {
    contents.policyName = __expectString(data.policyName);
  }
  if (data.policyVersionId !== undefined && data.policyVersionId !== null) {
    contents.policyVersionId = __expectString(data.policyVersionId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreatePolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MalformedPolicyException":
    case "com.amazonaws.iot#MalformedPolicyException":
      response = {
        ...(await deserializeAws_restJson1MalformedPolicyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreatePolicyVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePolicyVersionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreatePolicyVersionCommandError(output, context);
  }
  const contents: CreatePolicyVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    isDefaultVersion: undefined,
    policyArn: undefined,
    policyDocument: undefined,
    policyVersionId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
    contents.isDefaultVersion = __expectBoolean(data.isDefaultVersion);
  }
  if (data.policyArn !== undefined && data.policyArn !== null) {
    contents.policyArn = __expectString(data.policyArn);
  }
  if (data.policyDocument !== undefined && data.policyDocument !== null) {
    contents.policyDocument = __expectString(data.policyDocument);
  }
  if (data.policyVersionId !== undefined && data.policyVersionId !== null) {
    contents.policyVersionId = __expectString(data.policyVersionId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreatePolicyVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreatePolicyVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "MalformedPolicyException":
    case "com.amazonaws.iot#MalformedPolicyException":
      response = {
        ...(await deserializeAws_restJson1MalformedPolicyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionsLimitExceededException":
    case "com.amazonaws.iot#VersionsLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1VersionsLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateProvisioningClaimCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningClaimCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateProvisioningClaimCommandError(output, context);
  }
  const contents: CreateProvisioningClaimCommandOutput = {
    $metadata: deserializeMetadata(output),
    certificateId: undefined,
    certificatePem: undefined,
    expiration: undefined,
    keyPair: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = __expectString(data.certificateId);
  }
  if (data.certificatePem !== undefined && data.certificatePem !== null) {
    contents.certificatePem = __expectString(data.certificatePem);
  }
  if (data.expiration !== undefined && data.expiration !== null) {
    contents.expiration = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.expiration)));
  }
  if (data.keyPair !== undefined && data.keyPair !== null) {
    contents.keyPair = deserializeAws_restJson1KeyPair(data.keyPair, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateProvisioningClaimCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningClaimCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateProvisioningTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateProvisioningTemplateCommandError(output, context);
  }
  const contents: CreateProvisioningTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    defaultVersionId: undefined,
    templateArn: undefined,
    templateName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.defaultVersionId !== undefined && data.defaultVersionId !== null) {
    contents.defaultVersionId = __expectInt32(data.defaultVersionId);
  }
  if (data.templateArn !== undefined && data.templateArn !== null) {
    contents.templateArn = __expectString(data.templateArn);
  }
  if (data.templateName !== undefined && data.templateName !== null) {
    contents.templateName = __expectString(data.templateName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateProvisioningTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateProvisioningTemplateVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningTemplateVersionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateProvisioningTemplateVersionCommandError(output, context);
  }
  const contents: CreateProvisioningTemplateVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    isDefaultVersion: undefined,
    templateArn: undefined,
    templateName: undefined,
    versionId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
    contents.isDefaultVersion = __expectBoolean(data.isDefaultVersion);
  }
  if (data.templateArn !== undefined && data.templateArn !== null) {
    contents.templateArn = __expectString(data.templateArn);
  }
  if (data.templateName !== undefined && data.templateName !== null) {
    contents.templateName = __expectString(data.templateName);
  }
  if (data.versionId !== undefined && data.versionId !== null) {
    contents.versionId = __expectInt32(data.versionId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateProvisioningTemplateVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateProvisioningTemplateVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionsLimitExceededException":
    case "com.amazonaws.iot#VersionsLimitExceededException":
      response = {
        ...(await deserializeAws_restJson1VersionsLimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateRoleAliasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRoleAliasCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateRoleAliasCommandError(output, context);
  }
  const contents: CreateRoleAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    roleAlias: undefined,
    roleAliasArn: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.roleAlias !== undefined && data.roleAlias !== null) {
    contents.roleAlias = __expectString(data.roleAlias);
  }
  if (data.roleAliasArn !== undefined && data.roleAliasArn !== null) {
    contents.roleAliasArn = __expectString(data.roleAliasArn);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateRoleAliasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateRoleAliasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateScheduledAuditCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScheduledAuditCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateScheduledAuditCommandError(output, context);
  }
  const contents: CreateScheduledAuditCommandOutput = {
    $metadata: deserializeMetadata(output),
    scheduledAuditArn: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.scheduledAuditArn !== undefined && data.scheduledAuditArn !== null) {
    contents.scheduledAuditArn = __expectString(data.scheduledAuditArn);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateScheduledAuditCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateScheduledAuditCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateSecurityProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateSecurityProfileCommandError(output, context);
  }
  const contents: CreateSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    securityProfileArn: undefined,
    securityProfileName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.securityProfileArn !== undefined && data.securityProfileArn !== null) {
    contents.securityProfileArn = __expectString(data.securityProfileArn);
  }
  if (data.securityProfileName !== undefined && data.securityProfileName !== null) {
    contents.securityProfileName = __expectString(data.securityProfileName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateSecurityProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateSecurityProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateStreamCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateStreamCommandError(output, context);
  }
  const contents: CreateStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    description: undefined,
    streamArn: undefined,
    streamId: undefined,
    streamVersion: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.description !== undefined && data.description !== null) {
    contents.description = __expectString(data.description);
  }
  if (data.streamArn !== undefined && data.streamArn !== null) {
    contents.streamArn = __expectString(data.streamArn);
  }
  if (data.streamId !== undefined && data.streamId !== null) {
    contents.streamId = __expectString(data.streamId);
  }
  if (data.streamVersion !== undefined && data.streamVersion !== null) {
    contents.streamVersion = __expectInt32(data.streamVersion);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateStreamCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateStreamCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateThingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateThingCommandError(output, context);
  }
  const contents: CreateThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    thingArn: undefined,
    thingId: undefined,
    thingName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.thingArn !== undefined && data.thingArn !== null) {
    contents.thingArn = __expectString(data.thingArn);
  }
  if (data.thingId !== undefined && data.thingId !== null) {
    contents.thingId = __expectString(data.thingId);
  }
  if (data.thingName !== undefined && data.thingName !== null) {
    contents.thingName = __expectString(data.thingName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateThingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateThingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateThingGroupCommandError(output, context);
  }
  const contents: CreateThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    thingGroupArn: undefined,
    thingGroupId: undefined,
    thingGroupName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.thingGroupArn !== undefined && data.thingGroupArn !== null) {
    contents.thingGroupArn = __expectString(data.thingGroupArn);
  }
  if (data.thingGroupId !== undefined && data.thingGroupId !== null) {
    contents.thingGroupId = __expectString(data.thingGroupId);
  }
  if (data.thingGroupName !== undefined && data.thingGroupName !== null) {
    contents.thingGroupName = __expectString(data.thingGroupName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateThingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateThingTypeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingTypeCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateThingTypeCommandError(output, context);
  }
  const contents: CreateThingTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    thingTypeArn: undefined,
    thingTypeId: undefined,
    thingTypeName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.thingTypeArn !== undefined && data.thingTypeArn !== null) {
    contents.thingTypeArn = __expectString(data.thingTypeArn);
  }
  if (data.thingTypeId !== undefined && data.thingTypeId !== null) {
    contents.thingTypeId = __expectString(data.thingTypeId);
  }
  if (data.thingTypeName !== undefined && data.thingTypeName !== null) {
    contents.thingTypeName = __expectString(data.thingTypeName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateThingTypeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateThingTypeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateTopicRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTopicRuleCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateTopicRuleCommandError(output, context);
  }
  const contents: CreateTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateTopicRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTopicRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "SqlParseException":
    case "com.amazonaws.iot#SqlParseException":
      response = {
        ...(await deserializeAws_restJson1SqlParseExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1CreateTopicRuleDestinationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTopicRuleDestinationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1CreateTopicRuleDestinationCommandError(output, context);
  }
  const contents: CreateTopicRuleDestinationCommandOutput = {
    $metadata: deserializeMetadata(output),
    topicRuleDestination: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.topicRuleDestination !== undefined && data.topicRuleDestination !== null) {
    contents.topicRuleDestination = deserializeAws_restJson1TopicRuleDestination(data.topicRuleDestination, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1CreateTopicRuleDestinationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTopicRuleDestinationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteAccountAuditConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAccountAuditConfigurationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteAccountAuditConfigurationCommandError(output, context);
  }
  const contents: DeleteAccountAuditConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteAccountAuditConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAccountAuditConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteAuditSuppressionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAuditSuppressionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteAuditSuppressionCommandError(output, context);
  }
  const contents: DeleteAuditSuppressionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteAuditSuppressionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAuditSuppressionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteAuthorizerCommandError(output, context);
  }
  const contents: DeleteAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteBillingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBillingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteBillingGroupCommandError(output, context);
  }
  const contents: DeleteBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteBillingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteBillingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteCACertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCACertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteCACertificateCommandError(output, context);
  }
  const contents: DeleteCACertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteCACertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCACertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateStateException":
    case "com.amazonaws.iot#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteCertificateCommandError(output, context);
  }
  const contents: DeleteCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateStateException":
    case "com.amazonaws.iot#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DeleteConflictException":
    case "com.amazonaws.iot#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteCustomMetricCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCustomMetricCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteCustomMetricCommandError(output, context);
  }
  const contents: DeleteCustomMetricCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteCustomMetricCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCustomMetricCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteDimensionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDimensionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteDimensionCommandError(output, context);
  }
  const contents: DeleteDimensionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteDimensionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDimensionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteDomainConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDomainConfigurationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteDomainConfigurationCommandError(output, context);
  }
  const contents: DeleteDomainConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteDomainConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDomainConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteDynamicThingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDynamicThingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteDynamicThingGroupCommandError(output, context);
  }
  const contents: DeleteDynamicThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteDynamicThingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteDynamicThingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteFleetMetricCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFleetMetricCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteFleetMetricCommandError(output, context);
  }
  const contents: DeleteFleetMetricCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteFleetMetricCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteFleetMetricCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteJobCommandError(output, context);
  }
  const contents: DeleteJobCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidStateTransitionException":
    case "com.amazonaws.iot#InvalidStateTransitionException":
      response = {
        ...(await deserializeAws_restJson1InvalidStateTransitionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteJobExecutionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobExecutionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteJobExecutionCommandError(output, context);
  }
  const contents: DeleteJobExecutionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteJobExecutionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobExecutionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidStateTransitionException":
    case "com.amazonaws.iot#InvalidStateTransitionException":
      response = {
        ...(await deserializeAws_restJson1InvalidStateTransitionExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteJobTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteJobTemplateCommandError(output, context);
  }
  const contents: DeleteJobTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteJobTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteJobTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteMitigationActionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMitigationActionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteMitigationActionCommandError(output, context);
  }
  const contents: DeleteMitigationActionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteMitigationActionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteMitigationActionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteOTAUpdateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteOTAUpdateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteOTAUpdateCommandError(output, context);
  }
  const contents: DeleteOTAUpdateCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteOTAUpdateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteOTAUpdateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeletePolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeletePolicyCommandError(output, context);
  }
  const contents: DeletePolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeletePolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeletePolicyVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePolicyVersionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeletePolicyVersionCommandError(output, context);
  }
  const contents: DeletePolicyVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeletePolicyVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeletePolicyVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteProvisioningTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteProvisioningTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteProvisioningTemplateCommandError(output, context);
  }
  const contents: DeleteProvisioningTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteProvisioningTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteProvisioningTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DeleteConflictException":
    case "com.amazonaws.iot#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteProvisioningTemplateVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteProvisioningTemplateVersionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteProvisioningTemplateVersionCommandError(output, context);
  }
  const contents: DeleteProvisioningTemplateVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteProvisioningTemplateVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteProvisioningTemplateVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "DeleteConflictException":
    case "com.amazonaws.iot#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteRegistrationCodeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegistrationCodeCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteRegistrationCodeCommandError(output, context);
  }
  const contents: DeleteRegistrationCodeCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteRegistrationCodeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRegistrationCodeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteRoleAliasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoleAliasCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteRoleAliasCommandError(output, context);
  }
  const contents: DeleteRoleAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteRoleAliasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteRoleAliasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteScheduledAuditCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteScheduledAuditCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteScheduledAuditCommandError(output, context);
  }
  const contents: DeleteScheduledAuditCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteScheduledAuditCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteScheduledAuditCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteSecurityProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteSecurityProfileCommandError(output, context);
  }
  const contents: DeleteSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteSecurityProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteSecurityProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteStreamCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStreamCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteStreamCommandError(output, context);
  }
  const contents: DeleteStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteStreamCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteStreamCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DeleteConflictException":
    case "com.amazonaws.iot#DeleteConflictException":
      response = {
        ...(await deserializeAws_restJson1DeleteConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteThingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteThingCommandError(output, context);
  }
  const contents: DeleteThingCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteThingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteThingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteThingGroupCommandError(output, context);
  }
  const contents: DeleteThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteThingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteThingTypeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingTypeCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteThingTypeCommandError(output, context);
  }
  const contents: DeleteThingTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteThingTypeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteThingTypeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteTopicRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTopicRuleCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteTopicRuleCommandError(output, context);
  }
  const contents: DeleteTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteTopicRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTopicRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteTopicRuleDestinationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTopicRuleDestinationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteTopicRuleDestinationCommandError(output, context);
  }
  const contents: DeleteTopicRuleDestinationCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteTopicRuleDestinationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTopicRuleDestinationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeleteV2LoggingLevelCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteV2LoggingLevelCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeleteV2LoggingLevelCommandError(output, context);
  }
  const contents: DeleteV2LoggingLevelCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeleteV2LoggingLevelCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteV2LoggingLevelCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DeprecateThingTypeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeprecateThingTypeCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DeprecateThingTypeCommandError(output, context);
  }
  const contents: DeprecateThingTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DeprecateThingTypeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeprecateThingTypeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeAccountAuditConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAuditConfigurationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeAccountAuditConfigurationCommandError(output, context);
  }
  const contents: DescribeAccountAuditConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    auditCheckConfigurations: undefined,
    auditNotificationTargetConfigurations: undefined,
    roleArn: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.auditCheckConfigurations !== undefined && data.auditCheckConfigurations !== null) {
    contents.auditCheckConfigurations = deserializeAws_restJson1AuditCheckConfigurations(
      data.auditCheckConfigurations,
      context
    );
  }
  if (data.auditNotificationTargetConfigurations !== undefined && data.auditNotificationTargetConfigurations !== null) {
    contents.auditNotificationTargetConfigurations = deserializeAws_restJson1AuditNotificationTargetConfigurations(
      data.auditNotificationTargetConfigurations,
      context
    );
  }
  if (data.roleArn !== undefined && data.roleArn !== null) {
    contents.roleArn = __expectString(data.roleArn);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeAccountAuditConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAuditConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeAuditFindingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditFindingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeAuditFindingCommandError(output, context);
  }
  const contents: DescribeAuditFindingCommandOutput = {
    $metadata: deserializeMetadata(output),
    finding: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.finding !== undefined && data.finding !== null) {
    contents.finding = deserializeAws_restJson1AuditFinding(data.finding, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeAuditFindingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditFindingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditMitigationActionsTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommandError(output, context);
  }
  const contents: DescribeAuditMitigationActionsTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    actionsDefinition: undefined,
    auditCheckToActionsMapping: undefined,
    endTime: undefined,
    startTime: undefined,
    target: undefined,
    taskStatistics: undefined,
    taskStatus: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.actionsDefinition !== undefined && data.actionsDefinition !== null) {
    contents.actionsDefinition = deserializeAws_restJson1MitigationActionList(data.actionsDefinition, context);
  }
  if (data.auditCheckToActionsMapping !== undefined && data.auditCheckToActionsMapping !== null) {
    contents.auditCheckToActionsMapping = deserializeAws_restJson1AuditCheckToActionsMapping(
      data.auditCheckToActionsMapping,
      context
    );
  }
  if (data.endTime !== undefined && data.endTime !== null) {
    contents.endTime = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.endTime)));
  }
  if (data.startTime !== undefined && data.startTime !== null) {
    contents.startTime = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.startTime)));
  }
  if (data.target !== undefined && data.target !== null) {
    contents.target = deserializeAws_restJson1AuditMitigationActionsTaskTarget(data.target, context);
  }
  if (data.taskStatistics !== undefined && data.taskStatistics !== null) {
    contents.taskStatistics = deserializeAws_restJson1AuditMitigationActionsTaskStatistics(
      data.taskStatistics,
      context
    );
  }
  if (data.taskStatus !== undefined && data.taskStatus !== null) {
    contents.taskStatus = __expectString(data.taskStatus);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeAuditMitigationActionsTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditMitigationActionsTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeAuditSuppressionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditSuppressionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeAuditSuppressionCommandError(output, context);
  }
  const contents: DescribeAuditSuppressionCommandOutput = {
    $metadata: deserializeMetadata(output),
    checkName: undefined,
    description: undefined,
    expirationDate: undefined,
    resourceIdentifier: undefined,
    suppressIndefinitely: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.checkName !== undefined && data.checkName !== null) {
    contents.checkName = __expectString(data.checkName);
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = __expectString(data.description);
  }
  if (data.expirationDate !== undefined && data.expirationDate !== null) {
    contents.expirationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.expirationDate)));
  }
  if (data.resourceIdentifier !== undefined && data.resourceIdentifier !== null) {
    contents.resourceIdentifier = deserializeAws_restJson1ResourceIdentifier(data.resourceIdentifier, context);
  }
  if (data.suppressIndefinitely !== undefined && data.suppressIndefinitely !== null) {
    contents.suppressIndefinitely = __expectBoolean(data.suppressIndefinitely);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeAuditSuppressionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditSuppressionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeAuditTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeAuditTaskCommandError(output, context);
  }
  const contents: DescribeAuditTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    auditDetails: undefined,
    scheduledAuditName: undefined,
    taskStartTime: undefined,
    taskStatistics: undefined,
    taskStatus: undefined,
    taskType: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.auditDetails !== undefined && data.auditDetails !== null) {
    contents.auditDetails = deserializeAws_restJson1AuditDetails(data.auditDetails, context);
  }
  if (data.scheduledAuditName !== undefined && data.scheduledAuditName !== null) {
    contents.scheduledAuditName = __expectString(data.scheduledAuditName);
  }
  if (data.taskStartTime !== undefined && data.taskStartTime !== null) {
    contents.taskStartTime = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.taskStartTime)));
  }
  if (data.taskStatistics !== undefined && data.taskStatistics !== null) {
    contents.taskStatistics = deserializeAws_restJson1TaskStatistics(data.taskStatistics, context);
  }
  if (data.taskStatus !== undefined && data.taskStatus !== null) {
    contents.taskStatus = __expectString(data.taskStatus);
  }
  if (data.taskType !== undefined && data.taskType !== null) {
    contents.taskType = __expectString(data.taskType);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeAuditTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuditTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeAuthorizerCommandError(output, context);
  }
  const contents: DescribeAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    authorizerDescription: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.authorizerDescription !== undefined && data.authorizerDescription !== null) {
    contents.authorizerDescription = deserializeAws_restJson1AuthorizerDescription(data.authorizerDescription, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeBillingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeBillingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeBillingGroupCommandError(output, context);
  }
  const contents: DescribeBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    billingGroupArn: undefined,
    billingGroupId: undefined,
    billingGroupMetadata: undefined,
    billingGroupName: undefined,
    billingGroupProperties: undefined,
    version: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.billingGroupArn !== undefined && data.billingGroupArn !== null) {
    contents.billingGroupArn = __expectString(data.billingGroupArn);
  }
  if (data.billingGroupId !== undefined && data.billingGroupId !== null) {
    contents.billingGroupId = __expectString(data.billingGroupId);
  }
  if (data.billingGroupMetadata !== undefined && data.billingGroupMetadata !== null) {
    contents.billingGroupMetadata = deserializeAws_restJson1BillingGroupMetadata(data.billingGroupMetadata, context);
  }
  if (data.billingGroupName !== undefined && data.billingGroupName !== null) {
    contents.billingGroupName = __expectString(data.billingGroupName);
  }
  if (data.billingGroupProperties !== undefined && data.billingGroupProperties !== null) {
    contents.billingGroupProperties = deserializeAws_restJson1BillingGroupProperties(
      data.billingGroupProperties,
      context
    );
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = __expectLong(data.version);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeBillingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeBillingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeCACertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCACertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeCACertificateCommandError(output, context);
  }
  const contents: DescribeCACertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    certificateDescription: undefined,
    registrationConfig: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificateDescription !== undefined && data.certificateDescription !== null) {
    contents.certificateDescription = deserializeAws_restJson1CACertificateDescription(
      data.certificateDescription,
      context
    );
  }
  if (data.registrationConfig !== undefined && data.registrationConfig !== null) {
    contents.registrationConfig = deserializeAws_restJson1RegistrationConfig(data.registrationConfig, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeCACertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCACertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeCertificateCommandError(output, context);
  }
  const contents: DescribeCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    certificateDescription: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificateDescription !== undefined && data.certificateDescription !== null) {
    contents.certificateDescription = deserializeAws_restJson1CertificateDescription(
      data.certificateDescription,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeCustomMetricCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCustomMetricCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeCustomMetricCommandError(output, context);
  }
  const contents: DescribeCustomMetricCommandOutput = {
    $metadata: deserializeMetadata(output),
    creationDate: undefined,
    displayName: undefined,
    lastModifiedDate: undefined,
    metricArn: undefined,
    metricName: undefined,
    metricType: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.displayName !== undefined && data.displayName !== null) {
    contents.displayName = __expectString(data.displayName);
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.metricArn !== undefined && data.metricArn !== null) {
    contents.metricArn = __expectString(data.metricArn);
  }
  if (data.metricName !== undefined && data.metricName !== null) {
    contents.metricName = __expectString(data.metricName);
  }
  if (data.metricType !== undefined && data.metricType !== null) {
    contents.metricType = __expectString(data.metricType);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeCustomMetricCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCustomMetricCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeDefaultAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDefaultAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeDefaultAuthorizerCommandError(output, context);
  }
  const contents: DescribeDefaultAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    authorizerDescription: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.authorizerDescription !== undefined && data.authorizerDescription !== null) {
    contents.authorizerDescription = deserializeAws_restJson1AuthorizerDescription(data.authorizerDescription, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeDefaultAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDefaultAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeDetectMitigationActionsTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDetectMitigationActionsTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeDetectMitigationActionsTaskCommandError(output, context);
  }
  const contents: DescribeDetectMitigationActionsTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    taskSummary: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.taskSummary !== undefined && data.taskSummary !== null) {
    contents.taskSummary = deserializeAws_restJson1DetectMitigationActionsTaskSummary(data.taskSummary, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeDetectMitigationActionsTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDetectMitigationActionsTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeDimensionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDimensionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeDimensionCommandError(output, context);
  }
  const contents: DescribeDimensionCommandOutput = {
    $metadata: deserializeMetadata(output),
    arn: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    name: undefined,
    stringValues: undefined,
    type: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.arn !== undefined && data.arn !== null) {
    contents.arn = __expectString(data.arn);
  }
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = __expectString(data.name);
  }
  if (data.stringValues !== undefined && data.stringValues !== null) {
    contents.stringValues = deserializeAws_restJson1DimensionStringValues(data.stringValues, context);
  }
  if (data.type !== undefined && data.type !== null) {
    contents.type = __expectString(data.type);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeDimensionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDimensionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeDomainConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDomainConfigurationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeDomainConfigurationCommandError(output, context);
  }
  const contents: DescribeDomainConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    authorizerConfig: undefined,
    domainConfigurationArn: undefined,
    domainConfigurationName: undefined,
    domainConfigurationStatus: undefined,
    domainName: undefined,
    domainType: undefined,
    lastStatusChangeDate: undefined,
    serverCertificates: undefined,
    serviceType: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.authorizerConfig !== undefined && data.authorizerConfig !== null) {
    contents.authorizerConfig = deserializeAws_restJson1AuthorizerConfig(data.authorizerConfig, context);
  }
  if (data.domainConfigurationArn !== undefined && data.domainConfigurationArn !== null) {
    contents.domainConfigurationArn = __expectString(data.domainConfigurationArn);
  }
  if (data.domainConfigurationName !== undefined && data.domainConfigurationName !== null) {
    contents.domainConfigurationName = __expectString(data.domainConfigurationName);
  }
  if (data.domainConfigurationStatus !== undefined && data.domainConfigurationStatus !== null) {
    contents.domainConfigurationStatus = __expectString(data.domainConfigurationStatus);
  }
  if (data.domainName !== undefined && data.domainName !== null) {
    contents.domainName = __expectString(data.domainName);
  }
  if (data.domainType !== undefined && data.domainType !== null) {
    contents.domainType = __expectString(data.domainType);
  }
  if (data.lastStatusChangeDate !== undefined && data.lastStatusChangeDate !== null) {
    contents.lastStatusChangeDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastStatusChangeDate)));
  }
  if (data.serverCertificates !== undefined && data.serverCertificates !== null) {
    contents.serverCertificates = deserializeAws_restJson1ServerCertificates(data.serverCertificates, context);
  }
  if (data.serviceType !== undefined && data.serviceType !== null) {
    contents.serviceType = __expectString(data.serviceType);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeDomainConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeDomainConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeEndpointCommandError(output, context);
  }
  const contents: DescribeEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    endpointAddress: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.endpointAddress !== undefined && data.endpointAddress !== null) {
    contents.endpointAddress = __expectString(data.endpointAddress);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeEventConfigurationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventConfigurationsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeEventConfigurationsCommandError(output, context);
  }
  const contents: DescribeEventConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    creationDate: undefined,
    eventConfigurations: undefined,
    lastModifiedDate: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.eventConfigurations !== undefined && data.eventConfigurations !== null) {
    contents.eventConfigurations = deserializeAws_restJson1EventConfigurations(data.eventConfigurations, context);
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeEventConfigurationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventConfigurationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeFleetMetricCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetMetricCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeFleetMetricCommandError(output, context);
  }
  const contents: DescribeFleetMetricCommandOutput = {
    $metadata: deserializeMetadata(output),
    aggregationField: undefined,
    aggregationType: undefined,
    creationDate: undefined,
    description: undefined,
    indexName: undefined,
    lastModifiedDate: undefined,
    metricArn: undefined,
    metricName: undefined,
    period: undefined,
    queryString: undefined,
    queryVersion: undefined,
    unit: undefined,
    version: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.aggregationField !== undefined && data.aggregationField !== null) {
    contents.aggregationField = __expectString(data.aggregationField);
  }
  if (data.aggregationType !== undefined && data.aggregationType !== null) {
    contents.aggregationType = deserializeAws_restJson1AggregationType(data.aggregationType, context);
  }
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = __expectString(data.description);
  }
  if (data.indexName !== undefined && data.indexName !== null) {
    contents.indexName = __expectString(data.indexName);
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.metricArn !== undefined && data.metricArn !== null) {
    contents.metricArn = __expectString(data.metricArn);
  }
  if (data.metricName !== undefined && data.metricName !== null) {
    contents.metricName = __expectString(data.metricName);
  }
  if (data.period !== undefined && data.period !== null) {
    contents.period = __expectInt32(data.period);
  }
  if (data.queryString !== undefined && data.queryString !== null) {
    contents.queryString = __expectString(data.queryString);
  }
  if (data.queryVersion !== undefined && data.queryVersion !== null) {
    contents.queryVersion = __expectString(data.queryVersion);
  }
  if (data.unit !== undefined && data.unit !== null) {
    contents.unit = __expectString(data.unit);
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = __expectLong(data.version);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeFleetMetricCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeFleetMetricCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeIndexCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIndexCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeIndexCommandError(output, context);
  }
  const contents: DescribeIndexCommandOutput = {
    $metadata: deserializeMetadata(output),
    indexName: undefined,
    indexStatus: undefined,
    schema: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.indexName !== undefined && data.indexName !== null) {
    contents.indexName = __expectString(data.indexName);
  }
  if (data.indexStatus !== undefined && data.indexStatus !== null) {
    contents.indexStatus = __expectString(data.indexStatus);
  }
  if (data.schema !== undefined && data.schema !== null) {
    contents.schema = __expectString(data.schema);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeIndexCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeIndexCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeJobCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeJobCommandError(output, context);
  }
  const contents: DescribeJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    documentSource: undefined,
    job: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.documentSource !== undefined && data.documentSource !== null) {
    contents.documentSource = __expectString(data.documentSource);
  }
  if (data.job !== undefined && data.job !== null) {
    contents.job = deserializeAws_restJson1Job(data.job, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeJobExecutionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeJobExecutionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeJobExecutionCommandError(output, context);
  }
  const contents: DescribeJobExecutionCommandOutput = {
    $metadata: deserializeMetadata(output),
    execution: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.execution !== undefined && data.execution !== null) {
    contents.execution = deserializeAws_restJson1JobExecution(data.execution, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeJobExecutionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeJobExecutionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeJobTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeJobTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeJobTemplateCommandError(output, context);
  }
  const contents: DescribeJobTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    abortConfig: undefined,
    createdAt: undefined,
    description: undefined,
    document: undefined,
    documentSource: undefined,
    jobExecutionsRolloutConfig: undefined,
    jobTemplateArn: undefined,
    jobTemplateId: undefined,
    presignedUrlConfig: undefined,
    timeoutConfig: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.abortConfig !== undefined && data.abortConfig !== null) {
    contents.abortConfig = deserializeAws_restJson1AbortConfig(data.abortConfig, context);
  }
  if (data.createdAt !== undefined && data.createdAt !== null) {
    contents.createdAt = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.createdAt)));
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = __expectString(data.description);
  }
  if (data.document !== undefined && data.document !== null) {
    contents.document = __expectString(data.document);
  }
  if (data.documentSource !== undefined && data.documentSource !== null) {
    contents.documentSource = __expectString(data.documentSource);
  }
  if (data.jobExecutionsRolloutConfig !== undefined && data.jobExecutionsRolloutConfig !== null) {
    contents.jobExecutionsRolloutConfig = deserializeAws_restJson1JobExecutionsRolloutConfig(
      data.jobExecutionsRolloutConfig,
      context
    );
  }
  if (data.jobTemplateArn !== undefined && data.jobTemplateArn !== null) {
    contents.jobTemplateArn = __expectString(data.jobTemplateArn);
  }
  if (data.jobTemplateId !== undefined && data.jobTemplateId !== null) {
    contents.jobTemplateId = __expectString(data.jobTemplateId);
  }
  if (data.presignedUrlConfig !== undefined && data.presignedUrlConfig !== null) {
    contents.presignedUrlConfig = deserializeAws_restJson1PresignedUrlConfig(data.presignedUrlConfig, context);
  }
  if (data.timeoutConfig !== undefined && data.timeoutConfig !== null) {
    contents.timeoutConfig = deserializeAws_restJson1TimeoutConfig(data.timeoutConfig, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeJobTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeJobTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeMitigationActionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMitigationActionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeMitigationActionCommandError(output, context);
  }
  const contents: DescribeMitigationActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    actionArn: undefined,
    actionId: undefined,
    actionName: undefined,
    actionParams: undefined,
    actionType: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    roleArn: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.actionArn !== undefined && data.actionArn !== null) {
    contents.actionArn = __expectString(data.actionArn);
  }
  if (data.actionId !== undefined && data.actionId !== null) {
    contents.actionId = __expectString(data.actionId);
  }
  if (data.actionName !== undefined && data.actionName !== null) {
    contents.actionName = __expectString(data.actionName);
  }
  if (data.actionParams !== undefined && data.actionParams !== null) {
    contents.actionParams = deserializeAws_restJson1MitigationActionParams(data.actionParams, context);
  }
  if (data.actionType !== undefined && data.actionType !== null) {
    contents.actionType = __expectString(data.actionType);
  }
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.roleArn !== undefined && data.roleArn !== null) {
    contents.roleArn = __expectString(data.roleArn);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeMitigationActionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeMitigationActionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeProvisioningTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeProvisioningTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeProvisioningTemplateCommandError(output, context);
  }
  const contents: DescribeProvisioningTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
    creationDate: undefined,
    defaultVersionId: undefined,
    description: undefined,
    enabled: undefined,
    lastModifiedDate: undefined,
    preProvisioningHook: undefined,
    provisioningRoleArn: undefined,
    templateArn: undefined,
    templateBody: undefined,
    templateName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.defaultVersionId !== undefined && data.defaultVersionId !== null) {
    contents.defaultVersionId = __expectInt32(data.defaultVersionId);
  }
  if (data.description !== undefined && data.description !== null) {
    contents.description = __expectString(data.description);
  }
  if (data.enabled !== undefined && data.enabled !== null) {
    contents.enabled = __expectBoolean(data.enabled);
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.preProvisioningHook !== undefined && data.preProvisioningHook !== null) {
    contents.preProvisioningHook = deserializeAws_restJson1ProvisioningHook(data.preProvisioningHook, context);
  }
  if (data.provisioningRoleArn !== undefined && data.provisioningRoleArn !== null) {
    contents.provisioningRoleArn = __expectString(data.provisioningRoleArn);
  }
  if (data.templateArn !== undefined && data.templateArn !== null) {
    contents.templateArn = __expectString(data.templateArn);
  }
  if (data.templateBody !== undefined && data.templateBody !== null) {
    contents.templateBody = __expectString(data.templateBody);
  }
  if (data.templateName !== undefined && data.templateName !== null) {
    contents.templateName = __expectString(data.templateName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeProvisioningTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeProvisioningTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeProvisioningTemplateVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeProvisioningTemplateVersionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeProvisioningTemplateVersionCommandError(output, context);
  }
  const contents: DescribeProvisioningTemplateVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    creationDate: undefined,
    isDefaultVersion: undefined,
    templateBody: undefined,
    versionId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
    contents.isDefaultVersion = __expectBoolean(data.isDefaultVersion);
  }
  if (data.templateBody !== undefined && data.templateBody !== null) {
    contents.templateBody = __expectString(data.templateBody);
  }
  if (data.versionId !== undefined && data.versionId !== null) {
    contents.versionId = __expectInt32(data.versionId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeProvisioningTemplateVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeProvisioningTemplateVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeRoleAliasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRoleAliasCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeRoleAliasCommandError(output, context);
  }
  const contents: DescribeRoleAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    roleAliasDescription: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.roleAliasDescription !== undefined && data.roleAliasDescription !== null) {
    contents.roleAliasDescription = deserializeAws_restJson1RoleAliasDescription(data.roleAliasDescription, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeRoleAliasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRoleAliasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeScheduledAuditCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScheduledAuditCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeScheduledAuditCommandError(output, context);
  }
  const contents: DescribeScheduledAuditCommandOutput = {
    $metadata: deserializeMetadata(output),
    dayOfMonth: undefined,
    dayOfWeek: undefined,
    frequency: undefined,
    scheduledAuditArn: undefined,
    scheduledAuditName: undefined,
    targetCheckNames: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.dayOfMonth !== undefined && data.dayOfMonth !== null) {
    contents.dayOfMonth = __expectString(data.dayOfMonth);
  }
  if (data.dayOfWeek !== undefined && data.dayOfWeek !== null) {
    contents.dayOfWeek = __expectString(data.dayOfWeek);
  }
  if (data.frequency !== undefined && data.frequency !== null) {
    contents.frequency = __expectString(data.frequency);
  }
  if (data.scheduledAuditArn !== undefined && data.scheduledAuditArn !== null) {
    contents.scheduledAuditArn = __expectString(data.scheduledAuditArn);
  }
  if (data.scheduledAuditName !== undefined && data.scheduledAuditName !== null) {
    contents.scheduledAuditName = __expectString(data.scheduledAuditName);
  }
  if (data.targetCheckNames !== undefined && data.targetCheckNames !== null) {
    contents.targetCheckNames = deserializeAws_restJson1TargetAuditCheckNames(data.targetCheckNames, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeScheduledAuditCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeScheduledAuditCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeSecurityProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSecurityProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeSecurityProfileCommandError(output, context);
  }
  const contents: DescribeSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    additionalMetricsToRetain: undefined,
    additionalMetricsToRetainV2: undefined,
    alertTargets: undefined,
    behaviors: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    securityProfileArn: undefined,
    securityProfileDescription: undefined,
    securityProfileName: undefined,
    version: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.additionalMetricsToRetain !== undefined && data.additionalMetricsToRetain !== null) {
    contents.additionalMetricsToRetain = deserializeAws_restJson1AdditionalMetricsToRetainList(
      data.additionalMetricsToRetain,
      context
    );
  }
  if (data.additionalMetricsToRetainV2 !== undefined && data.additionalMetricsToRetainV2 !== null) {
    contents.additionalMetricsToRetainV2 = deserializeAws_restJson1AdditionalMetricsToRetainV2List(
      data.additionalMetricsToRetainV2,
      context
    );
  }
  if (data.alertTargets !== undefined && data.alertTargets !== null) {
    contents.alertTargets = deserializeAws_restJson1AlertTargets(data.alertTargets, context);
  }
  if (data.behaviors !== undefined && data.behaviors !== null) {
    contents.behaviors = deserializeAws_restJson1Behaviors(data.behaviors, context);
  }
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.securityProfileArn !== undefined && data.securityProfileArn !== null) {
    contents.securityProfileArn = __expectString(data.securityProfileArn);
  }
  if (data.securityProfileDescription !== undefined && data.securityProfileDescription !== null) {
    contents.securityProfileDescription = __expectString(data.securityProfileDescription);
  }
  if (data.securityProfileName !== undefined && data.securityProfileName !== null) {
    contents.securityProfileName = __expectString(data.securityProfileName);
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = __expectLong(data.version);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeSecurityProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSecurityProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeStreamCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStreamCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeStreamCommandError(output, context);
  }
  const contents: DescribeStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    streamInfo: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.streamInfo !== undefined && data.streamInfo !== null) {
    contents.streamInfo = deserializeAws_restJson1StreamInfo(data.streamInfo, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeStreamCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeStreamCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeThingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeThingCommandError(output, context);
  }
  const contents: DescribeThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    attributes: undefined,
    billingGroupName: undefined,
    defaultClientId: undefined,
    thingArn: undefined,
    thingId: undefined,
    thingName: undefined,
    thingTypeName: undefined,
    version: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.attributes !== undefined && data.attributes !== null) {
    contents.attributes = deserializeAws_restJson1Attributes(data.attributes, context);
  }
  if (data.billingGroupName !== undefined && data.billingGroupName !== null) {
    contents.billingGroupName = __expectString(data.billingGroupName);
  }
  if (data.defaultClientId !== undefined && data.defaultClientId !== null) {
    contents.defaultClientId = __expectString(data.defaultClientId);
  }
  if (data.thingArn !== undefined && data.thingArn !== null) {
    contents.thingArn = __expectString(data.thingArn);
  }
  if (data.thingId !== undefined && data.thingId !== null) {
    contents.thingId = __expectString(data.thingId);
  }
  if (data.thingName !== undefined && data.thingName !== null) {
    contents.thingName = __expectString(data.thingName);
  }
  if (data.thingTypeName !== undefined && data.thingTypeName !== null) {
    contents.thingTypeName = __expectString(data.thingTypeName);
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = __expectLong(data.version);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeThingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeThingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeThingGroupCommandError(output, context);
  }
  const contents: DescribeThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    indexName: undefined,
    queryString: undefined,
    queryVersion: undefined,
    status: undefined,
    thingGroupArn: undefined,
    thingGroupId: undefined,
    thingGroupMetadata: undefined,
    thingGroupName: undefined,
    thingGroupProperties: undefined,
    version: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.indexName !== undefined && data.indexName !== null) {
    contents.indexName = __expectString(data.indexName);
  }
  if (data.queryString !== undefined && data.queryString !== null) {
    contents.queryString = __expectString(data.queryString);
  }
  if (data.queryVersion !== undefined && data.queryVersion !== null) {
    contents.queryVersion = __expectString(data.queryVersion);
  }
  if (data.status !== undefined && data.status !== null) {
    contents.status = __expectString(data.status);
  }
  if (data.thingGroupArn !== undefined && data.thingGroupArn !== null) {
    contents.thingGroupArn = __expectString(data.thingGroupArn);
  }
  if (data.thingGroupId !== undefined && data.thingGroupId !== null) {
    contents.thingGroupId = __expectString(data.thingGroupId);
  }
  if (data.thingGroupMetadata !== undefined && data.thingGroupMetadata !== null) {
    contents.thingGroupMetadata = deserializeAws_restJson1ThingGroupMetadata(data.thingGroupMetadata, context);
  }
  if (data.thingGroupName !== undefined && data.thingGroupName !== null) {
    contents.thingGroupName = __expectString(data.thingGroupName);
  }
  if (data.thingGroupProperties !== undefined && data.thingGroupProperties !== null) {
    contents.thingGroupProperties = deserializeAws_restJson1ThingGroupProperties(data.thingGroupProperties, context);
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = __expectLong(data.version);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeThingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeThingRegistrationTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingRegistrationTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeThingRegistrationTaskCommandError(output, context);
  }
  const contents: DescribeThingRegistrationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    creationDate: undefined,
    failureCount: undefined,
    inputFileBucket: undefined,
    inputFileKey: undefined,
    lastModifiedDate: undefined,
    message: undefined,
    percentageProgress: undefined,
    roleArn: undefined,
    status: undefined,
    successCount: undefined,
    taskId: undefined,
    templateBody: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.failureCount !== undefined && data.failureCount !== null) {
    contents.failureCount = __expectInt32(data.failureCount);
  }
  if (data.inputFileBucket !== undefined && data.inputFileBucket !== null) {
    contents.inputFileBucket = __expectString(data.inputFileBucket);
  }
  if (data.inputFileKey !== undefined && data.inputFileKey !== null) {
    contents.inputFileKey = __expectString(data.inputFileKey);
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  if (data.percentageProgress !== undefined && data.percentageProgress !== null) {
    contents.percentageProgress = __expectInt32(data.percentageProgress);
  }
  if (data.roleArn !== undefined && data.roleArn !== null) {
    contents.roleArn = __expectString(data.roleArn);
  }
  if (data.status !== undefined && data.status !== null) {
    contents.status = __expectString(data.status);
  }
  if (data.successCount !== undefined && data.successCount !== null) {
    contents.successCount = __expectInt32(data.successCount);
  }
  if (data.taskId !== undefined && data.taskId !== null) {
    contents.taskId = __expectString(data.taskId);
  }
  if (data.templateBody !== undefined && data.templateBody !== null) {
    contents.templateBody = __expectString(data.templateBody);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeThingRegistrationTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingRegistrationTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DescribeThingTypeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingTypeCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DescribeThingTypeCommandError(output, context);
  }
  const contents: DescribeThingTypeCommandOutput = {
    $metadata: deserializeMetadata(output),
    thingTypeArn: undefined,
    thingTypeId: undefined,
    thingTypeMetadata: undefined,
    thingTypeName: undefined,
    thingTypeProperties: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.thingTypeArn !== undefined && data.thingTypeArn !== null) {
    contents.thingTypeArn = __expectString(data.thingTypeArn);
  }
  if (data.thingTypeId !== undefined && data.thingTypeId !== null) {
    contents.thingTypeId = __expectString(data.thingTypeId);
  }
  if (data.thingTypeMetadata !== undefined && data.thingTypeMetadata !== null) {
    contents.thingTypeMetadata = deserializeAws_restJson1ThingTypeMetadata(data.thingTypeMetadata, context);
  }
  if (data.thingTypeName !== undefined && data.thingTypeName !== null) {
    contents.thingTypeName = __expectString(data.thingTypeName);
  }
  if (data.thingTypeProperties !== undefined && data.thingTypeProperties !== null) {
    contents.thingTypeProperties = deserializeAws_restJson1ThingTypeProperties(data.thingTypeProperties, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DescribeThingTypeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeThingTypeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DetachPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachPolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DetachPolicyCommandError(output, context);
  }
  const contents: DetachPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DetachPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DetachPrincipalPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachPrincipalPolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DetachPrincipalPolicyCommandError(output, context);
  }
  const contents: DetachPrincipalPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DetachPrincipalPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachPrincipalPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DetachSecurityProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachSecurityProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DetachSecurityProfileCommandError(output, context);
  }
  const contents: DetachSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DetachSecurityProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachSecurityProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DetachThingPrincipalCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachThingPrincipalCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DetachThingPrincipalCommandError(output, context);
  }
  const contents: DetachThingPrincipalCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DetachThingPrincipalCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DetachThingPrincipalCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1DisableTopicRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableTopicRuleCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1DisableTopicRuleCommandError(output, context);
  }
  const contents: DisableTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1DisableTopicRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisableTopicRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1EnableTopicRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableTopicRuleCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1EnableTopicRuleCommandError(output, context);
  }
  const contents: EnableTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1EnableTopicRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<EnableTopicRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetBehaviorModelTrainingSummariesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBehaviorModelTrainingSummariesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetBehaviorModelTrainingSummariesCommandError(output, context);
  }
  const contents: GetBehaviorModelTrainingSummariesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    summaries: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.summaries !== undefined && data.summaries !== null) {
    contents.summaries = deserializeAws_restJson1BehaviorModelTrainingSummaries(data.summaries, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetBehaviorModelTrainingSummariesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBehaviorModelTrainingSummariesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetBucketsAggregationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketsAggregationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetBucketsAggregationCommandError(output, context);
  }
  const contents: GetBucketsAggregationCommandOutput = {
    $metadata: deserializeMetadata(output),
    buckets: undefined,
    totalCount: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.buckets !== undefined && data.buckets !== null) {
    contents.buckets = deserializeAws_restJson1Buckets(data.buckets, context);
  }
  if (data.totalCount !== undefined && data.totalCount !== null) {
    contents.totalCount = __expectInt32(data.totalCount);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetBucketsAggregationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetBucketsAggregationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IndexNotReadyException":
    case "com.amazonaws.iot#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidAggregationException":
    case "com.amazonaws.iot#InvalidAggregationException":
      response = {
        ...(await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetCardinalityCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCardinalityCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetCardinalityCommandError(output, context);
  }
  const contents: GetCardinalityCommandOutput = {
    $metadata: deserializeMetadata(output),
    cardinality: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.cardinality !== undefined && data.cardinality !== null) {
    contents.cardinality = __expectInt32(data.cardinality);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetCardinalityCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCardinalityCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IndexNotReadyException":
    case "com.amazonaws.iot#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidAggregationException":
    case "com.amazonaws.iot#InvalidAggregationException":
      response = {
        ...(await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetEffectivePoliciesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEffectivePoliciesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetEffectivePoliciesCommandError(output, context);
  }
  const contents: GetEffectivePoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    effectivePolicies: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.effectivePolicies !== undefined && data.effectivePolicies !== null) {
    contents.effectivePolicies = deserializeAws_restJson1EffectivePolicies(data.effectivePolicies, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetEffectivePoliciesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetEffectivePoliciesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetIndexingConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIndexingConfigurationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetIndexingConfigurationCommandError(output, context);
  }
  const contents: GetIndexingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    thingGroupIndexingConfiguration: undefined,
    thingIndexingConfiguration: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.thingGroupIndexingConfiguration !== undefined && data.thingGroupIndexingConfiguration !== null) {
    contents.thingGroupIndexingConfiguration = deserializeAws_restJson1ThingGroupIndexingConfiguration(
      data.thingGroupIndexingConfiguration,
      context
    );
  }
  if (data.thingIndexingConfiguration !== undefined && data.thingIndexingConfiguration !== null) {
    contents.thingIndexingConfiguration = deserializeAws_restJson1ThingIndexingConfiguration(
      data.thingIndexingConfiguration,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetIndexingConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetIndexingConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetJobDocumentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobDocumentCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetJobDocumentCommandError(output, context);
  }
  const contents: GetJobDocumentCommandOutput = {
    $metadata: deserializeMetadata(output),
    document: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.document !== undefined && data.document !== null) {
    contents.document = __expectString(data.document);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetJobDocumentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetJobDocumentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetLoggingOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggingOptionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetLoggingOptionsCommandError(output, context);
  }
  const contents: GetLoggingOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    logLevel: undefined,
    roleArn: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.logLevel !== undefined && data.logLevel !== null) {
    contents.logLevel = __expectString(data.logLevel);
  }
  if (data.roleArn !== undefined && data.roleArn !== null) {
    contents.roleArn = __expectString(data.roleArn);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetLoggingOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetLoggingOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetOTAUpdateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetOTAUpdateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetOTAUpdateCommandError(output, context);
  }
  const contents: GetOTAUpdateCommandOutput = {
    $metadata: deserializeMetadata(output),
    otaUpdateInfo: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.otaUpdateInfo !== undefined && data.otaUpdateInfo !== null) {
    contents.otaUpdateInfo = deserializeAws_restJson1OTAUpdateInfo(data.otaUpdateInfo, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetOTAUpdateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetOTAUpdateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetPercentilesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPercentilesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetPercentilesCommandError(output, context);
  }
  const contents: GetPercentilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    percentiles: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.percentiles !== undefined && data.percentiles !== null) {
    contents.percentiles = deserializeAws_restJson1Percentiles(data.percentiles, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetPercentilesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPercentilesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IndexNotReadyException":
    case "com.amazonaws.iot#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidAggregationException":
    case "com.amazonaws.iot#InvalidAggregationException":
      response = {
        ...(await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetPolicyCommandError(output, context);
  }
  const contents: GetPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    creationDate: undefined,
    defaultVersionId: undefined,
    generationId: undefined,
    lastModifiedDate: undefined,
    policyArn: undefined,
    policyDocument: undefined,
    policyName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.defaultVersionId !== undefined && data.defaultVersionId !== null) {
    contents.defaultVersionId = __expectString(data.defaultVersionId);
  }
  if (data.generationId !== undefined && data.generationId !== null) {
    contents.generationId = __expectString(data.generationId);
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.policyArn !== undefined && data.policyArn !== null) {
    contents.policyArn = __expectString(data.policyArn);
  }
  if (data.policyDocument !== undefined && data.policyDocument !== null) {
    contents.policyDocument = __expectString(data.policyDocument);
  }
  if (data.policyName !== undefined && data.policyName !== null) {
    contents.policyName = __expectString(data.policyName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetPolicyVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPolicyVersionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetPolicyVersionCommandError(output, context);
  }
  const contents: GetPolicyVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    creationDate: undefined,
    generationId: undefined,
    isDefaultVersion: undefined,
    lastModifiedDate: undefined,
    policyArn: undefined,
    policyDocument: undefined,
    policyName: undefined,
    policyVersionId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.generationId !== undefined && data.generationId !== null) {
    contents.generationId = __expectString(data.generationId);
  }
  if (data.isDefaultVersion !== undefined && data.isDefaultVersion !== null) {
    contents.isDefaultVersion = __expectBoolean(data.isDefaultVersion);
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.policyArn !== undefined && data.policyArn !== null) {
    contents.policyArn = __expectString(data.policyArn);
  }
  if (data.policyDocument !== undefined && data.policyDocument !== null) {
    contents.policyDocument = __expectString(data.policyDocument);
  }
  if (data.policyName !== undefined && data.policyName !== null) {
    contents.policyName = __expectString(data.policyName);
  }
  if (data.policyVersionId !== undefined && data.policyVersionId !== null) {
    contents.policyVersionId = __expectString(data.policyVersionId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetPolicyVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetPolicyVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetRegistrationCodeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegistrationCodeCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetRegistrationCodeCommandError(output, context);
  }
  const contents: GetRegistrationCodeCommandOutput = {
    $metadata: deserializeMetadata(output),
    registrationCode: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.registrationCode !== undefined && data.registrationCode !== null) {
    contents.registrationCode = __expectString(data.registrationCode);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetRegistrationCodeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetRegistrationCodeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetStatisticsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStatisticsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetStatisticsCommandError(output, context);
  }
  const contents: GetStatisticsCommandOutput = {
    $metadata: deserializeMetadata(output),
    statistics: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.statistics !== undefined && data.statistics !== null) {
    contents.statistics = deserializeAws_restJson1Statistics(data.statistics, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetStatisticsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetStatisticsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IndexNotReadyException":
    case "com.amazonaws.iot#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidAggregationException":
    case "com.amazonaws.iot#InvalidAggregationException":
      response = {
        ...(await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetTopicRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTopicRuleCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetTopicRuleCommandError(output, context);
  }
  const contents: GetTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
    rule: undefined,
    ruleArn: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.rule !== undefined && data.rule !== null) {
    contents.rule = deserializeAws_restJson1TopicRule(data.rule, context);
  }
  if (data.ruleArn !== undefined && data.ruleArn !== null) {
    contents.ruleArn = __expectString(data.ruleArn);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetTopicRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTopicRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetTopicRuleDestinationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTopicRuleDestinationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetTopicRuleDestinationCommandError(output, context);
  }
  const contents: GetTopicRuleDestinationCommandOutput = {
    $metadata: deserializeMetadata(output),
    topicRuleDestination: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.topicRuleDestination !== undefined && data.topicRuleDestination !== null) {
    contents.topicRuleDestination = deserializeAws_restJson1TopicRuleDestination(data.topicRuleDestination, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetTopicRuleDestinationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTopicRuleDestinationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1GetV2LoggingOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetV2LoggingOptionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1GetV2LoggingOptionsCommandError(output, context);
  }
  const contents: GetV2LoggingOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    defaultLogLevel: undefined,
    disableAllLogs: undefined,
    roleArn: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.defaultLogLevel !== undefined && data.defaultLogLevel !== null) {
    contents.defaultLogLevel = __expectString(data.defaultLogLevel);
  }
  if (data.disableAllLogs !== undefined && data.disableAllLogs !== null) {
    contents.disableAllLogs = __expectBoolean(data.disableAllLogs);
  }
  if (data.roleArn !== undefined && data.roleArn !== null) {
    contents.roleArn = __expectString(data.roleArn);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1GetV2LoggingOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetV2LoggingOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotConfiguredException":
    case "com.amazonaws.iot#NotConfiguredException":
      response = {
        ...(await deserializeAws_restJson1NotConfiguredExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListActiveViolationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListActiveViolationsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListActiveViolationsCommandError(output, context);
  }
  const contents: ListActiveViolationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    activeViolations: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.activeViolations !== undefined && data.activeViolations !== null) {
    contents.activeViolations = deserializeAws_restJson1ActiveViolations(data.activeViolations, context);
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListActiveViolationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListActiveViolationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListAttachedPoliciesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAttachedPoliciesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAttachedPoliciesCommandError(output, context);
  }
  const contents: ListAttachedPoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextMarker: undefined,
    policies: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  if (data.policies !== undefined && data.policies !== null) {
    contents.policies = deserializeAws_restJson1Policies(data.policies, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListAttachedPoliciesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAttachedPoliciesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListAuditFindingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditFindingsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAuditFindingsCommandError(output, context);
  }
  const contents: ListAuditFindingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    findings: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.findings !== undefined && data.findings !== null) {
    contents.findings = deserializeAws_restJson1AuditFindings(data.findings, context);
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListAuditFindingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditFindingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditMitigationActionsExecutionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommandError(output, context);
  }
  const contents: ListAuditMitigationActionsExecutionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    actionsExecutions: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.actionsExecutions !== undefined && data.actionsExecutions !== null) {
    contents.actionsExecutions = deserializeAws_restJson1AuditMitigationActionExecutionMetadataList(
      data.actionsExecutions,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListAuditMitigationActionsExecutionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditMitigationActionsExecutionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListAuditMitigationActionsTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditMitigationActionsTasksCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAuditMitigationActionsTasksCommandError(output, context);
  }
  const contents: ListAuditMitigationActionsTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    tasks: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.tasks !== undefined && data.tasks !== null) {
    contents.tasks = deserializeAws_restJson1AuditMitigationActionsTaskMetadataList(data.tasks, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListAuditMitigationActionsTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditMitigationActionsTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListAuditSuppressionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditSuppressionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAuditSuppressionsCommandError(output, context);
  }
  const contents: ListAuditSuppressionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    suppressions: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.suppressions !== undefined && data.suppressions !== null) {
    contents.suppressions = deserializeAws_restJson1AuditSuppressionList(data.suppressions, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListAuditSuppressionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditSuppressionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListAuditTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditTasksCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAuditTasksCommandError(output, context);
  }
  const contents: ListAuditTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    tasks: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.tasks !== undefined && data.tasks !== null) {
    contents.tasks = deserializeAws_restJson1AuditTaskMetadataList(data.tasks, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListAuditTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuditTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListAuthorizersCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuthorizersCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListAuthorizersCommandError(output, context);
  }
  const contents: ListAuthorizersCommandOutput = {
    $metadata: deserializeMetadata(output),
    authorizers: undefined,
    nextMarker: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.authorizers !== undefined && data.authorizers !== null) {
    contents.authorizers = deserializeAws_restJson1Authorizers(data.authorizers, context);
  }
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListAuthorizersCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListAuthorizersCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListBillingGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBillingGroupsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListBillingGroupsCommandError(output, context);
  }
  const contents: ListBillingGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    billingGroups: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.billingGroups !== undefined && data.billingGroups !== null) {
    contents.billingGroups = deserializeAws_restJson1BillingGroupNameAndArnList(data.billingGroups, context);
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListBillingGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListBillingGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListCACertificatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCACertificatesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListCACertificatesCommandError(output, context);
  }
  const contents: ListCACertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    certificates: undefined,
    nextMarker: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificates !== undefined && data.certificates !== null) {
    contents.certificates = deserializeAws_restJson1CACertificates(data.certificates, context);
  }
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListCACertificatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCACertificatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListCertificatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCertificatesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListCertificatesCommandError(output, context);
  }
  const contents: ListCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    certificates: undefined,
    nextMarker: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificates !== undefined && data.certificates !== null) {
    contents.certificates = deserializeAws_restJson1Certificates(data.certificates, context);
  }
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListCertificatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCertificatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListCertificatesByCACommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCertificatesByCACommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListCertificatesByCACommandError(output, context);
  }
  const contents: ListCertificatesByCACommandOutput = {
    $metadata: deserializeMetadata(output),
    certificates: undefined,
    nextMarker: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificates !== undefined && data.certificates !== null) {
    contents.certificates = deserializeAws_restJson1Certificates(data.certificates, context);
  }
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListCertificatesByCACommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCertificatesByCACommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListCustomMetricsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCustomMetricsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListCustomMetricsCommandError(output, context);
  }
  const contents: ListCustomMetricsCommandOutput = {
    $metadata: deserializeMetadata(output),
    metricNames: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.metricNames !== undefined && data.metricNames !== null) {
    contents.metricNames = deserializeAws_restJson1MetricNames(data.metricNames, context);
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListCustomMetricsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListCustomMetricsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListDetectMitigationActionsExecutionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDetectMitigationActionsExecutionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListDetectMitigationActionsExecutionsCommandError(output, context);
  }
  const contents: ListDetectMitigationActionsExecutionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    actionsExecutions: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.actionsExecutions !== undefined && data.actionsExecutions !== null) {
    contents.actionsExecutions = deserializeAws_restJson1DetectMitigationActionExecutionList(
      data.actionsExecutions,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListDetectMitigationActionsExecutionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDetectMitigationActionsExecutionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListDetectMitigationActionsTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDetectMitigationActionsTasksCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListDetectMitigationActionsTasksCommandError(output, context);
  }
  const contents: ListDetectMitigationActionsTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    tasks: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.tasks !== undefined && data.tasks !== null) {
    contents.tasks = deserializeAws_restJson1DetectMitigationActionsTaskSummaryList(data.tasks, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListDetectMitigationActionsTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDetectMitigationActionsTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListDimensionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDimensionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListDimensionsCommandError(output, context);
  }
  const contents: ListDimensionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    dimensionNames: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.dimensionNames !== undefined && data.dimensionNames !== null) {
    contents.dimensionNames = deserializeAws_restJson1DimensionNames(data.dimensionNames, context);
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListDimensionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDimensionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListDomainConfigurationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDomainConfigurationsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListDomainConfigurationsCommandError(output, context);
  }
  const contents: ListDomainConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    domainConfigurations: undefined,
    nextMarker: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.domainConfigurations !== undefined && data.domainConfigurations !== null) {
    contents.domainConfigurations = deserializeAws_restJson1DomainConfigurations(data.domainConfigurations, context);
  }
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListDomainConfigurationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListDomainConfigurationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListFleetMetricsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFleetMetricsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListFleetMetricsCommandError(output, context);
  }
  const contents: ListFleetMetricsCommandOutput = {
    $metadata: deserializeMetadata(output),
    fleetMetrics: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.fleetMetrics !== undefined && data.fleetMetrics !== null) {
    contents.fleetMetrics = deserializeAws_restJson1FleetMetricNameAndArnList(data.fleetMetrics, context);
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListFleetMetricsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListFleetMetricsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListIndicesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIndicesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListIndicesCommandError(output, context);
  }
  const contents: ListIndicesCommandOutput = {
    $metadata: deserializeMetadata(output),
    indexNames: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.indexNames !== undefined && data.indexNames !== null) {
    contents.indexNames = deserializeAws_restJson1IndexNamesList(data.indexNames, context);
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListIndicesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListIndicesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListJobExecutionsForJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobExecutionsForJobCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListJobExecutionsForJobCommandError(output, context);
  }
  const contents: ListJobExecutionsForJobCommandOutput = {
    $metadata: deserializeMetadata(output),
    executionSummaries: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.executionSummaries !== undefined && data.executionSummaries !== null) {
    contents.executionSummaries = deserializeAws_restJson1JobExecutionSummaryForJobList(
      data.executionSummaries,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListJobExecutionsForJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobExecutionsForJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListJobExecutionsForThingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobExecutionsForThingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListJobExecutionsForThingCommandError(output, context);
  }
  const contents: ListJobExecutionsForThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    executionSummaries: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.executionSummaries !== undefined && data.executionSummaries !== null) {
    contents.executionSummaries = deserializeAws_restJson1JobExecutionSummaryForThingList(
      data.executionSummaries,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListJobExecutionsForThingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobExecutionsForThingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListJobsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListJobsCommandError(output, context);
  }
  const contents: ListJobsCommandOutput = {
    $metadata: deserializeMetadata(output),
    jobs: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.jobs !== undefined && data.jobs !== null) {
    contents.jobs = deserializeAws_restJson1JobSummaryList(data.jobs, context);
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListJobsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListJobTemplatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobTemplatesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListJobTemplatesCommandError(output, context);
  }
  const contents: ListJobTemplatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    jobTemplates: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.jobTemplates !== undefined && data.jobTemplates !== null) {
    contents.jobTemplates = deserializeAws_restJson1JobTemplateSummaryList(data.jobTemplates, context);
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListJobTemplatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListJobTemplatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListMitigationActionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMitigationActionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListMitigationActionsCommandError(output, context);
  }
  const contents: ListMitigationActionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    actionIdentifiers: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.actionIdentifiers !== undefined && data.actionIdentifiers !== null) {
    contents.actionIdentifiers = deserializeAws_restJson1MitigationActionIdentifierList(
      data.actionIdentifiers,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListMitigationActionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListMitigationActionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListOTAUpdatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListOTAUpdatesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListOTAUpdatesCommandError(output, context);
  }
  const contents: ListOTAUpdatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    otaUpdates: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.otaUpdates !== undefined && data.otaUpdates !== null) {
    contents.otaUpdates = deserializeAws_restJson1OTAUpdatesSummary(data.otaUpdates, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListOTAUpdatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListOTAUpdatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListOutgoingCertificatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListOutgoingCertificatesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListOutgoingCertificatesCommandError(output, context);
  }
  const contents: ListOutgoingCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextMarker: undefined,
    outgoingCertificates: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  if (data.outgoingCertificates !== undefined && data.outgoingCertificates !== null) {
    contents.outgoingCertificates = deserializeAws_restJson1OutgoingCertificates(data.outgoingCertificates, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListOutgoingCertificatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListOutgoingCertificatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListPoliciesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPoliciesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListPoliciesCommandError(output, context);
  }
  const contents: ListPoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextMarker: undefined,
    policies: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  if (data.policies !== undefined && data.policies !== null) {
    contents.policies = deserializeAws_restJson1Policies(data.policies, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListPoliciesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPoliciesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListPolicyPrincipalsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPolicyPrincipalsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListPolicyPrincipalsCommandError(output, context);
  }
  const contents: ListPolicyPrincipalsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextMarker: undefined,
    principals: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  if (data.principals !== undefined && data.principals !== null) {
    contents.principals = deserializeAws_restJson1Principals(data.principals, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListPolicyPrincipalsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPolicyPrincipalsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListPolicyVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPolicyVersionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListPolicyVersionsCommandError(output, context);
  }
  const contents: ListPolicyVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    policyVersions: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.policyVersions !== undefined && data.policyVersions !== null) {
    contents.policyVersions = deserializeAws_restJson1PolicyVersions(data.policyVersions, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListPolicyVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPolicyVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListPrincipalPoliciesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPrincipalPoliciesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListPrincipalPoliciesCommandError(output, context);
  }
  const contents: ListPrincipalPoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextMarker: undefined,
    policies: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  if (data.policies !== undefined && data.policies !== null) {
    contents.policies = deserializeAws_restJson1Policies(data.policies, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListPrincipalPoliciesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPrincipalPoliciesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListPrincipalThingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPrincipalThingsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListPrincipalThingsCommandError(output, context);
  }
  const contents: ListPrincipalThingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    things: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.things !== undefined && data.things !== null) {
    contents.things = deserializeAws_restJson1ThingNameList(data.things, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListPrincipalThingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListPrincipalThingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListProvisioningTemplatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListProvisioningTemplatesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListProvisioningTemplatesCommandError(output, context);
  }
  const contents: ListProvisioningTemplatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    templates: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.templates !== undefined && data.templates !== null) {
    contents.templates = deserializeAws_restJson1ProvisioningTemplateListing(data.templates, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListProvisioningTemplatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListProvisioningTemplatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListProvisioningTemplateVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListProvisioningTemplateVersionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListProvisioningTemplateVersionsCommandError(output, context);
  }
  const contents: ListProvisioningTemplateVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    versions: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.versions !== undefined && data.versions !== null) {
    contents.versions = deserializeAws_restJson1ProvisioningTemplateVersionListing(data.versions, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListProvisioningTemplateVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListProvisioningTemplateVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListRoleAliasesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRoleAliasesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListRoleAliasesCommandError(output, context);
  }
  const contents: ListRoleAliasesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextMarker: undefined,
    roleAliases: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  if (data.roleAliases !== undefined && data.roleAliases !== null) {
    contents.roleAliases = deserializeAws_restJson1RoleAliases(data.roleAliases, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListRoleAliasesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListRoleAliasesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListScheduledAuditsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListScheduledAuditsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListScheduledAuditsCommandError(output, context);
  }
  const contents: ListScheduledAuditsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    scheduledAudits: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.scheduledAudits !== undefined && data.scheduledAudits !== null) {
    contents.scheduledAudits = deserializeAws_restJson1ScheduledAuditMetadataList(data.scheduledAudits, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListScheduledAuditsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListScheduledAuditsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListSecurityProfilesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSecurityProfilesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListSecurityProfilesCommandError(output, context);
  }
  const contents: ListSecurityProfilesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    securityProfileIdentifiers: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.securityProfileIdentifiers !== undefined && data.securityProfileIdentifiers !== null) {
    contents.securityProfileIdentifiers = deserializeAws_restJson1SecurityProfileIdentifiers(
      data.securityProfileIdentifiers,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListSecurityProfilesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSecurityProfilesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListSecurityProfilesForTargetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSecurityProfilesForTargetCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListSecurityProfilesForTargetCommandError(output, context);
  }
  const contents: ListSecurityProfilesForTargetCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    securityProfileTargetMappings: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.securityProfileTargetMappings !== undefined && data.securityProfileTargetMappings !== null) {
    contents.securityProfileTargetMappings = deserializeAws_restJson1SecurityProfileTargetMappings(
      data.securityProfileTargetMappings,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListSecurityProfilesForTargetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListSecurityProfilesForTargetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListStreamsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListStreamsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListStreamsCommandError(output, context);
  }
  const contents: ListStreamsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    streams: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.streams !== undefined && data.streams !== null) {
    contents.streams = deserializeAws_restJson1StreamsSummary(data.streams, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListStreamsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListStreamsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListTagsForResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListTagsForResourceCommandError(output, context);
  }
  const contents: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    tags: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.tags !== undefined && data.tags !== null) {
    contents.tags = deserializeAws_restJson1TagList(data.tags, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListTagsForResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListTargetsForPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTargetsForPolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListTargetsForPolicyCommandError(output, context);
  }
  const contents: ListTargetsForPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextMarker: undefined,
    targets: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextMarker !== undefined && data.nextMarker !== null) {
    contents.nextMarker = __expectString(data.nextMarker);
  }
  if (data.targets !== undefined && data.targets !== null) {
    contents.targets = deserializeAws_restJson1PolicyTargets(data.targets, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListTargetsForPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTargetsForPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListTargetsForSecurityProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTargetsForSecurityProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListTargetsForSecurityProfileCommandError(output, context);
  }
  const contents: ListTargetsForSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    securityProfileTargets: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.securityProfileTargets !== undefined && data.securityProfileTargets !== null) {
    contents.securityProfileTargets = deserializeAws_restJson1SecurityProfileTargets(
      data.securityProfileTargets,
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListTargetsForSecurityProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTargetsForSecurityProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListThingGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingGroupsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListThingGroupsCommandError(output, context);
  }
  const contents: ListThingGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    thingGroups: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.thingGroups !== undefined && data.thingGroups !== null) {
    contents.thingGroups = deserializeAws_restJson1ThingGroupNameAndArnList(data.thingGroups, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListThingGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListThingGroupsForThingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingGroupsForThingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListThingGroupsForThingCommandError(output, context);
  }
  const contents: ListThingGroupsForThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    thingGroups: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.thingGroups !== undefined && data.thingGroups !== null) {
    contents.thingGroups = deserializeAws_restJson1ThingGroupNameAndArnList(data.thingGroups, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListThingGroupsForThingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingGroupsForThingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListThingPrincipalsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingPrincipalsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListThingPrincipalsCommandError(output, context);
  }
  const contents: ListThingPrincipalsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    principals: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.principals !== undefined && data.principals !== null) {
    contents.principals = deserializeAws_restJson1Principals(data.principals, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListThingPrincipalsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingPrincipalsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListThingRegistrationTaskReportsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingRegistrationTaskReportsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListThingRegistrationTaskReportsCommandError(output, context);
  }
  const contents: ListThingRegistrationTaskReportsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    reportType: undefined,
    resourceLinks: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.reportType !== undefined && data.reportType !== null) {
    contents.reportType = __expectString(data.reportType);
  }
  if (data.resourceLinks !== undefined && data.resourceLinks !== null) {
    contents.resourceLinks = deserializeAws_restJson1S3FileUrlList(data.resourceLinks, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListThingRegistrationTaskReportsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingRegistrationTaskReportsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListThingRegistrationTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingRegistrationTasksCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListThingRegistrationTasksCommandError(output, context);
  }
  const contents: ListThingRegistrationTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    taskIds: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.taskIds !== undefined && data.taskIds !== null) {
    contents.taskIds = deserializeAws_restJson1TaskIdList(data.taskIds, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListThingRegistrationTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingRegistrationTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListThingsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListThingsCommandError(output, context);
  }
  const contents: ListThingsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    things: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.things !== undefined && data.things !== null) {
    contents.things = deserializeAws_restJson1ThingAttributeList(data.things, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListThingsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListThingsInBillingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsInBillingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListThingsInBillingGroupCommandError(output, context);
  }
  const contents: ListThingsInBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    things: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.things !== undefined && data.things !== null) {
    contents.things = deserializeAws_restJson1ThingNameList(data.things, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListThingsInBillingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsInBillingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListThingsInThingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsInThingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListThingsInThingGroupCommandError(output, context);
  }
  const contents: ListThingsInThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    things: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.things !== undefined && data.things !== null) {
    contents.things = deserializeAws_restJson1ThingNameList(data.things, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListThingsInThingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingsInThingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListThingTypesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingTypesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListThingTypesCommandError(output, context);
  }
  const contents: ListThingTypesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    thingTypes: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.thingTypes !== undefined && data.thingTypes !== null) {
    contents.thingTypes = deserializeAws_restJson1ThingTypeList(data.thingTypes, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListThingTypesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListThingTypesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListTopicRuleDestinationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicRuleDestinationsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListTopicRuleDestinationsCommandError(output, context);
  }
  const contents: ListTopicRuleDestinationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    destinationSummaries: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.destinationSummaries !== undefined && data.destinationSummaries !== null) {
    contents.destinationSummaries = deserializeAws_restJson1TopicRuleDestinationSummaries(
      data.destinationSummaries,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListTopicRuleDestinationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicRuleDestinationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListTopicRulesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicRulesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListTopicRulesCommandError(output, context);
  }
  const contents: ListTopicRulesCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    rules: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.rules !== undefined && data.rules !== null) {
    contents.rules = deserializeAws_restJson1TopicRuleList(data.rules, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListTopicRulesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTopicRulesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListV2LoggingLevelsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListV2LoggingLevelsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListV2LoggingLevelsCommandError(output, context);
  }
  const contents: ListV2LoggingLevelsCommandOutput = {
    $metadata: deserializeMetadata(output),
    logTargetConfigurations: undefined,
    nextToken: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.logTargetConfigurations !== undefined && data.logTargetConfigurations !== null) {
    contents.logTargetConfigurations = deserializeAws_restJson1LogTargetConfigurations(
      data.logTargetConfigurations,
      context
    );
  }
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListV2LoggingLevelsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListV2LoggingLevelsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotConfiguredException":
    case "com.amazonaws.iot#NotConfiguredException":
      response = {
        ...(await deserializeAws_restJson1NotConfiguredExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ListViolationEventsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListViolationEventsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ListViolationEventsCommandError(output, context);
  }
  const contents: ListViolationEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    violationEvents: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.violationEvents !== undefined && data.violationEvents !== null) {
    contents.violationEvents = deserializeAws_restJson1ViolationEvents(data.violationEvents, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ListViolationEventsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListViolationEventsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1RegisterCACertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCACertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RegisterCACertificateCommandError(output, context);
  }
  const contents: RegisterCACertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    certificateArn: undefined,
    certificateId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = __expectString(data.certificateArn);
  }
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = __expectString(data.certificateId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1RegisterCACertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCACertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateValidationException":
    case "com.amazonaws.iot#CertificateValidationException":
      response = {
        ...(await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "RegistrationCodeValidationException":
    case "com.amazonaws.iot#RegistrationCodeValidationException":
      response = {
        ...(await deserializeAws_restJson1RegistrationCodeValidationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1RegisterCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RegisterCertificateCommandError(output, context);
  }
  const contents: RegisterCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    certificateArn: undefined,
    certificateId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = __expectString(data.certificateArn);
  }
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = __expectString(data.certificateId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1RegisterCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateConflictException":
    case "com.amazonaws.iot#CertificateConflictException":
      response = {
        ...(await deserializeAws_restJson1CertificateConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CertificateStateException":
    case "com.amazonaws.iot#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CertificateValidationException":
    case "com.amazonaws.iot#CertificateValidationException":
      response = {
        ...(await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1RegisterCertificateWithoutCACommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCertificateWithoutCACommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RegisterCertificateWithoutCACommandError(output, context);
  }
  const contents: RegisterCertificateWithoutCACommandOutput = {
    $metadata: deserializeMetadata(output),
    certificateArn: undefined,
    certificateId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificateArn !== undefined && data.certificateArn !== null) {
    contents.certificateArn = __expectString(data.certificateArn);
  }
  if (data.certificateId !== undefined && data.certificateId !== null) {
    contents.certificateId = __expectString(data.certificateId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1RegisterCertificateWithoutCACommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterCertificateWithoutCACommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateStateException":
    case "com.amazonaws.iot#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "CertificateValidationException":
    case "com.amazonaws.iot#CertificateValidationException":
      response = {
        ...(await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1RegisterThingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterThingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RegisterThingCommandError(output, context);
  }
  const contents: RegisterThingCommandOutput = {
    $metadata: deserializeMetadata(output),
    certificatePem: undefined,
    resourceArns: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.certificatePem !== undefined && data.certificatePem !== null) {
    contents.certificatePem = __expectString(data.certificatePem);
  }
  if (data.resourceArns !== undefined && data.resourceArns !== null) {
    contents.resourceArns = deserializeAws_restJson1ResourceArns(data.resourceArns, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1RegisterThingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RegisterThingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceRegistrationFailureException":
    case "com.amazonaws.iot#ResourceRegistrationFailureException":
      response = {
        ...(await deserializeAws_restJson1ResourceRegistrationFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1RejectCertificateTransferCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectCertificateTransferCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RejectCertificateTransferCommandError(output, context);
  }
  const contents: RejectCertificateTransferCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1RejectCertificateTransferCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RejectCertificateTransferCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TransferAlreadyCompletedException":
    case "com.amazonaws.iot#TransferAlreadyCompletedException":
      response = {
        ...(await deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1RemoveThingFromBillingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveThingFromBillingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RemoveThingFromBillingGroupCommandError(output, context);
  }
  const contents: RemoveThingFromBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1RemoveThingFromBillingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveThingFromBillingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1RemoveThingFromThingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveThingFromThingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1RemoveThingFromThingGroupCommandError(output, context);
  }
  const contents: RemoveThingFromThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1RemoveThingFromThingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveThingFromThingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ReplaceTopicRuleCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceTopicRuleCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ReplaceTopicRuleCommandError(output, context);
  }
  const contents: ReplaceTopicRuleCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ReplaceTopicRuleCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReplaceTopicRuleCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "SqlParseException":
    case "com.amazonaws.iot#SqlParseException":
      response = {
        ...(await deserializeAws_restJson1SqlParseExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1SearchIndexCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchIndexCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1SearchIndexCommandError(output, context);
  }
  const contents: SearchIndexCommandOutput = {
    $metadata: deserializeMetadata(output),
    nextToken: undefined,
    thingGroups: undefined,
    things: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.nextToken !== undefined && data.nextToken !== null) {
    contents.nextToken = __expectString(data.nextToken);
  }
  if (data.thingGroups !== undefined && data.thingGroups !== null) {
    contents.thingGroups = deserializeAws_restJson1ThingGroupDocumentList(data.thingGroups, context);
  }
  if (data.things !== undefined && data.things !== null) {
    contents.things = deserializeAws_restJson1ThingDocumentList(data.things, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1SearchIndexCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SearchIndexCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IndexNotReadyException":
    case "com.amazonaws.iot#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1SetDefaultAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetDefaultAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1SetDefaultAuthorizerCommandError(output, context);
  }
  const contents: SetDefaultAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    authorizerArn: undefined,
    authorizerName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.authorizerArn !== undefined && data.authorizerArn !== null) {
    contents.authorizerArn = __expectString(data.authorizerArn);
  }
  if (data.authorizerName !== undefined && data.authorizerName !== null) {
    contents.authorizerName = __expectString(data.authorizerName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1SetDefaultAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetDefaultAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceAlreadyExistsException":
    case "com.amazonaws.iot#ResourceAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1SetDefaultPolicyVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetDefaultPolicyVersionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1SetDefaultPolicyVersionCommandError(output, context);
  }
  const contents: SetDefaultPolicyVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1SetDefaultPolicyVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetDefaultPolicyVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1SetLoggingOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetLoggingOptionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1SetLoggingOptionsCommandError(output, context);
  }
  const contents: SetLoggingOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1SetLoggingOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetLoggingOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1SetV2LoggingLevelCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetV2LoggingLevelCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1SetV2LoggingLevelCommandError(output, context);
  }
  const contents: SetV2LoggingLevelCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1SetV2LoggingLevelCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetV2LoggingLevelCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "NotConfiguredException":
    case "com.amazonaws.iot#NotConfiguredException":
      response = {
        ...(await deserializeAws_restJson1NotConfiguredExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1SetV2LoggingOptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetV2LoggingOptionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1SetV2LoggingOptionsCommandError(output, context);
  }
  const contents: SetV2LoggingOptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1SetV2LoggingOptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<SetV2LoggingOptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1StartAuditMitigationActionsTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartAuditMitigationActionsTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1StartAuditMitigationActionsTaskCommandError(output, context);
  }
  const contents: StartAuditMitigationActionsTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    taskId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.taskId !== undefined && data.taskId !== null) {
    contents.taskId = __expectString(data.taskId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1StartAuditMitigationActionsTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartAuditMitigationActionsTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TaskAlreadyExistsException":
    case "com.amazonaws.iot#TaskAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1TaskAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1StartDetectMitigationActionsTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDetectMitigationActionsTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1StartDetectMitigationActionsTaskCommandError(output, context);
  }
  const contents: StartDetectMitigationActionsTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    taskId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.taskId !== undefined && data.taskId !== null) {
    contents.taskId = __expectString(data.taskId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1StartDetectMitigationActionsTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartDetectMitigationActionsTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TaskAlreadyExistsException":
    case "com.amazonaws.iot#TaskAlreadyExistsException":
      response = {
        ...(await deserializeAws_restJson1TaskAlreadyExistsExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1StartOnDemandAuditTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartOnDemandAuditTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1StartOnDemandAuditTaskCommandError(output, context);
  }
  const contents: StartOnDemandAuditTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    taskId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.taskId !== undefined && data.taskId !== null) {
    contents.taskId = __expectString(data.taskId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1StartOnDemandAuditTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartOnDemandAuditTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1StartThingRegistrationTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartThingRegistrationTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1StartThingRegistrationTaskCommandError(output, context);
  }
  const contents: StartThingRegistrationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    taskId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.taskId !== undefined && data.taskId !== null) {
    contents.taskId = __expectString(data.taskId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1StartThingRegistrationTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartThingRegistrationTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1StopThingRegistrationTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopThingRegistrationTaskCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1StopThingRegistrationTaskCommandError(output, context);
  }
  const contents: StopThingRegistrationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1StopThingRegistrationTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopThingRegistrationTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1TagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1TagResourceCommandError(output, context);
  }
  const contents: TagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1TagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1TestAuthorizationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestAuthorizationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1TestAuthorizationCommandError(output, context);
  }
  const contents: TestAuthorizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    authResults: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.authResults !== undefined && data.authResults !== null) {
    contents.authResults = deserializeAws_restJson1AuthResults(data.authResults, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1TestAuthorizationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestAuthorizationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1TestInvokeAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestInvokeAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1TestInvokeAuthorizerCommandError(output, context);
  }
  const contents: TestInvokeAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    disconnectAfterInSeconds: undefined,
    isAuthenticated: undefined,
    policyDocuments: undefined,
    principalId: undefined,
    refreshAfterInSeconds: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.disconnectAfterInSeconds !== undefined && data.disconnectAfterInSeconds !== null) {
    contents.disconnectAfterInSeconds = __expectInt32(data.disconnectAfterInSeconds);
  }
  if (data.isAuthenticated !== undefined && data.isAuthenticated !== null) {
    contents.isAuthenticated = __expectBoolean(data.isAuthenticated);
  }
  if (data.policyDocuments !== undefined && data.policyDocuments !== null) {
    contents.policyDocuments = deserializeAws_restJson1PolicyDocuments(data.policyDocuments, context);
  }
  if (data.principalId !== undefined && data.principalId !== null) {
    contents.principalId = __expectString(data.principalId);
  }
  if (data.refreshAfterInSeconds !== undefined && data.refreshAfterInSeconds !== null) {
    contents.refreshAfterInSeconds = __expectInt32(data.refreshAfterInSeconds);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1TestInvokeAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestInvokeAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidResponseException":
    case "com.amazonaws.iot#InvalidResponseException":
      response = {
        ...(await deserializeAws_restJson1InvalidResponseExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1TransferCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TransferCertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1TransferCertificateCommandError(output, context);
  }
  const contents: TransferCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    transferredCertificateArn: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.transferredCertificateArn !== undefined && data.transferredCertificateArn !== null) {
    contents.transferredCertificateArn = __expectString(data.transferredCertificateArn);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1TransferCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TransferCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateStateException":
    case "com.amazonaws.iot#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "TransferConflictException":
    case "com.amazonaws.iot#TransferConflictException":
      response = {
        ...(await deserializeAws_restJson1TransferConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UntagResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UntagResourceCommandError(output, context);
  }
  const contents: UntagResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UntagResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UntagResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateAccountAuditConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountAuditConfigurationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateAccountAuditConfigurationCommandError(output, context);
  }
  const contents: UpdateAccountAuditConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateAccountAuditConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAccountAuditConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateAuditSuppressionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAuditSuppressionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateAuditSuppressionCommandError(output, context);
  }
  const contents: UpdateAuditSuppressionCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateAuditSuppressionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAuditSuppressionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateAuthorizerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAuthorizerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateAuthorizerCommandError(output, context);
  }
  const contents: UpdateAuthorizerCommandOutput = {
    $metadata: deserializeMetadata(output),
    authorizerArn: undefined,
    authorizerName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.authorizerArn !== undefined && data.authorizerArn !== null) {
    contents.authorizerArn = __expectString(data.authorizerArn);
  }
  if (data.authorizerName !== undefined && data.authorizerName !== null) {
    contents.authorizerName = __expectString(data.authorizerName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateAuthorizerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateAuthorizerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "LimitExceededException":
    case "com.amazonaws.iot#LimitExceededException":
      response = {
        ...(await deserializeAws_restJson1LimitExceededExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateBillingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBillingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateBillingGroupCommandError(output, context);
  }
  const contents: UpdateBillingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    version: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.version !== undefined && data.version !== null) {
    contents.version = __expectLong(data.version);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateBillingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateBillingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateCACertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCACertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateCACertificateCommandError(output, context);
  }
  const contents: UpdateCACertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateCACertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCACertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCertificateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateCertificateCommandError(output, context);
  }
  const contents: UpdateCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateStateException":
    case "com.amazonaws.iot#CertificateStateException":
      response = {
        ...(await deserializeAws_restJson1CertificateStateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateCustomMetricCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCustomMetricCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateCustomMetricCommandError(output, context);
  }
  const contents: UpdateCustomMetricCommandOutput = {
    $metadata: deserializeMetadata(output),
    creationDate: undefined,
    displayName: undefined,
    lastModifiedDate: undefined,
    metricArn: undefined,
    metricName: undefined,
    metricType: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.displayName !== undefined && data.displayName !== null) {
    contents.displayName = __expectString(data.displayName);
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.metricArn !== undefined && data.metricArn !== null) {
    contents.metricArn = __expectString(data.metricArn);
  }
  if (data.metricName !== undefined && data.metricName !== null) {
    contents.metricName = __expectString(data.metricName);
  }
  if (data.metricType !== undefined && data.metricType !== null) {
    contents.metricType = __expectString(data.metricType);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateCustomMetricCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateCustomMetricCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateDimensionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDimensionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateDimensionCommandError(output, context);
  }
  const contents: UpdateDimensionCommandOutput = {
    $metadata: deserializeMetadata(output),
    arn: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    name: undefined,
    stringValues: undefined,
    type: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.arn !== undefined && data.arn !== null) {
    contents.arn = __expectString(data.arn);
  }
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.name !== undefined && data.name !== null) {
    contents.name = __expectString(data.name);
  }
  if (data.stringValues !== undefined && data.stringValues !== null) {
    contents.stringValues = deserializeAws_restJson1DimensionStringValues(data.stringValues, context);
  }
  if (data.type !== undefined && data.type !== null) {
    contents.type = __expectString(data.type);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateDimensionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDimensionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateDomainConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDomainConfigurationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateDomainConfigurationCommandError(output, context);
  }
  const contents: UpdateDomainConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
    domainConfigurationArn: undefined,
    domainConfigurationName: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.domainConfigurationArn !== undefined && data.domainConfigurationArn !== null) {
    contents.domainConfigurationArn = __expectString(data.domainConfigurationArn);
  }
  if (data.domainConfigurationName !== undefined && data.domainConfigurationName !== null) {
    contents.domainConfigurationName = __expectString(data.domainConfigurationName);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateDomainConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDomainConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "CertificateValidationException":
    case "com.amazonaws.iot#CertificateValidationException":
      response = {
        ...(await deserializeAws_restJson1CertificateValidationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateDynamicThingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDynamicThingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateDynamicThingGroupCommandError(output, context);
  }
  const contents: UpdateDynamicThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    version: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.version !== undefined && data.version !== null) {
    contents.version = __expectLong(data.version);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateDynamicThingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateDynamicThingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateEventConfigurationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEventConfigurationsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateEventConfigurationsCommandError(output, context);
  }
  const contents: UpdateEventConfigurationsCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateEventConfigurationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateEventConfigurationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateFleetMetricCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFleetMetricCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateFleetMetricCommandError(output, context);
  }
  const contents: UpdateFleetMetricCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateFleetMetricCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateFleetMetricCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IndexNotReadyException":
    case "com.amazonaws.iot#IndexNotReadyException":
      response = {
        ...(await deserializeAws_restJson1IndexNotReadyExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidAggregationException":
    case "com.amazonaws.iot#InvalidAggregationException":
      response = {
        ...(await deserializeAws_restJson1InvalidAggregationExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidQueryException":
    case "com.amazonaws.iot#InvalidQueryException":
      response = {
        ...(await deserializeAws_restJson1InvalidQueryExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateIndexingConfigurationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIndexingConfigurationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateIndexingConfigurationCommandError(output, context);
  }
  const contents: UpdateIndexingConfigurationCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateIndexingConfigurationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateIndexingConfigurationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateJobCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateJobCommandError(output, context);
  }
  const contents: UpdateJobCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateJobCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateJobCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateMitigationActionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMitigationActionCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateMitigationActionCommandError(output, context);
  }
  const contents: UpdateMitigationActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    actionArn: undefined,
    actionId: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.actionArn !== undefined && data.actionArn !== null) {
    contents.actionArn = __expectString(data.actionArn);
  }
  if (data.actionId !== undefined && data.actionId !== null) {
    contents.actionId = __expectString(data.actionId);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateMitigationActionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateMitigationActionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateProvisioningTemplateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateProvisioningTemplateCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateProvisioningTemplateCommandError(output, context);
  }
  const contents: UpdateProvisioningTemplateCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateProvisioningTemplateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateProvisioningTemplateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateRoleAliasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRoleAliasCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateRoleAliasCommandError(output, context);
  }
  const contents: UpdateRoleAliasCommandOutput = {
    $metadata: deserializeMetadata(output),
    roleAlias: undefined,
    roleAliasArn: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.roleAlias !== undefined && data.roleAlias !== null) {
    contents.roleAlias = __expectString(data.roleAlias);
  }
  if (data.roleAliasArn !== undefined && data.roleAliasArn !== null) {
    contents.roleAliasArn = __expectString(data.roleAliasArn);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateRoleAliasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateRoleAliasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateScheduledAuditCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateScheduledAuditCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateScheduledAuditCommandError(output, context);
  }
  const contents: UpdateScheduledAuditCommandOutput = {
    $metadata: deserializeMetadata(output),
    scheduledAuditArn: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.scheduledAuditArn !== undefined && data.scheduledAuditArn !== null) {
    contents.scheduledAuditArn = __expectString(data.scheduledAuditArn);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateScheduledAuditCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateScheduledAuditCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateSecurityProfileCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSecurityProfileCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateSecurityProfileCommandError(output, context);
  }
  const contents: UpdateSecurityProfileCommandOutput = {
    $metadata: deserializeMetadata(output),
    additionalMetricsToRetain: undefined,
    additionalMetricsToRetainV2: undefined,
    alertTargets: undefined,
    behaviors: undefined,
    creationDate: undefined,
    lastModifiedDate: undefined,
    securityProfileArn: undefined,
    securityProfileDescription: undefined,
    securityProfileName: undefined,
    version: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.additionalMetricsToRetain !== undefined && data.additionalMetricsToRetain !== null) {
    contents.additionalMetricsToRetain = deserializeAws_restJson1AdditionalMetricsToRetainList(
      data.additionalMetricsToRetain,
      context
    );
  }
  if (data.additionalMetricsToRetainV2 !== undefined && data.additionalMetricsToRetainV2 !== null) {
    contents.additionalMetricsToRetainV2 = deserializeAws_restJson1AdditionalMetricsToRetainV2List(
      data.additionalMetricsToRetainV2,
      context
    );
  }
  if (data.alertTargets !== undefined && data.alertTargets !== null) {
    contents.alertTargets = deserializeAws_restJson1AlertTargets(data.alertTargets, context);
  }
  if (data.behaviors !== undefined && data.behaviors !== null) {
    contents.behaviors = deserializeAws_restJson1Behaviors(data.behaviors, context);
  }
  if (data.creationDate !== undefined && data.creationDate !== null) {
    contents.creationDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.creationDate)));
  }
  if (data.lastModifiedDate !== undefined && data.lastModifiedDate !== null) {
    contents.lastModifiedDate = __expectNonNull(__parseEpochTimestamp(__expectNumber(data.lastModifiedDate)));
  }
  if (data.securityProfileArn !== undefined && data.securityProfileArn !== null) {
    contents.securityProfileArn = __expectString(data.securityProfileArn);
  }
  if (data.securityProfileDescription !== undefined && data.securityProfileDescription !== null) {
    contents.securityProfileDescription = __expectString(data.securityProfileDescription);
  }
  if (data.securityProfileName !== undefined && data.securityProfileName !== null) {
    contents.securityProfileName = __expectString(data.securityProfileName);
  }
  if (data.version !== undefined && data.version !== null) {
    contents.version = __expectLong(data.version);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateSecurityProfileCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateSecurityProfileCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateStreamCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStreamCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateStreamCommandError(output, context);
  }
  const contents: UpdateStreamCommandOutput = {
    $metadata: deserializeMetadata(output),
    description: undefined,
    streamArn: undefined,
    streamId: undefined,
    streamVersion: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.description !== undefined && data.description !== null) {
    contents.description = __expectString(data.description);
  }
  if (data.streamArn !== undefined && data.streamArn !== null) {
    contents.streamArn = __expectString(data.streamArn);
  }
  if (data.streamId !== undefined && data.streamId !== null) {
    contents.streamId = __expectString(data.streamId);
  }
  if (data.streamVersion !== undefined && data.streamVersion !== null) {
    contents.streamVersion = __expectInt32(data.streamVersion);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateStreamCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateStreamCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateThingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateThingCommandError(output, context);
  }
  const contents: UpdateThingCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateThingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateThingGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingGroupCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateThingGroupCommandError(output, context);
  }
  const contents: UpdateThingGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    version: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.version !== undefined && data.version !== null) {
    contents.version = __expectLong(data.version);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateThingGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "VersionConflictException":
    case "com.amazonaws.iot#VersionConflictException":
      response = {
        ...(await deserializeAws_restJson1VersionConflictExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateThingGroupsForThingCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingGroupsForThingCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateThingGroupsForThingCommandError(output, context);
  }
  const contents: UpdateThingGroupsForThingCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateThingGroupsForThingCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateThingGroupsForThingCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ResourceNotFoundException":
    case "com.amazonaws.iot#ResourceNotFoundException":
      response = {
        ...(await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1UpdateTopicRuleDestinationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTopicRuleDestinationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1UpdateTopicRuleDestinationCommandError(output, context);
  }
  const contents: UpdateTopicRuleDestinationCommandOutput = {
    $metadata: deserializeMetadata(output),
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restJson1UpdateTopicRuleDestinationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTopicRuleDestinationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingResourceUpdateException":
    case "com.amazonaws.iot#ConflictingResourceUpdateException":
      response = {
        ...(await deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InternalException":
    case "com.amazonaws.iot#InternalException":
      response = {
        ...(await deserializeAws_restJson1InternalExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ServiceUnavailableException":
    case "com.amazonaws.iot#ServiceUnavailableException":
      response = {
        ...(await deserializeAws_restJson1ServiceUnavailableExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "UnauthorizedException":
    case "com.amazonaws.iot#UnauthorizedException":
      response = {
        ...(await deserializeAws_restJson1UnauthorizedExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ValidateSecurityProfileBehaviorsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 300) {
    return deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommandError(output, context);
  }
  const contents: ValidateSecurityProfileBehaviorsCommandOutput = {
    $metadata: deserializeMetadata(output),
    valid: undefined,
    validationErrors: undefined,
  };
  const data: { [key: string]: any } = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
  if (data.valid !== undefined && data.valid !== null) {
    contents.valid = __expectBoolean(data.valid);
  }
  if (data.validationErrors !== undefined && data.validationErrors !== null) {
    contents.validationErrors = deserializeAws_restJson1ValidationErrors(data.validationErrors, context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restJson1ValidateSecurityProfileBehaviorsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ValidateSecurityProfileBehaviorsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context),
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InternalFailureException":
    case "com.amazonaws.iot#InternalFailureException":
      response = {
        ...(await deserializeAws_restJson1InternalFailureExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "InvalidRequestException":
    case "com.amazonaws.iot#InvalidRequestException":
      response = {
        ...(await deserializeAws_restJson1InvalidRequestExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.iot#ThrottlingException":
      response = {
        ...(await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context)),
        name: errorCode,
        $metadata: deserializeMetadata(output),
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output),
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_restJson1CertificateConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CertificateConflictException> => {
  const contents: CertificateConflictException = {
    name: "CertificateConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1CertificateStateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CertificateStateException> => {
  const contents: CertificateStateException = {
    name: "CertificateStateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1CertificateValidationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<CertificateValidationException> => {
  const contents: CertificateValidationException = {
    name: "CertificateValidationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1ConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConflictException> => {
  const contents: ConflictException = {
    name: "ConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1ConflictingResourceUpdateExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConflictingResourceUpdateException> => {
  const contents: ConflictingResourceUpdateException = {
    name: "ConflictingResourceUpdateException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1DeleteConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DeleteConflictException> => {
  const contents: DeleteConflictException = {
    name: "DeleteConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1IndexNotReadyExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IndexNotReadyException> => {
  const contents: IndexNotReadyException = {
    name: "IndexNotReadyException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1InternalExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InternalException> => {
  const contents: InternalException = {
    name: "InternalException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1InternalFailureExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InternalFailureException> => {
  const contents: InternalFailureException = {
    name: "InternalFailureException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1InvalidAggregationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidAggregationException> => {
  const contents: InvalidAggregationException = {
    name: "InvalidAggregationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1InvalidQueryExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidQueryException> => {
  const contents: InvalidQueryException = {
    name: "InvalidQueryException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1InvalidRequestExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidRequestException> => {
  const contents: InvalidRequestException = {
    name: "InvalidRequestException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1InvalidResponseExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidResponseException> => {
  const contents: InvalidResponseException = {
    name: "InvalidResponseException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1InvalidStateTransitionExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidStateTransitionException> => {
  const contents: InvalidStateTransitionException = {
    name: "InvalidStateTransitionException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1LimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<LimitExceededException> => {
  const contents: LimitExceededException = {
    name: "LimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1MalformedPolicyExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<MalformedPolicyException> => {
  const contents: MalformedPolicyException = {
    name: "MalformedPolicyException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1NotConfiguredExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NotConfiguredException> => {
  const contents: NotConfiguredException = {
    name: "NotConfiguredException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1RegistrationCodeValidationExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<RegistrationCodeValidationException> => {
  const contents: RegistrationCodeValidationException = {
    name: "RegistrationCodeValidationException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1ResourceAlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceAlreadyExistsException> => {
  const contents: ResourceAlreadyExistsException = {
    name: "ResourceAlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
    resourceArn: undefined,
    resourceId: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  if (data.resourceArn !== undefined && data.resourceArn !== null) {
    contents.resourceArn = __expectString(data.resourceArn);
  }
  if (data.resourceId !== undefined && data.resourceId !== null) {
    contents.resourceId = __expectString(data.resourceId);
  }
  return contents;
};

const deserializeAws_restJson1ResourceNotFoundExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNotFoundException> => {
  const contents: ResourceNotFoundException = {
    name: "ResourceNotFoundException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1ResourceRegistrationFailureExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceRegistrationFailureException> => {
  const contents: ResourceRegistrationFailureException = {
    name: "ResourceRegistrationFailureException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1ServiceUnavailableExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ServiceUnavailableException> => {
  const contents: ServiceUnavailableException = {
    name: "ServiceUnavailableException",
    $fault: "server",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1SqlParseExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SqlParseException> => {
  const contents: SqlParseException = {
    name: "SqlParseException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1TaskAlreadyExistsExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TaskAlreadyExistsException> => {
  const contents: TaskAlreadyExistsException = {
    name: "TaskAlreadyExistsException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1ThrottlingExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ThrottlingException> => {
  const contents: ThrottlingException = {
    name: "ThrottlingException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1TransferAlreadyCompletedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TransferAlreadyCompletedException> => {
  const contents: TransferAlreadyCompletedException = {
    name: "TransferAlreadyCompletedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1TransferConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TransferConflictException> => {
  const contents: TransferConflictException = {
    name: "TransferConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1UnauthorizedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UnauthorizedException> => {
  const contents: UnauthorizedException = {
    name: "UnauthorizedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1VersionConflictExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<VersionConflictException> => {
  const contents: VersionConflictException = {
    name: "VersionConflictException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const deserializeAws_restJson1VersionsLimitExceededExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<VersionsLimitExceededException> => {
  const contents: VersionsLimitExceededException = {
    name: "VersionsLimitExceededException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
  };
  const data: any = parsedOutput.body;
  if (data.message !== undefined && data.message !== null) {
    contents.message = __expectString(data.message);
  }
  return contents;
};

const serializeAws_restJson1AbortConfig = (input: AbortConfig, context: __SerdeContext): any => {
  return {
    ...(input.criteriaList !== undefined &&
      input.criteriaList !== null && {
        criteriaList: serializeAws_restJson1AbortCriteriaList(input.criteriaList, context),
      }),
  };
};

const serializeAws_restJson1AbortCriteria = (input: AbortCriteria, context: __SerdeContext): any => {
  return {
    ...(input.action !== undefined && input.action !== null && { action: input.action }),
    ...(input.failureType !== undefined && input.failureType !== null && { failureType: input.failureType }),
    ...(input.minNumberOfExecutedThings !== undefined &&
      input.minNumberOfExecutedThings !== null && { minNumberOfExecutedThings: input.minNumberOfExecutedThings }),
    ...(input.thresholdPercentage !== undefined &&
      input.thresholdPercentage !== null && { thresholdPercentage: __serializeFloat(input.thresholdPercentage) }),
  };
};

const serializeAws_restJson1AbortCriteriaList = (input: AbortCriteria[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1AbortCriteria(entry, context);
    });
};

const serializeAws_restJson1Action = (input: Action, context: __SerdeContext): any => {
  return {
    ...(input.cloudwatchAlarm !== undefined &&
      input.cloudwatchAlarm !== null && {
        cloudwatchAlarm: serializeAws_restJson1CloudwatchAlarmAction(input.cloudwatchAlarm, context),
      }),
    ...(input.cloudwatchLogs !== undefined &&
      input.cloudwatchLogs !== null && {
        cloudwatchLogs: serializeAws_restJson1CloudwatchLogsAction(input.cloudwatchLogs, context),
      }),
    ...(input.cloudwatchMetric !== undefined &&
      input.cloudwatchMetric !== null && {
        cloudwatchMetric: serializeAws_restJson1CloudwatchMetricAction(input.cloudwatchMetric, context),
      }),
    ...(input.dynamoDB !== undefined &&
      input.dynamoDB !== null && { dynamoDB: serializeAws_restJson1DynamoDBAction(input.dynamoDB, context) }),
    ...(input.dynamoDBv2 !== undefined &&
      input.dynamoDBv2 !== null && { dynamoDBv2: serializeAws_restJson1DynamoDBv2Action(input.dynamoDBv2, context) }),
    ...(input.elasticsearch !== undefined &&
      input.elasticsearch !== null && {
        elasticsearch: serializeAws_restJson1ElasticsearchAction(input.elasticsearch, context),
      }),
    ...(input.firehose !== undefined &&
      input.firehose !== null && { firehose: serializeAws_restJson1FirehoseAction(input.firehose, context) }),
    ...(input.http !== undefined &&
      input.http !== null && { http: serializeAws_restJson1HttpAction(input.http, context) }),
    ...(input.iotAnalytics !== undefined &&
      input.iotAnalytics !== null && {
        iotAnalytics: serializeAws_restJson1IotAnalyticsAction(input.iotAnalytics, context),
      }),
    ...(input.iotEvents !== undefined &&
      input.iotEvents !== null && { iotEvents: serializeAws_restJson1IotEventsAction(input.iotEvents, context) }),
    ...(input.iotSiteWise !== undefined &&
      input.iotSiteWise !== null && {
        iotSiteWise: serializeAws_restJson1IotSiteWiseAction(input.iotSiteWise, context),
      }),
    ...(input.kafka !== undefined &&
      input.kafka !== null && { kafka: serializeAws_restJson1KafkaAction(input.kafka, context) }),
    ...(input.kinesis !== undefined &&
      input.kinesis !== null && { kinesis: serializeAws_restJson1KinesisAction(input.kinesis, context) }),
    ...(input.lambda !== undefined &&
      input.lambda !== null && { lambda: serializeAws_restJson1LambdaAction(input.lambda, context) }),
    ...(input.openSearch !== undefined &&
      input.openSearch !== null && { openSearch: serializeAws_restJson1OpenSearchAction(input.openSearch, context) }),
    ...(input.republish !== undefined &&
      input.republish !== null && { republish: serializeAws_restJson1RepublishAction(input.republish, context) }),
    ...(input.s3 !== undefined && input.s3 !== null && { s3: serializeAws_restJson1S3Action(input.s3, context) }),
    ...(input.salesforce !== undefined &&
      input.salesforce !== null && { salesforce: serializeAws_restJson1SalesforceAction(input.salesforce, context) }),
    ...(input.sns !== undefined && input.sns !== null && { sns: serializeAws_restJson1SnsAction(input.sns, context) }),
    ...(input.sqs !== undefined && input.sqs !== null && { sqs: serializeAws_restJson1SqsAction(input.sqs, context) }),
    ...(input.stepFunctions !== undefined &&
      input.stepFunctions !== null && {
        stepFunctions: serializeAws_restJson1StepFunctionsAction(input.stepFunctions, context),
      }),
    ...(input.timestream !== undefined &&
      input.timestream !== null && { timestream: serializeAws_restJson1TimestreamAction(input.timestream, context) }),
  };
};

const serializeAws_restJson1ActionList = (input: Action[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1Action(entry, context);
    });
};

const serializeAws_restJson1AdditionalMetricsToRetainList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1AdditionalMetricsToRetainV2List = (
  input: MetricToRetain[],
  context: __SerdeContext
): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1MetricToRetain(entry, context);
    });
};

const serializeAws_restJson1AdditionalParameterMap = (
  input: { [key: string]: string },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: value,
    };
  }, {});
};

const serializeAws_restJson1AddThingsToThingGroupParams = (
  input: AddThingsToThingGroupParams,
  context: __SerdeContext
): any => {
  return {
    ...(input.overrideDynamicGroups !== undefined &&
      input.overrideDynamicGroups !== null && { overrideDynamicGroups: input.overrideDynamicGroups }),
    ...(input.thingGroupNames !== undefined &&
      input.thingGroupNames !== null && {
        thingGroupNames: serializeAws_restJson1ThingGroupNames(input.thingGroupNames, context),
      }),
  };
};

const serializeAws_restJson1AggregationType = (input: AggregationType, context: __SerdeContext): any => {
  return {
    ...(input.name !== undefined && input.name !== null && { name: input.name }),
    ...(input.values !== undefined &&
      input.values !== null && { values: serializeAws_restJson1AggregationTypeValues(input.values, context) }),
  };
};

const serializeAws_restJson1AggregationTypeValues = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1AlertTarget = (input: AlertTarget, context: __SerdeContext): any => {
  return {
    ...(input.alertTargetArn !== undefined &&
      input.alertTargetArn !== null && { alertTargetArn: input.alertTargetArn }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  };
};

const serializeAws_restJson1AlertTargets = (input: { [key: string]: AlertTarget }, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [AlertTargetType | string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: serializeAws_restJson1AlertTarget(value, context),
    };
  }, {});
};

const serializeAws_restJson1AssetPropertyTimestamp = (input: AssetPropertyTimestamp, context: __SerdeContext): any => {
  return {
    ...(input.offsetInNanos !== undefined && input.offsetInNanos !== null && { offsetInNanos: input.offsetInNanos }),
    ...(input.timeInSeconds !== undefined && input.timeInSeconds !== null && { timeInSeconds: input.timeInSeconds }),
  };
};

const serializeAws_restJson1AssetPropertyValue = (input: AssetPropertyValue, context: __SerdeContext): any => {
  return {
    ...(input.quality !== undefined && input.quality !== null && { quality: input.quality }),
    ...(input.timestamp !== undefined &&
      input.timestamp !== null && {
        timestamp: serializeAws_restJson1AssetPropertyTimestamp(input.timestamp, context),
      }),
    ...(input.value !== undefined &&
      input.value !== null && { value: serializeAws_restJson1AssetPropertyVariant(input.value, context) }),
  };
};

const serializeAws_restJson1AssetPropertyValueList = (input: AssetPropertyValue[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1AssetPropertyValue(entry, context);
    });
};

const serializeAws_restJson1AssetPropertyVariant = (input: AssetPropertyVariant, context: __SerdeContext): any => {
  return AssetPropertyVariant.visit(input, {
    booleanValue: (value) => ({ booleanValue: value }),
    doubleValue: (value) => ({ doubleValue: value }),
    integerValue: (value) => ({ integerValue: value }),
    stringValue: (value) => ({ stringValue: value }),
    _: (name, value) => ({ name: value } as any),
  });
};

const serializeAws_restJson1AttributePayload = (input: AttributePayload, context: __SerdeContext): any => {
  return {
    ...(input.attributes !== undefined &&
      input.attributes !== null && { attributes: serializeAws_restJson1Attributes(input.attributes, context) }),
    ...(input.merge !== undefined && input.merge !== null && { merge: input.merge }),
  };
};

const serializeAws_restJson1Attributes = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: value,
    };
  }, {});
};

const serializeAws_restJson1AttributesMap = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: value,
    };
  }, {});
};

const serializeAws_restJson1AuditCheckConfiguration = (
  input: AuditCheckConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.enabled !== undefined && input.enabled !== null && { enabled: input.enabled }),
  };
};

const serializeAws_restJson1AuditCheckConfigurations = (
  input: { [key: string]: AuditCheckConfiguration },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: serializeAws_restJson1AuditCheckConfiguration(value, context),
    };
  }, {});
};

const serializeAws_restJson1AuditCheckToActionsMapping = (
  input: { [key: string]: string[] },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: serializeAws_restJson1MitigationActionNameList(value, context),
    };
  }, {});
};

const serializeAws_restJson1AuditCheckToReasonCodeFilter = (
  input: { [key: string]: string[] },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: serializeAws_restJson1ReasonForNonComplianceCodes(value, context),
    };
  }, {});
};

const serializeAws_restJson1AuditMitigationActionsTaskTarget = (
  input: AuditMitigationActionsTaskTarget,
  context: __SerdeContext
): any => {
  return {
    ...(input.auditCheckToReasonCodeFilter !== undefined &&
      input.auditCheckToReasonCodeFilter !== null && {
        auditCheckToReasonCodeFilter: serializeAws_restJson1AuditCheckToReasonCodeFilter(
          input.auditCheckToReasonCodeFilter,
          context
        ),
      }),
    ...(input.auditTaskId !== undefined && input.auditTaskId !== null && { auditTaskId: input.auditTaskId }),
    ...(input.findingIds !== undefined &&
      input.findingIds !== null && { findingIds: serializeAws_restJson1FindingIds(input.findingIds, context) }),
  };
};

const serializeAws_restJson1AuditNotificationTarget = (
  input: AuditNotificationTarget,
  context: __SerdeContext
): any => {
  return {
    ...(input.enabled !== undefined && input.enabled !== null && { enabled: input.enabled }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.targetArn !== undefined && input.targetArn !== null && { targetArn: input.targetArn }),
  };
};

const serializeAws_restJson1AuditNotificationTargetConfigurations = (
  input: { [key: string]: AuditNotificationTarget },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce(
    (acc: { [key: string]: any }, [key, value]: [AuditNotificationType | string, any]) => {
      if (value === null) {
        return acc;
      }
      return {
        ...acc,
        [key]: serializeAws_restJson1AuditNotificationTarget(value, context),
      };
    },
    {}
  );
};

const serializeAws_restJson1AuthInfo = (input: AuthInfo, context: __SerdeContext): any => {
  return {
    ...(input.actionType !== undefined && input.actionType !== null && { actionType: input.actionType }),
    ...(input.resources !== undefined &&
      input.resources !== null && { resources: serializeAws_restJson1Resources(input.resources, context) }),
  };
};

const serializeAws_restJson1AuthInfos = (input: AuthInfo[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1AuthInfo(entry, context);
    });
};

const serializeAws_restJson1AuthorizerConfig = (input: AuthorizerConfig, context: __SerdeContext): any => {
  return {
    ...(input.allowAuthorizerOverride !== undefined &&
      input.allowAuthorizerOverride !== null && { allowAuthorizerOverride: input.allowAuthorizerOverride }),
    ...(input.defaultAuthorizerName !== undefined &&
      input.defaultAuthorizerName !== null && { defaultAuthorizerName: input.defaultAuthorizerName }),
  };
};

const serializeAws_restJson1AwsJobAbortConfig = (input: AwsJobAbortConfig, context: __SerdeContext): any => {
  return {
    ...(input.abortCriteriaList !== undefined &&
      input.abortCriteriaList !== null && {
        abortCriteriaList: serializeAws_restJson1AwsJobAbortCriteriaList(input.abortCriteriaList, context),
      }),
  };
};

const serializeAws_restJson1AwsJobAbortCriteria = (input: AwsJobAbortCriteria, context: __SerdeContext): any => {
  return {
    ...(input.action !== undefined && input.action !== null && { action: input.action }),
    ...(input.failureType !== undefined && input.failureType !== null && { failureType: input.failureType }),
    ...(input.minNumberOfExecutedThings !== undefined &&
      input.minNumberOfExecutedThings !== null && { minNumberOfExecutedThings: input.minNumberOfExecutedThings }),
    ...(input.thresholdPercentage !== undefined &&
      input.thresholdPercentage !== null && { thresholdPercentage: __serializeFloat(input.thresholdPercentage) }),
  };
};

const serializeAws_restJson1AwsJobAbortCriteriaList = (input: AwsJobAbortCriteria[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1AwsJobAbortCriteria(entry, context);
    });
};

const serializeAws_restJson1AwsJobExecutionsRolloutConfig = (
  input: AwsJobExecutionsRolloutConfig,
  context: __SerdeContext
): any => {
  return {
    ...(input.exponentialRate !== undefined &&
      input.exponentialRate !== null && {
        exponentialRate: serializeAws_restJson1AwsJobExponentialRolloutRate(input.exponentialRate, context),
      }),
    ...(input.maximumPerMinute !== undefined &&
      input.maximumPerMinute !== null && { maximumPerMinute: input.maximumPerMinute }),
  };
};

const serializeAws_restJson1AwsJobExponentialRolloutRate = (
  input: AwsJobExponentialRolloutRate,
  context: __SerdeContext
): any => {
  return {
    ...(input.baseRatePerMinute !== undefined &&
      input.baseRatePerMinute !== null && { baseRatePerMinute: input.baseRatePerMinute }),
    ...(input.incrementFactor !== undefined &&
      input.incrementFactor !== null && { incrementFactor: __serializeFloat(input.incrementFactor) }),
    ...(input.rateIncreaseCriteria !== undefined &&
      input.rateIncreaseCriteria !== null && {
        rateIncreaseCriteria: serializeAws_restJson1AwsJobRateIncreaseCriteria(input.rateIncreaseCriteria, context),
      }),
  };
};

const serializeAws_restJson1AwsJobPresignedUrlConfig = (
  input: AwsJobPresignedUrlConfig,
  context: __SerdeContext
): any => {
  return {
    ...(input.expiresInSec !== undefined && input.expiresInSec !== null && { expiresInSec: input.expiresInSec }),
  };
};

const serializeAws_restJson1AwsJobRateIncreaseCriteria = (
  input: AwsJobRateIncreaseCriteria,
  context: __SerdeContext
): any => {
  return {
    ...(input.numberOfNotifiedThings !== undefined &&
      input.numberOfNotifiedThings !== null && { numberOfNotifiedThings: input.numberOfNotifiedThings }),
    ...(input.numberOfSucceededThings !== undefined &&
      input.numberOfSucceededThings !== null && { numberOfSucceededThings: input.numberOfSucceededThings }),
  };
};

const serializeAws_restJson1AwsJobTimeoutConfig = (input: AwsJobTimeoutConfig, context: __SerdeContext): any => {
  return {
    ...(input.inProgressTimeoutInMinutes !== undefined &&
      input.inProgressTimeoutInMinutes !== null && { inProgressTimeoutInMinutes: input.inProgressTimeoutInMinutes }),
  };
};

const serializeAws_restJson1Behavior = (input: Behavior, context: __SerdeContext): any => {
  return {
    ...(input.criteria !== undefined &&
      input.criteria !== null && { criteria: serializeAws_restJson1BehaviorCriteria(input.criteria, context) }),
    ...(input.metric !== undefined && input.metric !== null && { metric: input.metric }),
    ...(input.metricDimension !== undefined &&
      input.metricDimension !== null && {
        metricDimension: serializeAws_restJson1MetricDimension(input.metricDimension, context),
      }),
    ...(input.name !== undefined && input.name !== null && { name: input.name }),
    ...(input.suppressAlerts !== undefined &&
      input.suppressAlerts !== null && { suppressAlerts: input.suppressAlerts }),
  };
};

const serializeAws_restJson1BehaviorCriteria = (input: BehaviorCriteria, context: __SerdeContext): any => {
  return {
    ...(input.comparisonOperator !== undefined &&
      input.comparisonOperator !== null && { comparisonOperator: input.comparisonOperator }),
    ...(input.consecutiveDatapointsToAlarm !== undefined &&
      input.consecutiveDatapointsToAlarm !== null && {
        consecutiveDatapointsToAlarm: input.consecutiveDatapointsToAlarm,
      }),
    ...(input.consecutiveDatapointsToClear !== undefined &&
      input.consecutiveDatapointsToClear !== null && {
        consecutiveDatapointsToClear: input.consecutiveDatapointsToClear,
      }),
    ...(input.durationSeconds !== undefined &&
      input.durationSeconds !== null && { durationSeconds: input.durationSeconds }),
    ...(input.mlDetectionConfig !== undefined &&
      input.mlDetectionConfig !== null && {
        mlDetectionConfig: serializeAws_restJson1MachineLearningDetectionConfig(input.mlDetectionConfig, context),
      }),
    ...(input.statisticalThreshold !== undefined &&
      input.statisticalThreshold !== null && {
        statisticalThreshold: serializeAws_restJson1StatisticalThreshold(input.statisticalThreshold, context),
      }),
    ...(input.value !== undefined &&
      input.value !== null && { value: serializeAws_restJson1MetricValue(input.value, context) }),
  };
};

const serializeAws_restJson1Behaviors = (input: Behavior[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1Behavior(entry, context);
    });
};

const serializeAws_restJson1BillingGroupProperties = (input: BillingGroupProperties, context: __SerdeContext): any => {
  return {
    ...(input.billingGroupDescription !== undefined &&
      input.billingGroupDescription !== null && { billingGroupDescription: input.billingGroupDescription }),
  };
};

const serializeAws_restJson1BucketsAggregationType = (input: BucketsAggregationType, context: __SerdeContext): any => {
  return {
    ...(input.termsAggregation !== undefined &&
      input.termsAggregation !== null && {
        termsAggregation: serializeAws_restJson1TermsAggregation(input.termsAggregation, context),
      }),
  };
};

const serializeAws_restJson1Cidrs = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1ClientProperties = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: value,
    };
  }, {});
};

const serializeAws_restJson1CloudwatchAlarmAction = (input: CloudwatchAlarmAction, context: __SerdeContext): any => {
  return {
    ...(input.alarmName !== undefined && input.alarmName !== null && { alarmName: input.alarmName }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.stateReason !== undefined && input.stateReason !== null && { stateReason: input.stateReason }),
    ...(input.stateValue !== undefined && input.stateValue !== null && { stateValue: input.stateValue }),
  };
};

const serializeAws_restJson1CloudwatchLogsAction = (input: CloudwatchLogsAction, context: __SerdeContext): any => {
  return {
    ...(input.logGroupName !== undefined && input.logGroupName !== null && { logGroupName: input.logGroupName }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  };
};

const serializeAws_restJson1CloudwatchMetricAction = (input: CloudwatchMetricAction, context: __SerdeContext): any => {
  return {
    ...(input.metricName !== undefined && input.metricName !== null && { metricName: input.metricName }),
    ...(input.metricNamespace !== undefined &&
      input.metricNamespace !== null && { metricNamespace: input.metricNamespace }),
    ...(input.metricTimestamp !== undefined &&
      input.metricTimestamp !== null && { metricTimestamp: input.metricTimestamp }),
    ...(input.metricUnit !== undefined && input.metricUnit !== null && { metricUnit: input.metricUnit }),
    ...(input.metricValue !== undefined && input.metricValue !== null && { metricValue: input.metricValue }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  };
};

const serializeAws_restJson1CodeSigning = (input: CodeSigning, context: __SerdeContext): any => {
  return {
    ...(input.awsSignerJobId !== undefined &&
      input.awsSignerJobId !== null && { awsSignerJobId: input.awsSignerJobId }),
    ...(input.customCodeSigning !== undefined &&
      input.customCodeSigning !== null && {
        customCodeSigning: serializeAws_restJson1CustomCodeSigning(input.customCodeSigning, context),
      }),
    ...(input.startSigningJobParameter !== undefined &&
      input.startSigningJobParameter !== null && {
        startSigningJobParameter: serializeAws_restJson1StartSigningJobParameter(
          input.startSigningJobParameter,
          context
        ),
      }),
  };
};

const serializeAws_restJson1CodeSigningCertificateChain = (
  input: CodeSigningCertificateChain,
  context: __SerdeContext
): any => {
  return {
    ...(input.certificateName !== undefined &&
      input.certificateName !== null && { certificateName: input.certificateName }),
    ...(input.inlineDocument !== undefined &&
      input.inlineDocument !== null && { inlineDocument: input.inlineDocument }),
  };
};

const serializeAws_restJson1CodeSigningSignature = (input: CodeSigningSignature, context: __SerdeContext): any => {
  return {
    ...(input.inlineDocument !== undefined &&
      input.inlineDocument !== null && { inlineDocument: context.base64Encoder(input.inlineDocument) }),
  };
};

const serializeAws_restJson1Configuration = (input: Configuration, context: __SerdeContext): any => {
  return {
    ...(input.Enabled !== undefined && input.Enabled !== null && { Enabled: input.Enabled }),
  };
};

const serializeAws_restJson1CustomCodeSigning = (input: CustomCodeSigning, context: __SerdeContext): any => {
  return {
    ...(input.certificateChain !== undefined &&
      input.certificateChain !== null && {
        certificateChain: serializeAws_restJson1CodeSigningCertificateChain(input.certificateChain, context),
      }),
    ...(input.hashAlgorithm !== undefined && input.hashAlgorithm !== null && { hashAlgorithm: input.hashAlgorithm }),
    ...(input.signature !== undefined &&
      input.signature !== null && { signature: serializeAws_restJson1CodeSigningSignature(input.signature, context) }),
    ...(input.signatureAlgorithm !== undefined &&
      input.signatureAlgorithm !== null && { signatureAlgorithm: input.signatureAlgorithm }),
  };
};

const serializeAws_restJson1Destination = (input: Destination, context: __SerdeContext): any => {
  return {
    ...(input.s3Destination !== undefined &&
      input.s3Destination !== null && {
        s3Destination: serializeAws_restJson1S3Destination(input.s3Destination, context),
      }),
  };
};

const serializeAws_restJson1DetailsMap = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: value,
    };
  }, {});
};

const serializeAws_restJson1DetectMitigationActionsTaskTarget = (
  input: DetectMitigationActionsTaskTarget,
  context: __SerdeContext
): any => {
  return {
    ...(input.behaviorName !== undefined && input.behaviorName !== null && { behaviorName: input.behaviorName }),
    ...(input.securityProfileName !== undefined &&
      input.securityProfileName !== null && { securityProfileName: input.securityProfileName }),
    ...(input.violationIds !== undefined &&
      input.violationIds !== null && {
        violationIds: serializeAws_restJson1TargetViolationIdsForDetectMitigationActions(input.violationIds, context),
      }),
  };
};

const serializeAws_restJson1DetectMitigationActionsToExecuteList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1DimensionStringValues = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1DynamoDBAction = (input: DynamoDBAction, context: __SerdeContext): any => {
  return {
    ...(input.hashKeyField !== undefined && input.hashKeyField !== null && { hashKeyField: input.hashKeyField }),
    ...(input.hashKeyType !== undefined && input.hashKeyType !== null && { hashKeyType: input.hashKeyType }),
    ...(input.hashKeyValue !== undefined && input.hashKeyValue !== null && { hashKeyValue: input.hashKeyValue }),
    ...(input.operation !== undefined && input.operation !== null && { operation: input.operation }),
    ...(input.payloadField !== undefined && input.payloadField !== null && { payloadField: input.payloadField }),
    ...(input.rangeKeyField !== undefined && input.rangeKeyField !== null && { rangeKeyField: input.rangeKeyField }),
    ...(input.rangeKeyType !== undefined && input.rangeKeyType !== null && { rangeKeyType: input.rangeKeyType }),
    ...(input.rangeKeyValue !== undefined && input.rangeKeyValue !== null && { rangeKeyValue: input.rangeKeyValue }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.tableName !== undefined && input.tableName !== null && { tableName: input.tableName }),
  };
};

const serializeAws_restJson1DynamoDBv2Action = (input: DynamoDBv2Action, context: __SerdeContext): any => {
  return {
    ...(input.putItem !== undefined &&
      input.putItem !== null && { putItem: serializeAws_restJson1PutItemInput(input.putItem, context) }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  };
};

const serializeAws_restJson1ElasticsearchAction = (input: ElasticsearchAction, context: __SerdeContext): any => {
  return {
    ...(input.endpoint !== undefined && input.endpoint !== null && { endpoint: input.endpoint }),
    ...(input.id !== undefined && input.id !== null && { id: input.id }),
    ...(input.index !== undefined && input.index !== null && { index: input.index }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.type !== undefined && input.type !== null && { type: input.type }),
  };
};

const serializeAws_restJson1EnableIoTLoggingParams = (input: EnableIoTLoggingParams, context: __SerdeContext): any => {
  return {
    ...(input.logLevel !== undefined && input.logLevel !== null && { logLevel: input.logLevel }),
    ...(input.roleArnForLogging !== undefined &&
      input.roleArnForLogging !== null && { roleArnForLogging: input.roleArnForLogging }),
  };
};

const serializeAws_restJson1EventConfigurations = (
  input: { [key: string]: Configuration },
  context: __SerdeContext
): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [EventType | string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: serializeAws_restJson1Configuration(value, context),
    };
  }, {});
};

const serializeAws_restJson1ExponentialRolloutRate = (input: ExponentialRolloutRate, context: __SerdeContext): any => {
  return {
    ...(input.baseRatePerMinute !== undefined &&
      input.baseRatePerMinute !== null && { baseRatePerMinute: input.baseRatePerMinute }),
    ...(input.incrementFactor !== undefined &&
      input.incrementFactor !== null && { incrementFactor: __serializeFloat(input.incrementFactor) }),
    ...(input.rateIncreaseCriteria !== undefined &&
      input.rateIncreaseCriteria !== null && {
        rateIncreaseCriteria: serializeAws_restJson1RateIncreaseCriteria(input.rateIncreaseCriteria, context),
      }),
  };
};

const serializeAws_restJson1Field = (input: Field, context: __SerdeContext): any => {
  return {
    ...(input.name !== undefined && input.name !== null && { name: input.name }),
    ...(input.type !== undefined && input.type !== null && { type: input.type }),
  };
};

const serializeAws_restJson1Fields = (input: Field[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1Field(entry, context);
    });
};

const serializeAws_restJson1FileLocation = (input: FileLocation, context: __SerdeContext): any => {
  return {
    ...(input.s3Location !== undefined &&
      input.s3Location !== null && { s3Location: serializeAws_restJson1S3Location(input.s3Location, context) }),
    ...(input.stream !== undefined &&
      input.stream !== null && { stream: serializeAws_restJson1_Stream(input.stream, context) }),
  };
};

const serializeAws_restJson1FindingIds = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1FirehoseAction = (input: FirehoseAction, context: __SerdeContext): any => {
  return {
    ...(input.batchMode !== undefined && input.batchMode !== null && { batchMode: input.batchMode }),
    ...(input.deliveryStreamName !== undefined &&
      input.deliveryStreamName !== null && { deliveryStreamName: input.deliveryStreamName }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.separator !== undefined && input.separator !== null && { separator: input.separator }),
  };
};

const serializeAws_restJson1HeaderList = (input: HttpActionHeader[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1HttpActionHeader(entry, context);
    });
};

const serializeAws_restJson1HttpAction = (input: HttpAction, context: __SerdeContext): any => {
  return {
    ...(input.auth !== undefined &&
      input.auth !== null && { auth: serializeAws_restJson1HttpAuthorization(input.auth, context) }),
    ...(input.confirmationUrl !== undefined &&
      input.confirmationUrl !== null && { confirmationUrl: input.confirmationUrl }),
    ...(input.headers !== undefined &&
      input.headers !== null && { headers: serializeAws_restJson1HeaderList(input.headers, context) }),
    ...(input.url !== undefined && input.url !== null && { url: input.url }),
  };
};

const serializeAws_restJson1HttpActionHeader = (input: HttpActionHeader, context: __SerdeContext): any => {
  return {
    ...(input.key !== undefined && input.key !== null && { key: input.key }),
    ...(input.value !== undefined && input.value !== null && { value: input.value }),
  };
};

const serializeAws_restJson1HttpAuthorization = (input: HttpAuthorization, context: __SerdeContext): any => {
  return {
    ...(input.sigv4 !== undefined &&
      input.sigv4 !== null && { sigv4: serializeAws_restJson1SigV4Authorization(input.sigv4, context) }),
  };
};

const serializeAws_restJson1HttpContext = (input: HttpContext, context: __SerdeContext): any => {
  return {
    ...(input.headers !== undefined &&
      input.headers !== null && { headers: serializeAws_restJson1HttpHeaders(input.headers, context) }),
    ...(input.queryString !== undefined && input.queryString !== null && { queryString: input.queryString }),
  };
};

const serializeAws_restJson1HttpHeaders = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: value,
    };
  }, {});
};

const serializeAws_restJson1HttpUrlDestinationConfiguration = (
  input: HttpUrlDestinationConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.confirmationUrl !== undefined &&
      input.confirmationUrl !== null && { confirmationUrl: input.confirmationUrl }),
  };
};

const serializeAws_restJson1IotAnalyticsAction = (input: IotAnalyticsAction, context: __SerdeContext): any => {
  return {
    ...(input.batchMode !== undefined && input.batchMode !== null && { batchMode: input.batchMode }),
    ...(input.channelArn !== undefined && input.channelArn !== null && { channelArn: input.channelArn }),
    ...(input.channelName !== undefined && input.channelName !== null && { channelName: input.channelName }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  };
};

const serializeAws_restJson1IotEventsAction = (input: IotEventsAction, context: __SerdeContext): any => {
  return {
    ...(input.batchMode !== undefined && input.batchMode !== null && { batchMode: input.batchMode }),
    ...(input.inputName !== undefined && input.inputName !== null && { inputName: input.inputName }),
    ...(input.messageId !== undefined && input.messageId !== null && { messageId: input.messageId }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  };
};

const serializeAws_restJson1IotSiteWiseAction = (input: IotSiteWiseAction, context: __SerdeContext): any => {
  return {
    ...(input.putAssetPropertyValueEntries !== undefined &&
      input.putAssetPropertyValueEntries !== null && {
        putAssetPropertyValueEntries: serializeAws_restJson1PutAssetPropertyValueEntryList(
          input.putAssetPropertyValueEntries,
          context
        ),
      }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  };
};

const serializeAws_restJson1JobExecutionsRolloutConfig = (
  input: JobExecutionsRolloutConfig,
  context: __SerdeContext
): any => {
  return {
    ...(input.exponentialRate !== undefined &&
      input.exponentialRate !== null && {
        exponentialRate: serializeAws_restJson1ExponentialRolloutRate(input.exponentialRate, context),
      }),
    ...(input.maximumPerMinute !== undefined &&
      input.maximumPerMinute !== null && { maximumPerMinute: input.maximumPerMinute }),
  };
};

const serializeAws_restJson1JobTargets = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1KafkaAction = (input: KafkaAction, context: __SerdeContext): any => {
  return {
    ...(input.clientProperties !== undefined &&
      input.clientProperties !== null && {
        clientProperties: serializeAws_restJson1ClientProperties(input.clientProperties, context),
      }),
    ...(input.destinationArn !== undefined &&
      input.destinationArn !== null && { destinationArn: input.destinationArn }),
    ...(input.key !== undefined && input.key !== null && { key: input.key }),
    ...(input.partition !== undefined && input.partition !== null && { partition: input.partition }),
    ...(input.topic !== undefined && input.topic !== null && { topic: input.topic }),
  };
};

const serializeAws_restJson1KinesisAction = (input: KinesisAction, context: __SerdeContext): any => {
  return {
    ...(input.partitionKey !== undefined && input.partitionKey !== null && { partitionKey: input.partitionKey }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.streamName !== undefined && input.streamName !== null && { streamName: input.streamName }),
  };
};

const serializeAws_restJson1LambdaAction = (input: LambdaAction, context: __SerdeContext): any => {
  return {
    ...(input.functionArn !== undefined && input.functionArn !== null && { functionArn: input.functionArn }),
  };
};

const serializeAws_restJson1LoggingOptionsPayload = (input: LoggingOptionsPayload, context: __SerdeContext): any => {
  return {
    ...(input.logLevel !== undefined && input.logLevel !== null && { logLevel: input.logLevel }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  };
};

const serializeAws_restJson1LogTarget = (input: LogTarget, context: __SerdeContext): any => {
  return {
    ...(input.targetName !== undefined && input.targetName !== null && { targetName: input.targetName }),
    ...(input.targetType !== undefined && input.targetType !== null && { targetType: input.targetType }),
  };
};

const serializeAws_restJson1MachineLearningDetectionConfig = (
  input: MachineLearningDetectionConfig,
  context: __SerdeContext
): any => {
  return {
    ...(input.confidenceLevel !== undefined &&
      input.confidenceLevel !== null && { confidenceLevel: input.confidenceLevel }),
  };
};

const serializeAws_restJson1MetricDimension = (input: MetricDimension, context: __SerdeContext): any => {
  return {
    ...(input.dimensionName !== undefined && input.dimensionName !== null && { dimensionName: input.dimensionName }),
    ...(input.operator !== undefined && input.operator !== null && { operator: input.operator }),
  };
};

const serializeAws_restJson1MetricToRetain = (input: MetricToRetain, context: __SerdeContext): any => {
  return {
    ...(input.metric !== undefined && input.metric !== null && { metric: input.metric }),
    ...(input.metricDimension !== undefined &&
      input.metricDimension !== null && {
        metricDimension: serializeAws_restJson1MetricDimension(input.metricDimension, context),
      }),
  };
};

const serializeAws_restJson1MetricValue = (input: MetricValue, context: __SerdeContext): any => {
  return {
    ...(input.cidrs !== undefined &&
      input.cidrs !== null && { cidrs: serializeAws_restJson1Cidrs(input.cidrs, context) }),
    ...(input.count !== undefined && input.count !== null && { count: input.count }),
    ...(input.number !== undefined && input.number !== null && { number: __serializeFloat(input.number) }),
    ...(input.numbers !== undefined &&
      input.numbers !== null && { numbers: serializeAws_restJson1NumberList(input.numbers, context) }),
    ...(input.ports !== undefined &&
      input.ports !== null && { ports: serializeAws_restJson1Ports(input.ports, context) }),
    ...(input.strings !== undefined &&
      input.strings !== null && { strings: serializeAws_restJson1StringList(input.strings, context) }),
  };
};

const serializeAws_restJson1MitigationActionNameList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1MitigationActionParams = (input: MitigationActionParams, context: __SerdeContext): any => {
  return {
    ...(input.addThingsToThingGroupParams !== undefined &&
      input.addThingsToThingGroupParams !== null && {
        addThingsToThingGroupParams: serializeAws_restJson1AddThingsToThingGroupParams(
          input.addThingsToThingGroupParams,
          context
        ),
      }),
    ...(input.enableIoTLoggingParams !== undefined &&
      input.enableIoTLoggingParams !== null && {
        enableIoTLoggingParams: serializeAws_restJson1EnableIoTLoggingParams(input.enableIoTLoggingParams, context),
      }),
    ...(input.publishFindingToSnsParams !== undefined &&
      input.publishFindingToSnsParams !== null && {
        publishFindingToSnsParams: serializeAws_restJson1PublishFindingToSnsParams(
          input.publishFindingToSnsParams,
          context
        ),
      }),
    ...(input.replaceDefaultPolicyVersionParams !== undefined &&
      input.replaceDefaultPolicyVersionParams !== null && {
        replaceDefaultPolicyVersionParams: serializeAws_restJson1ReplaceDefaultPolicyVersionParams(
          input.replaceDefaultPolicyVersionParams,
          context
        ),
      }),
    ...(input.updateCACertificateParams !== undefined &&
      input.updateCACertificateParams !== null && {
        updateCACertificateParams: serializeAws_restJson1UpdateCACertificateParams(
          input.updateCACertificateParams,
          context
        ),
      }),
    ...(input.updateDeviceCertificateParams !== undefined &&
      input.updateDeviceCertificateParams !== null && {
        updateDeviceCertificateParams: serializeAws_restJson1UpdateDeviceCertificateParams(
          input.updateDeviceCertificateParams,
          context
        ),
      }),
  };
};

const serializeAws_restJson1MqttContext = (input: MqttContext, context: __SerdeContext): any => {
  return {
    ...(input.clientId !== undefined && input.clientId !== null && { clientId: input.clientId }),
    ...(input.password !== undefined && input.password !== null && { password: context.base64Encoder(input.password) }),
    ...(input.username !== undefined && input.username !== null && { username: input.username }),
  };
};

const serializeAws_restJson1NumberList = (input: number[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return __serializeFloat(entry);
    });
};

const serializeAws_restJson1OpenSearchAction = (input: OpenSearchAction, context: __SerdeContext): any => {
  return {
    ...(input.endpoint !== undefined && input.endpoint !== null && { endpoint: input.endpoint }),
    ...(input.id !== undefined && input.id !== null && { id: input.id }),
    ...(input.index !== undefined && input.index !== null && { index: input.index }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.type !== undefined && input.type !== null && { type: input.type }),
  };
};

const serializeAws_restJson1OTAUpdateFile = (input: OTAUpdateFile, context: __SerdeContext): any => {
  return {
    ...(input.attributes !== undefined &&
      input.attributes !== null && { attributes: serializeAws_restJson1AttributesMap(input.attributes, context) }),
    ...(input.codeSigning !== undefined &&
      input.codeSigning !== null && { codeSigning: serializeAws_restJson1CodeSigning(input.codeSigning, context) }),
    ...(input.fileLocation !== undefined &&
      input.fileLocation !== null && { fileLocation: serializeAws_restJson1FileLocation(input.fileLocation, context) }),
    ...(input.fileName !== undefined && input.fileName !== null && { fileName: input.fileName }),
    ...(input.fileType !== undefined && input.fileType !== null && { fileType: input.fileType }),
    ...(input.fileVersion !== undefined && input.fileVersion !== null && { fileVersion: input.fileVersion }),
  };
};

const serializeAws_restJson1OTAUpdateFiles = (input: OTAUpdateFile[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1OTAUpdateFile(entry, context);
    });
};

const serializeAws_restJson1Parameters = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: value,
    };
  }, {});
};

const serializeAws_restJson1PercentList = (input: number[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return __serializeFloat(entry);
    });
};

const serializeAws_restJson1PolicyNames = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1PolicyVersionIdentifier = (
  input: PolicyVersionIdentifier,
  context: __SerdeContext
): any => {
  return {
    ...(input.policyName !== undefined && input.policyName !== null && { policyName: input.policyName }),
    ...(input.policyVersionId !== undefined &&
      input.policyVersionId !== null && { policyVersionId: input.policyVersionId }),
  };
};

const serializeAws_restJson1Ports = (input: number[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1PresignedUrlConfig = (input: PresignedUrlConfig, context: __SerdeContext): any => {
  return {
    ...(input.expiresInSec !== undefined && input.expiresInSec !== null && { expiresInSec: input.expiresInSec }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  };
};

const serializeAws_restJson1Protocols = (input: (Protocol | string)[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1ProvisioningHook = (input: ProvisioningHook, context: __SerdeContext): any => {
  return {
    ...(input.payloadVersion !== undefined &&
      input.payloadVersion !== null && { payloadVersion: input.payloadVersion }),
    ...(input.targetArn !== undefined && input.targetArn !== null && { targetArn: input.targetArn }),
  };
};

const serializeAws_restJson1PublicKeyMap = (input: { [key: string]: string }, context: __SerdeContext): any => {
  return Object.entries(input).reduce((acc: { [key: string]: any }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: value,
    };
  }, {});
};

const serializeAws_restJson1PublishFindingToSnsParams = (
  input: PublishFindingToSnsParams,
  context: __SerdeContext
): any => {
  return {
    ...(input.topicArn !== undefined && input.topicArn !== null && { topicArn: input.topicArn }),
  };
};

const serializeAws_restJson1PutAssetPropertyValueEntry = (
  input: PutAssetPropertyValueEntry,
  context: __SerdeContext
): any => {
  return {
    ...(input.assetId !== undefined && input.assetId !== null && { assetId: input.assetId }),
    ...(input.entryId !== undefined && input.entryId !== null && { entryId: input.entryId }),
    ...(input.propertyAlias !== undefined && input.propertyAlias !== null && { propertyAlias: input.propertyAlias }),
    ...(input.propertyId !== undefined && input.propertyId !== null && { propertyId: input.propertyId }),
    ...(input.propertyValues !== undefined &&
      input.propertyValues !== null && {
        propertyValues: serializeAws_restJson1AssetPropertyValueList(input.propertyValues, context),
      }),
  };
};

const serializeAws_restJson1PutAssetPropertyValueEntryList = (
  input: PutAssetPropertyValueEntry[],
  context: __SerdeContext
): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1PutAssetPropertyValueEntry(entry, context);
    });
};

const serializeAws_restJson1PutItemInput = (input: PutItemInput, context: __SerdeContext): any => {
  return {
    ...(input.tableName !== undefined && input.tableName !== null && { tableName: input.tableName }),
  };
};

const serializeAws_restJson1RateIncreaseCriteria = (input: RateIncreaseCriteria, context: __SerdeContext): any => {
  return {
    ...(input.numberOfNotifiedThings !== undefined &&
      input.numberOfNotifiedThings !== null && { numberOfNotifiedThings: input.numberOfNotifiedThings }),
    ...(input.numberOfSucceededThings !== undefined &&
      input.numberOfSucceededThings !== null && { numberOfSucceededThings: input.numberOfSucceededThings }),
  };
};

const serializeAws_restJson1ReasonForNonComplianceCodes = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1RegistrationConfig = (input: RegistrationConfig, context: __SerdeContext): any => {
  return {
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.templateBody !== undefined && input.templateBody !== null && { templateBody: input.templateBody }),
  };
};

const serializeAws_restJson1ReplaceDefaultPolicyVersionParams = (
  input: ReplaceDefaultPolicyVersionParams,
  context: __SerdeContext
): any => {
  return {
    ...(input.templateName !== undefined && input.templateName !== null && { templateName: input.templateName }),
  };
};

const serializeAws_restJson1RepublishAction = (input: RepublishAction, context: __SerdeContext): any => {
  return {
    ...(input.qos !== undefined && input.qos !== null && { qos: input.qos }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.topic !== undefined && input.topic !== null && { topic: input.topic }),
  };
};

const serializeAws_restJson1ResourceIdentifier = (input: ResourceIdentifier, context: __SerdeContext): any => {
  return {
    ...(input.account !== undefined && input.account !== null && { account: input.account }),
    ...(input.caCertificateId !== undefined &&
      input.caCertificateId !== null && { caCertificateId: input.caCertificateId }),
    ...(input.clientId !== undefined && input.clientId !== null && { clientId: input.clientId }),
    ...(input.cognitoIdentityPoolId !== undefined &&
      input.cognitoIdentityPoolId !== null && { cognitoIdentityPoolId: input.cognitoIdentityPoolId }),
    ...(input.deviceCertificateId !== undefined &&
      input.deviceCertificateId !== null && { deviceCertificateId: input.deviceCertificateId }),
    ...(input.iamRoleArn !== undefined && input.iamRoleArn !== null && { iamRoleArn: input.iamRoleArn }),
    ...(input.policyVersionIdentifier !== undefined &&
      input.policyVersionIdentifier !== null && {
        policyVersionIdentifier: serializeAws_restJson1PolicyVersionIdentifier(input.policyVersionIdentifier, context),
      }),
    ...(input.roleAliasArn !== undefined && input.roleAliasArn !== null && { roleAliasArn: input.roleAliasArn }),
  };
};

const serializeAws_restJson1Resources = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1S3Action = (input: S3Action, context: __SerdeContext): any => {
  return {
    ...(input.bucketName !== undefined && input.bucketName !== null && { bucketName: input.bucketName }),
    ...(input.cannedAcl !== undefined && input.cannedAcl !== null && { cannedAcl: input.cannedAcl }),
    ...(input.key !== undefined && input.key !== null && { key: input.key }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
  };
};

const serializeAws_restJson1S3Destination = (input: S3Destination, context: __SerdeContext): any => {
  return {
    ...(input.bucket !== undefined && input.bucket !== null && { bucket: input.bucket }),
    ...(input.prefix !== undefined && input.prefix !== null && { prefix: input.prefix }),
  };
};

const serializeAws_restJson1S3Location = (input: S3Location, context: __SerdeContext): any => {
  return {
    ...(input.bucket !== undefined && input.bucket !== null && { bucket: input.bucket }),
    ...(input.key !== undefined && input.key !== null && { key: input.key }),
    ...(input.version !== undefined && input.version !== null && { version: input.version }),
  };
};

const serializeAws_restJson1SalesforceAction = (input: SalesforceAction, context: __SerdeContext): any => {
  return {
    ...(input.token !== undefined && input.token !== null && { token: input.token }),
    ...(input.url !== undefined && input.url !== null && { url: input.url }),
  };
};

const serializeAws_restJson1SearchableAttributes = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1SecurityGroupList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1ServerCertificateArns = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1SigningProfileParameter = (
  input: SigningProfileParameter,
  context: __SerdeContext
): any => {
  return {
    ...(input.certificateArn !== undefined &&
      input.certificateArn !== null && { certificateArn: input.certificateArn }),
    ...(input.certificatePathOnDevice !== undefined &&
      input.certificatePathOnDevice !== null && { certificatePathOnDevice: input.certificatePathOnDevice }),
    ...(input.platform !== undefined && input.platform !== null && { platform: input.platform }),
  };
};

const serializeAws_restJson1SigV4Authorization = (input: SigV4Authorization, context: __SerdeContext): any => {
  return {
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.serviceName !== undefined && input.serviceName !== null && { serviceName: input.serviceName }),
    ...(input.signingRegion !== undefined && input.signingRegion !== null && { signingRegion: input.signingRegion }),
  };
};

const serializeAws_restJson1SnsAction = (input: SnsAction, context: __SerdeContext): any => {
  return {
    ...(input.messageFormat !== undefined && input.messageFormat !== null && { messageFormat: input.messageFormat }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.targetArn !== undefined && input.targetArn !== null && { targetArn: input.targetArn }),
  };
};

const serializeAws_restJson1SqsAction = (input: SqsAction, context: __SerdeContext): any => {
  return {
    ...(input.queueUrl !== undefined && input.queueUrl !== null && { queueUrl: input.queueUrl }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.useBase64 !== undefined && input.useBase64 !== null && { useBase64: input.useBase64 }),
  };
};

const serializeAws_restJson1StartSigningJobParameter = (
  input: StartSigningJobParameter,
  context: __SerdeContext
): any => {
  return {
    ...(input.destination !== undefined &&
      input.destination !== null && { destination: serializeAws_restJson1Destination(input.destination, context) }),
    ...(input.signingProfileName !== undefined &&
      input.signingProfileName !== null && { signingProfileName: input.signingProfileName }),
    ...(input.signingProfileParameter !== undefined &&
      input.signingProfileParameter !== null && {
        signingProfileParameter: serializeAws_restJson1SigningProfileParameter(input.signingProfileParameter, context),
      }),
  };
};

const serializeAws_restJson1StatisticalThreshold = (input: StatisticalThreshold, context: __SerdeContext): any => {
  return {
    ...(input.statistic !== undefined && input.statistic !== null && { statistic: input.statistic }),
  };
};

const serializeAws_restJson1StepFunctionsAction = (input: StepFunctionsAction, context: __SerdeContext): any => {
  return {
    ...(input.executionNamePrefix !== undefined &&
      input.executionNamePrefix !== null && { executionNamePrefix: input.executionNamePrefix }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.stateMachineName !== undefined &&
      input.stateMachineName !== null && { stateMachineName: input.stateMachineName }),
  };
};

const serializeAws_restJson1_Stream = (input: _Stream, context: __SerdeContext): any => {
  return {
    ...(input.fileId !== undefined && input.fileId !== null && { fileId: input.fileId }),
    ...(input.streamId !== undefined && input.streamId !== null && { streamId: input.streamId }),
  };
};

const serializeAws_restJson1StreamFile = (input: StreamFile, context: __SerdeContext): any => {
  return {
    ...(input.fileId !== undefined && input.fileId !== null && { fileId: input.fileId }),
    ...(input.s3Location !== undefined &&
      input.s3Location !== null && { s3Location: serializeAws_restJson1S3Location(input.s3Location, context) }),
  };
};

const serializeAws_restJson1StreamFiles = (input: StreamFile[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1StreamFile(entry, context);
    });
};

const serializeAws_restJson1StringList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1SubnetIdList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1Tag = (input: Tag, context: __SerdeContext): any => {
  return {
    ...(input.Key !== undefined && input.Key !== null && { Key: input.Key }),
    ...(input.Value !== undefined && input.Value !== null && { Value: input.Value }),
  };
};

const serializeAws_restJson1TagKeyList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1TagList = (input: Tag[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1Tag(entry, context);
    });
};

const serializeAws_restJson1TargetAuditCheckNames = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1Targets = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1TargetViolationIdsForDetectMitigationActions = (
  input: string[],
  context: __SerdeContext
): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1TermsAggregation = (input: TermsAggregation, context: __SerdeContext): any => {
  return {
    ...(input.maxBuckets !== undefined && input.maxBuckets !== null && { maxBuckets: input.maxBuckets }),
  };
};

const serializeAws_restJson1ThingGroupIndexingConfiguration = (
  input: ThingGroupIndexingConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.customFields !== undefined &&
      input.customFields !== null && { customFields: serializeAws_restJson1Fields(input.customFields, context) }),
    ...(input.managedFields !== undefined &&
      input.managedFields !== null && { managedFields: serializeAws_restJson1Fields(input.managedFields, context) }),
    ...(input.thingGroupIndexingMode !== undefined &&
      input.thingGroupIndexingMode !== null && { thingGroupIndexingMode: input.thingGroupIndexingMode }),
  };
};

const serializeAws_restJson1ThingGroupList = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1ThingGroupNames = (input: string[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return entry;
    });
};

const serializeAws_restJson1ThingGroupProperties = (input: ThingGroupProperties, context: __SerdeContext): any => {
  return {
    ...(input.attributePayload !== undefined &&
      input.attributePayload !== null && {
        attributePayload: serializeAws_restJson1AttributePayload(input.attributePayload, context),
      }),
    ...(input.thingGroupDescription !== undefined &&
      input.thingGroupDescription !== null && { thingGroupDescription: input.thingGroupDescription }),
  };
};

const serializeAws_restJson1ThingIndexingConfiguration = (
  input: ThingIndexingConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.customFields !== undefined &&
      input.customFields !== null && { customFields: serializeAws_restJson1Fields(input.customFields, context) }),
    ...(input.managedFields !== undefined &&
      input.managedFields !== null && { managedFields: serializeAws_restJson1Fields(input.managedFields, context) }),
    ...(input.thingConnectivityIndexingMode !== undefined &&
      input.thingConnectivityIndexingMode !== null && {
        thingConnectivityIndexingMode: input.thingConnectivityIndexingMode,
      }),
    ...(input.thingIndexingMode !== undefined &&
      input.thingIndexingMode !== null && { thingIndexingMode: input.thingIndexingMode }),
  };
};

const serializeAws_restJson1ThingTypeProperties = (input: ThingTypeProperties, context: __SerdeContext): any => {
  return {
    ...(input.searchableAttributes !== undefined &&
      input.searchableAttributes !== null && {
        searchableAttributes: serializeAws_restJson1SearchableAttributes(input.searchableAttributes, context),
      }),
    ...(input.thingTypeDescription !== undefined &&
      input.thingTypeDescription !== null && { thingTypeDescription: input.thingTypeDescription }),
  };
};

const serializeAws_restJson1TimeoutConfig = (input: TimeoutConfig, context: __SerdeContext): any => {
  return {
    ...(input.inProgressTimeoutInMinutes !== undefined &&
      input.inProgressTimeoutInMinutes !== null && { inProgressTimeoutInMinutes: input.inProgressTimeoutInMinutes }),
  };
};

const serializeAws_restJson1TimestreamAction = (input: TimestreamAction, context: __SerdeContext): any => {
  return {
    ...(input.databaseName !== undefined && input.databaseName !== null && { databaseName: input.databaseName }),
    ...(input.dimensions !== undefined &&
      input.dimensions !== null && {
        dimensions: serializeAws_restJson1TimestreamDimensionList(input.dimensions, context),
      }),
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.tableName !== undefined && input.tableName !== null && { tableName: input.tableName }),
    ...(input.timestamp !== undefined &&
      input.timestamp !== null && { timestamp: serializeAws_restJson1TimestreamTimestamp(input.timestamp, context) }),
  };
};

const serializeAws_restJson1TimestreamDimension = (input: TimestreamDimension, context: __SerdeContext): any => {
  return {
    ...(input.name !== undefined && input.name !== null && { name: input.name }),
    ...(input.value !== undefined && input.value !== null && { value: input.value }),
  };
};

const serializeAws_restJson1TimestreamDimensionList = (input: TimestreamDimension[], context: __SerdeContext): any => {
  return input
    .filter((e: any) => e != null)
    .map((entry) => {
      if (entry === null) {
        return null as any;
      }
      return serializeAws_restJson1TimestreamDimension(entry, context);
    });
};

const serializeAws_restJson1TimestreamTimestamp = (input: TimestreamTimestamp, context: __SerdeContext): any => {
  return {
    ...(input.unit !== undefined && input.unit !== null && { unit: input.unit }),
    ...(input.value !== undefined && input.value !== null && { value: input.value }),
  };
};

const serializeAws_restJson1TlsContext = (input: TlsContext, context: __SerdeContext): any => {
  return {
    ...(input.serverName !== undefined && input.serverName !== null && { serverName: input.serverName }),
  };
};

const serializeAws_restJson1TopicRuleDestinationConfiguration = (
  input: TopicRuleDestinationConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.httpUrlConfiguration !== undefined &&
      input.httpUrlConfiguration !== null && {
        httpUrlConfiguration: serializeAws_restJson1HttpUrlDestinationConfiguration(
          input.httpUrlConfiguration,
          context
        ),
      }),
    ...(input.vpcConfiguration !== undefined &&
      input.vpcConfiguration !== null && {
        vpcConfiguration: serializeAws_restJson1VpcDestinationConfiguration(input.vpcConfiguration, context),
      }),
  };
};

const serializeAws_restJson1TopicRulePayload = (input: TopicRulePayload, context: __SerdeContext): any => {
  return {
    ...(input.actions !== undefined &&
      input.actions !== null && { actions: serializeAws_restJson1ActionList(input.actions, context) }),
    ...(input.awsIotSqlVersion !== undefined &&
      input.awsIotSqlVersion !== null && { awsIotSqlVersion: input.awsIotSqlVersion }),
    ...(input.description !== undefined && input.description !== null && { description: input.description }),
    ...(input.errorAction !== undefined &&
      input.errorAction !== null && { errorAction: serializeAws_restJson1Action(input.errorAction, context) }),
    ...(input.ruleDisabled !== undefined && input.ruleDisabled !== null && { ruleDisabled: input.ruleDisabled }),
    ...(input.sql !== undefined && input.sql !== null && { sql: input.sql }),
  };
};

const serializeAws_restJson1UpdateCACertificateParams = (
  input: UpdateCACertificateParams,
  context: __SerdeContext
): any => {
  return {
    ...(input.action !== undefined && input.action !== null && { action: input.action }),
  };
};

const serializeAws_restJson1UpdateDeviceCertificateParams = (
  input: UpdateDeviceCertificateParams,
  context: __SerdeContext
): any => {
  return {
    ...(input.action !== undefined && input.action !== null && { action: input.action }),
  };
};

const serializeAws_restJson1ViolationEventOccurrenceRange = (
  input: ViolationEventOccurrenceRange,
  context: __SerdeContext
): any => {
  return {
    ...(input.endTime !== undefined &&
      input.endTime !== null && { endTime: Math.round(input.endTime.getTime() / 1000) }),
    ...(input.startTime !== undefined &&
      input.startTime !== null && { startTime: Math.round(input.startTime.getTime() / 1000) }),
  };
};

const serializeAws_restJson1VpcDestinationConfiguration = (
  input: VpcDestinationConfiguration,
  context: __SerdeContext
): any => {
  return {
    ...(input.roleArn !== undefined && input.roleArn !== null && { roleArn: input.roleArn }),
    ...(input.securityGroups !== undefined &&
      input.securityGroups !== null && {
        securityGroups: serializeAws_restJson1SecurityGroupList(input.securityGroups, context),
      }),
    ...(input.subnetIds !== undefined &&
      input.subnetIds !== null && { subnetIds: serializeAws_restJson1SubnetIdList(input.subnetIds, context) }),
    ...(input.vpcId !== undefined && input.vpcId !== null && { vpcId: input.vpcId }),
  };
};

const deserializeAws_restJson1AbortConfig = (output: any, context: __SerdeContext): AbortConfig => {
  return {
    criteriaList:
      output.criteriaList !== undefined && output.criteriaList !== null
        ? deserializeAws_restJson1AbortCriteriaList(output.criteriaList, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1AbortCriteria = (output: any, context: __SerdeContext): AbortCriteria => {
  return {
    action: __expectString(output.action),
    failureType: __expectString(output.failureType),
    minNumberOfExecutedThings: __expectInt32(output.minNumberOfExecutedThings),
    thresholdPercentage: __limitedParseDouble(output.thresholdPercentage),
  } as any;
};

const deserializeAws_restJson1AbortCriteriaList = (output: any, context: __SerdeContext): AbortCriteria[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1AbortCriteria(entry, context);
    });
};

const deserializeAws_restJson1Action = (output: any, context: __SerdeContext): Action => {
  return {
    cloudwatchAlarm:
      output.cloudwatchAlarm !== undefined && output.cloudwatchAlarm !== null
        ? deserializeAws_restJson1CloudwatchAlarmAction(output.cloudwatchAlarm, context)
        : undefined,
    cloudwatchLogs:
      output.cloudwatchLogs !== undefined && output.cloudwatchLogs !== null
        ? deserializeAws_restJson1CloudwatchLogsAction(output.cloudwatchLogs, context)
        : undefined,
    cloudwatchMetric:
      output.cloudwatchMetric !== undefined && output.cloudwatchMetric !== null
        ? deserializeAws_restJson1CloudwatchMetricAction(output.cloudwatchMetric, context)
        : undefined,
    dynamoDB:
      output.dynamoDB !== undefined && output.dynamoDB !== null
        ? deserializeAws_restJson1DynamoDBAction(output.dynamoDB, context)
        : undefined,
    dynamoDBv2:
      output.dynamoDBv2 !== undefined && output.dynamoDBv2 !== null
        ? deserializeAws_restJson1DynamoDBv2Action(output.dynamoDBv2, context)
        : undefined,
    elasticsearch:
      output.elasticsearch !== undefined && output.elasticsearch !== null
        ? deserializeAws_restJson1ElasticsearchAction(output.elasticsearch, context)
        : undefined,
    firehose:
      output.firehose !== undefined && output.firehose !== null
        ? deserializeAws_restJson1FirehoseAction(output.firehose, context)
        : undefined,
    http:
      output.http !== undefined && output.http !== null
        ? deserializeAws_restJson1HttpAction(output.http, context)
        : undefined,
    iotAnalytics:
      output.iotAnalytics !== undefined && output.iotAnalytics !== null
        ? deserializeAws_restJson1IotAnalyticsAction(output.iotAnalytics, context)
        : undefined,
    iotEvents:
      output.iotEvents !== undefined && output.iotEvents !== null
        ? deserializeAws_restJson1IotEventsAction(output.iotEvents, context)
        : undefined,
    iotSiteWise:
      output.iotSiteWise !== undefined && output.iotSiteWise !== null
        ? deserializeAws_restJson1IotSiteWiseAction(output.iotSiteWise, context)
        : undefined,
    kafka:
      output.kafka !== undefined && output.kafka !== null
        ? deserializeAws_restJson1KafkaAction(output.kafka, context)
        : undefined,
    kinesis:
      output.kinesis !== undefined && output.kinesis !== null
        ? deserializeAws_restJson1KinesisAction(output.kinesis, context)
        : undefined,
    lambda:
      output.lambda !== undefined && output.lambda !== null
        ? deserializeAws_restJson1LambdaAction(output.lambda, context)
        : undefined,
    openSearch:
      output.openSearch !== undefined && output.openSearch !== null
        ? deserializeAws_restJson1OpenSearchAction(output.openSearch, context)
        : undefined,
    republish:
      output.republish !== undefined && output.republish !== null
        ? deserializeAws_restJson1RepublishAction(output.republish, context)
        : undefined,
    s3:
      output.s3 !== undefined && output.s3 !== null ? deserializeAws_restJson1S3Action(output.s3, context) : undefined,
    salesforce:
      output.salesforce !== undefined && output.salesforce !== null
        ? deserializeAws_restJson1SalesforceAction(output.salesforce, context)
        : undefined,
    sns:
      output.sns !== undefined && output.sns !== null
        ? deserializeAws_restJson1SnsAction(output.sns, context)
        : undefined,
    sqs:
      output.sqs !== undefined && output.sqs !== null
        ? deserializeAws_restJson1SqsAction(output.sqs, context)
        : undefined,
    stepFunctions:
      output.stepFunctions !== undefined && output.stepFunctions !== null
        ? deserializeAws_restJson1StepFunctionsAction(output.stepFunctions, context)
        : undefined,
    timestream:
      output.timestream !== undefined && output.timestream !== null
        ? deserializeAws_restJson1TimestreamAction(output.timestream, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1ActionList = (output: any, context: __SerdeContext): Action[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1Action(entry, context);
    });
};

const deserializeAws_restJson1ActiveViolation = (output: any, context: __SerdeContext): ActiveViolation => {
  return {
    behavior:
      output.behavior !== undefined && output.behavior !== null
        ? deserializeAws_restJson1Behavior(output.behavior, context)
        : undefined,
    lastViolationTime:
      output.lastViolationTime !== undefined && output.lastViolationTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastViolationTime)))
        : undefined,
    lastViolationValue:
      output.lastViolationValue !== undefined && output.lastViolationValue !== null
        ? deserializeAws_restJson1MetricValue(output.lastViolationValue, context)
        : undefined,
    securityProfileName: __expectString(output.securityProfileName),
    thingName: __expectString(output.thingName),
    violationEventAdditionalInfo:
      output.violationEventAdditionalInfo !== undefined && output.violationEventAdditionalInfo !== null
        ? deserializeAws_restJson1ViolationEventAdditionalInfo(output.violationEventAdditionalInfo, context)
        : undefined,
    violationId: __expectString(output.violationId),
    violationStartTime:
      output.violationStartTime !== undefined && output.violationStartTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.violationStartTime)))
        : undefined,
  } as any;
};

const deserializeAws_restJson1ActiveViolations = (output: any, context: __SerdeContext): ActiveViolation[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ActiveViolation(entry, context);
    });
};

const deserializeAws_restJson1AdditionalMetricsToRetainList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1AdditionalMetricsToRetainV2List = (
  output: any,
  context: __SerdeContext
): MetricToRetain[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1MetricToRetain(entry, context);
    });
};

const deserializeAws_restJson1AdditionalParameterMap = (
  output: any,
  context: __SerdeContext
): { [key: string]: string } => {
  return Object.entries(output).reduce((acc: { [key: string]: string }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: __expectString(value) as any,
    };
  }, {});
};

const deserializeAws_restJson1AddThingsToThingGroupParams = (
  output: any,
  context: __SerdeContext
): AddThingsToThingGroupParams => {
  return {
    overrideDynamicGroups: __expectBoolean(output.overrideDynamicGroups),
    thingGroupNames:
      output.thingGroupNames !== undefined && output.thingGroupNames !== null
        ? deserializeAws_restJson1ThingGroupNames(output.thingGroupNames, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1AggregationType = (output: any, context: __SerdeContext): AggregationType => {
  return {
    name: __expectString(output.name),
    values:
      output.values !== undefined && output.values !== null
        ? deserializeAws_restJson1AggregationTypeValues(output.values, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1AggregationTypeValues = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1AlertTarget = (output: any, context: __SerdeContext): AlertTarget => {
  return {
    alertTargetArn: __expectString(output.alertTargetArn),
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1AlertTargets = (output: any, context: __SerdeContext): { [key: string]: AlertTarget } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: AlertTarget }, [key, value]: [AlertTargetType | string, any]) => {
      if (value === null) {
        return acc;
      }
      return {
        ...acc,
        [key]: deserializeAws_restJson1AlertTarget(value, context),
      };
    },
    {}
  );
};

const deserializeAws_restJson1Allowed = (output: any, context: __SerdeContext): Allowed => {
  return {
    policies:
      output.policies !== undefined && output.policies !== null
        ? deserializeAws_restJson1Policies(output.policies, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1AssetPropertyTimestamp = (
  output: any,
  context: __SerdeContext
): AssetPropertyTimestamp => {
  return {
    offsetInNanos: __expectString(output.offsetInNanos),
    timeInSeconds: __expectString(output.timeInSeconds),
  } as any;
};

const deserializeAws_restJson1AssetPropertyValue = (output: any, context: __SerdeContext): AssetPropertyValue => {
  return {
    quality: __expectString(output.quality),
    timestamp:
      output.timestamp !== undefined && output.timestamp !== null
        ? deserializeAws_restJson1AssetPropertyTimestamp(output.timestamp, context)
        : undefined,
    value:
      output.value !== undefined && output.value !== null
        ? deserializeAws_restJson1AssetPropertyVariant(__expectUnion(output.value), context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1AssetPropertyValueList = (output: any, context: __SerdeContext): AssetPropertyValue[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1AssetPropertyValue(entry, context);
    });
};

const deserializeAws_restJson1AssetPropertyVariant = (output: any, context: __SerdeContext): AssetPropertyVariant => {
  if (__expectString(output.booleanValue) !== undefined) {
    return { booleanValue: __expectString(output.booleanValue) as any };
  }
  if (__expectString(output.doubleValue) !== undefined) {
    return { doubleValue: __expectString(output.doubleValue) as any };
  }
  if (__expectString(output.integerValue) !== undefined) {
    return { integerValue: __expectString(output.integerValue) as any };
  }
  if (__expectString(output.stringValue) !== undefined) {
    return { stringValue: __expectString(output.stringValue) as any };
  }
  return { $unknown: Object.entries(output)[0] };
};

const deserializeAws_restJson1AttributePayload = (output: any, context: __SerdeContext): AttributePayload => {
  return {
    attributes:
      output.attributes !== undefined && output.attributes !== null
        ? deserializeAws_restJson1Attributes(output.attributes, context)
        : undefined,
    merge: __expectBoolean(output.merge),
  } as any;
};

const deserializeAws_restJson1Attributes = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce((acc: { [key: string]: string }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: __expectString(value) as any,
    };
  }, {});
};

const deserializeAws_restJson1AttributesMap = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce((acc: { [key: string]: string }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: __expectString(value) as any,
    };
  }, {});
};

const deserializeAws_restJson1AuditCheckConfiguration = (
  output: any,
  context: __SerdeContext
): AuditCheckConfiguration => {
  return {
    enabled: __expectBoolean(output.enabled),
  } as any;
};

const deserializeAws_restJson1AuditCheckConfigurations = (
  output: any,
  context: __SerdeContext
): { [key: string]: AuditCheckConfiguration } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: AuditCheckConfiguration }, [key, value]: [string, any]) => {
      if (value === null) {
        return acc;
      }
      return {
        ...acc,
        [key]: deserializeAws_restJson1AuditCheckConfiguration(value, context),
      };
    },
    {}
  );
};

const deserializeAws_restJson1AuditCheckDetails = (output: any, context: __SerdeContext): AuditCheckDetails => {
  return {
    checkCompliant: __expectBoolean(output.checkCompliant),
    checkRunStatus: __expectString(output.checkRunStatus),
    errorCode: __expectString(output.errorCode),
    message: __expectString(output.message),
    nonCompliantResourcesCount: __expectLong(output.nonCompliantResourcesCount),
    suppressedNonCompliantResourcesCount: __expectLong(output.suppressedNonCompliantResourcesCount),
    totalResourcesCount: __expectLong(output.totalResourcesCount),
  } as any;
};

const deserializeAws_restJson1AuditCheckToActionsMapping = (
  output: any,
  context: __SerdeContext
): { [key: string]: string[] } => {
  return Object.entries(output).reduce((acc: { [key: string]: string[] }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: deserializeAws_restJson1MitigationActionNameList(value, context),
    };
  }, {});
};

const deserializeAws_restJson1AuditCheckToReasonCodeFilter = (
  output: any,
  context: __SerdeContext
): { [key: string]: string[] } => {
  return Object.entries(output).reduce((acc: { [key: string]: string[] }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: deserializeAws_restJson1ReasonForNonComplianceCodes(value, context),
    };
  }, {});
};

const deserializeAws_restJson1AuditDetails = (
  output: any,
  context: __SerdeContext
): { [key: string]: AuditCheckDetails } => {
  return Object.entries(output).reduce((acc: { [key: string]: AuditCheckDetails }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: deserializeAws_restJson1AuditCheckDetails(value, context),
    };
  }, {});
};

const deserializeAws_restJson1AuditFinding = (output: any, context: __SerdeContext): AuditFinding => {
  return {
    checkName: __expectString(output.checkName),
    findingId: __expectString(output.findingId),
    findingTime:
      output.findingTime !== undefined && output.findingTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.findingTime)))
        : undefined,
    isSuppressed: __expectBoolean(output.isSuppressed),
    nonCompliantResource:
      output.nonCompliantResource !== undefined && output.nonCompliantResource !== null
        ? deserializeAws_restJson1NonCompliantResource(output.nonCompliantResource, context)
        : undefined,
    reasonForNonCompliance: __expectString(output.reasonForNonCompliance),
    reasonForNonComplianceCode: __expectString(output.reasonForNonComplianceCode),
    relatedResources:
      output.relatedResources !== undefined && output.relatedResources !== null
        ? deserializeAws_restJson1RelatedResources(output.relatedResources, context)
        : undefined,
    severity: __expectString(output.severity),
    taskId: __expectString(output.taskId),
    taskStartTime:
      output.taskStartTime !== undefined && output.taskStartTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.taskStartTime)))
        : undefined,
  } as any;
};

const deserializeAws_restJson1AuditFindings = (output: any, context: __SerdeContext): AuditFinding[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1AuditFinding(entry, context);
    });
};

const deserializeAws_restJson1AuditMitigationActionExecutionMetadata = (
  output: any,
  context: __SerdeContext
): AuditMitigationActionExecutionMetadata => {
  return {
    actionId: __expectString(output.actionId),
    actionName: __expectString(output.actionName),
    endTime:
      output.endTime !== undefined && output.endTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.endTime)))
        : undefined,
    errorCode: __expectString(output.errorCode),
    findingId: __expectString(output.findingId),
    message: __expectString(output.message),
    startTime:
      output.startTime !== undefined && output.startTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startTime)))
        : undefined,
    status: __expectString(output.status),
    taskId: __expectString(output.taskId),
  } as any;
};

const deserializeAws_restJson1AuditMitigationActionExecutionMetadataList = (
  output: any,
  context: __SerdeContext
): AuditMitigationActionExecutionMetadata[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1AuditMitigationActionExecutionMetadata(entry, context);
    });
};

const deserializeAws_restJson1AuditMitigationActionsTaskMetadata = (
  output: any,
  context: __SerdeContext
): AuditMitigationActionsTaskMetadata => {
  return {
    startTime:
      output.startTime !== undefined && output.startTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startTime)))
        : undefined,
    taskId: __expectString(output.taskId),
    taskStatus: __expectString(output.taskStatus),
  } as any;
};

const deserializeAws_restJson1AuditMitigationActionsTaskMetadataList = (
  output: any,
  context: __SerdeContext
): AuditMitigationActionsTaskMetadata[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1AuditMitigationActionsTaskMetadata(entry, context);
    });
};

const deserializeAws_restJson1AuditMitigationActionsTaskStatistics = (
  output: any,
  context: __SerdeContext
): { [key: string]: TaskStatisticsForAuditCheck } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: TaskStatisticsForAuditCheck }, [key, value]: [string, any]) => {
      if (value === null) {
        return acc;
      }
      return {
        ...acc,
        [key]: deserializeAws_restJson1TaskStatisticsForAuditCheck(value, context),
      };
    },
    {}
  );
};

const deserializeAws_restJson1AuditMitigationActionsTaskTarget = (
  output: any,
  context: __SerdeContext
): AuditMitigationActionsTaskTarget => {
  return {
    auditCheckToReasonCodeFilter:
      output.auditCheckToReasonCodeFilter !== undefined && output.auditCheckToReasonCodeFilter !== null
        ? deserializeAws_restJson1AuditCheckToReasonCodeFilter(output.auditCheckToReasonCodeFilter, context)
        : undefined,
    auditTaskId: __expectString(output.auditTaskId),
    findingIds:
      output.findingIds !== undefined && output.findingIds !== null
        ? deserializeAws_restJson1FindingIds(output.findingIds, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1AuditNotificationTarget = (
  output: any,
  context: __SerdeContext
): AuditNotificationTarget => {
  return {
    enabled: __expectBoolean(output.enabled),
    roleArn: __expectString(output.roleArn),
    targetArn: __expectString(output.targetArn),
  } as any;
};

const deserializeAws_restJson1AuditNotificationTargetConfigurations = (
  output: any,
  context: __SerdeContext
): { [key: string]: AuditNotificationTarget } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: AuditNotificationTarget }, [key, value]: [AuditNotificationType | string, any]) => {
      if (value === null) {
        return acc;
      }
      return {
        ...acc,
        [key]: deserializeAws_restJson1AuditNotificationTarget(value, context),
      };
    },
    {}
  );
};

const deserializeAws_restJson1AuditSuppression = (output: any, context: __SerdeContext): AuditSuppression => {
  return {
    checkName: __expectString(output.checkName),
    description: __expectString(output.description),
    expirationDate:
      output.expirationDate !== undefined && output.expirationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.expirationDate)))
        : undefined,
    resourceIdentifier:
      output.resourceIdentifier !== undefined && output.resourceIdentifier !== null
        ? deserializeAws_restJson1ResourceIdentifier(output.resourceIdentifier, context)
        : undefined,
    suppressIndefinitely: __expectBoolean(output.suppressIndefinitely),
  } as any;
};

const deserializeAws_restJson1AuditSuppressionList = (output: any, context: __SerdeContext): AuditSuppression[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1AuditSuppression(entry, context);
    });
};

const deserializeAws_restJson1AuditTaskMetadata = (output: any, context: __SerdeContext): AuditTaskMetadata => {
  return {
    taskId: __expectString(output.taskId),
    taskStatus: __expectString(output.taskStatus),
    taskType: __expectString(output.taskType),
  } as any;
};

const deserializeAws_restJson1AuditTaskMetadataList = (output: any, context: __SerdeContext): AuditTaskMetadata[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1AuditTaskMetadata(entry, context);
    });
};

const deserializeAws_restJson1AuthInfo = (output: any, context: __SerdeContext): AuthInfo => {
  return {
    actionType: __expectString(output.actionType),
    resources:
      output.resources !== undefined && output.resources !== null
        ? deserializeAws_restJson1Resources(output.resources, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1AuthorizerConfig = (output: any, context: __SerdeContext): AuthorizerConfig => {
  return {
    allowAuthorizerOverride: __expectBoolean(output.allowAuthorizerOverride),
    defaultAuthorizerName: __expectString(output.defaultAuthorizerName),
  } as any;
};

const deserializeAws_restJson1AuthorizerDescription = (output: any, context: __SerdeContext): AuthorizerDescription => {
  return {
    authorizerArn: __expectString(output.authorizerArn),
    authorizerFunctionArn: __expectString(output.authorizerFunctionArn),
    authorizerName: __expectString(output.authorizerName),
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    lastModifiedDate:
      output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
        : undefined,
    signingDisabled: __expectBoolean(output.signingDisabled),
    status: __expectString(output.status),
    tokenKeyName: __expectString(output.tokenKeyName),
    tokenSigningPublicKeys:
      output.tokenSigningPublicKeys !== undefined && output.tokenSigningPublicKeys !== null
        ? deserializeAws_restJson1PublicKeyMap(output.tokenSigningPublicKeys, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1Authorizers = (output: any, context: __SerdeContext): AuthorizerSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1AuthorizerSummary(entry, context);
    });
};

const deserializeAws_restJson1AuthorizerSummary = (output: any, context: __SerdeContext): AuthorizerSummary => {
  return {
    authorizerArn: __expectString(output.authorizerArn),
    authorizerName: __expectString(output.authorizerName),
  } as any;
};

const deserializeAws_restJson1AuthResult = (output: any, context: __SerdeContext): AuthResult => {
  return {
    allowed:
      output.allowed !== undefined && output.allowed !== null
        ? deserializeAws_restJson1Allowed(output.allowed, context)
        : undefined,
    authDecision: __expectString(output.authDecision),
    authInfo:
      output.authInfo !== undefined && output.authInfo !== null
        ? deserializeAws_restJson1AuthInfo(output.authInfo, context)
        : undefined,
    denied:
      output.denied !== undefined && output.denied !== null
        ? deserializeAws_restJson1Denied(output.denied, context)
        : undefined,
    missingContextValues:
      output.missingContextValues !== undefined && output.missingContextValues !== null
        ? deserializeAws_restJson1MissingContextValues(output.missingContextValues, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1AuthResults = (output: any, context: __SerdeContext): AuthResult[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1AuthResult(entry, context);
    });
};

const deserializeAws_restJson1AwsJobExecutionsRolloutConfig = (
  output: any,
  context: __SerdeContext
): AwsJobExecutionsRolloutConfig => {
  return {
    exponentialRate:
      output.exponentialRate !== undefined && output.exponentialRate !== null
        ? deserializeAws_restJson1AwsJobExponentialRolloutRate(output.exponentialRate, context)
        : undefined,
    maximumPerMinute: __expectInt32(output.maximumPerMinute),
  } as any;
};

const deserializeAws_restJson1AwsJobExponentialRolloutRate = (
  output: any,
  context: __SerdeContext
): AwsJobExponentialRolloutRate => {
  return {
    baseRatePerMinute: __expectInt32(output.baseRatePerMinute),
    incrementFactor: __limitedParseDouble(output.incrementFactor),
    rateIncreaseCriteria:
      output.rateIncreaseCriteria !== undefined && output.rateIncreaseCriteria !== null
        ? deserializeAws_restJson1AwsJobRateIncreaseCriteria(output.rateIncreaseCriteria, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1AwsJobPresignedUrlConfig = (
  output: any,
  context: __SerdeContext
): AwsJobPresignedUrlConfig => {
  return {
    expiresInSec: __expectLong(output.expiresInSec),
  } as any;
};

const deserializeAws_restJson1AwsJobRateIncreaseCriteria = (
  output: any,
  context: __SerdeContext
): AwsJobRateIncreaseCriteria => {
  return {
    numberOfNotifiedThings: __expectInt32(output.numberOfNotifiedThings),
    numberOfSucceededThings: __expectInt32(output.numberOfSucceededThings),
  } as any;
};

const deserializeAws_restJson1Behavior = (output: any, context: __SerdeContext): Behavior => {
  return {
    criteria:
      output.criteria !== undefined && output.criteria !== null
        ? deserializeAws_restJson1BehaviorCriteria(output.criteria, context)
        : undefined,
    metric: __expectString(output.metric),
    metricDimension:
      output.metricDimension !== undefined && output.metricDimension !== null
        ? deserializeAws_restJson1MetricDimension(output.metricDimension, context)
        : undefined,
    name: __expectString(output.name),
    suppressAlerts: __expectBoolean(output.suppressAlerts),
  } as any;
};

const deserializeAws_restJson1BehaviorCriteria = (output: any, context: __SerdeContext): BehaviorCriteria => {
  return {
    comparisonOperator: __expectString(output.comparisonOperator),
    consecutiveDatapointsToAlarm: __expectInt32(output.consecutiveDatapointsToAlarm),
    consecutiveDatapointsToClear: __expectInt32(output.consecutiveDatapointsToClear),
    durationSeconds: __expectInt32(output.durationSeconds),
    mlDetectionConfig:
      output.mlDetectionConfig !== undefined && output.mlDetectionConfig !== null
        ? deserializeAws_restJson1MachineLearningDetectionConfig(output.mlDetectionConfig, context)
        : undefined,
    statisticalThreshold:
      output.statisticalThreshold !== undefined && output.statisticalThreshold !== null
        ? deserializeAws_restJson1StatisticalThreshold(output.statisticalThreshold, context)
        : undefined,
    value:
      output.value !== undefined && output.value !== null
        ? deserializeAws_restJson1MetricValue(output.value, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1BehaviorModelTrainingSummaries = (
  output: any,
  context: __SerdeContext
): BehaviorModelTrainingSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1BehaviorModelTrainingSummary(entry, context);
    });
};

const deserializeAws_restJson1BehaviorModelTrainingSummary = (
  output: any,
  context: __SerdeContext
): BehaviorModelTrainingSummary => {
  return {
    behaviorName: __expectString(output.behaviorName),
    datapointsCollectionPercentage: __limitedParseDouble(output.datapointsCollectionPercentage),
    lastModelRefreshDate:
      output.lastModelRefreshDate !== undefined && output.lastModelRefreshDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModelRefreshDate)))
        : undefined,
    modelStatus: __expectString(output.modelStatus),
    securityProfileName: __expectString(output.securityProfileName),
    trainingDataCollectionStartDate:
      output.trainingDataCollectionStartDate !== undefined && output.trainingDataCollectionStartDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.trainingDataCollectionStartDate)))
        : undefined,
  } as any;
};

const deserializeAws_restJson1Behaviors = (output: any, context: __SerdeContext): Behavior[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1Behavior(entry, context);
    });
};

const deserializeAws_restJson1BillingGroupMetadata = (output: any, context: __SerdeContext): BillingGroupMetadata => {
  return {
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
  } as any;
};

const deserializeAws_restJson1BillingGroupNameAndArnList = (
  output: any,
  context: __SerdeContext
): GroupNameAndArn[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1GroupNameAndArn(entry, context);
    });
};

const deserializeAws_restJson1BillingGroupProperties = (
  output: any,
  context: __SerdeContext
): BillingGroupProperties => {
  return {
    billingGroupDescription: __expectString(output.billingGroupDescription),
  } as any;
};

const deserializeAws_restJson1Bucket = (output: any, context: __SerdeContext): Bucket => {
  return {
    count: __expectInt32(output.count),
    keyValue: __expectString(output.keyValue),
  } as any;
};

const deserializeAws_restJson1Buckets = (output: any, context: __SerdeContext): Bucket[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1Bucket(entry, context);
    });
};

const deserializeAws_restJson1CACertificate = (output: any, context: __SerdeContext): CACertificate => {
  return {
    certificateArn: __expectString(output.certificateArn),
    certificateId: __expectString(output.certificateId),
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    status: __expectString(output.status),
  } as any;
};

const deserializeAws_restJson1CACertificateDescription = (
  output: any,
  context: __SerdeContext
): CACertificateDescription => {
  return {
    autoRegistrationStatus: __expectString(output.autoRegistrationStatus),
    certificateArn: __expectString(output.certificateArn),
    certificateId: __expectString(output.certificateId),
    certificatePem: __expectString(output.certificatePem),
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    customerVersion: __expectInt32(output.customerVersion),
    generationId: __expectString(output.generationId),
    lastModifiedDate:
      output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
        : undefined,
    ownedBy: __expectString(output.ownedBy),
    status: __expectString(output.status),
    validity:
      output.validity !== undefined && output.validity !== null
        ? deserializeAws_restJson1CertificateValidity(output.validity, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1CACertificates = (output: any, context: __SerdeContext): CACertificate[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1CACertificate(entry, context);
    });
};

const deserializeAws_restJson1Certificate = (output: any, context: __SerdeContext): Certificate => {
  return {
    certificateArn: __expectString(output.certificateArn),
    certificateId: __expectString(output.certificateId),
    certificateMode: __expectString(output.certificateMode),
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    status: __expectString(output.status),
  } as any;
};

const deserializeAws_restJson1CertificateDescription = (
  output: any,
  context: __SerdeContext
): CertificateDescription => {
  return {
    caCertificateId: __expectString(output.caCertificateId),
    certificateArn: __expectString(output.certificateArn),
    certificateId: __expectString(output.certificateId),
    certificateMode: __expectString(output.certificateMode),
    certificatePem: __expectString(output.certificatePem),
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    customerVersion: __expectInt32(output.customerVersion),
    generationId: __expectString(output.generationId),
    lastModifiedDate:
      output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
        : undefined,
    ownedBy: __expectString(output.ownedBy),
    previousOwnedBy: __expectString(output.previousOwnedBy),
    status: __expectString(output.status),
    transferData:
      output.transferData !== undefined && output.transferData !== null
        ? deserializeAws_restJson1TransferData(output.transferData, context)
        : undefined,
    validity:
      output.validity !== undefined && output.validity !== null
        ? deserializeAws_restJson1CertificateValidity(output.validity, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1Certificates = (output: any, context: __SerdeContext): Certificate[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1Certificate(entry, context);
    });
};

const deserializeAws_restJson1CertificateValidity = (output: any, context: __SerdeContext): CertificateValidity => {
  return {
    notAfter:
      output.notAfter !== undefined && output.notAfter !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.notAfter)))
        : undefined,
    notBefore:
      output.notBefore !== undefined && output.notBefore !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.notBefore)))
        : undefined,
  } as any;
};

const deserializeAws_restJson1Cidrs = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1ClientProperties = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce((acc: { [key: string]: string }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: __expectString(value) as any,
    };
  }, {});
};

const deserializeAws_restJson1CloudwatchAlarmAction = (output: any, context: __SerdeContext): CloudwatchAlarmAction => {
  return {
    alarmName: __expectString(output.alarmName),
    roleArn: __expectString(output.roleArn),
    stateReason: __expectString(output.stateReason),
    stateValue: __expectString(output.stateValue),
  } as any;
};

const deserializeAws_restJson1CloudwatchLogsAction = (output: any, context: __SerdeContext): CloudwatchLogsAction => {
  return {
    logGroupName: __expectString(output.logGroupName),
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1CloudwatchMetricAction = (
  output: any,
  context: __SerdeContext
): CloudwatchMetricAction => {
  return {
    metricName: __expectString(output.metricName),
    metricNamespace: __expectString(output.metricNamespace),
    metricTimestamp: __expectString(output.metricTimestamp),
    metricUnit: __expectString(output.metricUnit),
    metricValue: __expectString(output.metricValue),
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1CodeSigning = (output: any, context: __SerdeContext): CodeSigning => {
  return {
    awsSignerJobId: __expectString(output.awsSignerJobId),
    customCodeSigning:
      output.customCodeSigning !== undefined && output.customCodeSigning !== null
        ? deserializeAws_restJson1CustomCodeSigning(output.customCodeSigning, context)
        : undefined,
    startSigningJobParameter:
      output.startSigningJobParameter !== undefined && output.startSigningJobParameter !== null
        ? deserializeAws_restJson1StartSigningJobParameter(output.startSigningJobParameter, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1CodeSigningCertificateChain = (
  output: any,
  context: __SerdeContext
): CodeSigningCertificateChain => {
  return {
    certificateName: __expectString(output.certificateName),
    inlineDocument: __expectString(output.inlineDocument),
  } as any;
};

const deserializeAws_restJson1CodeSigningSignature = (output: any, context: __SerdeContext): CodeSigningSignature => {
  return {
    inlineDocument:
      output.inlineDocument !== undefined && output.inlineDocument !== null
        ? context.base64Decoder(output.inlineDocument)
        : undefined,
  } as any;
};

const deserializeAws_restJson1Configuration = (output: any, context: __SerdeContext): Configuration => {
  return {
    Enabled: __expectBoolean(output.Enabled),
  } as any;
};

const deserializeAws_restJson1CustomCodeSigning = (output: any, context: __SerdeContext): CustomCodeSigning => {
  return {
    certificateChain:
      output.certificateChain !== undefined && output.certificateChain !== null
        ? deserializeAws_restJson1CodeSigningCertificateChain(output.certificateChain, context)
        : undefined,
    hashAlgorithm: __expectString(output.hashAlgorithm),
    signature:
      output.signature !== undefined && output.signature !== null
        ? deserializeAws_restJson1CodeSigningSignature(output.signature, context)
        : undefined,
    signatureAlgorithm: __expectString(output.signatureAlgorithm),
  } as any;
};

const deserializeAws_restJson1Denied = (output: any, context: __SerdeContext): Denied => {
  return {
    explicitDeny:
      output.explicitDeny !== undefined && output.explicitDeny !== null
        ? deserializeAws_restJson1ExplicitDeny(output.explicitDeny, context)
        : undefined,
    implicitDeny:
      output.implicitDeny !== undefined && output.implicitDeny !== null
        ? deserializeAws_restJson1ImplicitDeny(output.implicitDeny, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1Destination = (output: any, context: __SerdeContext): Destination => {
  return {
    s3Destination:
      output.s3Destination !== undefined && output.s3Destination !== null
        ? deserializeAws_restJson1S3Destination(output.s3Destination, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1DetailsMap = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce((acc: { [key: string]: string }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: __expectString(value) as any,
    };
  }, {});
};

const deserializeAws_restJson1DetectMitigationActionExecution = (
  output: any,
  context: __SerdeContext
): DetectMitigationActionExecution => {
  return {
    actionName: __expectString(output.actionName),
    errorCode: __expectString(output.errorCode),
    executionEndDate:
      output.executionEndDate !== undefined && output.executionEndDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.executionEndDate)))
        : undefined,
    executionStartDate:
      output.executionStartDate !== undefined && output.executionStartDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.executionStartDate)))
        : undefined,
    message: __expectString(output.message),
    status: __expectString(output.status),
    taskId: __expectString(output.taskId),
    thingName: __expectString(output.thingName),
    violationId: __expectString(output.violationId),
  } as any;
};

const deserializeAws_restJson1DetectMitigationActionExecutionList = (
  output: any,
  context: __SerdeContext
): DetectMitigationActionExecution[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1DetectMitigationActionExecution(entry, context);
    });
};

const deserializeAws_restJson1DetectMitigationActionsTaskStatistics = (
  output: any,
  context: __SerdeContext
): DetectMitigationActionsTaskStatistics => {
  return {
    actionsExecuted: __expectLong(output.actionsExecuted),
    actionsFailed: __expectLong(output.actionsFailed),
    actionsSkipped: __expectLong(output.actionsSkipped),
  } as any;
};

const deserializeAws_restJson1DetectMitigationActionsTaskSummary = (
  output: any,
  context: __SerdeContext
): DetectMitigationActionsTaskSummary => {
  return {
    actionsDefinition:
      output.actionsDefinition !== undefined && output.actionsDefinition !== null
        ? deserializeAws_restJson1MitigationActionList(output.actionsDefinition, context)
        : undefined,
    onlyActiveViolationsIncluded: __expectBoolean(output.onlyActiveViolationsIncluded),
    suppressedAlertsIncluded: __expectBoolean(output.suppressedAlertsIncluded),
    target:
      output.target !== undefined && output.target !== null
        ? deserializeAws_restJson1DetectMitigationActionsTaskTarget(output.target, context)
        : undefined,
    taskEndTime:
      output.taskEndTime !== undefined && output.taskEndTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.taskEndTime)))
        : undefined,
    taskId: __expectString(output.taskId),
    taskStartTime:
      output.taskStartTime !== undefined && output.taskStartTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.taskStartTime)))
        : undefined,
    taskStatistics:
      output.taskStatistics !== undefined && output.taskStatistics !== null
        ? deserializeAws_restJson1DetectMitigationActionsTaskStatistics(output.taskStatistics, context)
        : undefined,
    taskStatus: __expectString(output.taskStatus),
    violationEventOccurrenceRange:
      output.violationEventOccurrenceRange !== undefined && output.violationEventOccurrenceRange !== null
        ? deserializeAws_restJson1ViolationEventOccurrenceRange(output.violationEventOccurrenceRange, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1DetectMitigationActionsTaskSummaryList = (
  output: any,
  context: __SerdeContext
): DetectMitigationActionsTaskSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1DetectMitigationActionsTaskSummary(entry, context);
    });
};

const deserializeAws_restJson1DetectMitigationActionsTaskTarget = (
  output: any,
  context: __SerdeContext
): DetectMitigationActionsTaskTarget => {
  return {
    behaviorName: __expectString(output.behaviorName),
    securityProfileName: __expectString(output.securityProfileName),
    violationIds:
      output.violationIds !== undefined && output.violationIds !== null
        ? deserializeAws_restJson1TargetViolationIdsForDetectMitigationActions(output.violationIds, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1DimensionNames = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1DimensionStringValues = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1DomainConfigurations = (
  output: any,
  context: __SerdeContext
): DomainConfigurationSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1DomainConfigurationSummary(entry, context);
    });
};

const deserializeAws_restJson1DomainConfigurationSummary = (
  output: any,
  context: __SerdeContext
): DomainConfigurationSummary => {
  return {
    domainConfigurationArn: __expectString(output.domainConfigurationArn),
    domainConfigurationName: __expectString(output.domainConfigurationName),
    serviceType: __expectString(output.serviceType),
  } as any;
};

const deserializeAws_restJson1DynamoDBAction = (output: any, context: __SerdeContext): DynamoDBAction => {
  return {
    hashKeyField: __expectString(output.hashKeyField),
    hashKeyType: __expectString(output.hashKeyType),
    hashKeyValue: __expectString(output.hashKeyValue),
    operation: __expectString(output.operation),
    payloadField: __expectString(output.payloadField),
    rangeKeyField: __expectString(output.rangeKeyField),
    rangeKeyType: __expectString(output.rangeKeyType),
    rangeKeyValue: __expectString(output.rangeKeyValue),
    roleArn: __expectString(output.roleArn),
    tableName: __expectString(output.tableName),
  } as any;
};

const deserializeAws_restJson1DynamoDBv2Action = (output: any, context: __SerdeContext): DynamoDBv2Action => {
  return {
    putItem:
      output.putItem !== undefined && output.putItem !== null
        ? deserializeAws_restJson1PutItemInput(output.putItem, context)
        : undefined,
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1EffectivePolicies = (output: any, context: __SerdeContext): EffectivePolicy[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1EffectivePolicy(entry, context);
    });
};

const deserializeAws_restJson1EffectivePolicy = (output: any, context: __SerdeContext): EffectivePolicy => {
  return {
    policyArn: __expectString(output.policyArn),
    policyDocument: __expectString(output.policyDocument),
    policyName: __expectString(output.policyName),
  } as any;
};

const deserializeAws_restJson1ElasticsearchAction = (output: any, context: __SerdeContext): ElasticsearchAction => {
  return {
    endpoint: __expectString(output.endpoint),
    id: __expectString(output.id),
    index: __expectString(output.index),
    roleArn: __expectString(output.roleArn),
    type: __expectString(output.type),
  } as any;
};

const deserializeAws_restJson1EnableIoTLoggingParams = (
  output: any,
  context: __SerdeContext
): EnableIoTLoggingParams => {
  return {
    logLevel: __expectString(output.logLevel),
    roleArnForLogging: __expectString(output.roleArnForLogging),
  } as any;
};

const deserializeAws_restJson1ErrorInfo = (output: any, context: __SerdeContext): ErrorInfo => {
  return {
    code: __expectString(output.code),
    message: __expectString(output.message),
  } as any;
};

const deserializeAws_restJson1EventConfigurations = (
  output: any,
  context: __SerdeContext
): { [key: string]: Configuration } => {
  return Object.entries(output).reduce(
    (acc: { [key: string]: Configuration }, [key, value]: [EventType | string, any]) => {
      if (value === null) {
        return acc;
      }
      return {
        ...acc,
        [key]: deserializeAws_restJson1Configuration(value, context),
      };
    },
    {}
  );
};

const deserializeAws_restJson1ExplicitDeny = (output: any, context: __SerdeContext): ExplicitDeny => {
  return {
    policies:
      output.policies !== undefined && output.policies !== null
        ? deserializeAws_restJson1Policies(output.policies, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1ExponentialRolloutRate = (
  output: any,
  context: __SerdeContext
): ExponentialRolloutRate => {
  return {
    baseRatePerMinute: __expectInt32(output.baseRatePerMinute),
    incrementFactor: __limitedParseDouble(output.incrementFactor),
    rateIncreaseCriteria:
      output.rateIncreaseCriteria !== undefined && output.rateIncreaseCriteria !== null
        ? deserializeAws_restJson1RateIncreaseCriteria(output.rateIncreaseCriteria, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1Field = (output: any, context: __SerdeContext): Field => {
  return {
    name: __expectString(output.name),
    type: __expectString(output.type),
  } as any;
};

const deserializeAws_restJson1Fields = (output: any, context: __SerdeContext): Field[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1Field(entry, context);
    });
};

const deserializeAws_restJson1FileLocation = (output: any, context: __SerdeContext): FileLocation => {
  return {
    s3Location:
      output.s3Location !== undefined && output.s3Location !== null
        ? deserializeAws_restJson1S3Location(output.s3Location, context)
        : undefined,
    stream:
      output.stream !== undefined && output.stream !== null
        ? deserializeAws_restJson1_Stream(output.stream, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1FindingIds = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1FirehoseAction = (output: any, context: __SerdeContext): FirehoseAction => {
  return {
    batchMode: __expectBoolean(output.batchMode),
    deliveryStreamName: __expectString(output.deliveryStreamName),
    roleArn: __expectString(output.roleArn),
    separator: __expectString(output.separator),
  } as any;
};

const deserializeAws_restJson1FleetMetricNameAndArn = (output: any, context: __SerdeContext): FleetMetricNameAndArn => {
  return {
    metricArn: __expectString(output.metricArn),
    metricName: __expectString(output.metricName),
  } as any;
};

const deserializeAws_restJson1FleetMetricNameAndArnList = (
  output: any,
  context: __SerdeContext
): FleetMetricNameAndArn[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1FleetMetricNameAndArn(entry, context);
    });
};

const deserializeAws_restJson1GroupNameAndArn = (output: any, context: __SerdeContext): GroupNameAndArn => {
  return {
    groupArn: __expectString(output.groupArn),
    groupName: __expectString(output.groupName),
  } as any;
};

const deserializeAws_restJson1HeaderList = (output: any, context: __SerdeContext): HttpActionHeader[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1HttpActionHeader(entry, context);
    });
};

const deserializeAws_restJson1HttpAction = (output: any, context: __SerdeContext): HttpAction => {
  return {
    auth:
      output.auth !== undefined && output.auth !== null
        ? deserializeAws_restJson1HttpAuthorization(output.auth, context)
        : undefined,
    confirmationUrl: __expectString(output.confirmationUrl),
    headers:
      output.headers !== undefined && output.headers !== null
        ? deserializeAws_restJson1HeaderList(output.headers, context)
        : undefined,
    url: __expectString(output.url),
  } as any;
};

const deserializeAws_restJson1HttpActionHeader = (output: any, context: __SerdeContext): HttpActionHeader => {
  return {
    key: __expectString(output.key),
    value: __expectString(output.value),
  } as any;
};

const deserializeAws_restJson1HttpAuthorization = (output: any, context: __SerdeContext): HttpAuthorization => {
  return {
    sigv4:
      output.sigv4 !== undefined && output.sigv4 !== null
        ? deserializeAws_restJson1SigV4Authorization(output.sigv4, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1HttpUrlDestinationProperties = (
  output: any,
  context: __SerdeContext
): HttpUrlDestinationProperties => {
  return {
    confirmationUrl: __expectString(output.confirmationUrl),
  } as any;
};

const deserializeAws_restJson1HttpUrlDestinationSummary = (
  output: any,
  context: __SerdeContext
): HttpUrlDestinationSummary => {
  return {
    confirmationUrl: __expectString(output.confirmationUrl),
  } as any;
};

const deserializeAws_restJson1ImplicitDeny = (output: any, context: __SerdeContext): ImplicitDeny => {
  return {
    policies:
      output.policies !== undefined && output.policies !== null
        ? deserializeAws_restJson1Policies(output.policies, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1IndexNamesList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1IotAnalyticsAction = (output: any, context: __SerdeContext): IotAnalyticsAction => {
  return {
    batchMode: __expectBoolean(output.batchMode),
    channelArn: __expectString(output.channelArn),
    channelName: __expectString(output.channelName),
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1IotEventsAction = (output: any, context: __SerdeContext): IotEventsAction => {
  return {
    batchMode: __expectBoolean(output.batchMode),
    inputName: __expectString(output.inputName),
    messageId: __expectString(output.messageId),
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1IotSiteWiseAction = (output: any, context: __SerdeContext): IotSiteWiseAction => {
  return {
    putAssetPropertyValueEntries:
      output.putAssetPropertyValueEntries !== undefined && output.putAssetPropertyValueEntries !== null
        ? deserializeAws_restJson1PutAssetPropertyValueEntryList(output.putAssetPropertyValueEntries, context)
        : undefined,
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1Job = (output: any, context: __SerdeContext): Job => {
  return {
    abortConfig:
      output.abortConfig !== undefined && output.abortConfig !== null
        ? deserializeAws_restJson1AbortConfig(output.abortConfig, context)
        : undefined,
    comment: __expectString(output.comment),
    completedAt:
      output.completedAt !== undefined && output.completedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.completedAt)))
        : undefined,
    createdAt:
      output.createdAt !== undefined && output.createdAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt)))
        : undefined,
    description: __expectString(output.description),
    forceCanceled: __expectBoolean(output.forceCanceled),
    jobArn: __expectString(output.jobArn),
    jobExecutionsRolloutConfig:
      output.jobExecutionsRolloutConfig !== undefined && output.jobExecutionsRolloutConfig !== null
        ? deserializeAws_restJson1JobExecutionsRolloutConfig(output.jobExecutionsRolloutConfig, context)
        : undefined,
    jobId: __expectString(output.jobId),
    jobProcessDetails:
      output.jobProcessDetails !== undefined && output.jobProcessDetails !== null
        ? deserializeAws_restJson1JobProcessDetails(output.jobProcessDetails, context)
        : undefined,
    jobTemplateArn: __expectString(output.jobTemplateArn),
    lastUpdatedAt:
      output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
        : undefined,
    namespaceId: __expectString(output.namespaceId),
    presignedUrlConfig:
      output.presignedUrlConfig !== undefined && output.presignedUrlConfig !== null
        ? deserializeAws_restJson1PresignedUrlConfig(output.presignedUrlConfig, context)
        : undefined,
    reasonCode: __expectString(output.reasonCode),
    status: __expectString(output.status),
    targetSelection: __expectString(output.targetSelection),
    targets:
      output.targets !== undefined && output.targets !== null
        ? deserializeAws_restJson1JobTargets(output.targets, context)
        : undefined,
    timeoutConfig:
      output.timeoutConfig !== undefined && output.timeoutConfig !== null
        ? deserializeAws_restJson1TimeoutConfig(output.timeoutConfig, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1JobExecution = (output: any, context: __SerdeContext): JobExecution => {
  return {
    approximateSecondsBeforeTimedOut: __expectLong(output.approximateSecondsBeforeTimedOut),
    executionNumber: __expectLong(output.executionNumber),
    forceCanceled: __expectBoolean(output.forceCanceled),
    jobId: __expectString(output.jobId),
    lastUpdatedAt:
      output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
        : undefined,
    queuedAt:
      output.queuedAt !== undefined && output.queuedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.queuedAt)))
        : undefined,
    startedAt:
      output.startedAt !== undefined && output.startedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startedAt)))
        : undefined,
    status: __expectString(output.status),
    statusDetails:
      output.statusDetails !== undefined && output.statusDetails !== null
        ? deserializeAws_restJson1JobExecutionStatusDetails(output.statusDetails, context)
        : undefined,
    thingArn: __expectString(output.thingArn),
    versionNumber: __expectLong(output.versionNumber),
  } as any;
};

const deserializeAws_restJson1JobExecutionsRolloutConfig = (
  output: any,
  context: __SerdeContext
): JobExecutionsRolloutConfig => {
  return {
    exponentialRate:
      output.exponentialRate !== undefined && output.exponentialRate !== null
        ? deserializeAws_restJson1ExponentialRolloutRate(output.exponentialRate, context)
        : undefined,
    maximumPerMinute: __expectInt32(output.maximumPerMinute),
  } as any;
};

const deserializeAws_restJson1JobExecutionStatusDetails = (
  output: any,
  context: __SerdeContext
): JobExecutionStatusDetails => {
  return {
    detailsMap:
      output.detailsMap !== undefined && output.detailsMap !== null
        ? deserializeAws_restJson1DetailsMap(output.detailsMap, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1JobExecutionSummary = (output: any, context: __SerdeContext): JobExecutionSummary => {
  return {
    executionNumber: __expectLong(output.executionNumber),
    lastUpdatedAt:
      output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
        : undefined,
    queuedAt:
      output.queuedAt !== undefined && output.queuedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.queuedAt)))
        : undefined,
    startedAt:
      output.startedAt !== undefined && output.startedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startedAt)))
        : undefined,
    status: __expectString(output.status),
  } as any;
};

const deserializeAws_restJson1JobExecutionSummaryForJob = (
  output: any,
  context: __SerdeContext
): JobExecutionSummaryForJob => {
  return {
    jobExecutionSummary:
      output.jobExecutionSummary !== undefined && output.jobExecutionSummary !== null
        ? deserializeAws_restJson1JobExecutionSummary(output.jobExecutionSummary, context)
        : undefined,
    thingArn: __expectString(output.thingArn),
  } as any;
};

const deserializeAws_restJson1JobExecutionSummaryForJobList = (
  output: any,
  context: __SerdeContext
): JobExecutionSummaryForJob[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1JobExecutionSummaryForJob(entry, context);
    });
};

const deserializeAws_restJson1JobExecutionSummaryForThing = (
  output: any,
  context: __SerdeContext
): JobExecutionSummaryForThing => {
  return {
    jobExecutionSummary:
      output.jobExecutionSummary !== undefined && output.jobExecutionSummary !== null
        ? deserializeAws_restJson1JobExecutionSummary(output.jobExecutionSummary, context)
        : undefined,
    jobId: __expectString(output.jobId),
  } as any;
};

const deserializeAws_restJson1JobExecutionSummaryForThingList = (
  output: any,
  context: __SerdeContext
): JobExecutionSummaryForThing[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1JobExecutionSummaryForThing(entry, context);
    });
};

const deserializeAws_restJson1JobProcessDetails = (output: any, context: __SerdeContext): JobProcessDetails => {
  return {
    numberOfCanceledThings: __expectInt32(output.numberOfCanceledThings),
    numberOfFailedThings: __expectInt32(output.numberOfFailedThings),
    numberOfInProgressThings: __expectInt32(output.numberOfInProgressThings),
    numberOfQueuedThings: __expectInt32(output.numberOfQueuedThings),
    numberOfRejectedThings: __expectInt32(output.numberOfRejectedThings),
    numberOfRemovedThings: __expectInt32(output.numberOfRemovedThings),
    numberOfSucceededThings: __expectInt32(output.numberOfSucceededThings),
    numberOfTimedOutThings: __expectInt32(output.numberOfTimedOutThings),
    processingTargets:
      output.processingTargets !== undefined && output.processingTargets !== null
        ? deserializeAws_restJson1ProcessingTargetNameList(output.processingTargets, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1JobSummary = (output: any, context: __SerdeContext): JobSummary => {
  return {
    completedAt:
      output.completedAt !== undefined && output.completedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.completedAt)))
        : undefined,
    createdAt:
      output.createdAt !== undefined && output.createdAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt)))
        : undefined,
    jobArn: __expectString(output.jobArn),
    jobId: __expectString(output.jobId),
    lastUpdatedAt:
      output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
        : undefined,
    status: __expectString(output.status),
    targetSelection: __expectString(output.targetSelection),
    thingGroupId: __expectString(output.thingGroupId),
  } as any;
};

const deserializeAws_restJson1JobSummaryList = (output: any, context: __SerdeContext): JobSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1JobSummary(entry, context);
    });
};

const deserializeAws_restJson1JobTargets = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1JobTemplateSummary = (output: any, context: __SerdeContext): JobTemplateSummary => {
  return {
    createdAt:
      output.createdAt !== undefined && output.createdAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt)))
        : undefined,
    description: __expectString(output.description),
    jobTemplateArn: __expectString(output.jobTemplateArn),
    jobTemplateId: __expectString(output.jobTemplateId),
  } as any;
};

const deserializeAws_restJson1JobTemplateSummaryList = (output: any, context: __SerdeContext): JobTemplateSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1JobTemplateSummary(entry, context);
    });
};

const deserializeAws_restJson1KafkaAction = (output: any, context: __SerdeContext): KafkaAction => {
  return {
    clientProperties:
      output.clientProperties !== undefined && output.clientProperties !== null
        ? deserializeAws_restJson1ClientProperties(output.clientProperties, context)
        : undefined,
    destinationArn: __expectString(output.destinationArn),
    key: __expectString(output.key),
    partition: __expectString(output.partition),
    topic: __expectString(output.topic),
  } as any;
};

const deserializeAws_restJson1KeyPair = (output: any, context: __SerdeContext): KeyPair => {
  return {
    PrivateKey: __expectString(output.PrivateKey),
    PublicKey: __expectString(output.PublicKey),
  } as any;
};

const deserializeAws_restJson1KinesisAction = (output: any, context: __SerdeContext): KinesisAction => {
  return {
    partitionKey: __expectString(output.partitionKey),
    roleArn: __expectString(output.roleArn),
    streamName: __expectString(output.streamName),
  } as any;
};

const deserializeAws_restJson1LambdaAction = (output: any, context: __SerdeContext): LambdaAction => {
  return {
    functionArn: __expectString(output.functionArn),
  } as any;
};

const deserializeAws_restJson1LogTarget = (output: any, context: __SerdeContext): LogTarget => {
  return {
    targetName: __expectString(output.targetName),
    targetType: __expectString(output.targetType),
  } as any;
};

const deserializeAws_restJson1LogTargetConfiguration = (
  output: any,
  context: __SerdeContext
): LogTargetConfiguration => {
  return {
    logLevel: __expectString(output.logLevel),
    logTarget:
      output.logTarget !== undefined && output.logTarget !== null
        ? deserializeAws_restJson1LogTarget(output.logTarget, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1LogTargetConfigurations = (
  output: any,
  context: __SerdeContext
): LogTargetConfiguration[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1LogTargetConfiguration(entry, context);
    });
};

const deserializeAws_restJson1MachineLearningDetectionConfig = (
  output: any,
  context: __SerdeContext
): MachineLearningDetectionConfig => {
  return {
    confidenceLevel: __expectString(output.confidenceLevel),
  } as any;
};

const deserializeAws_restJson1MetricDimension = (output: any, context: __SerdeContext): MetricDimension => {
  return {
    dimensionName: __expectString(output.dimensionName),
    operator: __expectString(output.operator),
  } as any;
};

const deserializeAws_restJson1MetricNames = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1MetricToRetain = (output: any, context: __SerdeContext): MetricToRetain => {
  return {
    metric: __expectString(output.metric),
    metricDimension:
      output.metricDimension !== undefined && output.metricDimension !== null
        ? deserializeAws_restJson1MetricDimension(output.metricDimension, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1MetricValue = (output: any, context: __SerdeContext): MetricValue => {
  return {
    cidrs:
      output.cidrs !== undefined && output.cidrs !== null
        ? deserializeAws_restJson1Cidrs(output.cidrs, context)
        : undefined,
    count: __expectLong(output.count),
    number: __limitedParseDouble(output.number),
    numbers:
      output.numbers !== undefined && output.numbers !== null
        ? deserializeAws_restJson1NumberList(output.numbers, context)
        : undefined,
    ports:
      output.ports !== undefined && output.ports !== null
        ? deserializeAws_restJson1Ports(output.ports, context)
        : undefined,
    strings:
      output.strings !== undefined && output.strings !== null
        ? deserializeAws_restJson1StringList(output.strings, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1MissingContextValues = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1MitigationAction = (output: any, context: __SerdeContext): MitigationAction => {
  return {
    actionParams:
      output.actionParams !== undefined && output.actionParams !== null
        ? deserializeAws_restJson1MitigationActionParams(output.actionParams, context)
        : undefined,
    id: __expectString(output.id),
    name: __expectString(output.name),
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1MitigationActionIdentifier = (
  output: any,
  context: __SerdeContext
): MitigationActionIdentifier => {
  return {
    actionArn: __expectString(output.actionArn),
    actionName: __expectString(output.actionName),
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
  } as any;
};

const deserializeAws_restJson1MitigationActionIdentifierList = (
  output: any,
  context: __SerdeContext
): MitigationActionIdentifier[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1MitigationActionIdentifier(entry, context);
    });
};

const deserializeAws_restJson1MitigationActionList = (output: any, context: __SerdeContext): MitigationAction[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1MitigationAction(entry, context);
    });
};

const deserializeAws_restJson1MitigationActionNameList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1MitigationActionParams = (
  output: any,
  context: __SerdeContext
): MitigationActionParams => {
  return {
    addThingsToThingGroupParams:
      output.addThingsToThingGroupParams !== undefined && output.addThingsToThingGroupParams !== null
        ? deserializeAws_restJson1AddThingsToThingGroupParams(output.addThingsToThingGroupParams, context)
        : undefined,
    enableIoTLoggingParams:
      output.enableIoTLoggingParams !== undefined && output.enableIoTLoggingParams !== null
        ? deserializeAws_restJson1EnableIoTLoggingParams(output.enableIoTLoggingParams, context)
        : undefined,
    publishFindingToSnsParams:
      output.publishFindingToSnsParams !== undefined && output.publishFindingToSnsParams !== null
        ? deserializeAws_restJson1PublishFindingToSnsParams(output.publishFindingToSnsParams, context)
        : undefined,
    replaceDefaultPolicyVersionParams:
      output.replaceDefaultPolicyVersionParams !== undefined && output.replaceDefaultPolicyVersionParams !== null
        ? deserializeAws_restJson1ReplaceDefaultPolicyVersionParams(output.replaceDefaultPolicyVersionParams, context)
        : undefined,
    updateCACertificateParams:
      output.updateCACertificateParams !== undefined && output.updateCACertificateParams !== null
        ? deserializeAws_restJson1UpdateCACertificateParams(output.updateCACertificateParams, context)
        : undefined,
    updateDeviceCertificateParams:
      output.updateDeviceCertificateParams !== undefined && output.updateDeviceCertificateParams !== null
        ? deserializeAws_restJson1UpdateDeviceCertificateParams(output.updateDeviceCertificateParams, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1NonCompliantResource = (output: any, context: __SerdeContext): NonCompliantResource => {
  return {
    additionalInfo:
      output.additionalInfo !== undefined && output.additionalInfo !== null
        ? deserializeAws_restJson1StringMap(output.additionalInfo, context)
        : undefined,
    resourceIdentifier:
      output.resourceIdentifier !== undefined && output.resourceIdentifier !== null
        ? deserializeAws_restJson1ResourceIdentifier(output.resourceIdentifier, context)
        : undefined,
    resourceType: __expectString(output.resourceType),
  } as any;
};

const deserializeAws_restJson1NumberList = (output: any, context: __SerdeContext): number[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __limitedParseDouble(entry) as any;
    });
};

const deserializeAws_restJson1OpenSearchAction = (output: any, context: __SerdeContext): OpenSearchAction => {
  return {
    endpoint: __expectString(output.endpoint),
    id: __expectString(output.id),
    index: __expectString(output.index),
    roleArn: __expectString(output.roleArn),
    type: __expectString(output.type),
  } as any;
};

const deserializeAws_restJson1OTAUpdateFile = (output: any, context: __SerdeContext): OTAUpdateFile => {
  return {
    attributes:
      output.attributes !== undefined && output.attributes !== null
        ? deserializeAws_restJson1AttributesMap(output.attributes, context)
        : undefined,
    codeSigning:
      output.codeSigning !== undefined && output.codeSigning !== null
        ? deserializeAws_restJson1CodeSigning(output.codeSigning, context)
        : undefined,
    fileLocation:
      output.fileLocation !== undefined && output.fileLocation !== null
        ? deserializeAws_restJson1FileLocation(output.fileLocation, context)
        : undefined,
    fileName: __expectString(output.fileName),
    fileType: __expectInt32(output.fileType),
    fileVersion: __expectString(output.fileVersion),
  } as any;
};

const deserializeAws_restJson1OTAUpdateFiles = (output: any, context: __SerdeContext): OTAUpdateFile[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1OTAUpdateFile(entry, context);
    });
};

const deserializeAws_restJson1OTAUpdateInfo = (output: any, context: __SerdeContext): OTAUpdateInfo => {
  return {
    additionalParameters:
      output.additionalParameters !== undefined && output.additionalParameters !== null
        ? deserializeAws_restJson1AdditionalParameterMap(output.additionalParameters, context)
        : undefined,
    awsIotJobArn: __expectString(output.awsIotJobArn),
    awsIotJobId: __expectString(output.awsIotJobId),
    awsJobExecutionsRolloutConfig:
      output.awsJobExecutionsRolloutConfig !== undefined && output.awsJobExecutionsRolloutConfig !== null
        ? deserializeAws_restJson1AwsJobExecutionsRolloutConfig(output.awsJobExecutionsRolloutConfig, context)
        : undefined,
    awsJobPresignedUrlConfig:
      output.awsJobPresignedUrlConfig !== undefined && output.awsJobPresignedUrlConfig !== null
        ? deserializeAws_restJson1AwsJobPresignedUrlConfig(output.awsJobPresignedUrlConfig, context)
        : undefined,
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    description: __expectString(output.description),
    errorInfo:
      output.errorInfo !== undefined && output.errorInfo !== null
        ? deserializeAws_restJson1ErrorInfo(output.errorInfo, context)
        : undefined,
    lastModifiedDate:
      output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
        : undefined,
    otaUpdateArn: __expectString(output.otaUpdateArn),
    otaUpdateFiles:
      output.otaUpdateFiles !== undefined && output.otaUpdateFiles !== null
        ? deserializeAws_restJson1OTAUpdateFiles(output.otaUpdateFiles, context)
        : undefined,
    otaUpdateId: __expectString(output.otaUpdateId),
    otaUpdateStatus: __expectString(output.otaUpdateStatus),
    protocols:
      output.protocols !== undefined && output.protocols !== null
        ? deserializeAws_restJson1Protocols(output.protocols, context)
        : undefined,
    targetSelection: __expectString(output.targetSelection),
    targets:
      output.targets !== undefined && output.targets !== null
        ? deserializeAws_restJson1Targets(output.targets, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1OTAUpdatesSummary = (output: any, context: __SerdeContext): OTAUpdateSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1OTAUpdateSummary(entry, context);
    });
};

const deserializeAws_restJson1OTAUpdateSummary = (output: any, context: __SerdeContext): OTAUpdateSummary => {
  return {
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    otaUpdateArn: __expectString(output.otaUpdateArn),
    otaUpdateId: __expectString(output.otaUpdateId),
  } as any;
};

const deserializeAws_restJson1OutgoingCertificate = (output: any, context: __SerdeContext): OutgoingCertificate => {
  return {
    certificateArn: __expectString(output.certificateArn),
    certificateId: __expectString(output.certificateId),
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    transferDate:
      output.transferDate !== undefined && output.transferDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.transferDate)))
        : undefined,
    transferMessage: __expectString(output.transferMessage),
    transferredTo: __expectString(output.transferredTo),
  } as any;
};

const deserializeAws_restJson1OutgoingCertificates = (output: any, context: __SerdeContext): OutgoingCertificate[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1OutgoingCertificate(entry, context);
    });
};

const deserializeAws_restJson1Percentiles = (output: any, context: __SerdeContext): PercentPair[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1PercentPair(entry, context);
    });
};

const deserializeAws_restJson1PercentPair = (output: any, context: __SerdeContext): PercentPair => {
  return {
    percent: __limitedParseDouble(output.percent),
    value: __limitedParseDouble(output.value),
  } as any;
};

const deserializeAws_restJson1Policies = (output: any, context: __SerdeContext): Policy[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1Policy(entry, context);
    });
};

const deserializeAws_restJson1Policy = (output: any, context: __SerdeContext): Policy => {
  return {
    policyArn: __expectString(output.policyArn),
    policyName: __expectString(output.policyName),
  } as any;
};

const deserializeAws_restJson1PolicyDocuments = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1PolicyTargets = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1PolicyVersion = (output: any, context: __SerdeContext): PolicyVersion => {
  return {
    createDate:
      output.createDate !== undefined && output.createDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createDate)))
        : undefined,
    isDefaultVersion: __expectBoolean(output.isDefaultVersion),
    versionId: __expectString(output.versionId),
  } as any;
};

const deserializeAws_restJson1PolicyVersionIdentifier = (
  output: any,
  context: __SerdeContext
): PolicyVersionIdentifier => {
  return {
    policyName: __expectString(output.policyName),
    policyVersionId: __expectString(output.policyVersionId),
  } as any;
};

const deserializeAws_restJson1PolicyVersions = (output: any, context: __SerdeContext): PolicyVersion[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1PolicyVersion(entry, context);
    });
};

const deserializeAws_restJson1Ports = (output: any, context: __SerdeContext): number[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectInt32(entry) as any;
    });
};

const deserializeAws_restJson1PresignedUrlConfig = (output: any, context: __SerdeContext): PresignedUrlConfig => {
  return {
    expiresInSec: __expectLong(output.expiresInSec),
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1Principals = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1ProcessingTargetNameList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1Protocols = (output: any, context: __SerdeContext): (Protocol | string)[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1ProvisioningHook = (output: any, context: __SerdeContext): ProvisioningHook => {
  return {
    payloadVersion: __expectString(output.payloadVersion),
    targetArn: __expectString(output.targetArn),
  } as any;
};

const deserializeAws_restJson1ProvisioningTemplateListing = (
  output: any,
  context: __SerdeContext
): ProvisioningTemplateSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ProvisioningTemplateSummary(entry, context);
    });
};

const deserializeAws_restJson1ProvisioningTemplateSummary = (
  output: any,
  context: __SerdeContext
): ProvisioningTemplateSummary => {
  return {
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    description: __expectString(output.description),
    enabled: __expectBoolean(output.enabled),
    lastModifiedDate:
      output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
        : undefined,
    templateArn: __expectString(output.templateArn),
    templateName: __expectString(output.templateName),
  } as any;
};

const deserializeAws_restJson1ProvisioningTemplateVersionListing = (
  output: any,
  context: __SerdeContext
): ProvisioningTemplateVersionSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ProvisioningTemplateVersionSummary(entry, context);
    });
};

const deserializeAws_restJson1ProvisioningTemplateVersionSummary = (
  output: any,
  context: __SerdeContext
): ProvisioningTemplateVersionSummary => {
  return {
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    isDefaultVersion: __expectBoolean(output.isDefaultVersion),
    versionId: __expectInt32(output.versionId),
  } as any;
};

const deserializeAws_restJson1PublicKeyMap = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce((acc: { [key: string]: string }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: __expectString(value) as any,
    };
  }, {});
};

const deserializeAws_restJson1PublishFindingToSnsParams = (
  output: any,
  context: __SerdeContext
): PublishFindingToSnsParams => {
  return {
    topicArn: __expectString(output.topicArn),
  } as any;
};

const deserializeAws_restJson1PutAssetPropertyValueEntry = (
  output: any,
  context: __SerdeContext
): PutAssetPropertyValueEntry => {
  return {
    assetId: __expectString(output.assetId),
    entryId: __expectString(output.entryId),
    propertyAlias: __expectString(output.propertyAlias),
    propertyId: __expectString(output.propertyId),
    propertyValues:
      output.propertyValues !== undefined && output.propertyValues !== null
        ? deserializeAws_restJson1AssetPropertyValueList(output.propertyValues, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1PutAssetPropertyValueEntryList = (
  output: any,
  context: __SerdeContext
): PutAssetPropertyValueEntry[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1PutAssetPropertyValueEntry(entry, context);
    });
};

const deserializeAws_restJson1PutItemInput = (output: any, context: __SerdeContext): PutItemInput => {
  return {
    tableName: __expectString(output.tableName),
  } as any;
};

const deserializeAws_restJson1RateIncreaseCriteria = (output: any, context: __SerdeContext): RateIncreaseCriteria => {
  return {
    numberOfNotifiedThings: __expectInt32(output.numberOfNotifiedThings),
    numberOfSucceededThings: __expectInt32(output.numberOfSucceededThings),
  } as any;
};

const deserializeAws_restJson1ReasonForNonComplianceCodes = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1RegistrationConfig = (output: any, context: __SerdeContext): RegistrationConfig => {
  return {
    roleArn: __expectString(output.roleArn),
    templateBody: __expectString(output.templateBody),
  } as any;
};

const deserializeAws_restJson1RelatedResource = (output: any, context: __SerdeContext): RelatedResource => {
  return {
    additionalInfo:
      output.additionalInfo !== undefined && output.additionalInfo !== null
        ? deserializeAws_restJson1StringMap(output.additionalInfo, context)
        : undefined,
    resourceIdentifier:
      output.resourceIdentifier !== undefined && output.resourceIdentifier !== null
        ? deserializeAws_restJson1ResourceIdentifier(output.resourceIdentifier, context)
        : undefined,
    resourceType: __expectString(output.resourceType),
  } as any;
};

const deserializeAws_restJson1RelatedResources = (output: any, context: __SerdeContext): RelatedResource[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1RelatedResource(entry, context);
    });
};

const deserializeAws_restJson1ReplaceDefaultPolicyVersionParams = (
  output: any,
  context: __SerdeContext
): ReplaceDefaultPolicyVersionParams => {
  return {
    templateName: __expectString(output.templateName),
  } as any;
};

const deserializeAws_restJson1RepublishAction = (output: any, context: __SerdeContext): RepublishAction => {
  return {
    qos: __expectInt32(output.qos),
    roleArn: __expectString(output.roleArn),
    topic: __expectString(output.topic),
  } as any;
};

const deserializeAws_restJson1ResourceArns = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce((acc: { [key: string]: string }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: __expectString(value) as any,
    };
  }, {});
};

const deserializeAws_restJson1ResourceIdentifier = (output: any, context: __SerdeContext): ResourceIdentifier => {
  return {
    account: __expectString(output.account),
    caCertificateId: __expectString(output.caCertificateId),
    clientId: __expectString(output.clientId),
    cognitoIdentityPoolId: __expectString(output.cognitoIdentityPoolId),
    deviceCertificateId: __expectString(output.deviceCertificateId),
    iamRoleArn: __expectString(output.iamRoleArn),
    policyVersionIdentifier:
      output.policyVersionIdentifier !== undefined && output.policyVersionIdentifier !== null
        ? deserializeAws_restJson1PolicyVersionIdentifier(output.policyVersionIdentifier, context)
        : undefined,
    roleAliasArn: __expectString(output.roleAliasArn),
  } as any;
};

const deserializeAws_restJson1Resources = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1RoleAliasDescription = (output: any, context: __SerdeContext): RoleAliasDescription => {
  return {
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    credentialDurationSeconds: __expectInt32(output.credentialDurationSeconds),
    lastModifiedDate:
      output.lastModifiedDate !== undefined && output.lastModifiedDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastModifiedDate)))
        : undefined,
    owner: __expectString(output.owner),
    roleAlias: __expectString(output.roleAlias),
    roleAliasArn: __expectString(output.roleAliasArn),
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1RoleAliases = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1S3Action = (output: any, context: __SerdeContext): S3Action => {
  return {
    bucketName: __expectString(output.bucketName),
    cannedAcl: __expectString(output.cannedAcl),
    key: __expectString(output.key),
    roleArn: __expectString(output.roleArn),
  } as any;
};

const deserializeAws_restJson1S3Destination = (output: any, context: __SerdeContext): S3Destination => {
  return {
    bucket: __expectString(output.bucket),
    prefix: __expectString(output.prefix),
  } as any;
};

const deserializeAws_restJson1S3FileUrlList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1S3Location = (output: any, context: __SerdeContext): S3Location => {
  return {
    bucket: __expectString(output.bucket),
    key: __expectString(output.key),
    version: __expectString(output.version),
  } as any;
};

const deserializeAws_restJson1SalesforceAction = (output: any, context: __SerdeContext): SalesforceAction => {
  return {
    token: __expectString(output.token),
    url: __expectString(output.url),
  } as any;
};

const deserializeAws_restJson1ScheduledAuditMetadata = (
  output: any,
  context: __SerdeContext
): ScheduledAuditMetadata => {
  return {
    dayOfMonth: __expectString(output.dayOfMonth),
    dayOfWeek: __expectString(output.dayOfWeek),
    frequency: __expectString(output.frequency),
    scheduledAuditArn: __expectString(output.scheduledAuditArn),
    scheduledAuditName: __expectString(output.scheduledAuditName),
  } as any;
};

const deserializeAws_restJson1ScheduledAuditMetadataList = (
  output: any,
  context: __SerdeContext
): ScheduledAuditMetadata[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ScheduledAuditMetadata(entry, context);
    });
};

const deserializeAws_restJson1SearchableAttributes = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1SecurityGroupList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1SecurityProfileIdentifier = (
  output: any,
  context: __SerdeContext
): SecurityProfileIdentifier => {
  return {
    arn: __expectString(output.arn),
    name: __expectString(output.name),
  } as any;
};

const deserializeAws_restJson1SecurityProfileIdentifiers = (
  output: any,
  context: __SerdeContext
): SecurityProfileIdentifier[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1SecurityProfileIdentifier(entry, context);
    });
};

const deserializeAws_restJson1SecurityProfileTarget = (output: any, context: __SerdeContext): SecurityProfileTarget => {
  return {
    arn: __expectString(output.arn),
  } as any;
};

const deserializeAws_restJson1SecurityProfileTargetMapping = (
  output: any,
  context: __SerdeContext
): SecurityProfileTargetMapping => {
  return {
    securityProfileIdentifier:
      output.securityProfileIdentifier !== undefined && output.securityProfileIdentifier !== null
        ? deserializeAws_restJson1SecurityProfileIdentifier(output.securityProfileIdentifier, context)
        : undefined,
    target:
      output.target !== undefined && output.target !== null
        ? deserializeAws_restJson1SecurityProfileTarget(output.target, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1SecurityProfileTargetMappings = (
  output: any,
  context: __SerdeContext
): SecurityProfileTargetMapping[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1SecurityProfileTargetMapping(entry, context);
    });
};

const deserializeAws_restJson1SecurityProfileTargets = (
  output: any,
  context: __SerdeContext
): SecurityProfileTarget[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1SecurityProfileTarget(entry, context);
    });
};

const deserializeAws_restJson1ServerCertificates = (
  output: any,
  context: __SerdeContext
): ServerCertificateSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ServerCertificateSummary(entry, context);
    });
};

const deserializeAws_restJson1ServerCertificateSummary = (
  output: any,
  context: __SerdeContext
): ServerCertificateSummary => {
  return {
    serverCertificateArn: __expectString(output.serverCertificateArn),
    serverCertificateStatus: __expectString(output.serverCertificateStatus),
    serverCertificateStatusDetail: __expectString(output.serverCertificateStatusDetail),
  } as any;
};

const deserializeAws_restJson1SigningProfileParameter = (
  output: any,
  context: __SerdeContext
): SigningProfileParameter => {
  return {
    certificateArn: __expectString(output.certificateArn),
    certificatePathOnDevice: __expectString(output.certificatePathOnDevice),
    platform: __expectString(output.platform),
  } as any;
};

const deserializeAws_restJson1SigV4Authorization = (output: any, context: __SerdeContext): SigV4Authorization => {
  return {
    roleArn: __expectString(output.roleArn),
    serviceName: __expectString(output.serviceName),
    signingRegion: __expectString(output.signingRegion),
  } as any;
};

const deserializeAws_restJson1SnsAction = (output: any, context: __SerdeContext): SnsAction => {
  return {
    messageFormat: __expectString(output.messageFormat),
    roleArn: __expectString(output.roleArn),
    targetArn: __expectString(output.targetArn),
  } as any;
};

const deserializeAws_restJson1SqsAction = (output: any, context: __SerdeContext): SqsAction => {
  return {
    queueUrl: __expectString(output.queueUrl),
    roleArn: __expectString(output.roleArn),
    useBase64: __expectBoolean(output.useBase64),
  } as any;
};

const deserializeAws_restJson1StartSigningJobParameter = (
  output: any,
  context: __SerdeContext
): StartSigningJobParameter => {
  return {
    destination:
      output.destination !== undefined && output.destination !== null
        ? deserializeAws_restJson1Destination(output.destination, context)
        : undefined,
    signingProfileName: __expectString(output.signingProfileName),
    signingProfileParameter:
      output.signingProfileParameter !== undefined && output.signingProfileParameter !== null
        ? deserializeAws_restJson1SigningProfileParameter(output.signingProfileParameter, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1StatisticalThreshold = (output: any, context: __SerdeContext): StatisticalThreshold => {
  return {
    statistic: __expectString(output.statistic),
  } as any;
};

const deserializeAws_restJson1Statistics = (output: any, context: __SerdeContext): Statistics => {
  return {
    average: __limitedParseDouble(output.average),
    count: __expectInt32(output.count),
    maximum: __limitedParseDouble(output.maximum),
    minimum: __limitedParseDouble(output.minimum),
    stdDeviation: __limitedParseDouble(output.stdDeviation),
    sum: __limitedParseDouble(output.sum),
    sumOfSquares: __limitedParseDouble(output.sumOfSquares),
    variance: __limitedParseDouble(output.variance),
  } as any;
};

const deserializeAws_restJson1StepFunctionsAction = (output: any, context: __SerdeContext): StepFunctionsAction => {
  return {
    executionNamePrefix: __expectString(output.executionNamePrefix),
    roleArn: __expectString(output.roleArn),
    stateMachineName: __expectString(output.stateMachineName),
  } as any;
};

const deserializeAws_restJson1_Stream = (output: any, context: __SerdeContext): _Stream => {
  return {
    fileId: __expectInt32(output.fileId),
    streamId: __expectString(output.streamId),
  } as any;
};

const deserializeAws_restJson1StreamFile = (output: any, context: __SerdeContext): StreamFile => {
  return {
    fileId: __expectInt32(output.fileId),
    s3Location:
      output.s3Location !== undefined && output.s3Location !== null
        ? deserializeAws_restJson1S3Location(output.s3Location, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1StreamFiles = (output: any, context: __SerdeContext): StreamFile[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1StreamFile(entry, context);
    });
};

const deserializeAws_restJson1StreamInfo = (output: any, context: __SerdeContext): StreamInfo => {
  return {
    createdAt:
      output.createdAt !== undefined && output.createdAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt)))
        : undefined,
    description: __expectString(output.description),
    files:
      output.files !== undefined && output.files !== null
        ? deserializeAws_restJson1StreamFiles(output.files, context)
        : undefined,
    lastUpdatedAt:
      output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
        : undefined,
    roleArn: __expectString(output.roleArn),
    streamArn: __expectString(output.streamArn),
    streamId: __expectString(output.streamId),
    streamVersion: __expectInt32(output.streamVersion),
  } as any;
};

const deserializeAws_restJson1StreamsSummary = (output: any, context: __SerdeContext): StreamSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1StreamSummary(entry, context);
    });
};

const deserializeAws_restJson1StreamSummary = (output: any, context: __SerdeContext): StreamSummary => {
  return {
    description: __expectString(output.description),
    streamArn: __expectString(output.streamArn),
    streamId: __expectString(output.streamId),
    streamVersion: __expectInt32(output.streamVersion),
  } as any;
};

const deserializeAws_restJson1StringList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1StringMap = (output: any, context: __SerdeContext): { [key: string]: string } => {
  return Object.entries(output).reduce((acc: { [key: string]: string }, [key, value]: [string, any]) => {
    if (value === null) {
      return acc;
    }
    return {
      ...acc,
      [key]: __expectString(value) as any,
    };
  }, {});
};

const deserializeAws_restJson1SubnetIdList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1Tag = (output: any, context: __SerdeContext): Tag => {
  return {
    Key: __expectString(output.Key),
    Value: __expectString(output.Value),
  } as any;
};

const deserializeAws_restJson1TagList = (output: any, context: __SerdeContext): Tag[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1Tag(entry, context);
    });
};

const deserializeAws_restJson1TargetAuditCheckNames = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1Targets = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1TargetViolationIdsForDetectMitigationActions = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1TaskIdList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1TaskStatistics = (output: any, context: __SerdeContext): TaskStatistics => {
  return {
    canceledChecks: __expectInt32(output.canceledChecks),
    compliantChecks: __expectInt32(output.compliantChecks),
    failedChecks: __expectInt32(output.failedChecks),
    inProgressChecks: __expectInt32(output.inProgressChecks),
    nonCompliantChecks: __expectInt32(output.nonCompliantChecks),
    totalChecks: __expectInt32(output.totalChecks),
    waitingForDataCollectionChecks: __expectInt32(output.waitingForDataCollectionChecks),
  } as any;
};

const deserializeAws_restJson1TaskStatisticsForAuditCheck = (
  output: any,
  context: __SerdeContext
): TaskStatisticsForAuditCheck => {
  return {
    canceledFindingsCount: __expectLong(output.canceledFindingsCount),
    failedFindingsCount: __expectLong(output.failedFindingsCount),
    skippedFindingsCount: __expectLong(output.skippedFindingsCount),
    succeededFindingsCount: __expectLong(output.succeededFindingsCount),
    totalFindingsCount: __expectLong(output.totalFindingsCount),
  } as any;
};

const deserializeAws_restJson1ThingAttribute = (output: any, context: __SerdeContext): ThingAttribute => {
  return {
    attributes:
      output.attributes !== undefined && output.attributes !== null
        ? deserializeAws_restJson1Attributes(output.attributes, context)
        : undefined,
    thingArn: __expectString(output.thingArn),
    thingName: __expectString(output.thingName),
    thingTypeName: __expectString(output.thingTypeName),
    version: __expectLong(output.version),
  } as any;
};

const deserializeAws_restJson1ThingAttributeList = (output: any, context: __SerdeContext): ThingAttribute[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ThingAttribute(entry, context);
    });
};

const deserializeAws_restJson1ThingConnectivity = (output: any, context: __SerdeContext): ThingConnectivity => {
  return {
    connected: __expectBoolean(output.connected),
    disconnectReason: __expectString(output.disconnectReason),
    timestamp: __expectLong(output.timestamp),
  } as any;
};

const deserializeAws_restJson1ThingDocument = (output: any, context: __SerdeContext): ThingDocument => {
  return {
    attributes:
      output.attributes !== undefined && output.attributes !== null
        ? deserializeAws_restJson1Attributes(output.attributes, context)
        : undefined,
    connectivity:
      output.connectivity !== undefined && output.connectivity !== null
        ? deserializeAws_restJson1ThingConnectivity(output.connectivity, context)
        : undefined,
    shadow: __expectString(output.shadow),
    thingGroupNames:
      output.thingGroupNames !== undefined && output.thingGroupNames !== null
        ? deserializeAws_restJson1ThingGroupNameList(output.thingGroupNames, context)
        : undefined,
    thingId: __expectString(output.thingId),
    thingName: __expectString(output.thingName),
    thingTypeName: __expectString(output.thingTypeName),
  } as any;
};

const deserializeAws_restJson1ThingDocumentList = (output: any, context: __SerdeContext): ThingDocument[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ThingDocument(entry, context);
    });
};

const deserializeAws_restJson1ThingGroupDocument = (output: any, context: __SerdeContext): ThingGroupDocument => {
  return {
    attributes:
      output.attributes !== undefined && output.attributes !== null
        ? deserializeAws_restJson1Attributes(output.attributes, context)
        : undefined,
    parentGroupNames:
      output.parentGroupNames !== undefined && output.parentGroupNames !== null
        ? deserializeAws_restJson1ThingGroupNameList(output.parentGroupNames, context)
        : undefined,
    thingGroupDescription: __expectString(output.thingGroupDescription),
    thingGroupId: __expectString(output.thingGroupId),
    thingGroupName: __expectString(output.thingGroupName),
  } as any;
};

const deserializeAws_restJson1ThingGroupDocumentList = (output: any, context: __SerdeContext): ThingGroupDocument[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ThingGroupDocument(entry, context);
    });
};

const deserializeAws_restJson1ThingGroupIndexingConfiguration = (
  output: any,
  context: __SerdeContext
): ThingGroupIndexingConfiguration => {
  return {
    customFields:
      output.customFields !== undefined && output.customFields !== null
        ? deserializeAws_restJson1Fields(output.customFields, context)
        : undefined,
    managedFields:
      output.managedFields !== undefined && output.managedFields !== null
        ? deserializeAws_restJson1Fields(output.managedFields, context)
        : undefined,
    thingGroupIndexingMode: __expectString(output.thingGroupIndexingMode),
  } as any;
};

const deserializeAws_restJson1ThingGroupMetadata = (output: any, context: __SerdeContext): ThingGroupMetadata => {
  return {
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    parentGroupName: __expectString(output.parentGroupName),
    rootToParentThingGroups:
      output.rootToParentThingGroups !== undefined && output.rootToParentThingGroups !== null
        ? deserializeAws_restJson1ThingGroupNameAndArnList(output.rootToParentThingGroups, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1ThingGroupNameAndArnList = (output: any, context: __SerdeContext): GroupNameAndArn[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1GroupNameAndArn(entry, context);
    });
};

const deserializeAws_restJson1ThingGroupNameList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1ThingGroupNames = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1ThingGroupProperties = (output: any, context: __SerdeContext): ThingGroupProperties => {
  return {
    attributePayload:
      output.attributePayload !== undefined && output.attributePayload !== null
        ? deserializeAws_restJson1AttributePayload(output.attributePayload, context)
        : undefined,
    thingGroupDescription: __expectString(output.thingGroupDescription),
  } as any;
};

const deserializeAws_restJson1ThingIndexingConfiguration = (
  output: any,
  context: __SerdeContext
): ThingIndexingConfiguration => {
  return {
    customFields:
      output.customFields !== undefined && output.customFields !== null
        ? deserializeAws_restJson1Fields(output.customFields, context)
        : undefined,
    managedFields:
      output.managedFields !== undefined && output.managedFields !== null
        ? deserializeAws_restJson1Fields(output.managedFields, context)
        : undefined,
    thingConnectivityIndexingMode: __expectString(output.thingConnectivityIndexingMode),
    thingIndexingMode: __expectString(output.thingIndexingMode),
  } as any;
};

const deserializeAws_restJson1ThingNameList = (output: any, context: __SerdeContext): string[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return __expectString(entry) as any;
    });
};

const deserializeAws_restJson1ThingTypeDefinition = (output: any, context: __SerdeContext): ThingTypeDefinition => {
  return {
    thingTypeArn: __expectString(output.thingTypeArn),
    thingTypeMetadata:
      output.thingTypeMetadata !== undefined && output.thingTypeMetadata !== null
        ? deserializeAws_restJson1ThingTypeMetadata(output.thingTypeMetadata, context)
        : undefined,
    thingTypeName: __expectString(output.thingTypeName),
    thingTypeProperties:
      output.thingTypeProperties !== undefined && output.thingTypeProperties !== null
        ? deserializeAws_restJson1ThingTypeProperties(output.thingTypeProperties, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1ThingTypeList = (output: any, context: __SerdeContext): ThingTypeDefinition[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ThingTypeDefinition(entry, context);
    });
};

const deserializeAws_restJson1ThingTypeMetadata = (output: any, context: __SerdeContext): ThingTypeMetadata => {
  return {
    creationDate:
      output.creationDate !== undefined && output.creationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.creationDate)))
        : undefined,
    deprecated: __expectBoolean(output.deprecated),
    deprecationDate:
      output.deprecationDate !== undefined && output.deprecationDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.deprecationDate)))
        : undefined,
  } as any;
};

const deserializeAws_restJson1ThingTypeProperties = (output: any, context: __SerdeContext): ThingTypeProperties => {
  return {
    searchableAttributes:
      output.searchableAttributes !== undefined && output.searchableAttributes !== null
        ? deserializeAws_restJson1SearchableAttributes(output.searchableAttributes, context)
        : undefined,
    thingTypeDescription: __expectString(output.thingTypeDescription),
  } as any;
};

const deserializeAws_restJson1TimeoutConfig = (output: any, context: __SerdeContext): TimeoutConfig => {
  return {
    inProgressTimeoutInMinutes: __expectLong(output.inProgressTimeoutInMinutes),
  } as any;
};

const deserializeAws_restJson1TimestreamAction = (output: any, context: __SerdeContext): TimestreamAction => {
  return {
    databaseName: __expectString(output.databaseName),
    dimensions:
      output.dimensions !== undefined && output.dimensions !== null
        ? deserializeAws_restJson1TimestreamDimensionList(output.dimensions, context)
        : undefined,
    roleArn: __expectString(output.roleArn),
    tableName: __expectString(output.tableName),
    timestamp:
      output.timestamp !== undefined && output.timestamp !== null
        ? deserializeAws_restJson1TimestreamTimestamp(output.timestamp, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1TimestreamDimension = (output: any, context: __SerdeContext): TimestreamDimension => {
  return {
    name: __expectString(output.name),
    value: __expectString(output.value),
  } as any;
};

const deserializeAws_restJson1TimestreamDimensionList = (
  output: any,
  context: __SerdeContext
): TimestreamDimension[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1TimestreamDimension(entry, context);
    });
};

const deserializeAws_restJson1TimestreamTimestamp = (output: any, context: __SerdeContext): TimestreamTimestamp => {
  return {
    unit: __expectString(output.unit),
    value: __expectString(output.value),
  } as any;
};

const deserializeAws_restJson1TopicRule = (output: any, context: __SerdeContext): TopicRule => {
  return {
    actions:
      output.actions !== undefined && output.actions !== null
        ? deserializeAws_restJson1ActionList(output.actions, context)
        : undefined,
    awsIotSqlVersion: __expectString(output.awsIotSqlVersion),
    createdAt:
      output.createdAt !== undefined && output.createdAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt)))
        : undefined,
    description: __expectString(output.description),
    errorAction:
      output.errorAction !== undefined && output.errorAction !== null
        ? deserializeAws_restJson1Action(output.errorAction, context)
        : undefined,
    ruleDisabled: __expectBoolean(output.ruleDisabled),
    ruleName: __expectString(output.ruleName),
    sql: __expectString(output.sql),
  } as any;
};

const deserializeAws_restJson1TopicRuleDestination = (output: any, context: __SerdeContext): TopicRuleDestination => {
  return {
    arn: __expectString(output.arn),
    createdAt:
      output.createdAt !== undefined && output.createdAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt)))
        : undefined,
    httpUrlProperties:
      output.httpUrlProperties !== undefined && output.httpUrlProperties !== null
        ? deserializeAws_restJson1HttpUrlDestinationProperties(output.httpUrlProperties, context)
        : undefined,
    lastUpdatedAt:
      output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
        : undefined,
    status: __expectString(output.status),
    statusReason: __expectString(output.statusReason),
    vpcProperties:
      output.vpcProperties !== undefined && output.vpcProperties !== null
        ? deserializeAws_restJson1VpcDestinationProperties(output.vpcProperties, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1TopicRuleDestinationSummaries = (
  output: any,
  context: __SerdeContext
): TopicRuleDestinationSummary[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1TopicRuleDestinationSummary(entry, context);
    });
};

const deserializeAws_restJson1TopicRuleDestinationSummary = (
  output: any,
  context: __SerdeContext
): TopicRuleDestinationSummary => {
  return {
    arn: __expectString(output.arn),
    createdAt:
      output.createdAt !== undefined && output.createdAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt)))
        : undefined,
    httpUrlSummary:
      output.httpUrlSummary !== undefined && output.httpUrlSummary !== null
        ? deserializeAws_restJson1HttpUrlDestinationSummary(output.httpUrlSummary, context)
        : undefined,
    lastUpdatedAt:
      output.lastUpdatedAt !== undefined && output.lastUpdatedAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.lastUpdatedAt)))
        : undefined,
    status: __expectString(output.status),
    statusReason: __expectString(output.statusReason),
    vpcDestinationSummary:
      output.vpcDestinationSummary !== undefined && output.vpcDestinationSummary !== null
        ? deserializeAws_restJson1VpcDestinationSummary(output.vpcDestinationSummary, context)
        : undefined,
  } as any;
};

const deserializeAws_restJson1TopicRuleList = (output: any, context: __SerdeContext): TopicRuleListItem[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1TopicRuleListItem(entry, context);
    });
};

const deserializeAws_restJson1TopicRuleListItem = (output: any, context: __SerdeContext): TopicRuleListItem => {
  return {
    createdAt:
      output.createdAt !== undefined && output.createdAt !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.createdAt)))
        : undefined,
    ruleArn: __expectString(output.ruleArn),
    ruleDisabled: __expectBoolean(output.ruleDisabled),
    ruleName: __expectString(output.ruleName),
    topicPattern: __expectString(output.topicPattern),
  } as any;
};

const deserializeAws_restJson1TransferData = (output: any, context: __SerdeContext): TransferData => {
  return {
    acceptDate:
      output.acceptDate !== undefined && output.acceptDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.acceptDate)))
        : undefined,
    rejectDate:
      output.rejectDate !== undefined && output.rejectDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.rejectDate)))
        : undefined,
    rejectReason: __expectString(output.rejectReason),
    transferDate:
      output.transferDate !== undefined && output.transferDate !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.transferDate)))
        : undefined,
    transferMessage: __expectString(output.transferMessage),
  } as any;
};

const deserializeAws_restJson1UpdateCACertificateParams = (
  output: any,
  context: __SerdeContext
): UpdateCACertificateParams => {
  return {
    action: __expectString(output.action),
  } as any;
};

const deserializeAws_restJson1UpdateDeviceCertificateParams = (
  output: any,
  context: __SerdeContext
): UpdateDeviceCertificateParams => {
  return {
    action: __expectString(output.action),
  } as any;
};

const deserializeAws_restJson1ValidationError = (output: any, context: __SerdeContext): ValidationError => {
  return {
    errorMessage: __expectString(output.errorMessage),
  } as any;
};

const deserializeAws_restJson1ValidationErrors = (output: any, context: __SerdeContext): ValidationError[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ValidationError(entry, context);
    });
};

const deserializeAws_restJson1ViolationEvent = (output: any, context: __SerdeContext): ViolationEvent => {
  return {
    behavior:
      output.behavior !== undefined && output.behavior !== null
        ? deserializeAws_restJson1Behavior(output.behavior, context)
        : undefined,
    metricValue:
      output.metricValue !== undefined && output.metricValue !== null
        ? deserializeAws_restJson1MetricValue(output.metricValue, context)
        : undefined,
    securityProfileName: __expectString(output.securityProfileName),
    thingName: __expectString(output.thingName),
    violationEventAdditionalInfo:
      output.violationEventAdditionalInfo !== undefined && output.violationEventAdditionalInfo !== null
        ? deserializeAws_restJson1ViolationEventAdditionalInfo(output.violationEventAdditionalInfo, context)
        : undefined,
    violationEventTime:
      output.violationEventTime !== undefined && output.violationEventTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.violationEventTime)))
        : undefined,
    violationEventType: __expectString(output.violationEventType),
    violationId: __expectString(output.violationId),
  } as any;
};

const deserializeAws_restJson1ViolationEventAdditionalInfo = (
  output: any,
  context: __SerdeContext
): ViolationEventAdditionalInfo => {
  return {
    confidenceLevel: __expectString(output.confidenceLevel),
  } as any;
};

const deserializeAws_restJson1ViolationEventOccurrenceRange = (
  output: any,
  context: __SerdeContext
): ViolationEventOccurrenceRange => {
  return {
    endTime:
      output.endTime !== undefined && output.endTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.endTime)))
        : undefined,
    startTime:
      output.startTime !== undefined && output.startTime !== null
        ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.startTime)))
        : undefined,
  } as any;
};

const deserializeAws_restJson1ViolationEvents = (output: any, context: __SerdeContext): ViolationEvent[] => {
  return (output || [])
    .filter((e: any) => e != null)
    .map((entry: any) => {
      if (entry === null) {
        return null as any;
      }
      return deserializeAws_restJson1ViolationEvent(entry, context);
    });
};

const deserializeAws_restJson1VpcDestinationProperties = (
  output: any,
  context: __SerdeContext
): VpcDestinationProperties => {
  return {
    roleArn: __expectString(output.roleArn),
    securityGroups:
      output.securityGroups !== undefined && output.securityGroups !== null
        ? deserializeAws_restJson1SecurityGroupList(output.securityGroups, context)
        : undefined,
    subnetIds:
      output.subnetIds !== undefined && output.subnetIds !== null
        ? deserializeAws_restJson1SubnetIdList(output.subnetIds, context)
        : undefined,
    vpcId: __expectString(output.vpcId),
  } as any;
};

const deserializeAws_restJson1VpcDestinationSummary = (output: any, context: __SerdeContext): VpcDestinationSummary => {
  return {
    roleArn: __expectString(output.roleArn),
    securityGroups:
      output.securityGroups !== undefined && output.securityGroups !== null
        ? deserializeAws_restJson1SecurityGroupList(output.securityGroups, context)
        : undefined,
    subnetIds:
      output.subnetIds !== undefined && output.subnetIds !== null
        ? deserializeAws_restJson1SubnetIdList(output.subnetIds, context)
        : undefined,
    vpcId: __expectString(output.vpcId),
  } as any;
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"],
  extendedRequestId: output.headers["x-amz-id-2"],
  cfId: output.headers["x-amz-cf-id"],
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (streamBody: any = new Uint8Array(), context: __SerdeContext): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (streamBody: any, context: __SerdeContext): Promise<string> =>
  collectBody(streamBody, context).then((body) => context.utf8Encoder(body));

const isSerializableHeaderValue = (value: any): boolean =>
  value !== undefined &&
  value !== null &&
  value !== "" &&
  (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
  (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });

/**
 * Load an error code for the aws.rest-json-1.1 protocol.
 */
const loadRestJsonErrorCode = (output: __HttpResponse, data: any): string => {
  const findKey = (object: any, key: string) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());

  const sanitizeErrorCode = (rawValue: string): string => {
    let cleanValue = rawValue;
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };

  const headerKey = findKey(output.headers, "x-amzn-errortype");
  if (headerKey !== undefined) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }

  if (data.code !== undefined) {
    return sanitizeErrorCode(data.code);
  }

  if (data["__type"] !== undefined) {
    return sanitizeErrorCode(data["__type"]);
  }

  return "";
};
