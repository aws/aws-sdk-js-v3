import {
  AssociateVPCWithHostedZoneCommandInput,
  AssociateVPCWithHostedZoneCommandOutput
} from "../commands/AssociateVPCWithHostedZoneCommand";
import {
  ChangeResourceRecordSetsCommandInput,
  ChangeResourceRecordSetsCommandOutput
} from "../commands/ChangeResourceRecordSetsCommand";
import {
  ChangeTagsForResourceCommandInput,
  ChangeTagsForResourceCommandOutput
} from "../commands/ChangeTagsForResourceCommand";
import {
  CreateHealthCheckCommandInput,
  CreateHealthCheckCommandOutput
} from "../commands/CreateHealthCheckCommand";
import {
  CreateHostedZoneCommandInput,
  CreateHostedZoneCommandOutput
} from "../commands/CreateHostedZoneCommand";
import {
  CreateQueryLoggingConfigCommandInput,
  CreateQueryLoggingConfigCommandOutput
} from "../commands/CreateQueryLoggingConfigCommand";
import {
  CreateReusableDelegationSetCommandInput,
  CreateReusableDelegationSetCommandOutput
} from "../commands/CreateReusableDelegationSetCommand";
import {
  CreateTrafficPolicyCommandInput,
  CreateTrafficPolicyCommandOutput
} from "../commands/CreateTrafficPolicyCommand";
import {
  CreateTrafficPolicyInstanceCommandInput,
  CreateTrafficPolicyInstanceCommandOutput
} from "../commands/CreateTrafficPolicyInstanceCommand";
import {
  CreateTrafficPolicyVersionCommandInput,
  CreateTrafficPolicyVersionCommandOutput
} from "../commands/CreateTrafficPolicyVersionCommand";
import {
  CreateVPCAssociationAuthorizationCommandInput,
  CreateVPCAssociationAuthorizationCommandOutput
} from "../commands/CreateVPCAssociationAuthorizationCommand";
import {
  DeleteHealthCheckCommandInput,
  DeleteHealthCheckCommandOutput
} from "../commands/DeleteHealthCheckCommand";
import {
  DeleteHostedZoneCommandInput,
  DeleteHostedZoneCommandOutput
} from "../commands/DeleteHostedZoneCommand";
import {
  DeleteQueryLoggingConfigCommandInput,
  DeleteQueryLoggingConfigCommandOutput
} from "../commands/DeleteQueryLoggingConfigCommand";
import {
  DeleteReusableDelegationSetCommandInput,
  DeleteReusableDelegationSetCommandOutput
} from "../commands/DeleteReusableDelegationSetCommand";
import {
  DeleteTrafficPolicyCommandInput,
  DeleteTrafficPolicyCommandOutput
} from "../commands/DeleteTrafficPolicyCommand";
import {
  DeleteTrafficPolicyInstanceCommandInput,
  DeleteTrafficPolicyInstanceCommandOutput
} from "../commands/DeleteTrafficPolicyInstanceCommand";
import {
  DeleteVPCAssociationAuthorizationCommandInput,
  DeleteVPCAssociationAuthorizationCommandOutput
} from "../commands/DeleteVPCAssociationAuthorizationCommand";
import {
  DisassociateVPCFromHostedZoneCommandInput,
  DisassociateVPCFromHostedZoneCommandOutput
} from "../commands/DisassociateVPCFromHostedZoneCommand";
import {
  GetAccountLimitCommandInput,
  GetAccountLimitCommandOutput
} from "../commands/GetAccountLimitCommand";
import {
  GetChangeCommandInput,
  GetChangeCommandOutput
} from "../commands/GetChangeCommand";
import {
  GetCheckerIpRangesCommandInput,
  GetCheckerIpRangesCommandOutput
} from "../commands/GetCheckerIpRangesCommand";
import {
  GetGeoLocationCommandInput,
  GetGeoLocationCommandOutput
} from "../commands/GetGeoLocationCommand";
import {
  GetHealthCheckCommandInput,
  GetHealthCheckCommandOutput
} from "../commands/GetHealthCheckCommand";
import {
  GetHealthCheckCountCommandInput,
  GetHealthCheckCountCommandOutput
} from "../commands/GetHealthCheckCountCommand";
import {
  GetHealthCheckLastFailureReasonCommandInput,
  GetHealthCheckLastFailureReasonCommandOutput
} from "../commands/GetHealthCheckLastFailureReasonCommand";
import {
  GetHealthCheckStatusCommandInput,
  GetHealthCheckStatusCommandOutput
} from "../commands/GetHealthCheckStatusCommand";
import {
  GetHostedZoneCommandInput,
  GetHostedZoneCommandOutput
} from "../commands/GetHostedZoneCommand";
import {
  GetHostedZoneCountCommandInput,
  GetHostedZoneCountCommandOutput
} from "../commands/GetHostedZoneCountCommand";
import {
  GetHostedZoneLimitCommandInput,
  GetHostedZoneLimitCommandOutput
} from "../commands/GetHostedZoneLimitCommand";
import {
  GetQueryLoggingConfigCommandInput,
  GetQueryLoggingConfigCommandOutput
} from "../commands/GetQueryLoggingConfigCommand";
import {
  GetReusableDelegationSetCommandInput,
  GetReusableDelegationSetCommandOutput
} from "../commands/GetReusableDelegationSetCommand";
import {
  GetReusableDelegationSetLimitCommandInput,
  GetReusableDelegationSetLimitCommandOutput
} from "../commands/GetReusableDelegationSetLimitCommand";
import {
  GetTrafficPolicyCommandInput,
  GetTrafficPolicyCommandOutput
} from "../commands/GetTrafficPolicyCommand";
import {
  GetTrafficPolicyInstanceCommandInput,
  GetTrafficPolicyInstanceCommandOutput
} from "../commands/GetTrafficPolicyInstanceCommand";
import {
  GetTrafficPolicyInstanceCountCommandInput,
  GetTrafficPolicyInstanceCountCommandOutput
} from "../commands/GetTrafficPolicyInstanceCountCommand";
import {
  ListGeoLocationsCommandInput,
  ListGeoLocationsCommandOutput
} from "../commands/ListGeoLocationsCommand";
import {
  ListHealthChecksCommandInput,
  ListHealthChecksCommandOutput
} from "../commands/ListHealthChecksCommand";
import {
  ListHostedZonesByNameCommandInput,
  ListHostedZonesByNameCommandOutput
} from "../commands/ListHostedZonesByNameCommand";
import {
  ListHostedZonesCommandInput,
  ListHostedZonesCommandOutput
} from "../commands/ListHostedZonesCommand";
import {
  ListQueryLoggingConfigsCommandInput,
  ListQueryLoggingConfigsCommandOutput
} from "../commands/ListQueryLoggingConfigsCommand";
import {
  ListResourceRecordSetsCommandInput,
  ListResourceRecordSetsCommandOutput
} from "../commands/ListResourceRecordSetsCommand";
import {
  ListReusableDelegationSetsCommandInput,
  ListReusableDelegationSetsCommandOutput
} from "../commands/ListReusableDelegationSetsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ListTagsForResourcesCommandInput,
  ListTagsForResourcesCommandOutput
} from "../commands/ListTagsForResourcesCommand";
import {
  ListTrafficPoliciesCommandInput,
  ListTrafficPoliciesCommandOutput
} from "../commands/ListTrafficPoliciesCommand";
import {
  ListTrafficPolicyInstancesByHostedZoneCommandInput,
  ListTrafficPolicyInstancesByHostedZoneCommandOutput
} from "../commands/ListTrafficPolicyInstancesByHostedZoneCommand";
import {
  ListTrafficPolicyInstancesByPolicyCommandInput,
  ListTrafficPolicyInstancesByPolicyCommandOutput
} from "../commands/ListTrafficPolicyInstancesByPolicyCommand";
import {
  ListTrafficPolicyInstancesCommandInput,
  ListTrafficPolicyInstancesCommandOutput
} from "../commands/ListTrafficPolicyInstancesCommand";
import {
  ListTrafficPolicyVersionsCommandInput,
  ListTrafficPolicyVersionsCommandOutput
} from "../commands/ListTrafficPolicyVersionsCommand";
import {
  ListVPCAssociationAuthorizationsCommandInput,
  ListVPCAssociationAuthorizationsCommandOutput
} from "../commands/ListVPCAssociationAuthorizationsCommand";
import {
  TestDNSAnswerCommandInput,
  TestDNSAnswerCommandOutput
} from "../commands/TestDNSAnswerCommand";
import {
  UpdateHealthCheckCommandInput,
  UpdateHealthCheckCommandOutput
} from "../commands/UpdateHealthCheckCommand";
import {
  UpdateHostedZoneCommentCommandInput,
  UpdateHostedZoneCommentCommandOutput
} from "../commands/UpdateHostedZoneCommentCommand";
import {
  UpdateTrafficPolicyCommentCommandInput,
  UpdateTrafficPolicyCommentCommandOutput
} from "../commands/UpdateTrafficPolicyCommentCommand";
import {
  UpdateTrafficPolicyInstanceCommandInput,
  UpdateTrafficPolicyInstanceCommandOutput
} from "../commands/UpdateTrafficPolicyInstanceCommand";
import {
  AccountLimit,
  AlarmIdentifier,
  AliasTarget,
  Change,
  ChangeBatch,
  ChangeInfo,
  CloudWatchAlarmConfiguration,
  ConcurrentModification,
  ConflictingDomainExists,
  ConflictingTypes,
  DelegationSet,
  DelegationSetAlreadyCreated,
  DelegationSetAlreadyReusable,
  DelegationSetInUse,
  DelegationSetNotAvailable,
  DelegationSetNotReusable,
  Dimension,
  GeoLocation,
  GeoLocationDetails,
  HealthCheck,
  HealthCheckAlreadyExists,
  HealthCheckConfig,
  HealthCheckInUse,
  HealthCheckObservation,
  HealthCheckRegion,
  HealthCheckVersionMismatch,
  HostedZone,
  HostedZoneAlreadyExists,
  HostedZoneConfig,
  HostedZoneLimit,
  HostedZoneNotEmpty,
  HostedZoneNotFound,
  HostedZoneNotPrivate,
  IncompatibleVersion,
  InsufficientCloudWatchLogsResourcePolicy,
  InvalidArgument,
  InvalidChangeBatch,
  InvalidDomainName,
  InvalidInput,
  InvalidPaginationToken,
  InvalidTrafficPolicyDocument,
  InvalidVPCId,
  LastVPCAssociation,
  LimitsExceeded,
  LinkedService,
  NoSuchChange,
  NoSuchCloudWatchLogsLogGroup,
  NoSuchDelegationSet,
  NoSuchGeoLocation,
  NoSuchHealthCheck,
  NoSuchHostedZone,
  NoSuchQueryLoggingConfig,
  NoSuchTrafficPolicy,
  NoSuchTrafficPolicyInstance,
  NotAuthorizedException,
  PriorRequestNotComplete,
  PublicZoneVPCAssociation,
  QueryLoggingConfig,
  QueryLoggingConfigAlreadyExists,
  ResettableElementName,
  ResourceRecord,
  ResourceRecordSet,
  ResourceTagSet,
  ReusableDelegationSetLimit,
  StatusReport,
  Tag,
  ThrottlingException,
  TooManyHealthChecks,
  TooManyHostedZones,
  TooManyTrafficPolicies,
  TooManyTrafficPolicyInstances,
  TooManyTrafficPolicyVersionsForCurrentPolicy,
  TooManyVPCAssociationAuthorizations,
  TrafficPolicy,
  TrafficPolicyAlreadyExists,
  TrafficPolicyInUse,
  TrafficPolicyInstance,
  TrafficPolicyInstanceAlreadyExists,
  TrafficPolicySummary,
  VPC,
  VPCAssociationAuthorizationNotFound,
  VPCAssociationNotFound
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent,
  getArrayIfSingleItem as __getArrayIfSingleItem,
  getValueFromTextNode as __getValueFromTextNode
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import {
  XmlNode as __XmlNode,
  XmlText as __XmlText
} from "@aws-sdk/xml-builder";
import { parse as xmlParse } from "fast-xml-parser";

export const serializeAws_restXmlAssociateVPCWithHostedZoneCommand = async (
  input: AssociateVPCWithHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/hostedzone/{HostedZoneId}/associatevpc";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("AssociateVPCWithHostedZoneRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const node = new __XmlNode("AssociateVPCComment")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.VPC !== undefined) {
    const node = serializeAws_restXmlVPC(input.VPC, context).withName("VPC");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlChangeResourceRecordSetsCommand = async (
  input: ChangeResourceRecordSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/hostedzone/{HostedZoneId}/rrset";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("ChangeResourceRecordSetsRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.ChangeBatch !== undefined) {
    const node = serializeAws_restXmlChangeBatch(
      input.ChangeBatch,
      context
    ).withName("ChangeBatch");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlChangeTagsForResourceCommand = async (
  input: ChangeTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/tags/{ResourceType}/{ResourceId}";
  if (input.ResourceId !== undefined) {
    const labelValue: string = input.ResourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ResourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceId.");
  }
  if (input.ResourceType !== undefined) {
    const labelValue: string = input.ResourceType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceType.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("ChangeTagsForResourceRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.AddTags !== undefined) {
    const nodes = serializeAws_restXmlTagList(input.AddTags, context);
    const containerNode = new __XmlNode("AddTags");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.RemoveTagKeys !== undefined) {
    const nodes = serializeAws_restXmlTagKeyList(input.RemoveTagKeys, context);
    const containerNode = new __XmlNode("RemoveTagKeys");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateHealthCheckCommand = async (
  input: CreateHealthCheckCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/healthcheck";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateHealthCheckRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("HealthCheckNonce")
      .addChildNode(new __XmlText(input.CallerReference))
      .withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.HealthCheckConfig !== undefined) {
    const node = serializeAws_restXmlHealthCheckConfig(
      input.HealthCheckConfig,
      context
    ).withName("HealthCheckConfig");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateHostedZoneCommand = async (
  input: CreateHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/hostedzone";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateHostedZoneRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("Nonce")
      .addChildNode(new __XmlText(input.CallerReference))
      .withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.DelegationSetId !== undefined) {
    const node = new __XmlNode("ResourceId")
      .addChildNode(new __XmlText(input.DelegationSetId))
      .withName("DelegationSetId");
    bodyNode.addChildNode(node);
  }
  if (input.HostedZoneConfig !== undefined) {
    const node = serializeAws_restXmlHostedZoneConfig(
      input.HostedZoneConfig,
      context
    ).withName("HostedZoneConfig");
    bodyNode.addChildNode(node);
  }
  if (input.Name !== undefined) {
    const node = new __XmlNode("DNSName")
      .addChildNode(new __XmlText(input.Name))
      .withName("Name");
    bodyNode.addChildNode(node);
  }
  if (input.VPC !== undefined) {
    const node = serializeAws_restXmlVPC(input.VPC, context).withName("VPC");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateQueryLoggingConfigCommand = async (
  input: CreateQueryLoggingConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/queryloggingconfig";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateQueryLoggingConfigRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.CloudWatchLogsLogGroupArn !== undefined) {
    const node = new __XmlNode("CloudWatchLogsLogGroupArn")
      .addChildNode(new __XmlText(input.CloudWatchLogsLogGroupArn))
      .withName("CloudWatchLogsLogGroupArn");
    bodyNode.addChildNode(node);
  }
  if (input.HostedZoneId !== undefined) {
    const node = new __XmlNode("ResourceId")
      .addChildNode(new __XmlText(input.HostedZoneId))
      .withName("HostedZoneId");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateReusableDelegationSetCommand = async (
  input: CreateReusableDelegationSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/delegationset";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateReusableDelegationSetRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.CallerReference !== undefined) {
    const node = new __XmlNode("Nonce")
      .addChildNode(new __XmlText(input.CallerReference))
      .withName("CallerReference");
    bodyNode.addChildNode(node);
  }
  if (input.HostedZoneId !== undefined) {
    const node = new __XmlNode("ResourceId")
      .addChildNode(new __XmlText(input.HostedZoneId))
      .withName("HostedZoneId");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateTrafficPolicyCommand = async (
  input: CreateTrafficPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/trafficpolicy";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateTrafficPolicyRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const node = new __XmlNode("TrafficPolicyComment")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.Document !== undefined) {
    const node = new __XmlNode("TrafficPolicyDocument")
      .addChildNode(new __XmlText(input.Document))
      .withName("Document");
    bodyNode.addChildNode(node);
  }
  if (input.Name !== undefined) {
    const node = new __XmlNode("TrafficPolicyName")
      .addChildNode(new __XmlText(input.Name))
      .withName("Name");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateTrafficPolicyInstanceCommand = async (
  input: CreateTrafficPolicyInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/trafficpolicyinstance";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateTrafficPolicyInstanceRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.HostedZoneId !== undefined) {
    const node = new __XmlNode("ResourceId")
      .addChildNode(new __XmlText(input.HostedZoneId))
      .withName("HostedZoneId");
    bodyNode.addChildNode(node);
  }
  if (input.Name !== undefined) {
    const node = new __XmlNode("DNSName")
      .addChildNode(new __XmlText(input.Name))
      .withName("Name");
    bodyNode.addChildNode(node);
  }
  if (input.TTL !== undefined) {
    const node = new __XmlNode("TTL")
      .addChildNode(new __XmlText(String(input.TTL)))
      .withName("TTL");
    bodyNode.addChildNode(node);
  }
  if (input.TrafficPolicyId !== undefined) {
    const node = new __XmlNode("TrafficPolicyId")
      .addChildNode(new __XmlText(input.TrafficPolicyId))
      .withName("TrafficPolicyId");
    bodyNode.addChildNode(node);
  }
  if (input.TrafficPolicyVersion !== undefined) {
    const node = new __XmlNode("TrafficPolicyVersion")
      .addChildNode(new __XmlText(String(input.TrafficPolicyVersion)))
      .withName("TrafficPolicyVersion");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateTrafficPolicyVersionCommand = async (
  input: CreateTrafficPolicyVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/trafficpolicy/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateTrafficPolicyVersionRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const node = new __XmlNode("TrafficPolicyComment")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.Document !== undefined) {
    const node = new __XmlNode("TrafficPolicyDocument")
      .addChildNode(new __XmlText(input.Document))
      .withName("Document");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlCreateVPCAssociationAuthorizationCommand = async (
  input: CreateVPCAssociationAuthorizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath =
    "/2013-04-01/hostedzone/{HostedZoneId}/authorizevpcassociation";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateVPCAssociationAuthorizationRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.VPC !== undefined) {
    const node = serializeAws_restXmlVPC(input.VPC, context).withName("VPC");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteHealthCheckCommand = async (
  input: DeleteHealthCheckCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/healthcheck/{HealthCheckId}";
  if (input.HealthCheckId !== undefined) {
    const labelValue: string = input.HealthCheckId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HealthCheckId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HealthCheckId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HealthCheckId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteHostedZoneCommand = async (
  input: DeleteHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/hostedzone/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteQueryLoggingConfigCommand = async (
  input: DeleteQueryLoggingConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/queryloggingconfig/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteReusableDelegationSetCommand = async (
  input: DeleteReusableDelegationSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/delegationset/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteTrafficPolicyCommand = async (
  input: DeleteTrafficPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/trafficpolicy/{Id}/{Version}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  if (input.Version !== undefined) {
    const labelValue: string = input.Version.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Version.");
    }
    resolvedPath = resolvedPath.replace(
      "{Version}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Version.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteTrafficPolicyInstanceCommand = async (
  input: DeleteTrafficPolicyInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/trafficpolicyinstance/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "DELETE",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDeleteVPCAssociationAuthorizationCommand = async (
  input: DeleteVPCAssociationAuthorizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath =
    "/2013-04-01/hostedzone/{HostedZoneId}/deauthorizevpcassociation";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("DeleteVPCAssociationAuthorizationRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.VPC !== undefined) {
    const node = serializeAws_restXmlVPC(input.VPC, context).withName("VPC");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlDisassociateVPCFromHostedZoneCommand = async (
  input: DisassociateVPCFromHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/hostedzone/{HostedZoneId}/disassociatevpc";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("DisassociateVPCFromHostedZoneRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const node = new __XmlNode("DisassociateVPCComment")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.VPC !== undefined) {
    const node = serializeAws_restXmlVPC(input.VPC, context).withName("VPC");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetAccountLimitCommand = async (
  input: GetAccountLimitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/accountlimit/{Type}";
  if (input.Type !== undefined) {
    const labelValue: string = input.Type;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Type.");
    }
    resolvedPath = resolvedPath.replace(
      "{Type}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Type.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetChangeCommand = async (
  input: GetChangeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/change/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetCheckerIpRangesCommand = async (
  input: GetCheckerIpRangesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/checkeripranges";
  let body: any;
  body = "";
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetGeoLocationCommand = async (
  input: GetGeoLocationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/geolocation";
  const query: any = {
    ...(input.ContinentCode !== undefined && {
      continentcode: input.ContinentCode
    }),
    ...(input.CountryCode !== undefined && { countrycode: input.CountryCode }),
    ...(input.SubdivisionCode !== undefined && {
      subdivisioncode: input.SubdivisionCode
    })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlGetHealthCheckCommand = async (
  input: GetHealthCheckCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/healthcheck/{HealthCheckId}";
  if (input.HealthCheckId !== undefined) {
    const labelValue: string = input.HealthCheckId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HealthCheckId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HealthCheckId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HealthCheckId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetHealthCheckCountCommand = async (
  input: GetHealthCheckCountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/healthcheckcount";
  let body: any;
  body = "";
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetHealthCheckLastFailureReasonCommand = async (
  input: GetHealthCheckLastFailureReasonCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath =
    "/2013-04-01/healthcheck/{HealthCheckId}/lastfailurereason";
  if (input.HealthCheckId !== undefined) {
    const labelValue: string = input.HealthCheckId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HealthCheckId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HealthCheckId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HealthCheckId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetHealthCheckStatusCommand = async (
  input: GetHealthCheckStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/healthcheck/{HealthCheckId}/status";
  if (input.HealthCheckId !== undefined) {
    const labelValue: string = input.HealthCheckId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HealthCheckId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HealthCheckId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HealthCheckId.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetHostedZoneCommand = async (
  input: GetHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/hostedzone/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetHostedZoneCountCommand = async (
  input: GetHostedZoneCountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/hostedzonecount";
  let body: any;
  body = "";
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetHostedZoneLimitCommand = async (
  input: GetHostedZoneLimitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/hostedzonelimit/{HostedZoneId}/{Type}";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  if (input.Type !== undefined) {
    const labelValue: string = input.Type;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Type.");
    }
    resolvedPath = resolvedPath.replace(
      "{Type}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Type.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetQueryLoggingConfigCommand = async (
  input: GetQueryLoggingConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/queryloggingconfig/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetReusableDelegationSetCommand = async (
  input: GetReusableDelegationSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/delegationset/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetReusableDelegationSetLimitCommand = async (
  input: GetReusableDelegationSetLimitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath =
    "/2013-04-01/reusabledelegationsetlimit/{DelegationSetId}/{Type}";
  if (input.DelegationSetId !== undefined) {
    const labelValue: string = input.DelegationSetId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DelegationSetId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DelegationSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DelegationSetId.");
  }
  if (input.Type !== undefined) {
    const labelValue: string = input.Type;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Type.");
    }
    resolvedPath = resolvedPath.replace(
      "{Type}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Type.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetTrafficPolicyCommand = async (
  input: GetTrafficPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/trafficpolicy/{Id}/{Version}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  if (input.Version !== undefined) {
    const labelValue: string = input.Version.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Version.");
    }
    resolvedPath = resolvedPath.replace(
      "{Version}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Version.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetTrafficPolicyInstanceCommand = async (
  input: GetTrafficPolicyInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/trafficpolicyinstance/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlGetTrafficPolicyInstanceCountCommand = async (
  input: GetTrafficPolicyInstanceCountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/trafficpolicyinstancecount";
  let body: any;
  body = "";
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlListGeoLocationsCommand = async (
  input: ListGeoLocationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/geolocations";
  const query: any = {
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems }),
    ...(input.StartContinentCode !== undefined && {
      startcontinentcode: input.StartContinentCode
    }),
    ...(input.StartCountryCode !== undefined && {
      startcountrycode: input.StartCountryCode
    }),
    ...(input.StartSubdivisionCode !== undefined && {
      startsubdivisioncode: input.StartSubdivisionCode
    })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListHealthChecksCommand = async (
  input: ListHealthChecksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/healthcheck";
  const query: any = {
    ...(input.Marker !== undefined && { marker: input.Marker }),
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListHostedZonesCommand = async (
  input: ListHostedZonesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/hostedzone";
  const query: any = {
    ...(input.DelegationSetId !== undefined && {
      delegationsetid: input.DelegationSetId
    }),
    ...(input.Marker !== undefined && { marker: input.Marker }),
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListHostedZonesByNameCommand = async (
  input: ListHostedZonesByNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/hostedzonesbyname";
  const query: any = {
    ...(input.DNSName !== undefined && { dnsname: input.DNSName }),
    ...(input.HostedZoneId !== undefined && {
      hostedzoneid: input.HostedZoneId
    }),
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListQueryLoggingConfigsCommand = async (
  input: ListQueryLoggingConfigsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/queryloggingconfig";
  const query: any = {
    ...(input.HostedZoneId !== undefined && {
      hostedzoneid: input.HostedZoneId
    }),
    ...(input.MaxResults !== undefined && { maxresults: input.MaxResults }),
    ...(input.NextToken !== undefined && { nexttoken: input.NextToken })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListResourceRecordSetsCommand = async (
  input: ListResourceRecordSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/hostedzone/{HostedZoneId}/rrset";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  const query: any = {
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems }),
    ...(input.StartRecordIdentifier !== undefined && {
      identifier: input.StartRecordIdentifier
    }),
    ...(input.StartRecordName !== undefined && { name: input.StartRecordName }),
    ...(input.StartRecordType !== undefined && { type: input.StartRecordType })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListReusableDelegationSetsCommand = async (
  input: ListReusableDelegationSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/delegationset";
  const query: any = {
    ...(input.Marker !== undefined && { marker: input.Marker }),
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListTagsForResourceCommand = async (
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/tags/{ResourceType}/{ResourceId}";
  if (input.ResourceId !== undefined) {
    const labelValue: string = input.ResourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ResourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceId.");
  }
  if (input.ResourceType !== undefined) {
    const labelValue: string = input.ResourceType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceType.");
  }
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlListTagsForResourcesCommand = async (
  input: ListTagsForResourcesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/tags/{ResourceType}";
  if (input.ResourceType !== undefined) {
    const labelValue: string = input.ResourceType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceType.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("ListTagsForResourcesRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.ResourceIds !== undefined) {
    const nodes = serializeAws_restXmlTagResourceIdList(
      input.ResourceIds,
      context
    );
    const containerNode = new __XmlNode("ResourceIds");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlListTrafficPoliciesCommand = async (
  input: ListTrafficPoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/trafficpolicies";
  const query: any = {
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems }),
    ...(input.TrafficPolicyIdMarker !== undefined && {
      trafficpolicyid: input.TrafficPolicyIdMarker
    })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListTrafficPolicyInstancesCommand = async (
  input: ListTrafficPolicyInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/trafficpolicyinstances";
  const query: any = {
    ...(input.HostedZoneIdMarker !== undefined && {
      hostedzoneid: input.HostedZoneIdMarker
    }),
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems }),
    ...(input.TrafficPolicyInstanceNameMarker !== undefined && {
      trafficpolicyinstancename: input.TrafficPolicyInstanceNameMarker
    }),
    ...(input.TrafficPolicyInstanceTypeMarker !== undefined && {
      trafficpolicyinstancetype: input.TrafficPolicyInstanceTypeMarker
    })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListTrafficPolicyInstancesByHostedZoneCommand = async (
  input: ListTrafficPolicyInstancesByHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/trafficpolicyinstances/hostedzone";
  const query: any = {
    ...(input.HostedZoneId !== undefined && { id: input.HostedZoneId }),
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems }),
    ...(input.TrafficPolicyInstanceNameMarker !== undefined && {
      trafficpolicyinstancename: input.TrafficPolicyInstanceNameMarker
    }),
    ...(input.TrafficPolicyInstanceTypeMarker !== undefined && {
      trafficpolicyinstancetype: input.TrafficPolicyInstanceTypeMarker
    })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListTrafficPolicyInstancesByPolicyCommand = async (
  input: ListTrafficPolicyInstancesByPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/trafficpolicyinstances/trafficpolicy";
  const query: any = {
    ...(input.HostedZoneIdMarker !== undefined && {
      hostedzoneid: input.HostedZoneIdMarker
    }),
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems }),
    ...(input.TrafficPolicyId !== undefined && { id: input.TrafficPolicyId }),
    ...(input.TrafficPolicyInstanceNameMarker !== undefined && {
      trafficpolicyinstancename: input.TrafficPolicyInstanceNameMarker
    }),
    ...(input.TrafficPolicyInstanceTypeMarker !== undefined && {
      trafficpolicyinstancetype: input.TrafficPolicyInstanceTypeMarker
    }),
    ...(input.TrafficPolicyVersion !== undefined && {
      version: input.TrafficPolicyVersion.toString()
    })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListTrafficPolicyVersionsCommand = async (
  input: ListTrafficPolicyVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/trafficpolicies/{Id}/versions";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  const query: any = {
    ...(input.MaxItems !== undefined && { maxitems: input.MaxItems }),
    ...(input.TrafficPolicyVersionMarker !== undefined && {
      trafficpolicyversion: input.TrafficPolicyVersionMarker
    })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlListVPCAssociationAuthorizationsCommand = async (
  input: ListVPCAssociationAuthorizationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath =
    "/2013-04-01/hostedzone/{HostedZoneId}/authorizevpcassociation";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  const query: any = {
    ...(input.MaxResults !== undefined && { maxresults: input.MaxResults }),
    ...(input.NextToken !== undefined && { nexttoken: input.NextToken })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlTestDNSAnswerCommand = async (
  input: TestDNSAnswerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": ""
  };
  let resolvedPath = "/2013-04-01/testdnsanswer";
  const query: any = {
    ...(input.EDNS0ClientSubnetIP !== undefined && {
      edns0clientsubnetip: input.EDNS0ClientSubnetIP
    }),
    ...(input.EDNS0ClientSubnetMask !== undefined && {
      edns0clientsubnetmask: input.EDNS0ClientSubnetMask
    }),
    ...(input.HostedZoneId !== undefined && {
      hostedzoneid: input.HostedZoneId
    }),
    ...(input.RecordName !== undefined && { recordname: input.RecordName }),
    ...(input.RecordType !== undefined && { recordtype: input.RecordType }),
    ...(input.ResolverIP !== undefined && { resolverip: input.ResolverIP })
  };
  let body: any;
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "GET",
    headers,
    path: resolvedPath,
    query,
    body
  });
};

export const serializeAws_restXmlUpdateHealthCheckCommand = async (
  input: UpdateHealthCheckCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/healthcheck/{HealthCheckId}";
  if (input.HealthCheckId !== undefined) {
    const labelValue: string = input.HealthCheckId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HealthCheckId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HealthCheckId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HealthCheckId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("UpdateHealthCheckRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.AlarmIdentifier !== undefined) {
    const node = serializeAws_restXmlAlarmIdentifier(
      input.AlarmIdentifier,
      context
    ).withName("AlarmIdentifier");
    bodyNode.addChildNode(node);
  }
  if (input.ChildHealthChecks !== undefined) {
    const nodes = serializeAws_restXmlChildHealthCheckList(
      input.ChildHealthChecks,
      context
    );
    const containerNode = new __XmlNode("ChildHealthChecks");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Disabled !== undefined) {
    const node = new __XmlNode("Disabled")
      .addChildNode(new __XmlText(String(input.Disabled)))
      .withName("Disabled");
    bodyNode.addChildNode(node);
  }
  if (input.EnableSNI !== undefined) {
    const node = new __XmlNode("EnableSNI")
      .addChildNode(new __XmlText(String(input.EnableSNI)))
      .withName("EnableSNI");
    bodyNode.addChildNode(node);
  }
  if (input.FailureThreshold !== undefined) {
    const node = new __XmlNode("FailureThreshold")
      .addChildNode(new __XmlText(String(input.FailureThreshold)))
      .withName("FailureThreshold");
    bodyNode.addChildNode(node);
  }
  if (input.FullyQualifiedDomainName !== undefined) {
    const node = new __XmlNode("FullyQualifiedDomainName")
      .addChildNode(new __XmlText(input.FullyQualifiedDomainName))
      .withName("FullyQualifiedDomainName");
    bodyNode.addChildNode(node);
  }
  if (input.HealthCheckVersion !== undefined) {
    const node = new __XmlNode("HealthCheckVersion")
      .addChildNode(new __XmlText(String(input.HealthCheckVersion)))
      .withName("HealthCheckVersion");
    bodyNode.addChildNode(node);
  }
  if (input.HealthThreshold !== undefined) {
    const node = new __XmlNode("HealthThreshold")
      .addChildNode(new __XmlText(String(input.HealthThreshold)))
      .withName("HealthThreshold");
    bodyNode.addChildNode(node);
  }
  if (input.IPAddress !== undefined) {
    const node = new __XmlNode("IPAddress")
      .addChildNode(new __XmlText(input.IPAddress))
      .withName("IPAddress");
    bodyNode.addChildNode(node);
  }
  if (input.InsufficientDataHealthStatus !== undefined) {
    const node = new __XmlNode("InsufficientDataHealthStatus")
      .addChildNode(new __XmlText(input.InsufficientDataHealthStatus))
      .withName("InsufficientDataHealthStatus");
    bodyNode.addChildNode(node);
  }
  if (input.Inverted !== undefined) {
    const node = new __XmlNode("Inverted")
      .addChildNode(new __XmlText(String(input.Inverted)))
      .withName("Inverted");
    bodyNode.addChildNode(node);
  }
  if (input.Port !== undefined) {
    const node = new __XmlNode("Port")
      .addChildNode(new __XmlText(String(input.Port)))
      .withName("Port");
    bodyNode.addChildNode(node);
  }
  if (input.Regions !== undefined) {
    const nodes = serializeAws_restXmlHealthCheckRegionList(
      input.Regions,
      context
    );
    const containerNode = new __XmlNode("Regions");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.ResetElements !== undefined) {
    const nodes = serializeAws_restXmlResettableElementNameList(
      input.ResetElements,
      context
    );
    const containerNode = new __XmlNode("ResetElements");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.ResourcePath !== undefined) {
    const node = new __XmlNode("ResourcePath")
      .addChildNode(new __XmlText(input.ResourcePath))
      .withName("ResourcePath");
    bodyNode.addChildNode(node);
  }
  if (input.SearchString !== undefined) {
    const node = new __XmlNode("SearchString")
      .addChildNode(new __XmlText(input.SearchString))
      .withName("SearchString");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlUpdateHostedZoneCommentCommand = async (
  input: UpdateHostedZoneCommentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/hostedzone/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("UpdateHostedZoneCommentRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const node = new __XmlNode("ResourceDescription")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlUpdateTrafficPolicyCommentCommand = async (
  input: UpdateTrafficPolicyCommentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/trafficpolicy/{Id}/{Version}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  if (input.Version !== undefined) {
    const labelValue: string = input.Version.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Version.");
    }
    resolvedPath = resolvedPath.replace(
      "{Version}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Version.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("UpdateTrafficPolicyCommentRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const node = new __XmlNode("TrafficPolicyComment")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const serializeAws_restXmlUpdateTrafficPolicyInstanceCommand = async (
  input: UpdateTrafficPolicyInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: any = {
    "Content-Type": "application/xml"
  };
  let resolvedPath = "/2013-04-01/trafficpolicyinstance/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("UpdateTrafficPolicyInstanceRequest");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.TTL !== undefined) {
    const node = new __XmlNode("TTL")
      .addChildNode(new __XmlText(String(input.TTL)))
      .withName("TTL");
    bodyNode.addChildNode(node);
  }
  if (input.TrafficPolicyId !== undefined) {
    const node = new __XmlNode("TrafficPolicyId")
      .addChildNode(new __XmlText(input.TrafficPolicyId))
      .withName("TrafficPolicyId");
    bodyNode.addChildNode(node);
  }
  if (input.TrafficPolicyVersion !== undefined) {
    const node = new __XmlNode("TrafficPolicyVersion")
      .addChildNode(new __XmlText(String(input.TrafficPolicyVersion)))
      .withName("TrafficPolicyVersion");
    bodyNode.addChildNode(node);
  }
  body += bodyNode.toString();
  const { hostname, protocol = "https", port } = await context.endpoint();
  return new __HttpRequest({
    protocol,
    hostname,
    port,
    method: "POST",
    headers,
    path: resolvedPath,
    body
  });
};

export const deserializeAws_restXmlAssociateVPCWithHostedZoneCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateVPCWithHostedZoneCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlAssociateVPCWithHostedZoneCommandError(
      output,
      context
    );
  }
  const contents: AssociateVPCWithHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateVPCWithHostedZoneResponse",
    ChangeInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlAssociateVPCWithHostedZoneCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateVPCWithHostedZoneCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingDomainExists":
    case "com.amazonaws.route53#ConflictingDomainExists":
      response = {
        ...(await deserializeAws_restXmlConflictingDomainExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCId":
    case "com.amazonaws.route53#InvalidVPCId":
      response = {
        ...(await deserializeAws_restXmlInvalidVPCIdResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitsExceeded":
    case "com.amazonaws.route53#LimitsExceeded":
      response = {
        ...(await deserializeAws_restXmlLimitsExceededResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NotAuthorizedException":
    case "com.amazonaws.route53#NotAuthorizedException":
      response = {
        ...(await deserializeAws_restXmlNotAuthorizedExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PublicZoneVPCAssociation":
    case "com.amazonaws.route53#PublicZoneVPCAssociation":
      response = {
        ...(await deserializeAws_restXmlPublicZoneVPCAssociationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlChangeResourceRecordSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ChangeResourceRecordSetsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlChangeResourceRecordSetsCommandError(
      output,
      context
    );
  }
  const contents: ChangeResourceRecordSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ChangeResourceRecordSetsResponse",
    ChangeInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlChangeResourceRecordSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ChangeResourceRecordSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidChangeBatch":
    case "com.amazonaws.route53#InvalidChangeBatch":
      response = {
        ...(await deserializeAws_restXmlInvalidChangeBatchResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHealthCheck":
    case "com.amazonaws.route53#NoSuchHealthCheck":
      response = {
        ...(await deserializeAws_restXmlNoSuchHealthCheckResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PriorRequestNotComplete":
    case "com.amazonaws.route53#PriorRequestNotComplete":
      response = {
        ...(await deserializeAws_restXmlPriorRequestNotCompleteResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlChangeTagsForResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ChangeTagsForResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlChangeTagsForResourceCommandError(
      output,
      context
    );
  }
  const contents: ChangeTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ChangeTagsForResourceResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlChangeTagsForResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ChangeTagsForResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHealthCheck":
    case "com.amazonaws.route53#NoSuchHealthCheck":
      response = {
        ...(await deserializeAws_restXmlNoSuchHealthCheckResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PriorRequestNotComplete":
    case "com.amazonaws.route53#PriorRequestNotComplete":
      response = {
        ...(await deserializeAws_restXmlPriorRequestNotCompleteResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.route53#ThrottlingException":
      response = {
        ...(await deserializeAws_restXmlThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateHealthCheckCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHealthCheckCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateHealthCheckCommandError(output, context);
  }
  const contents: CreateHealthCheckCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateHealthCheckResponse",
    HealthCheck: undefined,
    Location: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["HealthCheck"] !== undefined) {
    contents.HealthCheck = deserializeAws_restXmlHealthCheck(
      data["HealthCheck"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateHealthCheckCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHealthCheckCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HealthCheckAlreadyExists":
    case "com.amazonaws.route53#HealthCheckAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlHealthCheckAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyHealthChecks":
    case "com.amazonaws.route53#TooManyHealthChecks":
      response = {
        ...(await deserializeAws_restXmlTooManyHealthChecksResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateHostedZoneCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHostedZoneCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateHostedZoneCommandError(output, context);
  }
  const contents: CreateHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateHostedZoneResponse",
    ChangeInfo: undefined,
    DelegationSet: undefined,
    HostedZone: undefined,
    Location: undefined,
    VPC: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  if (data["DelegationSet"] !== undefined) {
    contents.DelegationSet = deserializeAws_restXmlDelegationSet(
      data["DelegationSet"],
      context
    );
  }
  if (data["HostedZone"] !== undefined) {
    contents.HostedZone = deserializeAws_restXmlHostedZone(
      data["HostedZone"],
      context
    );
  }
  if (data["VPC"] !== undefined) {
    contents.VPC = deserializeAws_restXmlVPC(data["VPC"], context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateHostedZoneCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHostedZoneCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingDomainExists":
    case "com.amazonaws.route53#ConflictingDomainExists":
      response = {
        ...(await deserializeAws_restXmlConflictingDomainExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DelegationSetNotAvailable":
    case "com.amazonaws.route53#DelegationSetNotAvailable":
      response = {
        ...(await deserializeAws_restXmlDelegationSetNotAvailableResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DelegationSetNotReusable":
    case "com.amazonaws.route53#DelegationSetNotReusable":
      response = {
        ...(await deserializeAws_restXmlDelegationSetNotReusableResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "HostedZoneAlreadyExists":
    case "com.amazonaws.route53#HostedZoneAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlHostedZoneAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDomainName":
    case "com.amazonaws.route53#InvalidDomainName":
      response = {
        ...(await deserializeAws_restXmlInvalidDomainNameResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCId":
    case "com.amazonaws.route53#InvalidVPCId":
      response = {
        ...(await deserializeAws_restXmlInvalidVPCIdResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDelegationSet":
    case "com.amazonaws.route53#NoSuchDelegationSet":
      response = {
        ...(await deserializeAws_restXmlNoSuchDelegationSetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyHostedZones":
    case "com.amazonaws.route53#TooManyHostedZones":
      response = {
        ...(await deserializeAws_restXmlTooManyHostedZonesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateQueryLoggingConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateQueryLoggingConfigCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateQueryLoggingConfigCommandError(
      output,
      context
    );
  }
  const contents: CreateQueryLoggingConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateQueryLoggingConfigResponse",
    Location: undefined,
    QueryLoggingConfig: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["QueryLoggingConfig"] !== undefined) {
    contents.QueryLoggingConfig = deserializeAws_restXmlQueryLoggingConfig(
      data["QueryLoggingConfig"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateQueryLoggingConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateQueryLoggingConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazonaws.route53#ConcurrentModification":
      response = {
        ...(await deserializeAws_restXmlConcurrentModificationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientCloudWatchLogsResourcePolicy":
    case "com.amazonaws.route53#InsufficientCloudWatchLogsResourcePolicy":
      response = {
        ...(await deserializeAws_restXmlInsufficientCloudWatchLogsResourcePolicyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchCloudWatchLogsLogGroup":
    case "com.amazonaws.route53#NoSuchCloudWatchLogsLogGroup":
      response = {
        ...(await deserializeAws_restXmlNoSuchCloudWatchLogsLogGroupResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "QueryLoggingConfigAlreadyExists":
    case "com.amazonaws.route53#QueryLoggingConfigAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlQueryLoggingConfigAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateReusableDelegationSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReusableDelegationSetCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateReusableDelegationSetCommandError(
      output,
      context
    );
  }
  const contents: CreateReusableDelegationSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReusableDelegationSetResponse",
    DelegationSet: undefined,
    Location: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["DelegationSet"] !== undefined) {
    contents.DelegationSet = deserializeAws_restXmlDelegationSet(
      data["DelegationSet"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateReusableDelegationSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReusableDelegationSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DelegationSetAlreadyCreated":
    case "com.amazonaws.route53#DelegationSetAlreadyCreated":
      response = {
        ...(await deserializeAws_restXmlDelegationSetAlreadyCreatedResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DelegationSetAlreadyReusable":
    case "com.amazonaws.route53#DelegationSetAlreadyReusable":
      response = {
        ...(await deserializeAws_restXmlDelegationSetAlreadyReusableResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DelegationSetNotAvailable":
    case "com.amazonaws.route53#DelegationSetNotAvailable":
      response = {
        ...(await deserializeAws_restXmlDelegationSetNotAvailableResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "HostedZoneNotFound":
    case "com.amazonaws.route53#HostedZoneNotFound":
      response = {
        ...(await deserializeAws_restXmlHostedZoneNotFoundResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidArgument":
    case "com.amazonaws.route53#InvalidArgument":
      response = {
        ...(await deserializeAws_restXmlInvalidArgumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LimitsExceeded":
    case "com.amazonaws.route53#LimitsExceeded":
      response = {
        ...(await deserializeAws_restXmlLimitsExceededResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateTrafficPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateTrafficPolicyCommandError(
      output,
      context
    );
  }
  const contents: CreateTrafficPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrafficPolicyResponse",
    Location: undefined,
    TrafficPolicy: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicy"] !== undefined) {
    contents.TrafficPolicy = deserializeAws_restXmlTrafficPolicy(
      data["TrafficPolicy"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateTrafficPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTrafficPolicyDocument":
    case "com.amazonaws.route53#InvalidTrafficPolicyDocument":
      response = {
        ...(await deserializeAws_restXmlInvalidTrafficPolicyDocumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTrafficPolicies":
    case "com.amazonaws.route53#TooManyTrafficPolicies":
      response = {
        ...(await deserializeAws_restXmlTooManyTrafficPoliciesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TrafficPolicyAlreadyExists":
    case "com.amazonaws.route53#TrafficPolicyAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlTrafficPolicyAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateTrafficPolicyInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyInstanceCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateTrafficPolicyInstanceCommandError(
      output,
      context
    );
  }
  const contents: CreateTrafficPolicyInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrafficPolicyInstanceResponse",
    Location: undefined,
    TrafficPolicyInstance: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicyInstance"] !== undefined) {
    contents.TrafficPolicyInstance = deserializeAws_restXmlTrafficPolicyInstance(
      data["TrafficPolicyInstance"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateTrafficPolicyInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazonaws.route53#NoSuchTrafficPolicy":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTrafficPolicyInstances":
    case "com.amazonaws.route53#TooManyTrafficPolicyInstances":
      response = {
        ...(await deserializeAws_restXmlTooManyTrafficPolicyInstancesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TrafficPolicyInstanceAlreadyExists":
    case "com.amazonaws.route53#TrafficPolicyInstanceAlreadyExists":
      response = {
        ...(await deserializeAws_restXmlTrafficPolicyInstanceAlreadyExistsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateTrafficPolicyVersionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyVersionCommandOutput> => {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateTrafficPolicyVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateTrafficPolicyVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrafficPolicyVersionResponse",
    Location: undefined,
    TrafficPolicy: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicy"] !== undefined) {
    contents.TrafficPolicy = deserializeAws_restXmlTrafficPolicy(
      data["TrafficPolicy"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateTrafficPolicyVersionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyVersionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazonaws.route53#ConcurrentModification":
      response = {
        ...(await deserializeAws_restXmlConcurrentModificationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidTrafficPolicyDocument":
    case "com.amazonaws.route53#InvalidTrafficPolicyDocument":
      response = {
        ...(await deserializeAws_restXmlInvalidTrafficPolicyDocumentResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazonaws.route53#NoSuchTrafficPolicy":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyTrafficPolicyVersionsForCurrentPolicy":
    case "com.amazonaws.route53#TooManyTrafficPolicyVersionsForCurrentPolicy":
      response = {
        ...(await deserializeAws_restXmlTooManyTrafficPolicyVersionsForCurrentPolicyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlCreateVPCAssociationAuthorizationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVPCAssociationAuthorizationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateVPCAssociationAuthorizationCommandError(
      output,
      context
    );
  }
  const contents: CreateVPCAssociationAuthorizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVPCAssociationAuthorizationResponse",
    HostedZoneId: undefined,
    VPC: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = data["HostedZoneId"];
  }
  if (data["VPC"] !== undefined) {
    contents.VPC = deserializeAws_restXmlVPC(data["VPC"], context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlCreateVPCAssociationAuthorizationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVPCAssociationAuthorizationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazonaws.route53#ConcurrentModification":
      response = {
        ...(await deserializeAws_restXmlConcurrentModificationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCId":
    case "com.amazonaws.route53#InvalidVPCId":
      response = {
        ...(await deserializeAws_restXmlInvalidVPCIdResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TooManyVPCAssociationAuthorizations":
    case "com.amazonaws.route53#TooManyVPCAssociationAuthorizations":
      response = {
        ...(await deserializeAws_restXmlTooManyVPCAssociationAuthorizationsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteHealthCheckCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHealthCheckCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteHealthCheckCommandError(output, context);
  }
  const contents: DeleteHealthCheckCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteHealthCheckResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteHealthCheckCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHealthCheckCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HealthCheckInUse":
    case "com.amazonaws.route53#HealthCheckInUse":
      response = {
        ...(await deserializeAws_restXmlHealthCheckInUseResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHealthCheck":
    case "com.amazonaws.route53#NoSuchHealthCheck":
      response = {
        ...(await deserializeAws_restXmlNoSuchHealthCheckResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteHostedZoneCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHostedZoneCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteHostedZoneCommandError(output, context);
  }
  const contents: DeleteHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteHostedZoneResponse",
    ChangeInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteHostedZoneCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHostedZoneCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HostedZoneNotEmpty":
    case "com.amazonaws.route53#HostedZoneNotEmpty":
      response = {
        ...(await deserializeAws_restXmlHostedZoneNotEmptyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidDomainName":
    case "com.amazonaws.route53#InvalidDomainName":
      response = {
        ...(await deserializeAws_restXmlInvalidDomainNameResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PriorRequestNotComplete":
    case "com.amazonaws.route53#PriorRequestNotComplete":
      response = {
        ...(await deserializeAws_restXmlPriorRequestNotCompleteResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteQueryLoggingConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteQueryLoggingConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteQueryLoggingConfigCommandError(
      output,
      context
    );
  }
  const contents: DeleteQueryLoggingConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteQueryLoggingConfigResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteQueryLoggingConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteQueryLoggingConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazonaws.route53#ConcurrentModification":
      response = {
        ...(await deserializeAws_restXmlConcurrentModificationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchQueryLoggingConfig":
    case "com.amazonaws.route53#NoSuchQueryLoggingConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchQueryLoggingConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteReusableDelegationSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReusableDelegationSetCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteReusableDelegationSetCommandError(
      output,
      context
    );
  }
  const contents: DeleteReusableDelegationSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReusableDelegationSetResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteReusableDelegationSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReusableDelegationSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DelegationSetInUse":
    case "com.amazonaws.route53#DelegationSetInUse":
      response = {
        ...(await deserializeAws_restXmlDelegationSetInUseResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "DelegationSetNotReusable":
    case "com.amazonaws.route53#DelegationSetNotReusable":
      response = {
        ...(await deserializeAws_restXmlDelegationSetNotReusableResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDelegationSet":
    case "com.amazonaws.route53#NoSuchDelegationSet":
      response = {
        ...(await deserializeAws_restXmlNoSuchDelegationSetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteTrafficPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficPolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteTrafficPolicyCommandError(
      output,
      context
    );
  }
  const contents: DeleteTrafficPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrafficPolicyResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteTrafficPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazonaws.route53#ConcurrentModification":
      response = {
        ...(await deserializeAws_restXmlConcurrentModificationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazonaws.route53#NoSuchTrafficPolicy":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "TrafficPolicyInUse":
    case "com.amazonaws.route53#TrafficPolicyInUse":
      response = {
        ...(await deserializeAws_restXmlTrafficPolicyInUseResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteTrafficPolicyInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficPolicyInstanceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteTrafficPolicyInstanceCommandError(
      output,
      context
    );
  }
  const contents: DeleteTrafficPolicyInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrafficPolicyInstanceResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteTrafficPolicyInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficPolicyInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PriorRequestNotComplete":
    case "com.amazonaws.route53#PriorRequestNotComplete":
      response = {
        ...(await deserializeAws_restXmlPriorRequestNotCompleteResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDeleteVPCAssociationAuthorizationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVPCAssociationAuthorizationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteVPCAssociationAuthorizationCommandError(
      output,
      context
    );
  }
  const contents: DeleteVPCAssociationAuthorizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVPCAssociationAuthorizationResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDeleteVPCAssociationAuthorizationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVPCAssociationAuthorizationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazonaws.route53#ConcurrentModification":
      response = {
        ...(await deserializeAws_restXmlConcurrentModificationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCId":
    case "com.amazonaws.route53#InvalidVPCId":
      response = {
        ...(await deserializeAws_restXmlInvalidVPCIdResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VPCAssociationAuthorizationNotFound":
    case "com.amazonaws.route53#VPCAssociationAuthorizationNotFound":
      response = {
        ...(await deserializeAws_restXmlVPCAssociationAuthorizationNotFoundResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlDisassociateVPCFromHostedZoneCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateVPCFromHostedZoneCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDisassociateVPCFromHostedZoneCommandError(
      output,
      context
    );
  }
  const contents: DisassociateVPCFromHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateVPCFromHostedZoneResponse",
    ChangeInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlDisassociateVPCFromHostedZoneCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateVPCFromHostedZoneCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidVPCId":
    case "com.amazonaws.route53#InvalidVPCId":
      response = {
        ...(await deserializeAws_restXmlInvalidVPCIdResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "LastVPCAssociation":
    case "com.amazonaws.route53#LastVPCAssociation":
      response = {
        ...(await deserializeAws_restXmlLastVPCAssociationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "VPCAssociationNotFound":
    case "com.amazonaws.route53#VPCAssociationNotFound":
      response = {
        ...(await deserializeAws_restXmlVPCAssociationNotFoundResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetAccountLimitCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountLimitCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetAccountLimitCommandError(output, context);
  }
  const contents: GetAccountLimitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAccountLimitResponse",
    Count: undefined,
    Limit: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Count"] !== undefined) {
    contents.Count = parseInt(data["Count"]);
  }
  if (data["Limit"] !== undefined) {
    contents.Limit = deserializeAws_restXmlAccountLimit(data["Limit"], context);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetAccountLimitCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountLimitCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetChangeCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetChangeCommandError(output, context);
  }
  const contents: GetChangeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetChangeResponse",
    ChangeInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetChangeCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchChange":
    case "com.amazonaws.route53#NoSuchChange":
      response = {
        ...(await deserializeAws_restXmlNoSuchChangeResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetCheckerIpRangesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCheckerIpRangesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetCheckerIpRangesCommandError(
      output,
      context
    );
  }
  const contents: GetCheckerIpRangesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCheckerIpRangesResponse",
    CheckerIpRanges: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.CheckerIpRanges === "") {
    contents.CheckerIpRanges = [];
  }
  if (
    data["CheckerIpRanges"] !== undefined &&
    data["CheckerIpRanges"]["member"] !== undefined
  ) {
    contents.CheckerIpRanges = deserializeAws_restXmlCheckerIpRanges(
      __getArrayIfSingleItem(data["CheckerIpRanges"]["member"]),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetCheckerIpRangesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCheckerIpRangesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetGeoLocationCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGeoLocationCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetGeoLocationCommandError(output, context);
  }
  const contents: GetGeoLocationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGeoLocationResponse",
    GeoLocationDetails: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["GeoLocationDetails"] !== undefined) {
    contents.GeoLocationDetails = deserializeAws_restXmlGeoLocationDetails(
      data["GeoLocationDetails"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetGeoLocationCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGeoLocationCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchGeoLocation":
    case "com.amazonaws.route53#NoSuchGeoLocation":
      response = {
        ...(await deserializeAws_restXmlNoSuchGeoLocationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetHealthCheckCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHealthCheckCommandError(output, context);
  }
  const contents: GetHealthCheckCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHealthCheckResponse",
    HealthCheck: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HealthCheck"] !== undefined) {
    contents.HealthCheck = deserializeAws_restXmlHealthCheck(
      data["HealthCheck"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetHealthCheckCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IncompatibleVersion":
    case "com.amazonaws.route53#IncompatibleVersion":
      response = {
        ...(await deserializeAws_restXmlIncompatibleVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHealthCheck":
    case "com.amazonaws.route53#NoSuchHealthCheck":
      response = {
        ...(await deserializeAws_restXmlNoSuchHealthCheckResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetHealthCheckCountCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckCountCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHealthCheckCountCommandError(
      output,
      context
    );
  }
  const contents: GetHealthCheckCountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHealthCheckCountResponse",
    HealthCheckCount: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HealthCheckCount"] !== undefined) {
    contents.HealthCheckCount = parseInt(data["HealthCheckCount"]);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetHealthCheckCountCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckCountCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetHealthCheckLastFailureReasonCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckLastFailureReasonCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHealthCheckLastFailureReasonCommandError(
      output,
      context
    );
  }
  const contents: GetHealthCheckLastFailureReasonCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHealthCheckLastFailureReasonResponse",
    HealthCheckObservations: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.HealthCheckObservations === "") {
    contents.HealthCheckObservations = [];
  }
  if (
    data["HealthCheckObservations"] !== undefined &&
    data["HealthCheckObservations"]["HealthCheckObservation"] !== undefined
  ) {
    contents.HealthCheckObservations = deserializeAws_restXmlHealthCheckObservations(
      __getArrayIfSingleItem(
        data["HealthCheckObservations"]["HealthCheckObservation"]
      ),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetHealthCheckLastFailureReasonCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckLastFailureReasonCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHealthCheck":
    case "com.amazonaws.route53#NoSuchHealthCheck":
      response = {
        ...(await deserializeAws_restXmlNoSuchHealthCheckResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetHealthCheckStatusCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckStatusCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHealthCheckStatusCommandError(
      output,
      context
    );
  }
  const contents: GetHealthCheckStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHealthCheckStatusResponse",
    HealthCheckObservations: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.HealthCheckObservations === "") {
    contents.HealthCheckObservations = [];
  }
  if (
    data["HealthCheckObservations"] !== undefined &&
    data["HealthCheckObservations"]["HealthCheckObservation"] !== undefined
  ) {
    contents.HealthCheckObservations = deserializeAws_restXmlHealthCheckObservations(
      __getArrayIfSingleItem(
        data["HealthCheckObservations"]["HealthCheckObservation"]
      ),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetHealthCheckStatusCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckStatusCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHealthCheck":
    case "com.amazonaws.route53#NoSuchHealthCheck":
      response = {
        ...(await deserializeAws_restXmlNoSuchHealthCheckResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetHostedZoneCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHostedZoneCommandError(output, context);
  }
  const contents: GetHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHostedZoneResponse",
    DelegationSet: undefined,
    HostedZone: undefined,
    VPCs: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["DelegationSet"] !== undefined) {
    contents.DelegationSet = deserializeAws_restXmlDelegationSet(
      data["DelegationSet"],
      context
    );
  }
  if (data["HostedZone"] !== undefined) {
    contents.HostedZone = deserializeAws_restXmlHostedZone(
      data["HostedZone"],
      context
    );
  }
  if (data.VPCs === "") {
    contents.VPCs = [];
  }
  if (data["VPCs"] !== undefined && data["VPCs"]["VPC"] !== undefined) {
    contents.VPCs = deserializeAws_restXmlVPCs(
      __getArrayIfSingleItem(data["VPCs"]["VPC"]),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetHostedZoneCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetHostedZoneCountCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneCountCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHostedZoneCountCommandError(
      output,
      context
    );
  }
  const contents: GetHostedZoneCountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHostedZoneCountResponse",
    HostedZoneCount: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZoneCount"] !== undefined) {
    contents.HostedZoneCount = parseInt(data["HostedZoneCount"]);
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetHostedZoneCountCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneCountCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetHostedZoneLimitCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneLimitCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHostedZoneLimitCommandError(
      output,
      context
    );
  }
  const contents: GetHostedZoneLimitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHostedZoneLimitResponse",
    Count: undefined,
    Limit: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Count"] !== undefined) {
    contents.Count = parseInt(data["Count"]);
  }
  if (data["Limit"] !== undefined) {
    contents.Limit = deserializeAws_restXmlHostedZoneLimit(
      data["Limit"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetHostedZoneLimitCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneLimitCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HostedZoneNotPrivate":
    case "com.amazonaws.route53#HostedZoneNotPrivate":
      response = {
        ...(await deserializeAws_restXmlHostedZoneNotPrivateResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetQueryLoggingConfigCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetQueryLoggingConfigCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetQueryLoggingConfigCommandError(
      output,
      context
    );
  }
  const contents: GetQueryLoggingConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetQueryLoggingConfigResponse",
    QueryLoggingConfig: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["QueryLoggingConfig"] !== undefined) {
    contents.QueryLoggingConfig = deserializeAws_restXmlQueryLoggingConfig(
      data["QueryLoggingConfig"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetQueryLoggingConfigCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetQueryLoggingConfigCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchQueryLoggingConfig":
    case "com.amazonaws.route53#NoSuchQueryLoggingConfig":
      response = {
        ...(await deserializeAws_restXmlNoSuchQueryLoggingConfigResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetReusableDelegationSetCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReusableDelegationSetCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetReusableDelegationSetCommandError(
      output,
      context
    );
  }
  const contents: GetReusableDelegationSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetReusableDelegationSetResponse",
    DelegationSet: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["DelegationSet"] !== undefined) {
    contents.DelegationSet = deserializeAws_restXmlDelegationSet(
      data["DelegationSet"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetReusableDelegationSetCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReusableDelegationSetCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DelegationSetNotReusable":
    case "com.amazonaws.route53#DelegationSetNotReusable":
      response = {
        ...(await deserializeAws_restXmlDelegationSetNotReusableResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDelegationSet":
    case "com.amazonaws.route53#NoSuchDelegationSet":
      response = {
        ...(await deserializeAws_restXmlNoSuchDelegationSetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetReusableDelegationSetLimitCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReusableDelegationSetLimitCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetReusableDelegationSetLimitCommandError(
      output,
      context
    );
  }
  const contents: GetReusableDelegationSetLimitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetReusableDelegationSetLimitResponse",
    Count: undefined,
    Limit: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Count"] !== undefined) {
    contents.Count = parseInt(data["Count"]);
  }
  if (data["Limit"] !== undefined) {
    contents.Limit = deserializeAws_restXmlReusableDelegationSetLimit(
      data["Limit"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetReusableDelegationSetLimitCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReusableDelegationSetLimitCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDelegationSet":
    case "com.amazonaws.route53#NoSuchDelegationSet":
      response = {
        ...(await deserializeAws_restXmlNoSuchDelegationSetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetTrafficPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetTrafficPolicyCommandError(output, context);
  }
  const contents: GetTrafficPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTrafficPolicyResponse",
    TrafficPolicy: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicy"] !== undefined) {
    contents.TrafficPolicy = deserializeAws_restXmlTrafficPolicy(
      data["TrafficPolicy"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetTrafficPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazonaws.route53#NoSuchTrafficPolicy":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetTrafficPolicyInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyInstanceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetTrafficPolicyInstanceCommandError(
      output,
      context
    );
  }
  const contents: GetTrafficPolicyInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTrafficPolicyInstanceResponse",
    TrafficPolicyInstance: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicyInstance"] !== undefined) {
    contents.TrafficPolicyInstance = deserializeAws_restXmlTrafficPolicyInstance(
      data["TrafficPolicyInstance"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetTrafficPolicyInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlGetTrafficPolicyInstanceCountCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyInstanceCountCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetTrafficPolicyInstanceCountCommandError(
      output,
      context
    );
  }
  const contents: GetTrafficPolicyInstanceCountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTrafficPolicyInstanceCountResponse",
    TrafficPolicyInstanceCount: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicyInstanceCount"] !== undefined) {
    contents.TrafficPolicyInstanceCount = parseInt(
      data["TrafficPolicyInstanceCount"]
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlGetTrafficPolicyInstanceCountCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyInstanceCountCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListGeoLocationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGeoLocationsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListGeoLocationsCommandError(output, context);
  }
  const contents: ListGeoLocationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGeoLocationsResponse",
    GeoLocationDetailsList: undefined,
    IsTruncated: undefined,
    MaxItems: undefined,
    NextContinentCode: undefined,
    NextCountryCode: undefined,
    NextSubdivisionCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.GeoLocationDetailsList === "") {
    contents.GeoLocationDetailsList = [];
  }
  if (
    data["GeoLocationDetailsList"] !== undefined &&
    data["GeoLocationDetailsList"]["GeoLocationDetails"] !== undefined
  ) {
    contents.GeoLocationDetailsList = deserializeAws_restXmlGeoLocationDetailsList(
      __getArrayIfSingleItem(
        data["GeoLocationDetailsList"]["GeoLocationDetails"]
      ),
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextContinentCode"] !== undefined) {
    contents.NextContinentCode = data["NextContinentCode"];
  }
  if (data["NextCountryCode"] !== undefined) {
    contents.NextCountryCode = data["NextCountryCode"];
  }
  if (data["NextSubdivisionCode"] !== undefined) {
    contents.NextSubdivisionCode = data["NextSubdivisionCode"];
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListGeoLocationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGeoLocationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListHealthChecksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHealthChecksCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListHealthChecksCommandError(output, context);
  }
  const contents: ListHealthChecksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListHealthChecksResponse",
    HealthChecks: undefined,
    IsTruncated: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.HealthChecks === "") {
    contents.HealthChecks = [];
  }
  if (
    data["HealthChecks"] !== undefined &&
    data["HealthChecks"]["HealthCheck"] !== undefined
  ) {
    contents.HealthChecks = deserializeAws_restXmlHealthChecks(
      __getArrayIfSingleItem(data["HealthChecks"]["HealthCheck"]),
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["Marker"] !== undefined) {
    contents.Marker = data["Marker"];
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextMarker"] !== undefined) {
    contents.NextMarker = data["NextMarker"];
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListHealthChecksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHealthChecksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IncompatibleVersion":
    case "com.amazonaws.route53#IncompatibleVersion":
      response = {
        ...(await deserializeAws_restXmlIncompatibleVersionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListHostedZonesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHostedZonesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListHostedZonesCommandError(output, context);
  }
  const contents: ListHostedZonesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListHostedZonesResponse",
    HostedZones: undefined,
    IsTruncated: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.HostedZones === "") {
    contents.HostedZones = [];
  }
  if (
    data["HostedZones"] !== undefined &&
    data["HostedZones"]["HostedZone"] !== undefined
  ) {
    contents.HostedZones = deserializeAws_restXmlHostedZones(
      __getArrayIfSingleItem(data["HostedZones"]["HostedZone"]),
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["Marker"] !== undefined) {
    contents.Marker = data["Marker"];
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextMarker"] !== undefined) {
    contents.NextMarker = data["NextMarker"];
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListHostedZonesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHostedZonesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DelegationSetNotReusable":
    case "com.amazonaws.route53#DelegationSetNotReusable":
      response = {
        ...(await deserializeAws_restXmlDelegationSetNotReusableResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchDelegationSet":
    case "com.amazonaws.route53#NoSuchDelegationSet":
      response = {
        ...(await deserializeAws_restXmlNoSuchDelegationSetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListHostedZonesByNameCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHostedZonesByNameCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListHostedZonesByNameCommandError(
      output,
      context
    );
  }
  const contents: ListHostedZonesByNameCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListHostedZonesByNameResponse",
    DNSName: undefined,
    HostedZoneId: undefined,
    HostedZones: undefined,
    IsTruncated: undefined,
    MaxItems: undefined,
    NextDNSName: undefined,
    NextHostedZoneId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["DNSName"] !== undefined) {
    contents.DNSName = data["DNSName"];
  }
  if (data["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = data["HostedZoneId"];
  }
  if (data.HostedZones === "") {
    contents.HostedZones = [];
  }
  if (
    data["HostedZones"] !== undefined &&
    data["HostedZones"]["HostedZone"] !== undefined
  ) {
    contents.HostedZones = deserializeAws_restXmlHostedZones(
      __getArrayIfSingleItem(data["HostedZones"]["HostedZone"]),
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextDNSName"] !== undefined) {
    contents.NextDNSName = data["NextDNSName"];
  }
  if (data["NextHostedZoneId"] !== undefined) {
    contents.NextHostedZoneId = data["NextHostedZoneId"];
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListHostedZonesByNameCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHostedZonesByNameCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidDomainName":
    case "com.amazonaws.route53#InvalidDomainName":
      response = {
        ...(await deserializeAws_restXmlInvalidDomainNameResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListQueryLoggingConfigsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListQueryLoggingConfigsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListQueryLoggingConfigsCommandError(
      output,
      context
    );
  }
  const contents: ListQueryLoggingConfigsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListQueryLoggingConfigsResponse",
    NextToken: undefined,
    QueryLoggingConfigs: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["NextToken"] !== undefined) {
    contents.NextToken = data["NextToken"];
  }
  if (data.QueryLoggingConfigs === "") {
    contents.QueryLoggingConfigs = [];
  }
  if (
    data["QueryLoggingConfigs"] !== undefined &&
    data["QueryLoggingConfigs"]["QueryLoggingConfig"] !== undefined
  ) {
    contents.QueryLoggingConfigs = deserializeAws_restXmlQueryLoggingConfigs(
      __getArrayIfSingleItem(data["QueryLoggingConfigs"]["QueryLoggingConfig"]),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListQueryLoggingConfigsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListQueryLoggingConfigsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPaginationToken":
    case "com.amazonaws.route53#InvalidPaginationToken":
      response = {
        ...(await deserializeAws_restXmlInvalidPaginationTokenResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListResourceRecordSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceRecordSetsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListResourceRecordSetsCommandError(
      output,
      context
    );
  }
  const contents: ListResourceRecordSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListResourceRecordSetsResponse",
    IsTruncated: undefined,
    MaxItems: undefined,
    NextRecordIdentifier: undefined,
    NextRecordName: undefined,
    NextRecordType: undefined,
    ResourceRecordSets: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextRecordIdentifier"] !== undefined) {
    contents.NextRecordIdentifier = data["NextRecordIdentifier"];
  }
  if (data["NextRecordName"] !== undefined) {
    contents.NextRecordName = data["NextRecordName"];
  }
  if (data["NextRecordType"] !== undefined) {
    contents.NextRecordType = data["NextRecordType"];
  }
  if (data.ResourceRecordSets === "") {
    contents.ResourceRecordSets = [];
  }
  if (
    data["ResourceRecordSets"] !== undefined &&
    data["ResourceRecordSets"]["ResourceRecordSet"] !== undefined
  ) {
    contents.ResourceRecordSets = deserializeAws_restXmlResourceRecordSets(
      __getArrayIfSingleItem(data["ResourceRecordSets"]["ResourceRecordSet"]),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListResourceRecordSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceRecordSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListReusableDelegationSetsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListReusableDelegationSetsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListReusableDelegationSetsCommandError(
      output,
      context
    );
  }
  const contents: ListReusableDelegationSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListReusableDelegationSetsResponse",
    DelegationSets: undefined,
    IsTruncated: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DelegationSets === "") {
    contents.DelegationSets = [];
  }
  if (
    data["DelegationSets"] !== undefined &&
    data["DelegationSets"]["DelegationSet"] !== undefined
  ) {
    contents.DelegationSets = deserializeAws_restXmlDelegationSets(
      __getArrayIfSingleItem(data["DelegationSets"]["DelegationSet"]),
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["Marker"] !== undefined) {
    contents.Marker = data["Marker"];
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextMarker"] !== undefined) {
    contents.NextMarker = data["NextMarker"];
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListReusableDelegationSetsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListReusableDelegationSetsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListTagsForResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTagsForResourceCommandError(
      output,
      context
    );
  }
  const contents: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    ResourceTagSet: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ResourceTagSet"] !== undefined) {
    contents.ResourceTagSet = deserializeAws_restXmlResourceTagSet(
      data["ResourceTagSet"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListTagsForResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHealthCheck":
    case "com.amazonaws.route53#NoSuchHealthCheck":
      response = {
        ...(await deserializeAws_restXmlNoSuchHealthCheckResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PriorRequestNotComplete":
    case "com.amazonaws.route53#PriorRequestNotComplete":
      response = {
        ...(await deserializeAws_restXmlPriorRequestNotCompleteResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.route53#ThrottlingException":
      response = {
        ...(await deserializeAws_restXmlThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListTagsForResourcesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourcesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTagsForResourcesCommandError(
      output,
      context
    );
  }
  const contents: ListTagsForResourcesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourcesResponse",
    ResourceTagSets: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.ResourceTagSets === "") {
    contents.ResourceTagSets = [];
  }
  if (
    data["ResourceTagSets"] !== undefined &&
    data["ResourceTagSets"]["ResourceTagSet"] !== undefined
  ) {
    contents.ResourceTagSets = deserializeAws_restXmlResourceTagSetList(
      __getArrayIfSingleItem(data["ResourceTagSets"]["ResourceTagSet"]),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListTagsForResourcesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourcesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHealthCheck":
    case "com.amazonaws.route53#NoSuchHealthCheck":
      response = {
        ...(await deserializeAws_restXmlNoSuchHealthCheckResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PriorRequestNotComplete":
    case "com.amazonaws.route53#PriorRequestNotComplete":
      response = {
        ...(await deserializeAws_restXmlPriorRequestNotCompleteResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ThrottlingException":
    case "com.amazonaws.route53#ThrottlingException":
      response = {
        ...(await deserializeAws_restXmlThrottlingExceptionResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListTrafficPoliciesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPoliciesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTrafficPoliciesCommandError(
      output,
      context
    );
  }
  const contents: ListTrafficPoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrafficPoliciesResponse",
    IsTruncated: undefined,
    MaxItems: undefined,
    TrafficPolicyIdMarker: undefined,
    TrafficPolicySummaries: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["TrafficPolicyIdMarker"] !== undefined) {
    contents.TrafficPolicyIdMarker = data["TrafficPolicyIdMarker"];
  }
  if (data.TrafficPolicySummaries === "") {
    contents.TrafficPolicySummaries = [];
  }
  if (
    data["TrafficPolicySummaries"] !== undefined &&
    data["TrafficPolicySummaries"]["TrafficPolicySummary"] !== undefined
  ) {
    contents.TrafficPolicySummaries = deserializeAws_restXmlTrafficPolicySummaries(
      __getArrayIfSingleItem(
        data["TrafficPolicySummaries"]["TrafficPolicySummary"]
      ),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListTrafficPoliciesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPoliciesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListTrafficPolicyInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTrafficPolicyInstancesCommandError(
      output,
      context
    );
  }
  const contents: ListTrafficPolicyInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrafficPolicyInstancesResponse",
    HostedZoneIdMarker: undefined,
    IsTruncated: undefined,
    MaxItems: undefined,
    TrafficPolicyInstanceNameMarker: undefined,
    TrafficPolicyInstanceTypeMarker: undefined,
    TrafficPolicyInstances: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZoneIdMarker"] !== undefined) {
    contents.HostedZoneIdMarker = data["HostedZoneIdMarker"];
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["TrafficPolicyInstanceNameMarker"] !== undefined) {
    contents.TrafficPolicyInstanceNameMarker =
      data["TrafficPolicyInstanceNameMarker"];
  }
  if (data["TrafficPolicyInstanceTypeMarker"] !== undefined) {
    contents.TrafficPolicyInstanceTypeMarker =
      data["TrafficPolicyInstanceTypeMarker"];
  }
  if (data.TrafficPolicyInstances === "") {
    contents.TrafficPolicyInstances = [];
  }
  if (
    data["TrafficPolicyInstances"] !== undefined &&
    data["TrafficPolicyInstances"]["TrafficPolicyInstance"] !== undefined
  ) {
    contents.TrafficPolicyInstances = deserializeAws_restXmlTrafficPolicyInstances(
      __getArrayIfSingleItem(
        data["TrafficPolicyInstances"]["TrafficPolicyInstance"]
      ),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListTrafficPolicyInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListTrafficPolicyInstancesByHostedZoneCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesByHostedZoneCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTrafficPolicyInstancesByHostedZoneCommandError(
      output,
      context
    );
  }
  const contents: ListTrafficPolicyInstancesByHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrafficPolicyInstancesByHostedZoneResponse",
    IsTruncated: undefined,
    MaxItems: undefined,
    TrafficPolicyInstanceNameMarker: undefined,
    TrafficPolicyInstanceTypeMarker: undefined,
    TrafficPolicyInstances: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["TrafficPolicyInstanceNameMarker"] !== undefined) {
    contents.TrafficPolicyInstanceNameMarker =
      data["TrafficPolicyInstanceNameMarker"];
  }
  if (data["TrafficPolicyInstanceTypeMarker"] !== undefined) {
    contents.TrafficPolicyInstanceTypeMarker =
      data["TrafficPolicyInstanceTypeMarker"];
  }
  if (data.TrafficPolicyInstances === "") {
    contents.TrafficPolicyInstances = [];
  }
  if (
    data["TrafficPolicyInstances"] !== undefined &&
    data["TrafficPolicyInstances"]["TrafficPolicyInstance"] !== undefined
  ) {
    contents.TrafficPolicyInstances = deserializeAws_restXmlTrafficPolicyInstances(
      __getArrayIfSingleItem(
        data["TrafficPolicyInstances"]["TrafficPolicyInstance"]
      ),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListTrafficPolicyInstancesByHostedZoneCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesByHostedZoneCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListTrafficPolicyInstancesByPolicyCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesByPolicyCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTrafficPolicyInstancesByPolicyCommandError(
      output,
      context
    );
  }
  const contents: ListTrafficPolicyInstancesByPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrafficPolicyInstancesByPolicyResponse",
    HostedZoneIdMarker: undefined,
    IsTruncated: undefined,
    MaxItems: undefined,
    TrafficPolicyInstanceNameMarker: undefined,
    TrafficPolicyInstanceTypeMarker: undefined,
    TrafficPolicyInstances: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZoneIdMarker"] !== undefined) {
    contents.HostedZoneIdMarker = data["HostedZoneIdMarker"];
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["TrafficPolicyInstanceNameMarker"] !== undefined) {
    contents.TrafficPolicyInstanceNameMarker =
      data["TrafficPolicyInstanceNameMarker"];
  }
  if (data["TrafficPolicyInstanceTypeMarker"] !== undefined) {
    contents.TrafficPolicyInstanceTypeMarker =
      data["TrafficPolicyInstanceTypeMarker"];
  }
  if (data.TrafficPolicyInstances === "") {
    contents.TrafficPolicyInstances = [];
  }
  if (
    data["TrafficPolicyInstances"] !== undefined &&
    data["TrafficPolicyInstances"]["TrafficPolicyInstance"] !== undefined
  ) {
    contents.TrafficPolicyInstances = deserializeAws_restXmlTrafficPolicyInstances(
      __getArrayIfSingleItem(
        data["TrafficPolicyInstances"]["TrafficPolicyInstance"]
      ),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListTrafficPolicyInstancesByPolicyCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesByPolicyCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazonaws.route53#NoSuchTrafficPolicy":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListTrafficPolicyVersionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyVersionsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTrafficPolicyVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListTrafficPolicyVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrafficPolicyVersionsResponse",
    IsTruncated: undefined,
    MaxItems: undefined,
    TrafficPolicies: undefined,
    TrafficPolicyVersionMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data.TrafficPolicies === "") {
    contents.TrafficPolicies = [];
  }
  if (
    data["TrafficPolicies"] !== undefined &&
    data["TrafficPolicies"]["TrafficPolicy"] !== undefined
  ) {
    contents.TrafficPolicies = deserializeAws_restXmlTrafficPolicies(
      __getArrayIfSingleItem(data["TrafficPolicies"]["TrafficPolicy"]),
      context
    );
  }
  if (data["TrafficPolicyVersionMarker"] !== undefined) {
    contents.TrafficPolicyVersionMarker = data["TrafficPolicyVersionMarker"];
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListTrafficPolicyVersionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyVersionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazonaws.route53#NoSuchTrafficPolicy":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlListVPCAssociationAuthorizationsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVPCAssociationAuthorizationsCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListVPCAssociationAuthorizationsCommandError(
      output,
      context
    );
  }
  const contents: ListVPCAssociationAuthorizationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListVPCAssociationAuthorizationsResponse",
    HostedZoneId: undefined,
    NextToken: undefined,
    VPCs: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = data["HostedZoneId"];
  }
  if (data["NextToken"] !== undefined) {
    contents.NextToken = data["NextToken"];
  }
  if (data.VPCs === "") {
    contents.VPCs = [];
  }
  if (data["VPCs"] !== undefined && data["VPCs"]["VPC"] !== undefined) {
    contents.VPCs = deserializeAws_restXmlVPCs(
      __getArrayIfSingleItem(data["VPCs"]["VPC"]),
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlListVPCAssociationAuthorizationsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVPCAssociationAuthorizationsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidPaginationToken":
    case "com.amazonaws.route53#InvalidPaginationToken":
      response = {
        ...(await deserializeAws_restXmlInvalidPaginationTokenResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlTestDNSAnswerCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestDNSAnswerCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlTestDNSAnswerCommandError(output, context);
  }
  const contents: TestDNSAnswerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestDNSAnswerResponse",
    Nameserver: undefined,
    Protocol: undefined,
    RecordData: undefined,
    RecordName: undefined,
    RecordType: undefined,
    ResponseCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Nameserver"] !== undefined) {
    contents.Nameserver = data["Nameserver"];
  }
  if (data["Protocol"] !== undefined) {
    contents.Protocol = data["Protocol"];
  }
  if (data.RecordData === "") {
    contents.RecordData = [];
  }
  if (
    data["RecordData"] !== undefined &&
    data["RecordData"]["RecordDataEntry"] !== undefined
  ) {
    contents.RecordData = deserializeAws_restXmlRecordData(
      __getArrayIfSingleItem(data["RecordData"]["RecordDataEntry"]),
      context
    );
  }
  if (data["RecordName"] !== undefined) {
    contents.RecordName = data["RecordName"];
  }
  if (data["RecordType"] !== undefined) {
    contents.RecordType = data["RecordType"];
  }
  if (data["ResponseCode"] !== undefined) {
    contents.ResponseCode = data["ResponseCode"];
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlTestDNSAnswerCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestDNSAnswerCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateHealthCheckCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateHealthCheckCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateHealthCheckCommandError(output, context);
  }
  const contents: UpdateHealthCheckCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateHealthCheckResponse",
    HealthCheck: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HealthCheck"] !== undefined) {
    contents.HealthCheck = deserializeAws_restXmlHealthCheck(
      data["HealthCheck"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateHealthCheckCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateHealthCheckCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HealthCheckVersionMismatch":
    case "com.amazonaws.route53#HealthCheckVersionMismatch":
      response = {
        ...(await deserializeAws_restXmlHealthCheckVersionMismatchResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHealthCheck":
    case "com.amazonaws.route53#NoSuchHealthCheck":
      response = {
        ...(await deserializeAws_restXmlNoSuchHealthCheckResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateHostedZoneCommentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateHostedZoneCommentCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateHostedZoneCommentCommandError(
      output,
      context
    );
  }
  const contents: UpdateHostedZoneCommentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateHostedZoneCommentResponse",
    HostedZone: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZone"] !== undefined) {
    contents.HostedZone = deserializeAws_restXmlHostedZone(
      data["HostedZone"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateHostedZoneCommentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateHostedZoneCommentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchHostedZone":
    case "com.amazonaws.route53#NoSuchHostedZone":
      response = {
        ...(await deserializeAws_restXmlNoSuchHostedZoneResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateTrafficPolicyCommentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrafficPolicyCommentCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateTrafficPolicyCommentCommandError(
      output,
      context
    );
  }
  const contents: UpdateTrafficPolicyCommentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTrafficPolicyCommentResponse",
    TrafficPolicy: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicy"] !== undefined) {
    contents.TrafficPolicy = deserializeAws_restXmlTrafficPolicy(
      data["TrafficPolicy"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateTrafficPolicyCommentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrafficPolicyCommentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazonaws.route53#ConcurrentModification":
      response = {
        ...(await deserializeAws_restXmlConcurrentModificationResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazonaws.route53#NoSuchTrafficPolicy":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_restXmlUpdateTrafficPolicyInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrafficPolicyInstanceCommandOutput> => {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateTrafficPolicyInstanceCommandError(
      output,
      context
    );
  }
  const contents: UpdateTrafficPolicyInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTrafficPolicyInstanceResponse",
    TrafficPolicyInstance: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicyInstance"] !== undefined) {
    contents.TrafficPolicyInstance = deserializeAws_restXmlTrafficPolicyInstance(
      data["TrafficPolicyInstance"],
      context
    );
  }
  return Promise.resolve(contents);
};

const deserializeAws_restXmlUpdateTrafficPolicyInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrafficPolicyInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingTypes":
    case "com.amazonaws.route53#ConflictingTypes":
      response = {
        ...(await deserializeAws_restXmlConflictingTypesResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidInput":
    case "com.amazonaws.route53#InvalidInput":
      response = {
        ...(await deserializeAws_restXmlInvalidInputResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazonaws.route53#NoSuchTrafficPolicy":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazonaws.route53#NoSuchTrafficPolicyInstance":
      response = {
        ...(await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "PriorRequestNotComplete":
    case "com.amazonaws.route53#PriorRequestNotComplete":
      response = {
        ...(await deserializeAws_restXmlPriorRequestNotCompleteResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_restXmlConcurrentModificationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentModification> => {
  const contents: ConcurrentModification = {
    name: "ConcurrentModification",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlConflictingDomainExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConflictingDomainExists> => {
  const contents: ConflictingDomainExists = {
    name: "ConflictingDomainExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlConflictingTypesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConflictingTypes> => {
  const contents: ConflictingTypes = {
    name: "ConflictingTypes",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlDelegationSetAlreadyCreatedResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DelegationSetAlreadyCreated> => {
  const contents: DelegationSetAlreadyCreated = {
    name: "DelegationSetAlreadyCreated",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlDelegationSetAlreadyReusableResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DelegationSetAlreadyReusable> => {
  const contents: DelegationSetAlreadyReusable = {
    name: "DelegationSetAlreadyReusable",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlDelegationSetInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DelegationSetInUse> => {
  const contents: DelegationSetInUse = {
    name: "DelegationSetInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlDelegationSetNotAvailableResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DelegationSetNotAvailable> => {
  const contents: DelegationSetNotAvailable = {
    name: "DelegationSetNotAvailable",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlDelegationSetNotReusableResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DelegationSetNotReusable> => {
  const contents: DelegationSetNotReusable = {
    name: "DelegationSetNotReusable",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlHealthCheckAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HealthCheckAlreadyExists> => {
  const contents: HealthCheckAlreadyExists = {
    name: "HealthCheckAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlHealthCheckInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HealthCheckInUse> => {
  const contents: HealthCheckInUse = {
    name: "HealthCheckInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlHealthCheckVersionMismatchResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HealthCheckVersionMismatch> => {
  const contents: HealthCheckVersionMismatch = {
    name: "HealthCheckVersionMismatch",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlHostedZoneAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HostedZoneAlreadyExists> => {
  const contents: HostedZoneAlreadyExists = {
    name: "HostedZoneAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlHostedZoneNotEmptyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HostedZoneNotEmpty> => {
  const contents: HostedZoneNotEmpty = {
    name: "HostedZoneNotEmpty",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlHostedZoneNotFoundResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HostedZoneNotFound> => {
  const contents: HostedZoneNotFound = {
    name: "HostedZoneNotFound",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlHostedZoneNotPrivateResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HostedZoneNotPrivate> => {
  const contents: HostedZoneNotPrivate = {
    name: "HostedZoneNotPrivate",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlIncompatibleVersionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IncompatibleVersion> => {
  const contents: IncompatibleVersion = {
    name: "IncompatibleVersion",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlInsufficientCloudWatchLogsResourcePolicyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InsufficientCloudWatchLogsResourcePolicy> => {
  const contents: InsufficientCloudWatchLogsResourcePolicy = {
    name: "InsufficientCloudWatchLogsResourcePolicy",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidArgumentResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidArgument> => {
  const contents: InvalidArgument = {
    name: "InvalidArgument",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidChangeBatchResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidChangeBatch> => {
  const contents: InvalidChangeBatch = {
    name: "InvalidChangeBatch",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
    messages: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  if (data.messages === "") {
    contents.messages = [];
  }
  if (
    data["messages"] !== undefined &&
    data["messages"]["Message"] !== undefined
  ) {
    contents.messages = deserializeAws_restXmlErrorMessages(
      __getArrayIfSingleItem(data["messages"]["Message"]),
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlInvalidDomainNameResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDomainName> => {
  const contents: InvalidDomainName = {
    name: "InvalidDomainName",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidInputResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidInput> => {
  const contents: InvalidInput = {
    name: "InvalidInput",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidPaginationTokenResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPaginationToken> => {
  const contents: InvalidPaginationToken = {
    name: "InvalidPaginationToken",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidTrafficPolicyDocumentResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTrafficPolicyDocument> => {
  const contents: InvalidTrafficPolicyDocument = {
    name: "InvalidTrafficPolicyDocument",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlInvalidVPCIdResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidVPCId> => {
  const contents: InvalidVPCId = {
    name: "InvalidVPCId",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlLastVPCAssociationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<LastVPCAssociation> => {
  const contents: LastVPCAssociation = {
    name: "LastVPCAssociation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlLimitsExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<LimitsExceeded> => {
  const contents: LimitsExceeded = {
    name: "LimitsExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchChangeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchChange> => {
  const contents: NoSuchChange = {
    name: "NoSuchChange",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchCloudWatchLogsLogGroupResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchCloudWatchLogsLogGroup> => {
  const contents: NoSuchCloudWatchLogsLogGroup = {
    name: "NoSuchCloudWatchLogsLogGroup",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchDelegationSetResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchDelegationSet> => {
  const contents: NoSuchDelegationSet = {
    name: "NoSuchDelegationSet",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchGeoLocationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchGeoLocation> => {
  const contents: NoSuchGeoLocation = {
    name: "NoSuchGeoLocation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchHealthCheckResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchHealthCheck> => {
  const contents: NoSuchHealthCheck = {
    name: "NoSuchHealthCheck",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchHostedZoneResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchHostedZone> => {
  const contents: NoSuchHostedZone = {
    name: "NoSuchHostedZone",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchQueryLoggingConfigResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchQueryLoggingConfig> => {
  const contents: NoSuchQueryLoggingConfig = {
    name: "NoSuchQueryLoggingConfig",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchTrafficPolicyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchTrafficPolicy> => {
  const contents: NoSuchTrafficPolicy = {
    name: "NoSuchTrafficPolicy",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchTrafficPolicyInstance> => {
  const contents: NoSuchTrafficPolicyInstance = {
    name: "NoSuchTrafficPolicyInstance",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlNotAuthorizedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NotAuthorizedException> => {
  const contents: NotAuthorizedException = {
    name: "NotAuthorizedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlPriorRequestNotCompleteResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PriorRequestNotComplete> => {
  const contents: PriorRequestNotComplete = {
    name: "PriorRequestNotComplete",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlPublicZoneVPCAssociationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PublicZoneVPCAssociation> => {
  const contents: PublicZoneVPCAssociation = {
    name: "PublicZoneVPCAssociation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlQueryLoggingConfigAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<QueryLoggingConfigAlreadyExists> => {
  const contents: QueryLoggingConfigAlreadyExists = {
    name: "QueryLoggingConfigAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlThrottlingExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ThrottlingException> => {
  const contents: ThrottlingException = {
    name: "ThrottlingException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyHealthChecksResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyHealthChecks> => {
  const contents: TooManyHealthChecks = {
    name: "TooManyHealthChecks",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyHostedZonesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyHostedZones> => {
  const contents: TooManyHostedZones = {
    name: "TooManyHostedZones",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyTrafficPoliciesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTrafficPolicies> => {
  const contents: TooManyTrafficPolicies = {
    name: "TooManyTrafficPolicies",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyTrafficPolicyInstancesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTrafficPolicyInstances> => {
  const contents: TooManyTrafficPolicyInstances = {
    name: "TooManyTrafficPolicyInstances",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyTrafficPolicyVersionsForCurrentPolicyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTrafficPolicyVersionsForCurrentPolicy> => {
  const contents: TooManyTrafficPolicyVersionsForCurrentPolicy = {
    name: "TooManyTrafficPolicyVersionsForCurrentPolicy",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlTooManyVPCAssociationAuthorizationsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyVPCAssociationAuthorizations> => {
  const contents: TooManyVPCAssociationAuthorizations = {
    name: "TooManyVPCAssociationAuthorizations",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlTrafficPolicyAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TrafficPolicyAlreadyExists> => {
  const contents: TrafficPolicyAlreadyExists = {
    name: "TrafficPolicyAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlTrafficPolicyInstanceAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TrafficPolicyInstanceAlreadyExists> => {
  const contents: TrafficPolicyInstanceAlreadyExists = {
    name: "TrafficPolicyInstanceAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlTrafficPolicyInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TrafficPolicyInUse> => {
  const contents: TrafficPolicyInUse = {
    name: "TrafficPolicyInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlVPCAssociationAuthorizationNotFoundResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<VPCAssociationAuthorizationNotFound> => {
  const contents: VPCAssociationAuthorizationNotFound = {
    name: "VPCAssociationAuthorizationNotFound",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const deserializeAws_restXmlVPCAssociationNotFoundResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<VPCAssociationNotFound> => {
  const contents: VPCAssociationNotFound = {
    name: "VPCAssociationNotFound",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  if (data["message"] !== undefined) {
    contents.message = data["message"];
  }
  return contents;
};

const serializeAws_restXmlAlarmIdentifier = (
  input: AlarmIdentifier,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AlarmIdentifier");
  if (input.Name !== undefined) {
    const node = new __XmlNode("AlarmName")
      .addChildNode(new __XmlText(input.Name))
      .withName("Name");
    bodyNode.addChildNode(node);
  }
  if (input.Region !== undefined) {
    const node = new __XmlNode("CloudWatchRegion")
      .addChildNode(new __XmlText(input.Region))
      .withName("Region");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlAliasTarget = (
  input: AliasTarget,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AliasTarget");
  if (input.DNSName !== undefined) {
    const node = new __XmlNode("DNSName")
      .addChildNode(new __XmlText(input.DNSName))
      .withName("DNSName");
    bodyNode.addChildNode(node);
  }
  if (input.EvaluateTargetHealth !== undefined) {
    const node = new __XmlNode("AliasHealthEnabled")
      .addChildNode(new __XmlText(String(input.EvaluateTargetHealth)))
      .withName("EvaluateTargetHealth");
    bodyNode.addChildNode(node);
  }
  if (input.HostedZoneId !== undefined) {
    const node = new __XmlNode("ResourceId")
      .addChildNode(new __XmlText(input.HostedZoneId))
      .withName("HostedZoneId");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlChange = (
  input: Change,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Change");
  if (input.Action !== undefined) {
    const node = new __XmlNode("ChangeAction")
      .addChildNode(new __XmlText(input.Action))
      .withName("Action");
    bodyNode.addChildNode(node);
  }
  if (input.ResourceRecordSet !== undefined) {
    const node = serializeAws_restXmlResourceRecordSet(
      input.ResourceRecordSet,
      context
    ).withName("ResourceRecordSet");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlChangeBatch = (
  input: ChangeBatch,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ChangeBatch");
  if (input.Changes !== undefined) {
    const nodes = serializeAws_restXmlChanges(input.Changes, context);
    const containerNode = new __XmlNode("Changes");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Comment !== undefined) {
    const node = new __XmlNode("ResourceDescription")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlChanges = (
  input: Change[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlChange(entry, context);
    return node.withName("Change");
  });
};

const serializeAws_restXmlChildHealthCheckList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("HealthCheckId").addChildNode(
      new __XmlText(entry)
    );
    return node.withName("ChildHealthCheck");
  });
};

const serializeAws_restXmlGeoLocation = (
  input: GeoLocation,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("GeoLocation");
  if (input.ContinentCode !== undefined) {
    const node = new __XmlNode("GeoLocationContinentCode")
      .addChildNode(new __XmlText(input.ContinentCode))
      .withName("ContinentCode");
    bodyNode.addChildNode(node);
  }
  if (input.CountryCode !== undefined) {
    const node = new __XmlNode("GeoLocationCountryCode")
      .addChildNode(new __XmlText(input.CountryCode))
      .withName("CountryCode");
    bodyNode.addChildNode(node);
  }
  if (input.SubdivisionCode !== undefined) {
    const node = new __XmlNode("GeoLocationSubdivisionCode")
      .addChildNode(new __XmlText(input.SubdivisionCode))
      .withName("SubdivisionCode");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlHealthCheckConfig = (
  input: HealthCheckConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("HealthCheckConfig");
  if (input.AlarmIdentifier !== undefined) {
    const node = serializeAws_restXmlAlarmIdentifier(
      input.AlarmIdentifier,
      context
    ).withName("AlarmIdentifier");
    bodyNode.addChildNode(node);
  }
  if (input.ChildHealthChecks !== undefined) {
    const nodes = serializeAws_restXmlChildHealthCheckList(
      input.ChildHealthChecks,
      context
    );
    const containerNode = new __XmlNode("ChildHealthChecks");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Disabled !== undefined) {
    const node = new __XmlNode("Disabled")
      .addChildNode(new __XmlText(String(input.Disabled)))
      .withName("Disabled");
    bodyNode.addChildNode(node);
  }
  if (input.EnableSNI !== undefined) {
    const node = new __XmlNode("EnableSNI")
      .addChildNode(new __XmlText(String(input.EnableSNI)))
      .withName("EnableSNI");
    bodyNode.addChildNode(node);
  }
  if (input.FailureThreshold !== undefined) {
    const node = new __XmlNode("FailureThreshold")
      .addChildNode(new __XmlText(String(input.FailureThreshold)))
      .withName("FailureThreshold");
    bodyNode.addChildNode(node);
  }
  if (input.FullyQualifiedDomainName !== undefined) {
    const node = new __XmlNode("FullyQualifiedDomainName")
      .addChildNode(new __XmlText(input.FullyQualifiedDomainName))
      .withName("FullyQualifiedDomainName");
    bodyNode.addChildNode(node);
  }
  if (input.HealthThreshold !== undefined) {
    const node = new __XmlNode("HealthThreshold")
      .addChildNode(new __XmlText(String(input.HealthThreshold)))
      .withName("HealthThreshold");
    bodyNode.addChildNode(node);
  }
  if (input.IPAddress !== undefined) {
    const node = new __XmlNode("IPAddress")
      .addChildNode(new __XmlText(input.IPAddress))
      .withName("IPAddress");
    bodyNode.addChildNode(node);
  }
  if (input.InsufficientDataHealthStatus !== undefined) {
    const node = new __XmlNode("InsufficientDataHealthStatus")
      .addChildNode(new __XmlText(input.InsufficientDataHealthStatus))
      .withName("InsufficientDataHealthStatus");
    bodyNode.addChildNode(node);
  }
  if (input.Inverted !== undefined) {
    const node = new __XmlNode("Inverted")
      .addChildNode(new __XmlText(String(input.Inverted)))
      .withName("Inverted");
    bodyNode.addChildNode(node);
  }
  if (input.MeasureLatency !== undefined) {
    const node = new __XmlNode("MeasureLatency")
      .addChildNode(new __XmlText(String(input.MeasureLatency)))
      .withName("MeasureLatency");
    bodyNode.addChildNode(node);
  }
  if (input.Port !== undefined) {
    const node = new __XmlNode("Port")
      .addChildNode(new __XmlText(String(input.Port)))
      .withName("Port");
    bodyNode.addChildNode(node);
  }
  if (input.Regions !== undefined) {
    const nodes = serializeAws_restXmlHealthCheckRegionList(
      input.Regions,
      context
    );
    const containerNode = new __XmlNode("Regions");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.RequestInterval !== undefined) {
    const node = new __XmlNode("RequestInterval")
      .addChildNode(new __XmlText(String(input.RequestInterval)))
      .withName("RequestInterval");
    bodyNode.addChildNode(node);
  }
  if (input.ResourcePath !== undefined) {
    const node = new __XmlNode("ResourcePath")
      .addChildNode(new __XmlText(input.ResourcePath))
      .withName("ResourcePath");
    bodyNode.addChildNode(node);
  }
  if (input.SearchString !== undefined) {
    const node = new __XmlNode("SearchString")
      .addChildNode(new __XmlText(input.SearchString))
      .withName("SearchString");
    bodyNode.addChildNode(node);
  }
  if (input.Type !== undefined) {
    const node = new __XmlNode("HealthCheckType")
      .addChildNode(new __XmlText(input.Type))
      .withName("Type");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlHealthCheckRegionList = (
  input: (HealthCheckRegion | string)[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("HealthCheckRegion").addChildNode(
      new __XmlText(entry)
    );
    return node.withName("Region");
  });
};

const serializeAws_restXmlHostedZoneConfig = (
  input: HostedZoneConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("HostedZoneConfig");
  if (input.Comment !== undefined) {
    const node = new __XmlNode("ResourceDescription")
      .addChildNode(new __XmlText(input.Comment))
      .withName("Comment");
    bodyNode.addChildNode(node);
  }
  if (input.PrivateZone !== undefined) {
    const node = new __XmlNode("IsPrivateZone")
      .addChildNode(new __XmlText(String(input.PrivateZone)))
      .withName("PrivateZone");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlResettableElementNameList = (
  input: (ResettableElementName | string)[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("ResettableElementName").addChildNode(
      new __XmlText(entry)
    );
    return node.withName("ResettableElementName");
  });
};

const serializeAws_restXmlResourceRecord = (
  input: ResourceRecord,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ResourceRecord");
  if (input.Value !== undefined) {
    const node = new __XmlNode("RData")
      .addChildNode(new __XmlText(input.Value))
      .withName("Value");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlResourceRecords = (
  input: ResourceRecord[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlResourceRecord(entry, context);
    return node.withName("ResourceRecord");
  });
};

const serializeAws_restXmlResourceRecordSet = (
  input: ResourceRecordSet,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ResourceRecordSet");
  if (input.AliasTarget !== undefined) {
    const node = serializeAws_restXmlAliasTarget(
      input.AliasTarget,
      context
    ).withName("AliasTarget");
    bodyNode.addChildNode(node);
  }
  if (input.Failover !== undefined) {
    const node = new __XmlNode("ResourceRecordSetFailover")
      .addChildNode(new __XmlText(input.Failover))
      .withName("Failover");
    bodyNode.addChildNode(node);
  }
  if (input.GeoLocation !== undefined) {
    const node = serializeAws_restXmlGeoLocation(
      input.GeoLocation,
      context
    ).withName("GeoLocation");
    bodyNode.addChildNode(node);
  }
  if (input.HealthCheckId !== undefined) {
    const node = new __XmlNode("HealthCheckId")
      .addChildNode(new __XmlText(input.HealthCheckId))
      .withName("HealthCheckId");
    bodyNode.addChildNode(node);
  }
  if (input.MultiValueAnswer !== undefined) {
    const node = new __XmlNode("ResourceRecordSetMultiValueAnswer")
      .addChildNode(new __XmlText(String(input.MultiValueAnswer)))
      .withName("MultiValueAnswer");
    bodyNode.addChildNode(node);
  }
  if (input.Name !== undefined) {
    const node = new __XmlNode("DNSName")
      .addChildNode(new __XmlText(input.Name))
      .withName("Name");
    bodyNode.addChildNode(node);
  }
  if (input.Region !== undefined) {
    const node = new __XmlNode("ResourceRecordSetRegion")
      .addChildNode(new __XmlText(input.Region))
      .withName("Region");
    bodyNode.addChildNode(node);
  }
  if (input.ResourceRecords !== undefined) {
    const nodes = serializeAws_restXmlResourceRecords(
      input.ResourceRecords,
      context
    );
    const containerNode = new __XmlNode("ResourceRecords");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.SetIdentifier !== undefined) {
    const node = new __XmlNode("ResourceRecordSetIdentifier")
      .addChildNode(new __XmlText(input.SetIdentifier))
      .withName("SetIdentifier");
    bodyNode.addChildNode(node);
  }
  if (input.TTL !== undefined) {
    const node = new __XmlNode("TTL")
      .addChildNode(new __XmlText(String(input.TTL)))
      .withName("TTL");
    bodyNode.addChildNode(node);
  }
  if (input.TrafficPolicyInstanceId !== undefined) {
    const node = new __XmlNode("TrafficPolicyInstanceId")
      .addChildNode(new __XmlText(input.TrafficPolicyInstanceId))
      .withName("TrafficPolicyInstanceId");
    bodyNode.addChildNode(node);
  }
  if (input.Type !== undefined) {
    const node = new __XmlNode("RRType")
      .addChildNode(new __XmlText(input.Type))
      .withName("Type");
    bodyNode.addChildNode(node);
  }
  if (input.Weight !== undefined) {
    const node = new __XmlNode("ResourceRecordSetWeight")
      .addChildNode(new __XmlText(String(input.Weight)))
      .withName("Weight");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlTag = (input: Tag, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Tag");
  if (input.Key !== undefined) {
    const node = new __XmlNode("TagKey")
      .addChildNode(new __XmlText(input.Key))
      .withName("Key");
    bodyNode.addChildNode(node);
  }
  if (input.Value !== undefined) {
    const node = new __XmlNode("TagValue")
      .addChildNode(new __XmlText(input.Value))
      .withName("Value");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const serializeAws_restXmlTagKeyList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("TagKey").addChildNode(new __XmlText(entry));
    return node.withName("Key");
  });
};

const serializeAws_restXmlTagList = (
  input: Tag[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = serializeAws_restXmlTag(entry, context);
    return node.withName("Tag");
  });
};

const serializeAws_restXmlTagResourceIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => {
    const node = new __XmlNode("TagResourceId").addChildNode(
      new __XmlText(entry)
    );
    return node.withName("ResourceId");
  });
};

const serializeAws_restXmlVPC = (input: VPC, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("VPC");
  if (input.VPCId !== undefined) {
    const node = new __XmlNode("VPCId")
      .addChildNode(new __XmlText(input.VPCId))
      .withName("VPCId");
    bodyNode.addChildNode(node);
  }
  if (input.VPCRegion !== undefined) {
    const node = new __XmlNode("VPCRegion")
      .addChildNode(new __XmlText(input.VPCRegion))
      .withName("VPCRegion");
    bodyNode.addChildNode(node);
  }
  return bodyNode;
};

const deserializeAws_restXmlAccountLimit = (
  output: any,
  context: __SerdeContext
): AccountLimit => {
  let contents: any = {
    __type: "AccountLimit",
    Type: undefined,
    Value: undefined
  };
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = parseInt(output["Value"]);
  }
  return contents;
};

const deserializeAws_restXmlAlarmIdentifier = (
  output: any,
  context: __SerdeContext
): AlarmIdentifier => {
  let contents: any = {
    __type: "AlarmIdentifier",
    Name: undefined,
    Region: undefined
  };
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["Region"] !== undefined) {
    contents.Region = output["Region"];
  }
  return contents;
};

const deserializeAws_restXmlAliasTarget = (
  output: any,
  context: __SerdeContext
): AliasTarget => {
  let contents: any = {
    __type: "AliasTarget",
    DNSName: undefined,
    EvaluateTargetHealth: undefined,
    HostedZoneId: undefined
  };
  if (output["DNSName"] !== undefined) {
    contents.DNSName = output["DNSName"];
  }
  if (output["EvaluateTargetHealth"] !== undefined) {
    contents.EvaluateTargetHealth = output["EvaluateTargetHealth"] == "true";
  }
  if (output["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = output["HostedZoneId"];
  }
  return contents;
};

const deserializeAws_restXmlChangeInfo = (
  output: any,
  context: __SerdeContext
): ChangeInfo => {
  let contents: any = {
    __type: "ChangeInfo",
    Comment: undefined,
    Id: undefined,
    Status: undefined,
    SubmittedAt: undefined
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["SubmittedAt"] !== undefined) {
    contents.SubmittedAt = new Date(output["SubmittedAt"]);
  }
  return contents;
};

const deserializeAws_restXmlCheckerIpRanges = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlChildHealthCheckList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlCloudWatchAlarmConfiguration = (
  output: any,
  context: __SerdeContext
): CloudWatchAlarmConfiguration => {
  let contents: any = {
    __type: "CloudWatchAlarmConfiguration",
    ComparisonOperator: undefined,
    Dimensions: undefined,
    EvaluationPeriods: undefined,
    MetricName: undefined,
    Namespace: undefined,
    Period: undefined,
    Statistic: undefined,
    Threshold: undefined
  };
  if (output["ComparisonOperator"] !== undefined) {
    contents.ComparisonOperator = output["ComparisonOperator"];
  }
  if (output.Dimensions === "") {
    contents.Dimensions = [];
  }
  if (
    output["Dimensions"] !== undefined &&
    output["Dimensions"]["Dimension"] !== undefined
  ) {
    contents.Dimensions = deserializeAws_restXmlDimensionList(
      __getArrayIfSingleItem(output["Dimensions"]["Dimension"]),
      context
    );
  }
  if (output["EvaluationPeriods"] !== undefined) {
    contents.EvaluationPeriods = parseInt(output["EvaluationPeriods"]);
  }
  if (output["MetricName"] !== undefined) {
    contents.MetricName = output["MetricName"];
  }
  if (output["Namespace"] !== undefined) {
    contents.Namespace = output["Namespace"];
  }
  if (output["Period"] !== undefined) {
    contents.Period = parseInt(output["Period"]);
  }
  if (output["Statistic"] !== undefined) {
    contents.Statistic = output["Statistic"];
  }
  if (output["Threshold"] !== undefined) {
    contents.Threshold = parseFloat(output["Threshold"]);
  }
  return contents;
};

const deserializeAws_restXmlDelegationSet = (
  output: any,
  context: __SerdeContext
): DelegationSet => {
  let contents: any = {
    __type: "DelegationSet",
    CallerReference: undefined,
    Id: undefined,
    NameServers: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output.NameServers === "") {
    contents.NameServers = [];
  }
  if (
    output["NameServers"] !== undefined &&
    output["NameServers"]["NameServer"] !== undefined
  ) {
    contents.NameServers = deserializeAws_restXmlDelegationSetNameServers(
      __getArrayIfSingleItem(output["NameServers"]["NameServer"]),
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlDelegationSetNameServers = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlDelegationSets = (
  output: any,
  context: __SerdeContext
): DelegationSet[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlDelegationSet(entry, context)
  );
};

const deserializeAws_restXmlDimension = (
  output: any,
  context: __SerdeContext
): Dimension => {
  let contents: any = {
    __type: "Dimension",
    Name: undefined,
    Value: undefined
  };
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_restXmlDimensionList = (
  output: any,
  context: __SerdeContext
): Dimension[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlDimension(entry, context)
  );
};

const deserializeAws_restXmlErrorMessages = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlGeoLocation = (
  output: any,
  context: __SerdeContext
): GeoLocation => {
  let contents: any = {
    __type: "GeoLocation",
    ContinentCode: undefined,
    CountryCode: undefined,
    SubdivisionCode: undefined
  };
  if (output["ContinentCode"] !== undefined) {
    contents.ContinentCode = output["ContinentCode"];
  }
  if (output["CountryCode"] !== undefined) {
    contents.CountryCode = output["CountryCode"];
  }
  if (output["SubdivisionCode"] !== undefined) {
    contents.SubdivisionCode = output["SubdivisionCode"];
  }
  return contents;
};

const deserializeAws_restXmlGeoLocationDetails = (
  output: any,
  context: __SerdeContext
): GeoLocationDetails => {
  let contents: any = {
    __type: "GeoLocationDetails",
    ContinentCode: undefined,
    ContinentName: undefined,
    CountryCode: undefined,
    CountryName: undefined,
    SubdivisionCode: undefined,
    SubdivisionName: undefined
  };
  if (output["ContinentCode"] !== undefined) {
    contents.ContinentCode = output["ContinentCode"];
  }
  if (output["ContinentName"] !== undefined) {
    contents.ContinentName = output["ContinentName"];
  }
  if (output["CountryCode"] !== undefined) {
    contents.CountryCode = output["CountryCode"];
  }
  if (output["CountryName"] !== undefined) {
    contents.CountryName = output["CountryName"];
  }
  if (output["SubdivisionCode"] !== undefined) {
    contents.SubdivisionCode = output["SubdivisionCode"];
  }
  if (output["SubdivisionName"] !== undefined) {
    contents.SubdivisionName = output["SubdivisionName"];
  }
  return contents;
};

const deserializeAws_restXmlGeoLocationDetailsList = (
  output: any,
  context: __SerdeContext
): GeoLocationDetails[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlGeoLocationDetails(entry, context)
  );
};

const deserializeAws_restXmlHealthCheck = (
  output: any,
  context: __SerdeContext
): HealthCheck => {
  let contents: any = {
    __type: "HealthCheck",
    CallerReference: undefined,
    CloudWatchAlarmConfiguration: undefined,
    HealthCheckConfig: undefined,
    HealthCheckVersion: undefined,
    Id: undefined,
    LinkedService: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["CloudWatchAlarmConfiguration"] !== undefined) {
    contents.CloudWatchAlarmConfiguration = deserializeAws_restXmlCloudWatchAlarmConfiguration(
      output["CloudWatchAlarmConfiguration"],
      context
    );
  }
  if (output["HealthCheckConfig"] !== undefined) {
    contents.HealthCheckConfig = deserializeAws_restXmlHealthCheckConfig(
      output["HealthCheckConfig"],
      context
    );
  }
  if (output["HealthCheckVersion"] !== undefined) {
    contents.HealthCheckVersion = parseInt(output["HealthCheckVersion"]);
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LinkedService"] !== undefined) {
    contents.LinkedService = deserializeAws_restXmlLinkedService(
      output["LinkedService"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlHealthCheckConfig = (
  output: any,
  context: __SerdeContext
): HealthCheckConfig => {
  let contents: any = {
    __type: "HealthCheckConfig",
    AlarmIdentifier: undefined,
    ChildHealthChecks: undefined,
    Disabled: undefined,
    EnableSNI: undefined,
    FailureThreshold: undefined,
    FullyQualifiedDomainName: undefined,
    HealthThreshold: undefined,
    IPAddress: undefined,
    InsufficientDataHealthStatus: undefined,
    Inverted: undefined,
    MeasureLatency: undefined,
    Port: undefined,
    Regions: undefined,
    RequestInterval: undefined,
    ResourcePath: undefined,
    SearchString: undefined,
    Type: undefined
  };
  if (output["AlarmIdentifier"] !== undefined) {
    contents.AlarmIdentifier = deserializeAws_restXmlAlarmIdentifier(
      output["AlarmIdentifier"],
      context
    );
  }
  if (output.ChildHealthChecks === "") {
    contents.ChildHealthChecks = [];
  }
  if (
    output["ChildHealthChecks"] !== undefined &&
    output["ChildHealthChecks"]["ChildHealthCheck"] !== undefined
  ) {
    contents.ChildHealthChecks = deserializeAws_restXmlChildHealthCheckList(
      __getArrayIfSingleItem(output["ChildHealthChecks"]["ChildHealthCheck"]),
      context
    );
  }
  if (output["Disabled"] !== undefined) {
    contents.Disabled = output["Disabled"] == "true";
  }
  if (output["EnableSNI"] !== undefined) {
    contents.EnableSNI = output["EnableSNI"] == "true";
  }
  if (output["FailureThreshold"] !== undefined) {
    contents.FailureThreshold = parseInt(output["FailureThreshold"]);
  }
  if (output["FullyQualifiedDomainName"] !== undefined) {
    contents.FullyQualifiedDomainName = output["FullyQualifiedDomainName"];
  }
  if (output["HealthThreshold"] !== undefined) {
    contents.HealthThreshold = parseInt(output["HealthThreshold"]);
  }
  if (output["IPAddress"] !== undefined) {
    contents.IPAddress = output["IPAddress"];
  }
  if (output["InsufficientDataHealthStatus"] !== undefined) {
    contents.InsufficientDataHealthStatus =
      output["InsufficientDataHealthStatus"];
  }
  if (output["Inverted"] !== undefined) {
    contents.Inverted = output["Inverted"] == "true";
  }
  if (output["MeasureLatency"] !== undefined) {
    contents.MeasureLatency = output["MeasureLatency"] == "true";
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(output["Port"]);
  }
  if (output.Regions === "") {
    contents.Regions = [];
  }
  if (
    output["Regions"] !== undefined &&
    output["Regions"]["Region"] !== undefined
  ) {
    contents.Regions = deserializeAws_restXmlHealthCheckRegionList(
      __getArrayIfSingleItem(output["Regions"]["Region"]),
      context
    );
  }
  if (output["RequestInterval"] !== undefined) {
    contents.RequestInterval = parseInt(output["RequestInterval"]);
  }
  if (output["ResourcePath"] !== undefined) {
    contents.ResourcePath = output["ResourcePath"];
  }
  if (output["SearchString"] !== undefined) {
    contents.SearchString = output["SearchString"];
  }
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  return contents;
};

const deserializeAws_restXmlHealthCheckObservation = (
  output: any,
  context: __SerdeContext
): HealthCheckObservation => {
  let contents: any = {
    __type: "HealthCheckObservation",
    IPAddress: undefined,
    Region: undefined,
    StatusReport: undefined
  };
  if (output["IPAddress"] !== undefined) {
    contents.IPAddress = output["IPAddress"];
  }
  if (output["Region"] !== undefined) {
    contents.Region = output["Region"];
  }
  if (output["StatusReport"] !== undefined) {
    contents.StatusReport = deserializeAws_restXmlStatusReport(
      output["StatusReport"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlHealthCheckObservations = (
  output: any,
  context: __SerdeContext
): HealthCheckObservation[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlHealthCheckObservation(entry, context)
  );
};

const deserializeAws_restXmlHealthCheckRegionList = (
  output: any,
  context: __SerdeContext
): (HealthCheckRegion | string)[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlHealthChecks = (
  output: any,
  context: __SerdeContext
): HealthCheck[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlHealthCheck(entry, context)
  );
};

const deserializeAws_restXmlHostedZone = (
  output: any,
  context: __SerdeContext
): HostedZone => {
  let contents: any = {
    __type: "HostedZone",
    CallerReference: undefined,
    Config: undefined,
    Id: undefined,
    LinkedService: undefined,
    Name: undefined,
    ResourceRecordSetCount: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Config"] !== undefined) {
    contents.Config = deserializeAws_restXmlHostedZoneConfig(
      output["Config"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LinkedService"] !== undefined) {
    contents.LinkedService = deserializeAws_restXmlLinkedService(
      output["LinkedService"],
      context
    );
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["ResourceRecordSetCount"] !== undefined) {
    contents.ResourceRecordSetCount = parseInt(
      output["ResourceRecordSetCount"]
    );
  }
  return contents;
};

const deserializeAws_restXmlHostedZoneConfig = (
  output: any,
  context: __SerdeContext
): HostedZoneConfig => {
  let contents: any = {
    __type: "HostedZoneConfig",
    Comment: undefined,
    PrivateZone: undefined
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["PrivateZone"] !== undefined) {
    contents.PrivateZone = output["PrivateZone"] == "true";
  }
  return contents;
};

const deserializeAws_restXmlHostedZoneLimit = (
  output: any,
  context: __SerdeContext
): HostedZoneLimit => {
  let contents: any = {
    __type: "HostedZoneLimit",
    Type: undefined,
    Value: undefined
  };
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = parseInt(output["Value"]);
  }
  return contents;
};

const deserializeAws_restXmlHostedZones = (
  output: any,
  context: __SerdeContext
): HostedZone[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlHostedZone(entry, context)
  );
};

const deserializeAws_restXmlLinkedService = (
  output: any,
  context: __SerdeContext
): LinkedService => {
  let contents: any = {
    __type: "LinkedService",
    Description: undefined,
    ServicePrincipal: undefined
  };
  if (output["Description"] !== undefined) {
    contents.Description = output["Description"];
  }
  if (output["ServicePrincipal"] !== undefined) {
    contents.ServicePrincipal = output["ServicePrincipal"];
  }
  return contents;
};

const deserializeAws_restXmlQueryLoggingConfig = (
  output: any,
  context: __SerdeContext
): QueryLoggingConfig => {
  let contents: any = {
    __type: "QueryLoggingConfig",
    CloudWatchLogsLogGroupArn: undefined,
    HostedZoneId: undefined,
    Id: undefined
  };
  if (output["CloudWatchLogsLogGroupArn"] !== undefined) {
    contents.CloudWatchLogsLogGroupArn = output["CloudWatchLogsLogGroupArn"];
  }
  if (output["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = output["HostedZoneId"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  return contents;
};

const deserializeAws_restXmlQueryLoggingConfigs = (
  output: any,
  context: __SerdeContext
): QueryLoggingConfig[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlQueryLoggingConfig(entry, context)
  );
};

const deserializeAws_restXmlRecordData = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlResourceRecord = (
  output: any,
  context: __SerdeContext
): ResourceRecord => {
  let contents: any = {
    __type: "ResourceRecord",
    Value: undefined
  };
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_restXmlResourceRecords = (
  output: any,
  context: __SerdeContext
): ResourceRecord[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlResourceRecord(entry, context)
  );
};

const deserializeAws_restXmlResourceRecordSet = (
  output: any,
  context: __SerdeContext
): ResourceRecordSet => {
  let contents: any = {
    __type: "ResourceRecordSet",
    AliasTarget: undefined,
    Failover: undefined,
    GeoLocation: undefined,
    HealthCheckId: undefined,
    MultiValueAnswer: undefined,
    Name: undefined,
    Region: undefined,
    ResourceRecords: undefined,
    SetIdentifier: undefined,
    TTL: undefined,
    TrafficPolicyInstanceId: undefined,
    Type: undefined,
    Weight: undefined
  };
  if (output["AliasTarget"] !== undefined) {
    contents.AliasTarget = deserializeAws_restXmlAliasTarget(
      output["AliasTarget"],
      context
    );
  }
  if (output["Failover"] !== undefined) {
    contents.Failover = output["Failover"];
  }
  if (output["GeoLocation"] !== undefined) {
    contents.GeoLocation = deserializeAws_restXmlGeoLocation(
      output["GeoLocation"],
      context
    );
  }
  if (output["HealthCheckId"] !== undefined) {
    contents.HealthCheckId = output["HealthCheckId"];
  }
  if (output["MultiValueAnswer"] !== undefined) {
    contents.MultiValueAnswer = output["MultiValueAnswer"] == "true";
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["Region"] !== undefined) {
    contents.Region = output["Region"];
  }
  if (output.ResourceRecords === "") {
    contents.ResourceRecords = [];
  }
  if (
    output["ResourceRecords"] !== undefined &&
    output["ResourceRecords"]["ResourceRecord"] !== undefined
  ) {
    contents.ResourceRecords = deserializeAws_restXmlResourceRecords(
      __getArrayIfSingleItem(output["ResourceRecords"]["ResourceRecord"]),
      context
    );
  }
  if (output["SetIdentifier"] !== undefined) {
    contents.SetIdentifier = output["SetIdentifier"];
  }
  if (output["TTL"] !== undefined) {
    contents.TTL = parseInt(output["TTL"]);
  }
  if (output["TrafficPolicyInstanceId"] !== undefined) {
    contents.TrafficPolicyInstanceId = output["TrafficPolicyInstanceId"];
  }
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  if (output["Weight"] !== undefined) {
    contents.Weight = parseInt(output["Weight"]);
  }
  return contents;
};

const deserializeAws_restXmlResourceRecordSets = (
  output: any,
  context: __SerdeContext
): ResourceRecordSet[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlResourceRecordSet(entry, context)
  );
};

const deserializeAws_restXmlResourceTagSet = (
  output: any,
  context: __SerdeContext
): ResourceTagSet => {
  let contents: any = {
    __type: "ResourceTagSet",
    ResourceId: undefined,
    ResourceType: undefined,
    Tags: undefined
  };
  if (output["ResourceId"] !== undefined) {
    contents.ResourceId = output["ResourceId"];
  }
  if (output["ResourceType"] !== undefined) {
    contents.ResourceType = output["ResourceType"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    contents.Tags = deserializeAws_restXmlTagList(
      __getArrayIfSingleItem(output["Tags"]["Tag"]),
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlResourceTagSetList = (
  output: any,
  context: __SerdeContext
): ResourceTagSet[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlResourceTagSet(entry, context)
  );
};

const deserializeAws_restXmlReusableDelegationSetLimit = (
  output: any,
  context: __SerdeContext
): ReusableDelegationSetLimit => {
  let contents: any = {
    __type: "ReusableDelegationSetLimit",
    Type: undefined,
    Value: undefined
  };
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = parseInt(output["Value"]);
  }
  return contents;
};

const deserializeAws_restXmlStatusReport = (
  output: any,
  context: __SerdeContext
): StatusReport => {
  let contents: any = {
    __type: "StatusReport",
    CheckedTime: undefined,
    Status: undefined
  };
  if (output["CheckedTime"] !== undefined) {
    contents.CheckedTime = new Date(output["CheckedTime"]);
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlTag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_restXmlTagList = (
  output: any,
  context: __SerdeContext
): Tag[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlTag(entry, context)
  );
};

const deserializeAws_restXmlTrafficPolicies = (
  output: any,
  context: __SerdeContext
): TrafficPolicy[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlTrafficPolicy(entry, context)
  );
};

const deserializeAws_restXmlTrafficPolicy = (
  output: any,
  context: __SerdeContext
): TrafficPolicy => {
  let contents: any = {
    __type: "TrafficPolicy",
    Comment: undefined,
    Document: undefined,
    Id: undefined,
    Name: undefined,
    Type: undefined,
    Version: undefined
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["Document"] !== undefined) {
    contents.Document = output["Document"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  if (output["Version"] !== undefined) {
    contents.Version = parseInt(output["Version"]);
  }
  return contents;
};

const deserializeAws_restXmlTrafficPolicyInstance = (
  output: any,
  context: __SerdeContext
): TrafficPolicyInstance => {
  let contents: any = {
    __type: "TrafficPolicyInstance",
    HostedZoneId: undefined,
    Id: undefined,
    Message: undefined,
    Name: undefined,
    State: undefined,
    TTL: undefined,
    TrafficPolicyId: undefined,
    TrafficPolicyType: undefined,
    TrafficPolicyVersion: undefined
  };
  if (output["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = output["HostedZoneId"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Message"] !== undefined) {
    contents.Message = output["Message"];
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["State"] !== undefined) {
    contents.State = output["State"];
  }
  if (output["TTL"] !== undefined) {
    contents.TTL = parseInt(output["TTL"]);
  }
  if (output["TrafficPolicyId"] !== undefined) {
    contents.TrafficPolicyId = output["TrafficPolicyId"];
  }
  if (output["TrafficPolicyType"] !== undefined) {
    contents.TrafficPolicyType = output["TrafficPolicyType"];
  }
  if (output["TrafficPolicyVersion"] !== undefined) {
    contents.TrafficPolicyVersion = parseInt(output["TrafficPolicyVersion"]);
  }
  return contents;
};

const deserializeAws_restXmlTrafficPolicyInstances = (
  output: any,
  context: __SerdeContext
): TrafficPolicyInstance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlTrafficPolicyInstance(entry, context)
  );
};

const deserializeAws_restXmlTrafficPolicySummaries = (
  output: any,
  context: __SerdeContext
): TrafficPolicySummary[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlTrafficPolicySummary(entry, context)
  );
};

const deserializeAws_restXmlTrafficPolicySummary = (
  output: any,
  context: __SerdeContext
): TrafficPolicySummary => {
  let contents: any = {
    __type: "TrafficPolicySummary",
    Id: undefined,
    LatestVersion: undefined,
    Name: undefined,
    TrafficPolicyCount: undefined,
    Type: undefined
  };
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LatestVersion"] !== undefined) {
    contents.LatestVersion = parseInt(output["LatestVersion"]);
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["TrafficPolicyCount"] !== undefined) {
    contents.TrafficPolicyCount = parseInt(output["TrafficPolicyCount"]);
  }
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  return contents;
};

const deserializeAws_restXmlVPC = (
  output: any,
  context: __SerdeContext
): VPC => {
  let contents: any = {
    __type: "VPC",
    VPCId: undefined,
    VPCRegion: undefined
  };
  if (output["VPCId"] !== undefined) {
    contents.VPCId = output["VPCId"];
  }
  if (output["VPCRegion"] !== undefined) {
    contents.VPCRegion = output["VPCRegion"];
  }
  return contents;
};

const deserializeAws_restXmlVPCs = (
  output: any,
  context: __SerdeContext
): VPC[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlVPC(entry, context)
  );
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any = new Uint8Array(),
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> =>
  collectBody(streamBody, context).then(body => context.utf8Encoder(body));

const isSerializableHeaderValue = (value: any): boolean =>
  value !== undefined &&
  value !== "" &&
  (!Object.getOwnPropertyNames(value).includes("length") ||
    value.length != 0) &&
  (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);

const decodeEscapedXML = (str: string) =>
  str
    .replace(/&amp;/g, "&")
    .replace(/&apos;/g, "'")
    .replace(/&quot;/g, '"')
    .replace(/&gt;/g, ">")
    .replace(/&lt;/g, "<");

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      const parsedObj = xmlParse(encoded, {
        attributeNamePrefix: "",
        ignoreAttributes: false,
        parseNodeValue: false,
        tagValueProcessor: (val, tagName) => decodeEscapedXML(val)
      });
      const textNodeName = "#text";
      const key = Object.keys(parsedObj)[0];
      const parsedObjToReturn = parsedObj[key];
      if (parsedObjToReturn[textNodeName]) {
        parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
        delete parsedObjToReturn[textNodeName];
      }
      return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
  });

const loadRestXmlErrorCode = (output: __HttpResponse, data: any): string => {
  if (data.Error.Code !== undefined) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
  return "";
};
