import {
  AssociateVPCWithHostedZoneCommandInput,
  AssociateVPCWithHostedZoneCommandOutput
} from "../commands/AssociateVPCWithHostedZoneCommand";
import {
  ChangeResourceRecordSetsCommandInput,
  ChangeResourceRecordSetsCommandOutput
} from "../commands/ChangeResourceRecordSetsCommand";
import {
  ChangeTagsForResourceCommandInput,
  ChangeTagsForResourceCommandOutput
} from "../commands/ChangeTagsForResourceCommand";
import {
  CreateHealthCheckCommandInput,
  CreateHealthCheckCommandOutput
} from "../commands/CreateHealthCheckCommand";
import {
  CreateHostedZoneCommandInput,
  CreateHostedZoneCommandOutput
} from "../commands/CreateHostedZoneCommand";
import {
  CreateQueryLoggingConfigCommandInput,
  CreateQueryLoggingConfigCommandOutput
} from "../commands/CreateQueryLoggingConfigCommand";
import {
  CreateReusableDelegationSetCommandInput,
  CreateReusableDelegationSetCommandOutput
} from "../commands/CreateReusableDelegationSetCommand";
import {
  CreateTrafficPolicyCommandInput,
  CreateTrafficPolicyCommandOutput
} from "../commands/CreateTrafficPolicyCommand";
import {
  CreateTrafficPolicyInstanceCommandInput,
  CreateTrafficPolicyInstanceCommandOutput
} from "../commands/CreateTrafficPolicyInstanceCommand";
import {
  CreateTrafficPolicyVersionCommandInput,
  CreateTrafficPolicyVersionCommandOutput
} from "../commands/CreateTrafficPolicyVersionCommand";
import {
  CreateVPCAssociationAuthorizationCommandInput,
  CreateVPCAssociationAuthorizationCommandOutput
} from "../commands/CreateVPCAssociationAuthorizationCommand";
import {
  DeleteHealthCheckCommandInput,
  DeleteHealthCheckCommandOutput
} from "../commands/DeleteHealthCheckCommand";
import {
  DeleteHostedZoneCommandInput,
  DeleteHostedZoneCommandOutput
} from "../commands/DeleteHostedZoneCommand";
import {
  DeleteQueryLoggingConfigCommandInput,
  DeleteQueryLoggingConfigCommandOutput
} from "../commands/DeleteQueryLoggingConfigCommand";
import {
  DeleteReusableDelegationSetCommandInput,
  DeleteReusableDelegationSetCommandOutput
} from "../commands/DeleteReusableDelegationSetCommand";
import {
  DeleteTrafficPolicyCommandInput,
  DeleteTrafficPolicyCommandOutput
} from "../commands/DeleteTrafficPolicyCommand";
import {
  DeleteTrafficPolicyInstanceCommandInput,
  DeleteTrafficPolicyInstanceCommandOutput
} from "../commands/DeleteTrafficPolicyInstanceCommand";
import {
  DeleteVPCAssociationAuthorizationCommandInput,
  DeleteVPCAssociationAuthorizationCommandOutput
} from "../commands/DeleteVPCAssociationAuthorizationCommand";
import {
  DisassociateVPCFromHostedZoneCommandInput,
  DisassociateVPCFromHostedZoneCommandOutput
} from "../commands/DisassociateVPCFromHostedZoneCommand";
import {
  GetAccountLimitCommandInput,
  GetAccountLimitCommandOutput
} from "../commands/GetAccountLimitCommand";
import {
  GetChangeCommandInput,
  GetChangeCommandOutput
} from "../commands/GetChangeCommand";
import {
  GetCheckerIpRangesCommandInput,
  GetCheckerIpRangesCommandOutput
} from "../commands/GetCheckerIpRangesCommand";
import {
  GetGeoLocationCommandInput,
  GetGeoLocationCommandOutput
} from "../commands/GetGeoLocationCommand";
import {
  GetHealthCheckCommandInput,
  GetHealthCheckCommandOutput
} from "../commands/GetHealthCheckCommand";
import {
  GetHealthCheckCountCommandInput,
  GetHealthCheckCountCommandOutput
} from "../commands/GetHealthCheckCountCommand";
import {
  GetHealthCheckLastFailureReasonCommandInput,
  GetHealthCheckLastFailureReasonCommandOutput
} from "../commands/GetHealthCheckLastFailureReasonCommand";
import {
  GetHealthCheckStatusCommandInput,
  GetHealthCheckStatusCommandOutput
} from "../commands/GetHealthCheckStatusCommand";
import {
  GetHostedZoneCommandInput,
  GetHostedZoneCommandOutput
} from "../commands/GetHostedZoneCommand";
import {
  GetHostedZoneCountCommandInput,
  GetHostedZoneCountCommandOutput
} from "../commands/GetHostedZoneCountCommand";
import {
  GetHostedZoneLimitCommandInput,
  GetHostedZoneLimitCommandOutput
} from "../commands/GetHostedZoneLimitCommand";
import {
  GetQueryLoggingConfigCommandInput,
  GetQueryLoggingConfigCommandOutput
} from "../commands/GetQueryLoggingConfigCommand";
import {
  GetReusableDelegationSetCommandInput,
  GetReusableDelegationSetCommandOutput
} from "../commands/GetReusableDelegationSetCommand";
import {
  GetReusableDelegationSetLimitCommandInput,
  GetReusableDelegationSetLimitCommandOutput
} from "../commands/GetReusableDelegationSetLimitCommand";
import {
  GetTrafficPolicyCommandInput,
  GetTrafficPolicyCommandOutput
} from "../commands/GetTrafficPolicyCommand";
import {
  GetTrafficPolicyInstanceCommandInput,
  GetTrafficPolicyInstanceCommandOutput
} from "../commands/GetTrafficPolicyInstanceCommand";
import {
  GetTrafficPolicyInstanceCountCommandInput,
  GetTrafficPolicyInstanceCountCommandOutput
} from "../commands/GetTrafficPolicyInstanceCountCommand";
import {
  ListGeoLocationsCommandInput,
  ListGeoLocationsCommandOutput
} from "../commands/ListGeoLocationsCommand";
import {
  ListHealthChecksCommandInput,
  ListHealthChecksCommandOutput
} from "../commands/ListHealthChecksCommand";
import {
  ListHostedZonesByNameCommandInput,
  ListHostedZonesByNameCommandOutput
} from "../commands/ListHostedZonesByNameCommand";
import {
  ListHostedZonesCommandInput,
  ListHostedZonesCommandOutput
} from "../commands/ListHostedZonesCommand";
import {
  ListQueryLoggingConfigsCommandInput,
  ListQueryLoggingConfigsCommandOutput
} from "../commands/ListQueryLoggingConfigsCommand";
import {
  ListResourceRecordSetsCommandInput,
  ListResourceRecordSetsCommandOutput
} from "../commands/ListResourceRecordSetsCommand";
import {
  ListReusableDelegationSetsCommandInput,
  ListReusableDelegationSetsCommandOutput
} from "../commands/ListReusableDelegationSetsCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ListTagsForResourcesCommandInput,
  ListTagsForResourcesCommandOutput
} from "../commands/ListTagsForResourcesCommand";
import {
  ListTrafficPoliciesCommandInput,
  ListTrafficPoliciesCommandOutput
} from "../commands/ListTrafficPoliciesCommand";
import {
  ListTrafficPolicyInstancesByHostedZoneCommandInput,
  ListTrafficPolicyInstancesByHostedZoneCommandOutput
} from "../commands/ListTrafficPolicyInstancesByHostedZoneCommand";
import {
  ListTrafficPolicyInstancesByPolicyCommandInput,
  ListTrafficPolicyInstancesByPolicyCommandOutput
} from "../commands/ListTrafficPolicyInstancesByPolicyCommand";
import {
  ListTrafficPolicyInstancesCommandInput,
  ListTrafficPolicyInstancesCommandOutput
} from "../commands/ListTrafficPolicyInstancesCommand";
import {
  ListTrafficPolicyVersionsCommandInput,
  ListTrafficPolicyVersionsCommandOutput
} from "../commands/ListTrafficPolicyVersionsCommand";
import {
  ListVPCAssociationAuthorizationsCommandInput,
  ListVPCAssociationAuthorizationsCommandOutput
} from "../commands/ListVPCAssociationAuthorizationsCommand";
import {
  TestDNSAnswerCommandInput,
  TestDNSAnswerCommandOutput
} from "../commands/TestDNSAnswerCommand";
import {
  UpdateHealthCheckCommandInput,
  UpdateHealthCheckCommandOutput
} from "../commands/UpdateHealthCheckCommand";
import {
  UpdateHostedZoneCommentCommandInput,
  UpdateHostedZoneCommentCommandOutput
} from "../commands/UpdateHostedZoneCommentCommand";
import {
  UpdateTrafficPolicyCommentCommandInput,
  UpdateTrafficPolicyCommentCommandOutput
} from "../commands/UpdateTrafficPolicyCommentCommand";
import {
  UpdateTrafficPolicyInstanceCommandInput,
  UpdateTrafficPolicyInstanceCommandOutput
} from "../commands/UpdateTrafficPolicyInstanceCommand";
import {
  AccountLimit,
  AlarmIdentifier,
  AliasTarget,
  Change,
  ChangeBatch,
  ChangeInfo,
  CloudWatchAlarmConfiguration,
  ConcurrentModification,
  ConflictingDomainExists,
  ConflictingTypes,
  DelegationSet,
  DelegationSetAlreadyCreated,
  DelegationSetAlreadyReusable,
  DelegationSetInUse,
  DelegationSetNotAvailable,
  DelegationSetNotReusable,
  Dimension,
  GeoLocation,
  GeoLocationDetails,
  HealthCheck,
  HealthCheckAlreadyExists,
  HealthCheckConfig,
  HealthCheckInUse,
  HealthCheckObservation,
  HealthCheckRegion,
  HealthCheckVersionMismatch,
  HostedZone,
  HostedZoneAlreadyExists,
  HostedZoneConfig,
  HostedZoneLimit,
  HostedZoneNotEmpty,
  HostedZoneNotFound,
  HostedZoneNotPrivate,
  IncompatibleVersion,
  InsufficientCloudWatchLogsResourcePolicy,
  InvalidArgument,
  InvalidChangeBatch,
  InvalidDomainName,
  InvalidInput,
  InvalidPaginationToken,
  InvalidTrafficPolicyDocument,
  InvalidVPCId,
  LastVPCAssociation,
  LimitsExceeded,
  LinkedService,
  NoSuchChange,
  NoSuchCloudWatchLogsLogGroup,
  NoSuchDelegationSet,
  NoSuchGeoLocation,
  NoSuchHealthCheck,
  NoSuchHostedZone,
  NoSuchQueryLoggingConfig,
  NoSuchTrafficPolicy,
  NoSuchTrafficPolicyInstance,
  NotAuthorizedException,
  PriorRequestNotComplete,
  PublicZoneVPCAssociation,
  QueryLoggingConfig,
  QueryLoggingConfigAlreadyExists,
  ResettableElementName,
  ResourceRecord,
  ResourceRecordSet,
  ResourceTagSet,
  ReusableDelegationSetLimit,
  StatusReport,
  Tag,
  ThrottlingException,
  TooManyHealthChecks,
  TooManyHostedZones,
  TooManyTrafficPolicies,
  TooManyTrafficPolicyInstances,
  TooManyTrafficPolicyVersionsForCurrentPolicy,
  TooManyVPCAssociationAuthorizations,
  TrafficPolicy,
  TrafficPolicyAlreadyExists,
  TrafficPolicyInUse,
  TrafficPolicyInstance,
  TrafficPolicyInstanceAlreadyExists,
  TrafficPolicySummary,
  VPC,
  VPCAssociationAuthorizationNotFound,
  VPCAssociationNotFound
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import {
  SmithyException as __SmithyException,
  extendedEncodeURIComponent as __extendedEncodeURIComponent
} from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";
import {
  XmlNode as __XmlNode,
  XmlText as __XmlText
} from "@aws-sdk/xml-builder";
import { parse as xmlParse } from "fast-xml-parser";

export async function serializeAws_restXmlAssociateVPCWithHostedZoneCommand(
  input: AssociateVPCWithHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/hostedzone/{HostedZoneId}/associatevpc";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("AssociateVPCWithHostedZone");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const memberNode = new __XmlNode("AssociateVPCComment").addChildNode(
      new __XmlText(input.Comment)
    );
    bodyNode.addChildNode(memberNode.withName("Comment"));
  }
  if (input.VPC !== undefined) {
    const memberNode = serializeAws_restXmlVPC(input.VPC, context);
    bodyNode.addChildNode(memberNode.withName("VPC"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlChangeResourceRecordSetsCommand(
  input: ChangeResourceRecordSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/hostedzone/{HostedZoneId}/rrset";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("ChangeResourceRecordSets");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.ChangeBatch !== undefined) {
    const memberNode = serializeAws_restXmlChangeBatch(
      input.ChangeBatch,
      context
    );
    bodyNode.addChildNode(memberNode.withName("ChangeBatch"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlChangeTagsForResourceCommand(
  input: ChangeTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/tags/{ResourceType}/{ResourceId}";
  if (input.ResourceId !== undefined) {
    const labelValue: string = input.ResourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ResourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceId.");
  }
  if (input.ResourceType !== undefined) {
    const labelValue: string = input.ResourceType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceType.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("ChangeTagsForResource");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.AddTags !== undefined) {
    const nodes = serializeAws_restXmlTagList(input.AddTags, context);
    const containerNode = new __XmlNode("AddTags");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.RemoveTagKeys !== undefined) {
    const nodes = serializeAws_restXmlTagKeyList(input.RemoveTagKeys, context);
    const containerNode = new __XmlNode("RemoveTagKeys");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlCreateHealthCheckCommand(
  input: CreateHealthCheckCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/healthcheck";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateHealthCheck");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.CallerReference !== undefined) {
    const memberNode = new __XmlNode("HealthCheckNonce").addChildNode(
      new __XmlText(input.CallerReference)
    );
    bodyNode.addChildNode(memberNode.withName("CallerReference"));
  }
  if (input.HealthCheckConfig !== undefined) {
    const memberNode = serializeAws_restXmlHealthCheckConfig(
      input.HealthCheckConfig,
      context
    );
    bodyNode.addChildNode(memberNode.withName("HealthCheckConfig"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlCreateHostedZoneCommand(
  input: CreateHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/hostedzone";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateHostedZone");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.CallerReference !== undefined) {
    const memberNode = new __XmlNode("Nonce").addChildNode(
      new __XmlText(input.CallerReference)
    );
    bodyNode.addChildNode(memberNode.withName("CallerReference"));
  }
  if (input.DelegationSetId !== undefined) {
    const memberNode = new __XmlNode("ResourceId").addChildNode(
      new __XmlText(input.DelegationSetId)
    );
    bodyNode.addChildNode(memberNode.withName("DelegationSetId"));
  }
  if (input.HostedZoneConfig !== undefined) {
    const memberNode = serializeAws_restXmlHostedZoneConfig(
      input.HostedZoneConfig,
      context
    );
    bodyNode.addChildNode(memberNode.withName("HostedZoneConfig"));
  }
  if (input.Name !== undefined) {
    const memberNode = new __XmlNode("DNSName").addChildNode(
      new __XmlText(input.Name)
    );
    bodyNode.addChildNode(memberNode.withName("Name"));
  }
  if (input.VPC !== undefined) {
    const memberNode = serializeAws_restXmlVPC(input.VPC, context);
    bodyNode.addChildNode(memberNode.withName("VPC"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlCreateQueryLoggingConfigCommand(
  input: CreateQueryLoggingConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/queryloggingconfig";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateQueryLoggingConfig");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.CloudWatchLogsLogGroupArn !== undefined) {
    const memberNode = new __XmlNode("CloudWatchLogsLogGroupArn").addChildNode(
      new __XmlText(input.CloudWatchLogsLogGroupArn)
    );
    bodyNode.addChildNode(memberNode.withName("CloudWatchLogsLogGroupArn"));
  }
  if (input.HostedZoneId !== undefined) {
    const memberNode = new __XmlNode("ResourceId").addChildNode(
      new __XmlText(input.HostedZoneId)
    );
    bodyNode.addChildNode(memberNode.withName("HostedZoneId"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlCreateReusableDelegationSetCommand(
  input: CreateReusableDelegationSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/delegationset";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateReusableDelegationSet");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.CallerReference !== undefined) {
    const memberNode = new __XmlNode("Nonce").addChildNode(
      new __XmlText(input.CallerReference)
    );
    bodyNode.addChildNode(memberNode.withName("CallerReference"));
  }
  if (input.HostedZoneId !== undefined) {
    const memberNode = new __XmlNode("ResourceId").addChildNode(
      new __XmlText(input.HostedZoneId)
    );
    bodyNode.addChildNode(memberNode.withName("HostedZoneId"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlCreateTrafficPolicyCommand(
  input: CreateTrafficPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/trafficpolicy";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateTrafficPolicy");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyComment").addChildNode(
      new __XmlText(input.Comment)
    );
    bodyNode.addChildNode(memberNode.withName("Comment"));
  }
  if (input.Document !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyDocument").addChildNode(
      new __XmlText(input.Document)
    );
    bodyNode.addChildNode(memberNode.withName("Document"));
  }
  if (input.Name !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyName").addChildNode(
      new __XmlText(input.Name)
    );
    bodyNode.addChildNode(memberNode.withName("Name"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlCreateTrafficPolicyInstanceCommand(
  input: CreateTrafficPolicyInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/trafficpolicyinstance";
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateTrafficPolicyInstance");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.HostedZoneId !== undefined) {
    const memberNode = new __XmlNode("ResourceId").addChildNode(
      new __XmlText(input.HostedZoneId)
    );
    bodyNode.addChildNode(memberNode.withName("HostedZoneId"));
  }
  if (input.Name !== undefined) {
    const memberNode = new __XmlNode("DNSName").addChildNode(
      new __XmlText(input.Name)
    );
    bodyNode.addChildNode(memberNode.withName("Name"));
  }
  if (input.TTL !== undefined) {
    const memberNode = new __XmlNode("TTL").addChildNode(
      new __XmlText(String(input.TTL))
    );
    bodyNode.addChildNode(memberNode.withName("TTL"));
  }
  if (input.TrafficPolicyId !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyId").addChildNode(
      new __XmlText(input.TrafficPolicyId)
    );
    bodyNode.addChildNode(memberNode.withName("TrafficPolicyId"));
  }
  if (input.TrafficPolicyVersion !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyVersion").addChildNode(
      new __XmlText(String(input.TrafficPolicyVersion))
    );
    bodyNode.addChildNode(memberNode.withName("TrafficPolicyVersion"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlCreateTrafficPolicyVersionCommand(
  input: CreateTrafficPolicyVersionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/trafficpolicy/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateTrafficPolicyVersion");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyComment").addChildNode(
      new __XmlText(input.Comment)
    );
    bodyNode.addChildNode(memberNode.withName("Comment"));
  }
  if (input.Document !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyDocument").addChildNode(
      new __XmlText(input.Document)
    );
    bodyNode.addChildNode(memberNode.withName("Document"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlCreateVPCAssociationAuthorizationCommand(
  input: CreateVPCAssociationAuthorizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath =
    "/2013-04-01/hostedzone/{HostedZoneId}/authorizevpcassociation";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("CreateVPCAssociationAuthorization");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.VPC !== undefined) {
    const memberNode = serializeAws_restXmlVPC(input.VPC, context);
    bodyNode.addChildNode(memberNode.withName("VPC"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlDeleteHealthCheckCommand(
  input: DeleteHealthCheckCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/healthcheck/{HealthCheckId}";
  if (input.HealthCheckId !== undefined) {
    const labelValue: string = input.HealthCheckId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HealthCheckId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HealthCheckId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HealthCheckId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlDeleteHostedZoneCommand(
  input: DeleteHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/hostedzone/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlDeleteQueryLoggingConfigCommand(
  input: DeleteQueryLoggingConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/queryloggingconfig/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlDeleteReusableDelegationSetCommand(
  input: DeleteReusableDelegationSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/delegationset/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlDeleteTrafficPolicyCommand(
  input: DeleteTrafficPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/trafficpolicy/{Id}/{Version}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  if (input.Version !== undefined) {
    const labelValue: string = input.Version.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Version.");
    }
    resolvedPath = resolvedPath.replace(
      "{Version}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Version.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlDeleteTrafficPolicyInstanceCommand(
  input: DeleteTrafficPolicyInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/trafficpolicyinstance/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "DELETE",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlDeleteVPCAssociationAuthorizationCommand(
  input: DeleteVPCAssociationAuthorizationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath =
    "/2013-04-01/hostedzone/{HostedZoneId}/deauthorizevpcassociation";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("DeleteVPCAssociationAuthorization");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.VPC !== undefined) {
    const memberNode = serializeAws_restXmlVPC(input.VPC, context);
    bodyNode.addChildNode(memberNode.withName("VPC"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlDisassociateVPCFromHostedZoneCommand(
  input: DisassociateVPCFromHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/hostedzone/{HostedZoneId}/disassociatevpc";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("DisassociateVPCFromHostedZone");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const memberNode = new __XmlNode("DisassociateVPCComment").addChildNode(
      new __XmlText(input.Comment)
    );
    bodyNode.addChildNode(memberNode.withName("Comment"));
  }
  if (input.VPC !== undefined) {
    const memberNode = serializeAws_restXmlVPC(input.VPC, context);
    bodyNode.addChildNode(memberNode.withName("VPC"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlGetAccountLimitCommand(
  input: GetAccountLimitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/accountlimit/{Type}";
  if (input.Type !== undefined) {
    const labelValue: string = input.Type;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Type.");
    }
    resolvedPath = resolvedPath.replace(
      "{Type}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Type.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetChangeCommand(
  input: GetChangeCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/change/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetCheckerIpRangesCommand(
  input: GetCheckerIpRangesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/checkeripranges";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetGeoLocationCommand(
  input: GetGeoLocationCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/geolocation";
  const query: any = {};
  if (input.ContinentCode !== undefined) {
    query["continentcode"] = input.ContinentCode;
  }
  if (input.CountryCode !== undefined) {
    query["countrycode"] = input.CountryCode;
  }
  if (input.SubdivisionCode !== undefined) {
    query["subdivisioncode"] = input.SubdivisionCode;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlGetHealthCheckCommand(
  input: GetHealthCheckCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/healthcheck/{HealthCheckId}";
  if (input.HealthCheckId !== undefined) {
    const labelValue: string = input.HealthCheckId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HealthCheckId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HealthCheckId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HealthCheckId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetHealthCheckCountCommand(
  input: GetHealthCheckCountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/healthcheckcount";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetHealthCheckLastFailureReasonCommand(
  input: GetHealthCheckLastFailureReasonCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/2013-04-01/healthcheck/{HealthCheckId}/lastfailurereason";
  if (input.HealthCheckId !== undefined) {
    const labelValue: string = input.HealthCheckId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HealthCheckId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HealthCheckId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HealthCheckId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetHealthCheckStatusCommand(
  input: GetHealthCheckStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/healthcheck/{HealthCheckId}/status";
  if (input.HealthCheckId !== undefined) {
    const labelValue: string = input.HealthCheckId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HealthCheckId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HealthCheckId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HealthCheckId.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetHostedZoneCommand(
  input: GetHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/hostedzone/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetHostedZoneCountCommand(
  input: GetHostedZoneCountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/hostedzonecount";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetHostedZoneLimitCommand(
  input: GetHostedZoneLimitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/hostedzonelimit/{HostedZoneId}/{Type}";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  if (input.Type !== undefined) {
    const labelValue: string = input.Type;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Type.");
    }
    resolvedPath = resolvedPath.replace(
      "{Type}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Type.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetQueryLoggingConfigCommand(
  input: GetQueryLoggingConfigCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/queryloggingconfig/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetReusableDelegationSetCommand(
  input: GetReusableDelegationSetCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/delegationset/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetReusableDelegationSetLimitCommand(
  input: GetReusableDelegationSetLimitCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/2013-04-01/reusabledelegationsetlimit/{DelegationSetId}/{Type}";
  if (input.DelegationSetId !== undefined) {
    const labelValue: string = input.DelegationSetId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: DelegationSetId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{DelegationSetId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: DelegationSetId.");
  }
  if (input.Type !== undefined) {
    const labelValue: string = input.Type;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Type.");
    }
    resolvedPath = resolvedPath.replace(
      "{Type}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Type.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetTrafficPolicyCommand(
  input: GetTrafficPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/trafficpolicy/{Id}/{Version}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  if (input.Version !== undefined) {
    const labelValue: string = input.Version.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Version.");
    }
    resolvedPath = resolvedPath.replace(
      "{Version}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Version.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetTrafficPolicyInstanceCommand(
  input: GetTrafficPolicyInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/trafficpolicyinstance/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlGetTrafficPolicyInstanceCountCommand(
  input: GetTrafficPolicyInstanceCountCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/trafficpolicyinstancecount";
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlListGeoLocationsCommand(
  input: ListGeoLocationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/geolocations";
  const query: any = {};
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  if (input.StartContinentCode !== undefined) {
    query["startcontinentcode"] = input.StartContinentCode;
  }
  if (input.StartCountryCode !== undefined) {
    query["startcountrycode"] = input.StartCountryCode;
  }
  if (input.StartSubdivisionCode !== undefined) {
    query["startsubdivisioncode"] = input.StartSubdivisionCode;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListHealthChecksCommand(
  input: ListHealthChecksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/healthcheck";
  const query: any = {};
  if (input.Marker !== undefined) {
    query["marker"] = input.Marker;
  }
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListHostedZonesCommand(
  input: ListHostedZonesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/hostedzone";
  const query: any = {};
  if (input.DelegationSetId !== undefined) {
    query["delegationsetid"] = input.DelegationSetId;
  }
  if (input.Marker !== undefined) {
    query["marker"] = input.Marker;
  }
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListHostedZonesByNameCommand(
  input: ListHostedZonesByNameCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/hostedzonesbyname";
  const query: any = {};
  if (input.DNSName !== undefined) {
    query["dnsname"] = input.DNSName;
  }
  if (input.HostedZoneId !== undefined) {
    query["hostedzoneid"] = input.HostedZoneId;
  }
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListQueryLoggingConfigsCommand(
  input: ListQueryLoggingConfigsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/queryloggingconfig";
  const query: any = {};
  if (input.HostedZoneId !== undefined) {
    query["hostedzoneid"] = input.HostedZoneId;
  }
  if (input.MaxResults !== undefined) {
    query["maxresults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    query["nexttoken"] = input.NextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListResourceRecordSetsCommand(
  input: ListResourceRecordSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/hostedzone/{HostedZoneId}/rrset";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  const query: any = {};
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  if (input.StartRecordIdentifier !== undefined) {
    query["identifier"] = input.StartRecordIdentifier;
  }
  if (input.StartRecordName !== undefined) {
    query["name"] = input.StartRecordName;
  }
  if (input.StartRecordType !== undefined) {
    query["type"] = input.StartRecordType;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListReusableDelegationSetsCommand(
  input: ListReusableDelegationSetsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/delegationset";
  const query: any = {};
  if (input.Marker !== undefined) {
    query["marker"] = input.Marker;
  }
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/tags/{ResourceType}/{ResourceId}";
  if (input.ResourceId !== undefined) {
    const labelValue: string = input.ResourceId;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: ResourceId.");
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceId.");
  }
  if (input.ResourceType !== undefined) {
    const labelValue: string = input.ResourceType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceType.");
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath
  });
}

export async function serializeAws_restXmlListTagsForResourcesCommand(
  input: ListTagsForResourcesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/tags/{ResourceType}";
  if (input.ResourceType !== undefined) {
    const labelValue: string = input.ResourceType;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: ResourceType."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{ResourceType}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: ResourceType.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("ListTagsForResources");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.ResourceIds !== undefined) {
    const nodes = serializeAws_restXmlTagResourceIdList(
      input.ResourceIds,
      context
    );
    const containerNode = new __XmlNode("ResourceIds");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlListTrafficPoliciesCommand(
  input: ListTrafficPoliciesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/trafficpolicies";
  const query: any = {};
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  if (input.TrafficPolicyIdMarker !== undefined) {
    query["trafficpolicyid"] = input.TrafficPolicyIdMarker;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListTrafficPolicyInstancesCommand(
  input: ListTrafficPolicyInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/trafficpolicyinstances";
  const query: any = {};
  if (input.HostedZoneIdMarker !== undefined) {
    query["hostedzoneid"] = input.HostedZoneIdMarker;
  }
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  if (input.TrafficPolicyInstanceNameMarker !== undefined) {
    query["trafficpolicyinstancename"] = input.TrafficPolicyInstanceNameMarker;
  }
  if (input.TrafficPolicyInstanceTypeMarker !== undefined) {
    query["trafficpolicyinstancetype"] = input.TrafficPolicyInstanceTypeMarker;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListTrafficPolicyInstancesByHostedZoneCommand(
  input: ListTrafficPolicyInstancesByHostedZoneCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/trafficpolicyinstances/hostedzone";
  const query: any = {};
  if (input.HostedZoneId !== undefined) {
    query["id"] = input.HostedZoneId;
  }
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  if (input.TrafficPolicyInstanceNameMarker !== undefined) {
    query["trafficpolicyinstancename"] = input.TrafficPolicyInstanceNameMarker;
  }
  if (input.TrafficPolicyInstanceTypeMarker !== undefined) {
    query["trafficpolicyinstancetype"] = input.TrafficPolicyInstanceTypeMarker;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListTrafficPolicyInstancesByPolicyCommand(
  input: ListTrafficPolicyInstancesByPolicyCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/trafficpolicyinstances/trafficpolicy";
  const query: any = {};
  if (input.HostedZoneIdMarker !== undefined) {
    query["hostedzoneid"] = input.HostedZoneIdMarker;
  }
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  if (input.TrafficPolicyId !== undefined) {
    query["id"] = input.TrafficPolicyId;
  }
  if (input.TrafficPolicyInstanceNameMarker !== undefined) {
    query["trafficpolicyinstancename"] = input.TrafficPolicyInstanceNameMarker;
  }
  if (input.TrafficPolicyInstanceTypeMarker !== undefined) {
    query["trafficpolicyinstancetype"] = input.TrafficPolicyInstanceTypeMarker;
  }
  if (input.TrafficPolicyVersion !== undefined) {
    query["version"] = input.TrafficPolicyVersion.toString();
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListTrafficPolicyVersionsCommand(
  input: ListTrafficPolicyVersionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/trafficpolicies/{Id}/versions";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  const query: any = {};
  if (input.MaxItems !== undefined) {
    query["maxitems"] = input.MaxItems;
  }
  if (input.TrafficPolicyVersionMarker !== undefined) {
    query["trafficpolicyversion"] = input.TrafficPolicyVersionMarker;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlListVPCAssociationAuthorizationsCommand(
  input: ListVPCAssociationAuthorizationsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath =
    "/2013-04-01/hostedzone/{HostedZoneId}/authorizevpcassociation";
  if (input.HostedZoneId !== undefined) {
    const labelValue: string = input.HostedZoneId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HostedZoneId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HostedZoneId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HostedZoneId.");
  }
  const query: any = {};
  if (input.MaxResults !== undefined) {
    query["maxresults"] = input.MaxResults;
  }
  if (input.NextToken !== undefined) {
    query["nexttoken"] = input.NextToken;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlTestDNSAnswerCommand(
  input: TestDNSAnswerCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "";
  let resolvedPath = "/2013-04-01/testdnsanswer";
  const query: any = {};
  if (input.EDNS0ClientSubnetIP !== undefined) {
    query["edns0clientsubnetip"] = input.EDNS0ClientSubnetIP;
  }
  if (input.EDNS0ClientSubnetMask !== undefined) {
    query["edns0clientsubnetmask"] = input.EDNS0ClientSubnetMask;
  }
  if (input.HostedZoneId !== undefined) {
    query["hostedzoneid"] = input.HostedZoneId;
  }
  if (input.RecordName !== undefined) {
    query["recordname"] = input.RecordName;
  }
  if (input.RecordType !== undefined) {
    query["recordtype"] = input.RecordType;
  }
  if (input.ResolverIP !== undefined) {
    query["resolverip"] = input.ResolverIP;
  }
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "GET",
    headers: headers,
    path: resolvedPath,
    query: query
  });
}

export async function serializeAws_restXmlUpdateHealthCheckCommand(
  input: UpdateHealthCheckCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/healthcheck/{HealthCheckId}";
  if (input.HealthCheckId !== undefined) {
    const labelValue: string = input.HealthCheckId;
    if (labelValue.length <= 0) {
      throw new Error(
        "Empty value provided for input HTTP label: HealthCheckId."
      );
    }
    resolvedPath = resolvedPath.replace(
      "{HealthCheckId}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: HealthCheckId.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("UpdateHealthCheck");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.AlarmIdentifier !== undefined) {
    const memberNode = serializeAws_restXmlAlarmIdentifier(
      input.AlarmIdentifier,
      context
    );
    bodyNode.addChildNode(memberNode.withName("AlarmIdentifier"));
  }
  if (input.ChildHealthChecks !== undefined) {
    const nodes = serializeAws_restXmlChildHealthCheckList(
      input.ChildHealthChecks,
      context
    );
    const containerNode = new __XmlNode("ChildHealthChecks");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Disabled !== undefined) {
    const memberNode = new __XmlNode("Disabled").addChildNode(
      new __XmlText(String(input.Disabled))
    );
    bodyNode.addChildNode(memberNode.withName("Disabled"));
  }
  if (input.EnableSNI !== undefined) {
    const memberNode = new __XmlNode("EnableSNI").addChildNode(
      new __XmlText(String(input.EnableSNI))
    );
    bodyNode.addChildNode(memberNode.withName("EnableSNI"));
  }
  if (input.FailureThreshold !== undefined) {
    const memberNode = new __XmlNode("FailureThreshold").addChildNode(
      new __XmlText(String(input.FailureThreshold))
    );
    bodyNode.addChildNode(memberNode.withName("FailureThreshold"));
  }
  if (input.FullyQualifiedDomainName !== undefined) {
    const memberNode = new __XmlNode("FullyQualifiedDomainName").addChildNode(
      new __XmlText(input.FullyQualifiedDomainName)
    );
    bodyNode.addChildNode(memberNode.withName("FullyQualifiedDomainName"));
  }
  if (input.HealthCheckVersion !== undefined) {
    const memberNode = new __XmlNode("HealthCheckVersion").addChildNode(
      new __XmlText(String(input.HealthCheckVersion))
    );
    bodyNode.addChildNode(memberNode.withName("HealthCheckVersion"));
  }
  if (input.HealthThreshold !== undefined) {
    const memberNode = new __XmlNode("HealthThreshold").addChildNode(
      new __XmlText(String(input.HealthThreshold))
    );
    bodyNode.addChildNode(memberNode.withName("HealthThreshold"));
  }
  if (input.IPAddress !== undefined) {
    const memberNode = new __XmlNode("IPAddress").addChildNode(
      new __XmlText(input.IPAddress)
    );
    bodyNode.addChildNode(memberNode.withName("IPAddress"));
  }
  if (input.InsufficientDataHealthStatus !== undefined) {
    const memberNode = new __XmlNode(
      "InsufficientDataHealthStatus"
    ).addChildNode(new __XmlText(input.InsufficientDataHealthStatus));
    bodyNode.addChildNode(memberNode.withName("InsufficientDataHealthStatus"));
  }
  if (input.Inverted !== undefined) {
    const memberNode = new __XmlNode("Inverted").addChildNode(
      new __XmlText(String(input.Inverted))
    );
    bodyNode.addChildNode(memberNode.withName("Inverted"));
  }
  if (input.Port !== undefined) {
    const memberNode = new __XmlNode("Port").addChildNode(
      new __XmlText(String(input.Port))
    );
    bodyNode.addChildNode(memberNode.withName("Port"));
  }
  if (input.Regions !== undefined) {
    const nodes = serializeAws_restXmlHealthCheckRegionList(
      input.Regions,
      context
    );
    const containerNode = new __XmlNode("Regions");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.ResetElements !== undefined) {
    const nodes = serializeAws_restXmlResettableElementNameList(
      input.ResetElements,
      context
    );
    const containerNode = new __XmlNode("ResetElements");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.ResourcePath !== undefined) {
    const memberNode = new __XmlNode("ResourcePath").addChildNode(
      new __XmlText(input.ResourcePath)
    );
    bodyNode.addChildNode(memberNode.withName("ResourcePath"));
  }
  if (input.SearchString !== undefined) {
    const memberNode = new __XmlNode("SearchString").addChildNode(
      new __XmlText(input.SearchString)
    );
    bodyNode.addChildNode(memberNode.withName("SearchString"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlUpdateHostedZoneCommentCommand(
  input: UpdateHostedZoneCommentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/hostedzone/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("UpdateHostedZoneComment");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const memberNode = new __XmlNode("ResourceDescription").addChildNode(
      new __XmlText(input.Comment)
    );
    bodyNode.addChildNode(memberNode.withName("Comment"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlUpdateTrafficPolicyCommentCommand(
  input: UpdateTrafficPolicyCommentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/trafficpolicy/{Id}/{Version}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  if (input.Version !== undefined) {
    const labelValue: string = input.Version.toString();
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Version.");
    }
    resolvedPath = resolvedPath.replace(
      "{Version}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Version.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("UpdateTrafficPolicyComment");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.Comment !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyComment").addChildNode(
      new __XmlText(input.Comment)
    );
    bodyNode.addChildNode(memberNode.withName("Comment"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function serializeAws_restXmlUpdateTrafficPolicyInstanceCommand(
  input: UpdateTrafficPolicyInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/xml";
  let resolvedPath = "/2013-04-01/trafficpolicyinstance/{Id}";
  if (input.Id !== undefined) {
    const labelValue: string = input.Id;
    if (labelValue.length <= 0) {
      throw new Error("Empty value provided for input HTTP label: Id.");
    }
    resolvedPath = resolvedPath.replace(
      "{Id}",
      __extendedEncodeURIComponent(labelValue)
    );
  } else {
    throw new Error("No value provided for input HTTP label: Id.");
  }
  let body: any;
  body = '<?xml version="1.0" encoding="UTF-8"?>';
  const bodyNode = new __XmlNode("UpdateTrafficPolicyInstance");
  bodyNode.addAttribute(
    "xmlns",
    "https://route53.amazonaws.com/doc/2013-04-01/"
  );
  if (input.TTL !== undefined) {
    const memberNode = new __XmlNode("TTL").addChildNode(
      new __XmlText(String(input.TTL))
    );
    bodyNode.addChildNode(memberNode.withName("TTL"));
  }
  if (input.TrafficPolicyId !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyId").addChildNode(
      new __XmlText(input.TrafficPolicyId)
    );
    bodyNode.addChildNode(memberNode.withName("TrafficPolicyId"));
  }
  if (input.TrafficPolicyVersion !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyVersion").addChildNode(
      new __XmlText(String(input.TrafficPolicyVersion))
    );
    bodyNode.addChildNode(memberNode.withName("TrafficPolicyVersion"));
  }
  body += bodyNode.toString();
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    headers: headers,
    path: resolvedPath,
    body: body
  });
}

export async function deserializeAws_restXmlAssociateVPCWithHostedZoneCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateVPCWithHostedZoneCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlAssociateVPCWithHostedZoneCommandError(
      output,
      context
    );
  }
  const contents: AssociateVPCWithHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AssociateVPCWithHostedZoneResponse",
    ChangeInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlAssociateVPCWithHostedZoneCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AssociateVPCWithHostedZoneCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingDomainExists":
    case "com.amazon.webservices.dns.v20130401#ConflictingDomainExists":
      response = await deserializeAws_restXmlConflictingDomainExistsResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidVPCId":
    case "com.amazon.webservices.dns.v20130401#InvalidVPCId":
      response = await deserializeAws_restXmlInvalidVPCIdResponse(
        parsedOutput,
        context
      );
      break;
    case "LimitsExceeded":
    case "com.amazon.webservices.dns.v20130401#LimitsExceeded":
      response = await deserializeAws_restXmlLimitsExceededResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "NotAuthorizedException":
    case "com.amazon.webservices.dns.v20130401#NotAuthorizedException":
      response = await deserializeAws_restXmlNotAuthorizedExceptionResponse(
        parsedOutput,
        context
      );
      break;
    case "PublicZoneVPCAssociation":
    case "com.amazon.webservices.dns.v20130401#PublicZoneVPCAssociation":
      response = await deserializeAws_restXmlPublicZoneVPCAssociationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlChangeResourceRecordSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ChangeResourceRecordSetsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlChangeResourceRecordSetsCommandError(
      output,
      context
    );
  }
  const contents: ChangeResourceRecordSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ChangeResourceRecordSetsResponse",
    ChangeInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlChangeResourceRecordSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ChangeResourceRecordSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidChangeBatch":
    case "com.amazon.webservices.dns.v20130401#InvalidChangeBatch":
      response = await deserializeAws_restXmlInvalidChangeBatchResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHealthCheck":
    case "com.amazon.webservices.dns.v20130401#NoSuchHealthCheck":
      response = await deserializeAws_restXmlNoSuchHealthCheckResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "PriorRequestNotComplete":
    case "com.amazon.webservices.dns.v20130401#PriorRequestNotComplete":
      response = await deserializeAws_restXmlPriorRequestNotCompleteResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlChangeTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ChangeTagsForResourceCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlChangeTagsForResourceCommandError(
      output,
      context
    );
  }
  const contents: ChangeTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ChangeTagsForResourceResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlChangeTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ChangeTagsForResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHealthCheck":
    case "com.amazon.webservices.dns.v20130401#NoSuchHealthCheck":
      response = await deserializeAws_restXmlNoSuchHealthCheckResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "PriorRequestNotComplete":
    case "com.amazon.webservices.dns.v20130401#PriorRequestNotComplete":
      response = await deserializeAws_restXmlPriorRequestNotCompleteResponse(
        parsedOutput,
        context
      );
      break;
    case "ThrottlingException":
    case "com.amazon.webservices.dns.v20130401#ThrottlingException":
      response = await deserializeAws_restXmlThrottlingExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCreateHealthCheckCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHealthCheckCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateHealthCheckCommandError(output, context);
  }
  const contents: CreateHealthCheckCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateHealthCheckResponse",
    HealthCheck: undefined,
    Location: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["HealthCheck"] !== undefined) {
    contents.HealthCheck = deserializeAws_restXmlHealthCheck(
      data["HealthCheck"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCreateHealthCheckCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHealthCheckCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HealthCheckAlreadyExists":
    case "com.amazon.webservices.dns.v20130401#HealthCheckAlreadyExists":
      response = await deserializeAws_restXmlHealthCheckAlreadyExistsResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyHealthChecks":
    case "com.amazon.webservices.dns.v20130401#TooManyHealthChecks":
      response = await deserializeAws_restXmlTooManyHealthChecksResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCreateHostedZoneCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHostedZoneCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateHostedZoneCommandError(output, context);
  }
  const contents: CreateHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateHostedZoneResponse",
    ChangeInfo: undefined,
    DelegationSet: undefined,
    HostedZone: undefined,
    Location: undefined,
    VPC: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  if (data["DelegationSet"] !== undefined) {
    contents.DelegationSet = deserializeAws_restXmlDelegationSet(
      data["DelegationSet"],
      context
    );
  }
  if (data["HostedZone"] !== undefined) {
    contents.HostedZone = deserializeAws_restXmlHostedZone(
      data["HostedZone"],
      context
    );
  }
  if (data["VPC"] !== undefined) {
    contents.VPC = deserializeAws_restXmlVPC(data["VPC"], context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCreateHostedZoneCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateHostedZoneCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingDomainExists":
    case "com.amazon.webservices.dns.v20130401#ConflictingDomainExists":
      response = await deserializeAws_restXmlConflictingDomainExistsResponse(
        parsedOutput,
        context
      );
      break;
    case "DelegationSetNotAvailable":
    case "com.amazon.webservices.dns.v20130401#DelegationSetNotAvailable":
      response = await deserializeAws_restXmlDelegationSetNotAvailableResponse(
        parsedOutput,
        context
      );
      break;
    case "DelegationSetNotReusable":
    case "com.amazon.webservices.dns.v20130401#DelegationSetNotReusable":
      response = await deserializeAws_restXmlDelegationSetNotReusableResponse(
        parsedOutput,
        context
      );
      break;
    case "HostedZoneAlreadyExists":
    case "com.amazon.webservices.dns.v20130401#HostedZoneAlreadyExists":
      response = await deserializeAws_restXmlHostedZoneAlreadyExistsResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidDomainName":
    case "com.amazon.webservices.dns.v20130401#InvalidDomainName":
      response = await deserializeAws_restXmlInvalidDomainNameResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidVPCId":
    case "com.amazon.webservices.dns.v20130401#InvalidVPCId":
      response = await deserializeAws_restXmlInvalidVPCIdResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchDelegationSet":
    case "com.amazon.webservices.dns.v20130401#NoSuchDelegationSet":
      response = await deserializeAws_restXmlNoSuchDelegationSetResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyHostedZones":
    case "com.amazon.webservices.dns.v20130401#TooManyHostedZones":
      response = await deserializeAws_restXmlTooManyHostedZonesResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCreateQueryLoggingConfigCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateQueryLoggingConfigCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateQueryLoggingConfigCommandError(
      output,
      context
    );
  }
  const contents: CreateQueryLoggingConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateQueryLoggingConfigResponse",
    Location: undefined,
    QueryLoggingConfig: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["QueryLoggingConfig"] !== undefined) {
    contents.QueryLoggingConfig = deserializeAws_restXmlQueryLoggingConfig(
      data["QueryLoggingConfig"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCreateQueryLoggingConfigCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateQueryLoggingConfigCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazon.webservices.dns.v20130401#ConcurrentModification":
      response = await deserializeAws_restXmlConcurrentModificationResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientCloudWatchLogsResourcePolicy":
    case "com.amazon.webservices.dns.v20130401#InsufficientCloudWatchLogsResourcePolicy":
      response = await deserializeAws_restXmlInsufficientCloudWatchLogsResourcePolicyResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchCloudWatchLogsLogGroup":
    case "com.amazon.webservices.dns.v20130401#NoSuchCloudWatchLogsLogGroup":
      response = await deserializeAws_restXmlNoSuchCloudWatchLogsLogGroupResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "QueryLoggingConfigAlreadyExists":
    case "com.amazon.webservices.dns.v20130401#QueryLoggingConfigAlreadyExists":
      response = await deserializeAws_restXmlQueryLoggingConfigAlreadyExistsResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCreateReusableDelegationSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReusableDelegationSetCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateReusableDelegationSetCommandError(
      output,
      context
    );
  }
  const contents: CreateReusableDelegationSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReusableDelegationSetResponse",
    DelegationSet: undefined,
    Location: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["DelegationSet"] !== undefined) {
    contents.DelegationSet = deserializeAws_restXmlDelegationSet(
      data["DelegationSet"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCreateReusableDelegationSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReusableDelegationSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DelegationSetAlreadyCreated":
    case "com.amazon.webservices.dns.v20130401#DelegationSetAlreadyCreated":
      response = await deserializeAws_restXmlDelegationSetAlreadyCreatedResponse(
        parsedOutput,
        context
      );
      break;
    case "DelegationSetAlreadyReusable":
    case "com.amazon.webservices.dns.v20130401#DelegationSetAlreadyReusable":
      response = await deserializeAws_restXmlDelegationSetAlreadyReusableResponse(
        parsedOutput,
        context
      );
      break;
    case "DelegationSetNotAvailable":
    case "com.amazon.webservices.dns.v20130401#DelegationSetNotAvailable":
      response = await deserializeAws_restXmlDelegationSetNotAvailableResponse(
        parsedOutput,
        context
      );
      break;
    case "HostedZoneNotFound":
    case "com.amazon.webservices.dns.v20130401#HostedZoneNotFound":
      response = await deserializeAws_restXmlHostedZoneNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidArgument":
    case "com.amazon.webservices.dns.v20130401#InvalidArgument":
      response = await deserializeAws_restXmlInvalidArgumentResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "LimitsExceeded":
    case "com.amazon.webservices.dns.v20130401#LimitsExceeded":
      response = await deserializeAws_restXmlLimitsExceededResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCreateTrafficPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateTrafficPolicyCommandError(
      output,
      context
    );
  }
  const contents: CreateTrafficPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrafficPolicyResponse",
    Location: undefined,
    TrafficPolicy: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicy"] !== undefined) {
    contents.TrafficPolicy = deserializeAws_restXmlTrafficPolicy(
      data["TrafficPolicy"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCreateTrafficPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTrafficPolicyDocument":
    case "com.amazon.webservices.dns.v20130401#InvalidTrafficPolicyDocument":
      response = await deserializeAws_restXmlInvalidTrafficPolicyDocumentResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyTrafficPolicies":
    case "com.amazon.webservices.dns.v20130401#TooManyTrafficPolicies":
      response = await deserializeAws_restXmlTooManyTrafficPoliciesResponse(
        parsedOutput,
        context
      );
      break;
    case "TrafficPolicyAlreadyExists":
    case "com.amazon.webservices.dns.v20130401#TrafficPolicyAlreadyExists":
      response = await deserializeAws_restXmlTrafficPolicyAlreadyExistsResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCreateTrafficPolicyInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyInstanceCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateTrafficPolicyInstanceCommandError(
      output,
      context
    );
  }
  const contents: CreateTrafficPolicyInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrafficPolicyInstanceResponse",
    Location: undefined,
    TrafficPolicyInstance: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicyInstance"] !== undefined) {
    contents.TrafficPolicyInstance = deserializeAws_restXmlTrafficPolicyInstance(
      data["TrafficPolicyInstance"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCreateTrafficPolicyInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicy":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyTrafficPolicyInstances":
    case "com.amazon.webservices.dns.v20130401#TooManyTrafficPolicyInstances":
      response = await deserializeAws_restXmlTooManyTrafficPolicyInstancesResponse(
        parsedOutput,
        context
      );
      break;
    case "TrafficPolicyInstanceAlreadyExists":
    case "com.amazon.webservices.dns.v20130401#TrafficPolicyInstanceAlreadyExists":
      response = await deserializeAws_restXmlTrafficPolicyInstanceAlreadyExistsResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCreateTrafficPolicyVersionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyVersionCommandOutput> {
  if (output.statusCode !== 201 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateTrafficPolicyVersionCommandError(
      output,
      context
    );
  }
  const contents: CreateTrafficPolicyVersionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateTrafficPolicyVersionResponse",
    Location: undefined,
    TrafficPolicy: undefined
  };
  if (output.headers["location"] !== undefined) {
    contents.Location = output.headers["location"];
  }
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicy"] !== undefined) {
    contents.TrafficPolicy = deserializeAws_restXmlTrafficPolicy(
      data["TrafficPolicy"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCreateTrafficPolicyVersionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateTrafficPolicyVersionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazon.webservices.dns.v20130401#ConcurrentModification":
      response = await deserializeAws_restXmlConcurrentModificationResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidTrafficPolicyDocument":
    case "com.amazon.webservices.dns.v20130401#InvalidTrafficPolicyDocument":
      response = await deserializeAws_restXmlInvalidTrafficPolicyDocumentResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicy":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyTrafficPolicyVersionsForCurrentPolicy":
    case "com.amazon.webservices.dns.v20130401#TooManyTrafficPolicyVersionsForCurrentPolicy":
      response = await deserializeAws_restXmlTooManyTrafficPolicyVersionsForCurrentPolicyResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlCreateVPCAssociationAuthorizationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVPCAssociationAuthorizationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlCreateVPCAssociationAuthorizationCommandError(
      output,
      context
    );
  }
  const contents: CreateVPCAssociationAuthorizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateVPCAssociationAuthorizationResponse",
    HostedZoneId: undefined,
    VPC: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = data["HostedZoneId"];
  }
  if (data["VPC"] !== undefined) {
    contents.VPC = deserializeAws_restXmlVPC(data["VPC"], context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlCreateVPCAssociationAuthorizationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateVPCAssociationAuthorizationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazon.webservices.dns.v20130401#ConcurrentModification":
      response = await deserializeAws_restXmlConcurrentModificationResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidVPCId":
    case "com.amazon.webservices.dns.v20130401#InvalidVPCId":
      response = await deserializeAws_restXmlInvalidVPCIdResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "TooManyVPCAssociationAuthorizations":
    case "com.amazon.webservices.dns.v20130401#TooManyVPCAssociationAuthorizations":
      response = await deserializeAws_restXmlTooManyVPCAssociationAuthorizationsResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteHealthCheckCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHealthCheckCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteHealthCheckCommandError(output, context);
  }
  const contents: DeleteHealthCheckCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteHealthCheckResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteHealthCheckCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHealthCheckCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HealthCheckInUse":
    case "com.amazon.webservices.dns.v20130401#HealthCheckInUse":
      response = await deserializeAws_restXmlHealthCheckInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHealthCheck":
    case "com.amazon.webservices.dns.v20130401#NoSuchHealthCheck":
      response = await deserializeAws_restXmlNoSuchHealthCheckResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteHostedZoneCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHostedZoneCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteHostedZoneCommandError(output, context);
  }
  const contents: DeleteHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteHostedZoneResponse",
    ChangeInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteHostedZoneCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteHostedZoneCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HostedZoneNotEmpty":
    case "com.amazon.webservices.dns.v20130401#HostedZoneNotEmpty":
      response = await deserializeAws_restXmlHostedZoneNotEmptyResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidDomainName":
    case "com.amazon.webservices.dns.v20130401#InvalidDomainName":
      response = await deserializeAws_restXmlInvalidDomainNameResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "PriorRequestNotComplete":
    case "com.amazon.webservices.dns.v20130401#PriorRequestNotComplete":
      response = await deserializeAws_restXmlPriorRequestNotCompleteResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteQueryLoggingConfigCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteQueryLoggingConfigCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteQueryLoggingConfigCommandError(
      output,
      context
    );
  }
  const contents: DeleteQueryLoggingConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteQueryLoggingConfigResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteQueryLoggingConfigCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteQueryLoggingConfigCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazon.webservices.dns.v20130401#ConcurrentModification":
      response = await deserializeAws_restXmlConcurrentModificationResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchQueryLoggingConfig":
    case "com.amazon.webservices.dns.v20130401#NoSuchQueryLoggingConfig":
      response = await deserializeAws_restXmlNoSuchQueryLoggingConfigResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteReusableDelegationSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReusableDelegationSetCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteReusableDelegationSetCommandError(
      output,
      context
    );
  }
  const contents: DeleteReusableDelegationSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReusableDelegationSetResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteReusableDelegationSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReusableDelegationSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DelegationSetInUse":
    case "com.amazon.webservices.dns.v20130401#DelegationSetInUse":
      response = await deserializeAws_restXmlDelegationSetInUseResponse(
        parsedOutput,
        context
      );
      break;
    case "DelegationSetNotReusable":
    case "com.amazon.webservices.dns.v20130401#DelegationSetNotReusable":
      response = await deserializeAws_restXmlDelegationSetNotReusableResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchDelegationSet":
    case "com.amazon.webservices.dns.v20130401#NoSuchDelegationSet":
      response = await deserializeAws_restXmlNoSuchDelegationSetResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteTrafficPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteTrafficPolicyCommandError(
      output,
      context
    );
  }
  const contents: DeleteTrafficPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrafficPolicyResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteTrafficPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazon.webservices.dns.v20130401#ConcurrentModification":
      response = await deserializeAws_restXmlConcurrentModificationResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicy":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
        parsedOutput,
        context
      );
      break;
    case "TrafficPolicyInUse":
    case "com.amazon.webservices.dns.v20130401#TrafficPolicyInUse":
      response = await deserializeAws_restXmlTrafficPolicyInUseResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteTrafficPolicyInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficPolicyInstanceCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteTrafficPolicyInstanceCommandError(
      output,
      context
    );
  }
  const contents: DeleteTrafficPolicyInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteTrafficPolicyInstanceResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteTrafficPolicyInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteTrafficPolicyInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicyInstance":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
        parsedOutput,
        context
      );
      break;
    case "PriorRequestNotComplete":
    case "com.amazon.webservices.dns.v20130401#PriorRequestNotComplete":
      response = await deserializeAws_restXmlPriorRequestNotCompleteResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDeleteVPCAssociationAuthorizationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVPCAssociationAuthorizationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDeleteVPCAssociationAuthorizationCommandError(
      output,
      context
    );
  }
  const contents: DeleteVPCAssociationAuthorizationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteVPCAssociationAuthorizationResponse"
  };
  await collectBody(output.body, context);
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDeleteVPCAssociationAuthorizationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteVPCAssociationAuthorizationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazon.webservices.dns.v20130401#ConcurrentModification":
      response = await deserializeAws_restXmlConcurrentModificationResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidVPCId":
    case "com.amazon.webservices.dns.v20130401#InvalidVPCId":
      response = await deserializeAws_restXmlInvalidVPCIdResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "VPCAssociationAuthorizationNotFound":
    case "com.amazon.webservices.dns.v20130401#VPCAssociationAuthorizationNotFound":
      response = await deserializeAws_restXmlVPCAssociationAuthorizationNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlDisassociateVPCFromHostedZoneCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateVPCFromHostedZoneCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlDisassociateVPCFromHostedZoneCommandError(
      output,
      context
    );
  }
  const contents: DisassociateVPCFromHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DisassociateVPCFromHostedZoneResponse",
    ChangeInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlDisassociateVPCFromHostedZoneCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DisassociateVPCFromHostedZoneCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidVPCId":
    case "com.amazon.webservices.dns.v20130401#InvalidVPCId":
      response = await deserializeAws_restXmlInvalidVPCIdResponse(
        parsedOutput,
        context
      );
      break;
    case "LastVPCAssociation":
    case "com.amazon.webservices.dns.v20130401#LastVPCAssociation":
      response = await deserializeAws_restXmlLastVPCAssociationResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "VPCAssociationNotFound":
    case "com.amazon.webservices.dns.v20130401#VPCAssociationNotFound":
      response = await deserializeAws_restXmlVPCAssociationNotFoundResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetAccountLimitCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountLimitCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetAccountLimitCommandError(output, context);
  }
  const contents: GetAccountLimitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetAccountLimitResponse",
    Count: undefined,
    Limit: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Count"] !== undefined) {
    contents.Count = parseInt(data["Count"]);
  }
  if (data["Limit"] !== undefined) {
    contents.Limit = deserializeAws_restXmlAccountLimit(data["Limit"], context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetAccountLimitCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetAccountLimitCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetChangeCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetChangeCommandError(output, context);
  }
  const contents: GetChangeCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetChangeResponse",
    ChangeInfo: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ChangeInfo"] !== undefined) {
    contents.ChangeInfo = deserializeAws_restXmlChangeInfo(
      data["ChangeInfo"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetChangeCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetChangeCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchChange":
    case "com.amazon.webservices.dns.v20130401#NoSuchChange":
      response = await deserializeAws_restXmlNoSuchChangeResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetCheckerIpRangesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCheckerIpRangesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetCheckerIpRangesCommandError(
      output,
      context
    );
  }
  const contents: GetCheckerIpRangesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetCheckerIpRangesResponse",
    CheckerIpRanges: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.CheckerIpRanges === "") {
    contents.CheckerIpRanges = [];
  }
  if (
    data["CheckerIpRanges"] !== undefined &&
    data["CheckerIpRanges"]["member"] !== undefined
  ) {
    const wrappedItem =
      data["CheckerIpRanges"]["member"] instanceof Array
        ? data["CheckerIpRanges"]["member"]
        : [data["CheckerIpRanges"]["member"]];
    contents.CheckerIpRanges = deserializeAws_restXmlCheckerIpRanges(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetCheckerIpRangesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetCheckerIpRangesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetGeoLocationCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGeoLocationCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetGeoLocationCommandError(output, context);
  }
  const contents: GetGeoLocationCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetGeoLocationResponse",
    GeoLocationDetails: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["GeoLocationDetails"] !== undefined) {
    contents.GeoLocationDetails = deserializeAws_restXmlGeoLocationDetails(
      data["GeoLocationDetails"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetGeoLocationCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetGeoLocationCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchGeoLocation":
    case "com.amazon.webservices.dns.v20130401#NoSuchGeoLocation":
      response = await deserializeAws_restXmlNoSuchGeoLocationResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetHealthCheckCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHealthCheckCommandError(output, context);
  }
  const contents: GetHealthCheckCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHealthCheckResponse",
    HealthCheck: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HealthCheck"] !== undefined) {
    contents.HealthCheck = deserializeAws_restXmlHealthCheck(
      data["HealthCheck"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetHealthCheckCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IncompatibleVersion":
    case "com.amazon.webservices.dns.v20130401#IncompatibleVersion":
      response = await deserializeAws_restXmlIncompatibleVersionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHealthCheck":
    case "com.amazon.webservices.dns.v20130401#NoSuchHealthCheck":
      response = await deserializeAws_restXmlNoSuchHealthCheckResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetHealthCheckCountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckCountCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHealthCheckCountCommandError(
      output,
      context
    );
  }
  const contents: GetHealthCheckCountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHealthCheckCountResponse",
    HealthCheckCount: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HealthCheckCount"] !== undefined) {
    contents.HealthCheckCount = parseInt(data["HealthCheckCount"]);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetHealthCheckCountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckCountCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetHealthCheckLastFailureReasonCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckLastFailureReasonCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHealthCheckLastFailureReasonCommandError(
      output,
      context
    );
  }
  const contents: GetHealthCheckLastFailureReasonCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHealthCheckLastFailureReasonResponse",
    HealthCheckObservations: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.HealthCheckObservations === "") {
    contents.HealthCheckObservations = [];
  }
  if (
    data["HealthCheckObservations"] !== undefined &&
    data["HealthCheckObservations"]["HealthCheckObservation"] !== undefined
  ) {
    const wrappedItem =
      data["HealthCheckObservations"]["HealthCheckObservation"] instanceof Array
        ? data["HealthCheckObservations"]["HealthCheckObservation"]
        : [data["HealthCheckObservations"]["HealthCheckObservation"]];
    contents.HealthCheckObservations = deserializeAws_restXmlHealthCheckObservations(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetHealthCheckLastFailureReasonCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckLastFailureReasonCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHealthCheck":
    case "com.amazon.webservices.dns.v20130401#NoSuchHealthCheck":
      response = await deserializeAws_restXmlNoSuchHealthCheckResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetHealthCheckStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckStatusCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHealthCheckStatusCommandError(
      output,
      context
    );
  }
  const contents: GetHealthCheckStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHealthCheckStatusResponse",
    HealthCheckObservations: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.HealthCheckObservations === "") {
    contents.HealthCheckObservations = [];
  }
  if (
    data["HealthCheckObservations"] !== undefined &&
    data["HealthCheckObservations"]["HealthCheckObservation"] !== undefined
  ) {
    const wrappedItem =
      data["HealthCheckObservations"]["HealthCheckObservation"] instanceof Array
        ? data["HealthCheckObservations"]["HealthCheckObservation"]
        : [data["HealthCheckObservations"]["HealthCheckObservation"]];
    contents.HealthCheckObservations = deserializeAws_restXmlHealthCheckObservations(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetHealthCheckStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHealthCheckStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHealthCheck":
    case "com.amazon.webservices.dns.v20130401#NoSuchHealthCheck":
      response = await deserializeAws_restXmlNoSuchHealthCheckResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetHostedZoneCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHostedZoneCommandError(output, context);
  }
  const contents: GetHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHostedZoneResponse",
    DelegationSet: undefined,
    HostedZone: undefined,
    VPCs: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["DelegationSet"] !== undefined) {
    contents.DelegationSet = deserializeAws_restXmlDelegationSet(
      data["DelegationSet"],
      context
    );
  }
  if (data["HostedZone"] !== undefined) {
    contents.HostedZone = deserializeAws_restXmlHostedZone(
      data["HostedZone"],
      context
    );
  }
  if (data.VPCs === "") {
    contents.VPCs = [];
  }
  if (data["VPCs"] !== undefined && data["VPCs"]["VPC"] !== undefined) {
    const wrappedItem =
      data["VPCs"]["VPC"] instanceof Array
        ? data["VPCs"]["VPC"]
        : [data["VPCs"]["VPC"]];
    contents.VPCs = deserializeAws_restXmlVPCs(wrappedItem, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetHostedZoneCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetHostedZoneCountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneCountCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHostedZoneCountCommandError(
      output,
      context
    );
  }
  const contents: GetHostedZoneCountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHostedZoneCountResponse",
    HostedZoneCount: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZoneCount"] !== undefined) {
    contents.HostedZoneCount = parseInt(data["HostedZoneCount"]);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetHostedZoneCountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneCountCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetHostedZoneLimitCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneLimitCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetHostedZoneLimitCommandError(
      output,
      context
    );
  }
  const contents: GetHostedZoneLimitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetHostedZoneLimitResponse",
    Count: undefined,
    Limit: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Count"] !== undefined) {
    contents.Count = parseInt(data["Count"]);
  }
  if (data["Limit"] !== undefined) {
    contents.Limit = deserializeAws_restXmlHostedZoneLimit(
      data["Limit"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetHostedZoneLimitCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetHostedZoneLimitCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HostedZoneNotPrivate":
    case "com.amazon.webservices.dns.v20130401#HostedZoneNotPrivate":
      response = await deserializeAws_restXmlHostedZoneNotPrivateResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetQueryLoggingConfigCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetQueryLoggingConfigCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetQueryLoggingConfigCommandError(
      output,
      context
    );
  }
  const contents: GetQueryLoggingConfigCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetQueryLoggingConfigResponse",
    QueryLoggingConfig: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["QueryLoggingConfig"] !== undefined) {
    contents.QueryLoggingConfig = deserializeAws_restXmlQueryLoggingConfig(
      data["QueryLoggingConfig"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetQueryLoggingConfigCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetQueryLoggingConfigCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchQueryLoggingConfig":
    case "com.amazon.webservices.dns.v20130401#NoSuchQueryLoggingConfig":
      response = await deserializeAws_restXmlNoSuchQueryLoggingConfigResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetReusableDelegationSetCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReusableDelegationSetCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetReusableDelegationSetCommandError(
      output,
      context
    );
  }
  const contents: GetReusableDelegationSetCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetReusableDelegationSetResponse",
    DelegationSet: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["DelegationSet"] !== undefined) {
    contents.DelegationSet = deserializeAws_restXmlDelegationSet(
      data["DelegationSet"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetReusableDelegationSetCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReusableDelegationSetCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DelegationSetNotReusable":
    case "com.amazon.webservices.dns.v20130401#DelegationSetNotReusable":
      response = await deserializeAws_restXmlDelegationSetNotReusableResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchDelegationSet":
    case "com.amazon.webservices.dns.v20130401#NoSuchDelegationSet":
      response = await deserializeAws_restXmlNoSuchDelegationSetResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetReusableDelegationSetLimitCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReusableDelegationSetLimitCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetReusableDelegationSetLimitCommandError(
      output,
      context
    );
  }
  const contents: GetReusableDelegationSetLimitCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetReusableDelegationSetLimitResponse",
    Count: undefined,
    Limit: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Count"] !== undefined) {
    contents.Count = parseInt(data["Count"]);
  }
  if (data["Limit"] !== undefined) {
    contents.Limit = deserializeAws_restXmlReusableDelegationSetLimit(
      data["Limit"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetReusableDelegationSetLimitCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetReusableDelegationSetLimitCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchDelegationSet":
    case "com.amazon.webservices.dns.v20130401#NoSuchDelegationSet":
      response = await deserializeAws_restXmlNoSuchDelegationSetResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetTrafficPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetTrafficPolicyCommandError(output, context);
  }
  const contents: GetTrafficPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTrafficPolicyResponse",
    TrafficPolicy: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicy"] !== undefined) {
    contents.TrafficPolicy = deserializeAws_restXmlTrafficPolicy(
      data["TrafficPolicy"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetTrafficPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicy":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetTrafficPolicyInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyInstanceCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetTrafficPolicyInstanceCommandError(
      output,
      context
    );
  }
  const contents: GetTrafficPolicyInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTrafficPolicyInstanceResponse",
    TrafficPolicyInstance: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicyInstance"] !== undefined) {
    contents.TrafficPolicyInstance = deserializeAws_restXmlTrafficPolicyInstance(
      data["TrafficPolicyInstance"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetTrafficPolicyInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicyInstance":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlGetTrafficPolicyInstanceCountCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyInstanceCountCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlGetTrafficPolicyInstanceCountCommandError(
      output,
      context
    );
  }
  const contents: GetTrafficPolicyInstanceCountCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "GetTrafficPolicyInstanceCountResponse",
    TrafficPolicyInstanceCount: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicyInstanceCount"] !== undefined) {
    contents.TrafficPolicyInstanceCount = parseInt(
      data["TrafficPolicyInstanceCount"]
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlGetTrafficPolicyInstanceCountCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<GetTrafficPolicyInstanceCountCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListGeoLocationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGeoLocationsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListGeoLocationsCommandError(output, context);
  }
  const contents: ListGeoLocationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListGeoLocationsResponse",
    GeoLocationDetailsList: undefined,
    IsTruncated: undefined,
    MaxItems: undefined,
    NextContinentCode: undefined,
    NextCountryCode: undefined,
    NextSubdivisionCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.GeoLocationDetailsList === "") {
    contents.GeoLocationDetailsList = [];
  }
  if (
    data["GeoLocationDetailsList"] !== undefined &&
    data["GeoLocationDetailsList"]["GeoLocationDetails"] !== undefined
  ) {
    const wrappedItem =
      data["GeoLocationDetailsList"]["GeoLocationDetails"] instanceof Array
        ? data["GeoLocationDetailsList"]["GeoLocationDetails"]
        : [data["GeoLocationDetailsList"]["GeoLocationDetails"]];
    contents.GeoLocationDetailsList = deserializeAws_restXmlGeoLocationDetailsList(
      wrappedItem,
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextContinentCode"] !== undefined) {
    contents.NextContinentCode = data["NextContinentCode"];
  }
  if (data["NextCountryCode"] !== undefined) {
    contents.NextCountryCode = data["NextCountryCode"];
  }
  if (data["NextSubdivisionCode"] !== undefined) {
    contents.NextSubdivisionCode = data["NextSubdivisionCode"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListGeoLocationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListGeoLocationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListHealthChecksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHealthChecksCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListHealthChecksCommandError(output, context);
  }
  const contents: ListHealthChecksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListHealthChecksResponse",
    HealthChecks: undefined,
    IsTruncated: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.HealthChecks === "") {
    contents.HealthChecks = [];
  }
  if (
    data["HealthChecks"] !== undefined &&
    data["HealthChecks"]["HealthCheck"] !== undefined
  ) {
    const wrappedItem =
      data["HealthChecks"]["HealthCheck"] instanceof Array
        ? data["HealthChecks"]["HealthCheck"]
        : [data["HealthChecks"]["HealthCheck"]];
    contents.HealthChecks = deserializeAws_restXmlHealthChecks(
      wrappedItem,
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["Marker"] !== undefined) {
    contents.Marker = data["Marker"];
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextMarker"] !== undefined) {
    contents.NextMarker = data["NextMarker"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListHealthChecksCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHealthChecksCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "IncompatibleVersion":
    case "com.amazon.webservices.dns.v20130401#IncompatibleVersion":
      response = await deserializeAws_restXmlIncompatibleVersionResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListHostedZonesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHostedZonesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListHostedZonesCommandError(output, context);
  }
  const contents: ListHostedZonesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListHostedZonesResponse",
    HostedZones: undefined,
    IsTruncated: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.HostedZones === "") {
    contents.HostedZones = [];
  }
  if (
    data["HostedZones"] !== undefined &&
    data["HostedZones"]["HostedZone"] !== undefined
  ) {
    const wrappedItem =
      data["HostedZones"]["HostedZone"] instanceof Array
        ? data["HostedZones"]["HostedZone"]
        : [data["HostedZones"]["HostedZone"]];
    contents.HostedZones = deserializeAws_restXmlHostedZones(
      wrappedItem,
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["Marker"] !== undefined) {
    contents.Marker = data["Marker"];
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextMarker"] !== undefined) {
    contents.NextMarker = data["NextMarker"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListHostedZonesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHostedZonesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "DelegationSetNotReusable":
    case "com.amazon.webservices.dns.v20130401#DelegationSetNotReusable":
      response = await deserializeAws_restXmlDelegationSetNotReusableResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchDelegationSet":
    case "com.amazon.webservices.dns.v20130401#NoSuchDelegationSet":
      response = await deserializeAws_restXmlNoSuchDelegationSetResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListHostedZonesByNameCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHostedZonesByNameCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListHostedZonesByNameCommandError(
      output,
      context
    );
  }
  const contents: ListHostedZonesByNameCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListHostedZonesByNameResponse",
    DNSName: undefined,
    HostedZoneId: undefined,
    HostedZones: undefined,
    IsTruncated: undefined,
    MaxItems: undefined,
    NextDNSName: undefined,
    NextHostedZoneId: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["DNSName"] !== undefined) {
    contents.DNSName = data["DNSName"];
  }
  if (data["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = data["HostedZoneId"];
  }
  if (data.HostedZones === "") {
    contents.HostedZones = [];
  }
  if (
    data["HostedZones"] !== undefined &&
    data["HostedZones"]["HostedZone"] !== undefined
  ) {
    const wrappedItem =
      data["HostedZones"]["HostedZone"] instanceof Array
        ? data["HostedZones"]["HostedZone"]
        : [data["HostedZones"]["HostedZone"]];
    contents.HostedZones = deserializeAws_restXmlHostedZones(
      wrappedItem,
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextDNSName"] !== undefined) {
    contents.NextDNSName = data["NextDNSName"];
  }
  if (data["NextHostedZoneId"] !== undefined) {
    contents.NextHostedZoneId = data["NextHostedZoneId"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListHostedZonesByNameCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListHostedZonesByNameCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidDomainName":
    case "com.amazon.webservices.dns.v20130401#InvalidDomainName":
      response = await deserializeAws_restXmlInvalidDomainNameResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListQueryLoggingConfigsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListQueryLoggingConfigsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListQueryLoggingConfigsCommandError(
      output,
      context
    );
  }
  const contents: ListQueryLoggingConfigsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListQueryLoggingConfigsResponse",
    NextToken: undefined,
    QueryLoggingConfigs: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["NextToken"] !== undefined) {
    contents.NextToken = data["NextToken"];
  }
  if (data.QueryLoggingConfigs === "") {
    contents.QueryLoggingConfigs = [];
  }
  if (
    data["QueryLoggingConfigs"] !== undefined &&
    data["QueryLoggingConfigs"]["QueryLoggingConfig"] !== undefined
  ) {
    const wrappedItem =
      data["QueryLoggingConfigs"]["QueryLoggingConfig"] instanceof Array
        ? data["QueryLoggingConfigs"]["QueryLoggingConfig"]
        : [data["QueryLoggingConfigs"]["QueryLoggingConfig"]];
    contents.QueryLoggingConfigs = deserializeAws_restXmlQueryLoggingConfigs(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListQueryLoggingConfigsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListQueryLoggingConfigsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidPaginationToken":
    case "com.amazon.webservices.dns.v20130401#InvalidPaginationToken":
      response = await deserializeAws_restXmlInvalidPaginationTokenResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListResourceRecordSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceRecordSetsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListResourceRecordSetsCommandError(
      output,
      context
    );
  }
  const contents: ListResourceRecordSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListResourceRecordSetsResponse",
    IsTruncated: undefined,
    MaxItems: undefined,
    NextRecordIdentifier: undefined,
    NextRecordName: undefined,
    NextRecordType: undefined,
    ResourceRecordSets: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextRecordIdentifier"] !== undefined) {
    contents.NextRecordIdentifier = data["NextRecordIdentifier"];
  }
  if (data["NextRecordName"] !== undefined) {
    contents.NextRecordName = data["NextRecordName"];
  }
  if (data["NextRecordType"] !== undefined) {
    contents.NextRecordType = data["NextRecordType"];
  }
  if (data.ResourceRecordSets === "") {
    contents.ResourceRecordSets = [];
  }
  if (
    data["ResourceRecordSets"] !== undefined &&
    data["ResourceRecordSets"]["ResourceRecordSet"] !== undefined
  ) {
    const wrappedItem =
      data["ResourceRecordSets"]["ResourceRecordSet"] instanceof Array
        ? data["ResourceRecordSets"]["ResourceRecordSet"]
        : [data["ResourceRecordSets"]["ResourceRecordSet"]];
    contents.ResourceRecordSets = deserializeAws_restXmlResourceRecordSets(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListResourceRecordSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListResourceRecordSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListReusableDelegationSetsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListReusableDelegationSetsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListReusableDelegationSetsCommandError(
      output,
      context
    );
  }
  const contents: ListReusableDelegationSetsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListReusableDelegationSetsResponse",
    DelegationSets: undefined,
    IsTruncated: undefined,
    Marker: undefined,
    MaxItems: undefined,
    NextMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.DelegationSets === "") {
    contents.DelegationSets = [];
  }
  if (
    data["DelegationSets"] !== undefined &&
    data["DelegationSets"]["DelegationSet"] !== undefined
  ) {
    const wrappedItem =
      data["DelegationSets"]["DelegationSet"] instanceof Array
        ? data["DelegationSets"]["DelegationSet"]
        : [data["DelegationSets"]["DelegationSet"]];
    contents.DelegationSets = deserializeAws_restXmlDelegationSets(
      wrappedItem,
      context
    );
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["Marker"] !== undefined) {
    contents.Marker = data["Marker"];
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["NextMarker"] !== undefined) {
    contents.NextMarker = data["NextMarker"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListReusableDelegationSetsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListReusableDelegationSetsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTagsForResourceCommandError(
      output,
      context
    );
  }
  const contents: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    ResourceTagSet: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["ResourceTagSet"] !== undefined) {
    contents.ResourceTagSet = deserializeAws_restXmlResourceTagSet(
      data["ResourceTagSet"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHealthCheck":
    case "com.amazon.webservices.dns.v20130401#NoSuchHealthCheck":
      response = await deserializeAws_restXmlNoSuchHealthCheckResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "PriorRequestNotComplete":
    case "com.amazon.webservices.dns.v20130401#PriorRequestNotComplete":
      response = await deserializeAws_restXmlPriorRequestNotCompleteResponse(
        parsedOutput,
        context
      );
      break;
    case "ThrottlingException":
    case "com.amazon.webservices.dns.v20130401#ThrottlingException":
      response = await deserializeAws_restXmlThrottlingExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListTagsForResourcesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourcesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTagsForResourcesCommandError(
      output,
      context
    );
  }
  const contents: ListTagsForResourcesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourcesResponse",
    ResourceTagSets: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data.ResourceTagSets === "") {
    contents.ResourceTagSets = [];
  }
  if (
    data["ResourceTagSets"] !== undefined &&
    data["ResourceTagSets"]["ResourceTagSet"] !== undefined
  ) {
    const wrappedItem =
      data["ResourceTagSets"]["ResourceTagSet"] instanceof Array
        ? data["ResourceTagSets"]["ResourceTagSet"]
        : [data["ResourceTagSets"]["ResourceTagSet"]];
    contents.ResourceTagSets = deserializeAws_restXmlResourceTagSetList(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListTagsForResourcesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourcesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHealthCheck":
    case "com.amazon.webservices.dns.v20130401#NoSuchHealthCheck":
      response = await deserializeAws_restXmlNoSuchHealthCheckResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "PriorRequestNotComplete":
    case "com.amazon.webservices.dns.v20130401#PriorRequestNotComplete":
      response = await deserializeAws_restXmlPriorRequestNotCompleteResponse(
        parsedOutput,
        context
      );
      break;
    case "ThrottlingException":
    case "com.amazon.webservices.dns.v20130401#ThrottlingException":
      response = await deserializeAws_restXmlThrottlingExceptionResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListTrafficPoliciesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPoliciesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTrafficPoliciesCommandError(
      output,
      context
    );
  }
  const contents: ListTrafficPoliciesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrafficPoliciesResponse",
    IsTruncated: undefined,
    MaxItems: undefined,
    TrafficPolicyIdMarker: undefined,
    TrafficPolicySummaries: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["TrafficPolicyIdMarker"] !== undefined) {
    contents.TrafficPolicyIdMarker = data["TrafficPolicyIdMarker"];
  }
  if (data.TrafficPolicySummaries === "") {
    contents.TrafficPolicySummaries = [];
  }
  if (
    data["TrafficPolicySummaries"] !== undefined &&
    data["TrafficPolicySummaries"]["TrafficPolicySummary"] !== undefined
  ) {
    const wrappedItem =
      data["TrafficPolicySummaries"]["TrafficPolicySummary"] instanceof Array
        ? data["TrafficPolicySummaries"]["TrafficPolicySummary"]
        : [data["TrafficPolicySummaries"]["TrafficPolicySummary"]];
    contents.TrafficPolicySummaries = deserializeAws_restXmlTrafficPolicySummaries(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListTrafficPoliciesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPoliciesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListTrafficPolicyInstancesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTrafficPolicyInstancesCommandError(
      output,
      context
    );
  }
  const contents: ListTrafficPolicyInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrafficPolicyInstancesResponse",
    HostedZoneIdMarker: undefined,
    IsTruncated: undefined,
    MaxItems: undefined,
    TrafficPolicyInstanceNameMarker: undefined,
    TrafficPolicyInstanceTypeMarker: undefined,
    TrafficPolicyInstances: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZoneIdMarker"] !== undefined) {
    contents.HostedZoneIdMarker = data["HostedZoneIdMarker"];
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["TrafficPolicyInstanceNameMarker"] !== undefined) {
    contents.TrafficPolicyInstanceNameMarker =
      data["TrafficPolicyInstanceNameMarker"];
  }
  if (data["TrafficPolicyInstanceTypeMarker"] !== undefined) {
    contents.TrafficPolicyInstanceTypeMarker =
      data["TrafficPolicyInstanceTypeMarker"];
  }
  if (data.TrafficPolicyInstances === "") {
    contents.TrafficPolicyInstances = [];
  }
  if (
    data["TrafficPolicyInstances"] !== undefined &&
    data["TrafficPolicyInstances"]["TrafficPolicyInstance"] !== undefined
  ) {
    const wrappedItem =
      data["TrafficPolicyInstances"]["TrafficPolicyInstance"] instanceof Array
        ? data["TrafficPolicyInstances"]["TrafficPolicyInstance"]
        : [data["TrafficPolicyInstances"]["TrafficPolicyInstance"]];
    contents.TrafficPolicyInstances = deserializeAws_restXmlTrafficPolicyInstances(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListTrafficPolicyInstancesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicyInstance":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListTrafficPolicyInstancesByHostedZoneCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesByHostedZoneCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTrafficPolicyInstancesByHostedZoneCommandError(
      output,
      context
    );
  }
  const contents: ListTrafficPolicyInstancesByHostedZoneCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrafficPolicyInstancesByHostedZoneResponse",
    IsTruncated: undefined,
    MaxItems: undefined,
    TrafficPolicyInstanceNameMarker: undefined,
    TrafficPolicyInstanceTypeMarker: undefined,
    TrafficPolicyInstances: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["TrafficPolicyInstanceNameMarker"] !== undefined) {
    contents.TrafficPolicyInstanceNameMarker =
      data["TrafficPolicyInstanceNameMarker"];
  }
  if (data["TrafficPolicyInstanceTypeMarker"] !== undefined) {
    contents.TrafficPolicyInstanceTypeMarker =
      data["TrafficPolicyInstanceTypeMarker"];
  }
  if (data.TrafficPolicyInstances === "") {
    contents.TrafficPolicyInstances = [];
  }
  if (
    data["TrafficPolicyInstances"] !== undefined &&
    data["TrafficPolicyInstances"]["TrafficPolicyInstance"] !== undefined
  ) {
    const wrappedItem =
      data["TrafficPolicyInstances"]["TrafficPolicyInstance"] instanceof Array
        ? data["TrafficPolicyInstances"]["TrafficPolicyInstance"]
        : [data["TrafficPolicyInstances"]["TrafficPolicyInstance"]];
    contents.TrafficPolicyInstances = deserializeAws_restXmlTrafficPolicyInstances(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListTrafficPolicyInstancesByHostedZoneCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesByHostedZoneCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicyInstance":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListTrafficPolicyInstancesByPolicyCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesByPolicyCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTrafficPolicyInstancesByPolicyCommandError(
      output,
      context
    );
  }
  const contents: ListTrafficPolicyInstancesByPolicyCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrafficPolicyInstancesByPolicyResponse",
    HostedZoneIdMarker: undefined,
    IsTruncated: undefined,
    MaxItems: undefined,
    TrafficPolicyInstanceNameMarker: undefined,
    TrafficPolicyInstanceTypeMarker: undefined,
    TrafficPolicyInstances: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZoneIdMarker"] !== undefined) {
    contents.HostedZoneIdMarker = data["HostedZoneIdMarker"];
  }
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data["TrafficPolicyInstanceNameMarker"] !== undefined) {
    contents.TrafficPolicyInstanceNameMarker =
      data["TrafficPolicyInstanceNameMarker"];
  }
  if (data["TrafficPolicyInstanceTypeMarker"] !== undefined) {
    contents.TrafficPolicyInstanceTypeMarker =
      data["TrafficPolicyInstanceTypeMarker"];
  }
  if (data.TrafficPolicyInstances === "") {
    contents.TrafficPolicyInstances = [];
  }
  if (
    data["TrafficPolicyInstances"] !== undefined &&
    data["TrafficPolicyInstances"]["TrafficPolicyInstance"] !== undefined
  ) {
    const wrappedItem =
      data["TrafficPolicyInstances"]["TrafficPolicyInstance"] instanceof Array
        ? data["TrafficPolicyInstances"]["TrafficPolicyInstance"]
        : [data["TrafficPolicyInstances"]["TrafficPolicyInstance"]];
    contents.TrafficPolicyInstances = deserializeAws_restXmlTrafficPolicyInstances(
      wrappedItem,
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListTrafficPolicyInstancesByPolicyCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyInstancesByPolicyCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicy":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicyInstance":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListTrafficPolicyVersionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyVersionsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListTrafficPolicyVersionsCommandError(
      output,
      context
    );
  }
  const contents: ListTrafficPolicyVersionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTrafficPolicyVersionsResponse",
    IsTruncated: undefined,
    MaxItems: undefined,
    TrafficPolicies: undefined,
    TrafficPolicyVersionMarker: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["IsTruncated"] !== undefined) {
    contents.IsTruncated = data["IsTruncated"] == "true";
  }
  if (data["MaxItems"] !== undefined) {
    contents.MaxItems = data["MaxItems"];
  }
  if (data.TrafficPolicies === "") {
    contents.TrafficPolicies = [];
  }
  if (
    data["TrafficPolicies"] !== undefined &&
    data["TrafficPolicies"]["TrafficPolicy"] !== undefined
  ) {
    const wrappedItem =
      data["TrafficPolicies"]["TrafficPolicy"] instanceof Array
        ? data["TrafficPolicies"]["TrafficPolicy"]
        : [data["TrafficPolicies"]["TrafficPolicy"]];
    contents.TrafficPolicies = deserializeAws_restXmlTrafficPolicies(
      wrappedItem,
      context
    );
  }
  if (data["TrafficPolicyVersionMarker"] !== undefined) {
    contents.TrafficPolicyVersionMarker = data["TrafficPolicyVersionMarker"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListTrafficPolicyVersionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTrafficPolicyVersionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicy":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlListVPCAssociationAuthorizationsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVPCAssociationAuthorizationsCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlListVPCAssociationAuthorizationsCommandError(
      output,
      context
    );
  }
  const contents: ListVPCAssociationAuthorizationsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListVPCAssociationAuthorizationsResponse",
    HostedZoneId: undefined,
    NextToken: undefined,
    VPCs: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = data["HostedZoneId"];
  }
  if (data["NextToken"] !== undefined) {
    contents.NextToken = data["NextToken"];
  }
  if (data.VPCs === "") {
    contents.VPCs = [];
  }
  if (data["VPCs"] !== undefined && data["VPCs"]["VPC"] !== undefined) {
    const wrappedItem =
      data["VPCs"]["VPC"] instanceof Array
        ? data["VPCs"]["VPC"]
        : [data["VPCs"]["VPC"]];
    contents.VPCs = deserializeAws_restXmlVPCs(wrappedItem, context);
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlListVPCAssociationAuthorizationsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListVPCAssociationAuthorizationsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidPaginationToken":
    case "com.amazon.webservices.dns.v20130401#InvalidPaginationToken":
      response = await deserializeAws_restXmlInvalidPaginationTokenResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlTestDNSAnswerCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestDNSAnswerCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlTestDNSAnswerCommandError(output, context);
  }
  const contents: TestDNSAnswerCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestDNSAnswerResponse",
    Nameserver: undefined,
    Protocol: undefined,
    RecordData: undefined,
    RecordName: undefined,
    RecordType: undefined,
    ResponseCode: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["Nameserver"] !== undefined) {
    contents.Nameserver = data["Nameserver"];
  }
  if (data["Protocol"] !== undefined) {
    contents.Protocol = data["Protocol"];
  }
  if (data.RecordData === "") {
    contents.RecordData = [];
  }
  if (
    data["RecordData"] !== undefined &&
    data["RecordData"]["RecordDataEntry"] !== undefined
  ) {
    const wrappedItem =
      data["RecordData"]["RecordDataEntry"] instanceof Array
        ? data["RecordData"]["RecordDataEntry"]
        : [data["RecordData"]["RecordDataEntry"]];
    contents.RecordData = deserializeAws_restXmlRecordData(
      wrappedItem,
      context
    );
  }
  if (data["RecordName"] !== undefined) {
    contents.RecordName = data["RecordName"];
  }
  if (data["RecordType"] !== undefined) {
    contents.RecordType = data["RecordType"];
  }
  if (data["ResponseCode"] !== undefined) {
    contents.ResponseCode = data["ResponseCode"];
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlTestDNSAnswerCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestDNSAnswerCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlUpdateHealthCheckCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateHealthCheckCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateHealthCheckCommandError(output, context);
  }
  const contents: UpdateHealthCheckCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateHealthCheckResponse",
    HealthCheck: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HealthCheck"] !== undefined) {
    contents.HealthCheck = deserializeAws_restXmlHealthCheck(
      data["HealthCheck"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlUpdateHealthCheckCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateHealthCheckCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "HealthCheckVersionMismatch":
    case "com.amazon.webservices.dns.v20130401#HealthCheckVersionMismatch":
      response = await deserializeAws_restXmlHealthCheckVersionMismatchResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHealthCheck":
    case "com.amazon.webservices.dns.v20130401#NoSuchHealthCheck":
      response = await deserializeAws_restXmlNoSuchHealthCheckResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlUpdateHostedZoneCommentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateHostedZoneCommentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateHostedZoneCommentCommandError(
      output,
      context
    );
  }
  const contents: UpdateHostedZoneCommentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateHostedZoneCommentResponse",
    HostedZone: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["HostedZone"] !== undefined) {
    contents.HostedZone = deserializeAws_restXmlHostedZone(
      data["HostedZone"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlUpdateHostedZoneCommentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateHostedZoneCommentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchHostedZone":
    case "com.amazon.webservices.dns.v20130401#NoSuchHostedZone":
      response = await deserializeAws_restXmlNoSuchHostedZoneResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlUpdateTrafficPolicyCommentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrafficPolicyCommentCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateTrafficPolicyCommentCommandError(
      output,
      context
    );
  }
  const contents: UpdateTrafficPolicyCommentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTrafficPolicyCommentResponse",
    TrafficPolicy: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicy"] !== undefined) {
    contents.TrafficPolicy = deserializeAws_restXmlTrafficPolicy(
      data["TrafficPolicy"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlUpdateTrafficPolicyCommentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrafficPolicyCommentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConcurrentModification":
    case "com.amazon.webservices.dns.v20130401#ConcurrentModification":
      response = await deserializeAws_restXmlConcurrentModificationResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicy":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_restXmlUpdateTrafficPolicyInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrafficPolicyInstanceCommandOutput> {
  if (output.statusCode !== 200 && output.statusCode >= 400) {
    return deserializeAws_restXmlUpdateTrafficPolicyInstanceCommandError(
      output,
      context
    );
  }
  const contents: UpdateTrafficPolicyInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "UpdateTrafficPolicyInstanceResponse",
    TrafficPolicyInstance: undefined
  };
  const data: any = await parseBody(output.body, context);
  if (data["TrafficPolicyInstance"] !== undefined) {
    contents.TrafficPolicyInstance = deserializeAws_restXmlTrafficPolicyInstance(
      data["TrafficPolicyInstance"],
      context
    );
  }
  return Promise.resolve(contents);
}

async function deserializeAws_restXmlUpdateTrafficPolicyInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<UpdateTrafficPolicyInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  errorCode = loadRestXmlErrorCode(output, parsedOutput.body);
  switch (errorCode) {
    case "ConflictingTypes":
    case "com.amazon.webservices.dns.v20130401#ConflictingTypes":
      response = await deserializeAws_restXmlConflictingTypesResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidInput":
    case "com.amazon.webservices.dns.v20130401#InvalidInput":
      response = await deserializeAws_restXmlInvalidInputResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicy":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicy":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyResponse(
        parsedOutput,
        context
      );
      break;
    case "NoSuchTrafficPolicyInstance":
    case "com.amazon.webservices.dns.v20130401#NoSuchTrafficPolicyInstance":
      response = await deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse(
        parsedOutput,
        context
      );
      break;
    case "PriorRequestNotComplete":
    case "com.amazon.webservices.dns.v20130401#PriorRequestNotComplete":
      response = await deserializeAws_restXmlPriorRequestNotCompleteResponse(
        parsedOutput,
        context
      );
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.Error.code || parsedBody.Error.Code || errorCode;
      response = {
        ...parsedBody.Error,
        name: `${errorCode}`,
        message:
          parsedBody.Error.message || parsedBody.Error.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_restXmlConcurrentModificationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConcurrentModification> => {
  const contents: ConcurrentModification = {
    name: "ConcurrentModification",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlConflictingDomainExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConflictingDomainExists> => {
  const contents: ConflictingDomainExists = {
    name: "ConflictingDomainExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlConflictingTypesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ConflictingTypes> => {
  const contents: ConflictingTypes = {
    name: "ConflictingTypes",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlDelegationSetAlreadyCreatedResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DelegationSetAlreadyCreated> => {
  const contents: DelegationSetAlreadyCreated = {
    name: "DelegationSetAlreadyCreated",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlDelegationSetAlreadyReusableResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DelegationSetAlreadyReusable> => {
  const contents: DelegationSetAlreadyReusable = {
    name: "DelegationSetAlreadyReusable",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlDelegationSetInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DelegationSetInUse> => {
  const contents: DelegationSetInUse = {
    name: "DelegationSetInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlDelegationSetNotAvailableResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DelegationSetNotAvailable> => {
  const contents: DelegationSetNotAvailable = {
    name: "DelegationSetNotAvailable",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlDelegationSetNotReusableResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<DelegationSetNotReusable> => {
  const contents: DelegationSetNotReusable = {
    name: "DelegationSetNotReusable",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlHealthCheckAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HealthCheckAlreadyExists> => {
  const contents: HealthCheckAlreadyExists = {
    name: "HealthCheckAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlHealthCheckInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HealthCheckInUse> => {
  const contents: HealthCheckInUse = {
    name: "HealthCheckInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlHealthCheckVersionMismatchResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HealthCheckVersionMismatch> => {
  const contents: HealthCheckVersionMismatch = {
    name: "HealthCheckVersionMismatch",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlHostedZoneAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HostedZoneAlreadyExists> => {
  const contents: HostedZoneAlreadyExists = {
    name: "HostedZoneAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlHostedZoneNotEmptyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HostedZoneNotEmpty> => {
  const contents: HostedZoneNotEmpty = {
    name: "HostedZoneNotEmpty",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlHostedZoneNotFoundResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HostedZoneNotFound> => {
  const contents: HostedZoneNotFound = {
    name: "HostedZoneNotFound",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlHostedZoneNotPrivateResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<HostedZoneNotPrivate> => {
  const contents: HostedZoneNotPrivate = {
    name: "HostedZoneNotPrivate",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlIncompatibleVersionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<IncompatibleVersion> => {
  const contents: IncompatibleVersion = {
    name: "IncompatibleVersion",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlInsufficientCloudWatchLogsResourcePolicyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InsufficientCloudWatchLogsResourcePolicy> => {
  const contents: InsufficientCloudWatchLogsResourcePolicy = {
    name: "InsufficientCloudWatchLogsResourcePolicy",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlInvalidArgumentResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidArgument> => {
  const contents: InvalidArgument = {
    name: "InvalidArgument",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlInvalidChangeBatchResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidChangeBatch> => {
  const contents: InvalidChangeBatch = {
    name: "InvalidChangeBatch",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined,
    messages: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlInvalidDomainNameResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidDomainName> => {
  const contents: InvalidDomainName = {
    name: "InvalidDomainName",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlInvalidInputResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidInput> => {
  const contents: InvalidInput = {
    name: "InvalidInput",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlInvalidPaginationTokenResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidPaginationToken> => {
  const contents: InvalidPaginationToken = {
    name: "InvalidPaginationToken",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlInvalidTrafficPolicyDocumentResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidTrafficPolicyDocument> => {
  const contents: InvalidTrafficPolicyDocument = {
    name: "InvalidTrafficPolicyDocument",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlInvalidVPCIdResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidVPCId> => {
  const contents: InvalidVPCId = {
    name: "InvalidVPCId",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlLastVPCAssociationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<LastVPCAssociation> => {
  const contents: LastVPCAssociation = {
    name: "LastVPCAssociation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlLimitsExceededResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<LimitsExceeded> => {
  const contents: LimitsExceeded = {
    name: "LimitsExceeded",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlNoSuchChangeResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchChange> => {
  const contents: NoSuchChange = {
    name: "NoSuchChange",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlNoSuchCloudWatchLogsLogGroupResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchCloudWatchLogsLogGroup> => {
  const contents: NoSuchCloudWatchLogsLogGroup = {
    name: "NoSuchCloudWatchLogsLogGroup",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlNoSuchDelegationSetResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchDelegationSet> => {
  const contents: NoSuchDelegationSet = {
    name: "NoSuchDelegationSet",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlNoSuchGeoLocationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchGeoLocation> => {
  const contents: NoSuchGeoLocation = {
    name: "NoSuchGeoLocation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlNoSuchHealthCheckResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchHealthCheck> => {
  const contents: NoSuchHealthCheck = {
    name: "NoSuchHealthCheck",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlNoSuchHostedZoneResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchHostedZone> => {
  const contents: NoSuchHostedZone = {
    name: "NoSuchHostedZone",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlNoSuchQueryLoggingConfigResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchQueryLoggingConfig> => {
  const contents: NoSuchQueryLoggingConfig = {
    name: "NoSuchQueryLoggingConfig",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlNoSuchTrafficPolicyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchTrafficPolicy> => {
  const contents: NoSuchTrafficPolicy = {
    name: "NoSuchTrafficPolicy",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlNoSuchTrafficPolicyInstanceResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NoSuchTrafficPolicyInstance> => {
  const contents: NoSuchTrafficPolicyInstance = {
    name: "NoSuchTrafficPolicyInstance",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlNotAuthorizedExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<NotAuthorizedException> => {
  const contents: NotAuthorizedException = {
    name: "NotAuthorizedException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlPriorRequestNotCompleteResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PriorRequestNotComplete> => {
  const contents: PriorRequestNotComplete = {
    name: "PriorRequestNotComplete",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlPublicZoneVPCAssociationResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<PublicZoneVPCAssociation> => {
  const contents: PublicZoneVPCAssociation = {
    name: "PublicZoneVPCAssociation",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlQueryLoggingConfigAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<QueryLoggingConfigAlreadyExists> => {
  const contents: QueryLoggingConfigAlreadyExists = {
    name: "QueryLoggingConfigAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlThrottlingExceptionResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ThrottlingException> => {
  const contents: ThrottlingException = {
    name: "ThrottlingException",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlTooManyHealthChecksResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyHealthChecks> => {
  const contents: TooManyHealthChecks = {
    name: "TooManyHealthChecks",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlTooManyHostedZonesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyHostedZones> => {
  const contents: TooManyHostedZones = {
    name: "TooManyHostedZones",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlTooManyTrafficPoliciesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTrafficPolicies> => {
  const contents: TooManyTrafficPolicies = {
    name: "TooManyTrafficPolicies",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlTooManyTrafficPolicyInstancesResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTrafficPolicyInstances> => {
  const contents: TooManyTrafficPolicyInstances = {
    name: "TooManyTrafficPolicyInstances",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlTooManyTrafficPolicyVersionsForCurrentPolicyResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyTrafficPolicyVersionsForCurrentPolicy> => {
  const contents: TooManyTrafficPolicyVersionsForCurrentPolicy = {
    name: "TooManyTrafficPolicyVersionsForCurrentPolicy",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlTooManyVPCAssociationAuthorizationsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TooManyVPCAssociationAuthorizations> => {
  const contents: TooManyVPCAssociationAuthorizations = {
    name: "TooManyVPCAssociationAuthorizations",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlTrafficPolicyAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TrafficPolicyAlreadyExists> => {
  const contents: TrafficPolicyAlreadyExists = {
    name: "TrafficPolicyAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlTrafficPolicyInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TrafficPolicyInUse> => {
  const contents: TrafficPolicyInUse = {
    name: "TrafficPolicyInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlTrafficPolicyInstanceAlreadyExistsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<TrafficPolicyInstanceAlreadyExists> => {
  const contents: TrafficPolicyInstanceAlreadyExists = {
    name: "TrafficPolicyInstanceAlreadyExists",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlVPCAssociationAuthorizationNotFoundResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<VPCAssociationAuthorizationNotFound> => {
  const contents: VPCAssociationAuthorizationNotFound = {
    name: "VPCAssociationAuthorizationNotFound",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const deserializeAws_restXmlVPCAssociationNotFoundResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<VPCAssociationNotFound> => {
  const contents: VPCAssociationNotFound = {
    name: "VPCAssociationNotFound",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    message: undefined
  };
  const data: any = parsedOutput.body.Error;
  return contents;
};

const serializeAws_restXmlAlarmIdentifier = (
  input: AlarmIdentifier,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AlarmIdentifier");
  if (input.Name !== undefined) {
    const memberNode = new __XmlNode("AlarmName").addChildNode(
      new __XmlText(input.Name)
    );
    bodyNode.addChildNode(memberNode.withName("Name"));
  }
  if (input.Region !== undefined) {
    const memberNode = new __XmlNode("CloudWatchRegion").addChildNode(
      new __XmlText(input.Region)
    );
    bodyNode.addChildNode(memberNode.withName("Region"));
  }
  return bodyNode;
};

const serializeAws_restXmlAliasTarget = (
  input: AliasTarget,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("AliasTarget");
  if (input.DNSName !== undefined) {
    const memberNode = new __XmlNode("DNSName").addChildNode(
      new __XmlText(input.DNSName)
    );
    bodyNode.addChildNode(memberNode.withName("DNSName"));
  }
  if (input.EvaluateTargetHealth !== undefined) {
    const memberNode = new __XmlNode("AliasHealthEnabled").addChildNode(
      new __XmlText(String(input.EvaluateTargetHealth))
    );
    bodyNode.addChildNode(memberNode.withName("EvaluateTargetHealth"));
  }
  if (input.HostedZoneId !== undefined) {
    const memberNode = new __XmlNode("ResourceId").addChildNode(
      new __XmlText(input.HostedZoneId)
    );
    bodyNode.addChildNode(memberNode.withName("HostedZoneId"));
  }
  return bodyNode;
};

const serializeAws_restXmlChange = (
  input: Change,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("Change");
  if (input.Action !== undefined) {
    const memberNode = new __XmlNode("ChangeAction").addChildNode(
      new __XmlText(input.Action)
    );
    bodyNode.addChildNode(memberNode.withName("Action"));
  }
  if (input.ResourceRecordSet !== undefined) {
    const memberNode = serializeAws_restXmlResourceRecordSet(
      input.ResourceRecordSet,
      context
    );
    bodyNode.addChildNode(memberNode.withName("ResourceRecordSet"));
  }
  return bodyNode;
};

const serializeAws_restXmlChangeBatch = (
  input: ChangeBatch,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ChangeBatch");
  if (input.Changes !== undefined) {
    const nodes = serializeAws_restXmlChanges(input.Changes, context);
    const containerNode = new __XmlNode("Changes");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Comment !== undefined) {
    const memberNode = new __XmlNode("ResourceDescription").addChildNode(
      new __XmlText(input.Comment)
    );
    bodyNode.addChildNode(memberNode.withName("Comment"));
  }
  return bodyNode;
};

const serializeAws_restXmlChanges = (
  input: Array<Change>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  (input || []).map(entry => {
    const node = serializeAws_restXmlChange(entry, context);
    collectedNodes.push(node.withName("Change"));
  });
  return collectedNodes;
};

const serializeAws_restXmlChildHealthCheckList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  (input || []).map(entry => {
    const node = new __XmlNode("HealthCheckId").addChildNode(
      new __XmlText(entry)
    );
    collectedNodes.push(node.withName("ChildHealthCheck"));
  });
  return collectedNodes;
};

const serializeAws_restXmlGeoLocation = (
  input: GeoLocation,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("GeoLocation");
  if (input.ContinentCode !== undefined) {
    const memberNode = new __XmlNode("GeoLocationContinentCode").addChildNode(
      new __XmlText(input.ContinentCode)
    );
    bodyNode.addChildNode(memberNode.withName("ContinentCode"));
  }
  if (input.CountryCode !== undefined) {
    const memberNode = new __XmlNode("GeoLocationCountryCode").addChildNode(
      new __XmlText(input.CountryCode)
    );
    bodyNode.addChildNode(memberNode.withName("CountryCode"));
  }
  if (input.SubdivisionCode !== undefined) {
    const memberNode = new __XmlNode("GeoLocationSubdivisionCode").addChildNode(
      new __XmlText(input.SubdivisionCode)
    );
    bodyNode.addChildNode(memberNode.withName("SubdivisionCode"));
  }
  return bodyNode;
};

const serializeAws_restXmlHealthCheckConfig = (
  input: HealthCheckConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("HealthCheckConfig");
  if (input.AlarmIdentifier !== undefined) {
    const memberNode = serializeAws_restXmlAlarmIdentifier(
      input.AlarmIdentifier,
      context
    );
    bodyNode.addChildNode(memberNode.withName("AlarmIdentifier"));
  }
  if (input.ChildHealthChecks !== undefined) {
    const nodes = serializeAws_restXmlChildHealthCheckList(
      input.ChildHealthChecks,
      context
    );
    const containerNode = new __XmlNode("ChildHealthChecks");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.Disabled !== undefined) {
    const memberNode = new __XmlNode("Disabled").addChildNode(
      new __XmlText(String(input.Disabled))
    );
    bodyNode.addChildNode(memberNode.withName("Disabled"));
  }
  if (input.EnableSNI !== undefined) {
    const memberNode = new __XmlNode("EnableSNI").addChildNode(
      new __XmlText(String(input.EnableSNI))
    );
    bodyNode.addChildNode(memberNode.withName("EnableSNI"));
  }
  if (input.FailureThreshold !== undefined) {
    const memberNode = new __XmlNode("FailureThreshold").addChildNode(
      new __XmlText(String(input.FailureThreshold))
    );
    bodyNode.addChildNode(memberNode.withName("FailureThreshold"));
  }
  if (input.FullyQualifiedDomainName !== undefined) {
    const memberNode = new __XmlNode("FullyQualifiedDomainName").addChildNode(
      new __XmlText(input.FullyQualifiedDomainName)
    );
    bodyNode.addChildNode(memberNode.withName("FullyQualifiedDomainName"));
  }
  if (input.HealthThreshold !== undefined) {
    const memberNode = new __XmlNode("HealthThreshold").addChildNode(
      new __XmlText(String(input.HealthThreshold))
    );
    bodyNode.addChildNode(memberNode.withName("HealthThreshold"));
  }
  if (input.IPAddress !== undefined) {
    const memberNode = new __XmlNode("IPAddress").addChildNode(
      new __XmlText(input.IPAddress)
    );
    bodyNode.addChildNode(memberNode.withName("IPAddress"));
  }
  if (input.InsufficientDataHealthStatus !== undefined) {
    const memberNode = new __XmlNode(
      "InsufficientDataHealthStatus"
    ).addChildNode(new __XmlText(input.InsufficientDataHealthStatus));
    bodyNode.addChildNode(memberNode.withName("InsufficientDataHealthStatus"));
  }
  if (input.Inverted !== undefined) {
    const memberNode = new __XmlNode("Inverted").addChildNode(
      new __XmlText(String(input.Inverted))
    );
    bodyNode.addChildNode(memberNode.withName("Inverted"));
  }
  if (input.MeasureLatency !== undefined) {
    const memberNode = new __XmlNode("MeasureLatency").addChildNode(
      new __XmlText(String(input.MeasureLatency))
    );
    bodyNode.addChildNode(memberNode.withName("MeasureLatency"));
  }
  if (input.Port !== undefined) {
    const memberNode = new __XmlNode("Port").addChildNode(
      new __XmlText(String(input.Port))
    );
    bodyNode.addChildNode(memberNode.withName("Port"));
  }
  if (input.Regions !== undefined) {
    const nodes = serializeAws_restXmlHealthCheckRegionList(
      input.Regions,
      context
    );
    const containerNode = new __XmlNode("Regions");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.RequestInterval !== undefined) {
    const memberNode = new __XmlNode("RequestInterval").addChildNode(
      new __XmlText(String(input.RequestInterval))
    );
    bodyNode.addChildNode(memberNode.withName("RequestInterval"));
  }
  if (input.ResourcePath !== undefined) {
    const memberNode = new __XmlNode("ResourcePath").addChildNode(
      new __XmlText(input.ResourcePath)
    );
    bodyNode.addChildNode(memberNode.withName("ResourcePath"));
  }
  if (input.SearchString !== undefined) {
    const memberNode = new __XmlNode("SearchString").addChildNode(
      new __XmlText(input.SearchString)
    );
    bodyNode.addChildNode(memberNode.withName("SearchString"));
  }
  if (input.Type !== undefined) {
    const memberNode = new __XmlNode("HealthCheckType").addChildNode(
      new __XmlText(input.Type)
    );
    bodyNode.addChildNode(memberNode.withName("Type"));
  }
  return bodyNode;
};

const serializeAws_restXmlHealthCheckRegionList = (
  input: Array<HealthCheckRegion | string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  (input || []).map(entry => {
    const node = new __XmlNode("HealthCheckRegion").addChildNode(
      new __XmlText(entry)
    );
    collectedNodes.push(node.withName("Region"));
  });
  return collectedNodes;
};

const serializeAws_restXmlHostedZoneConfig = (
  input: HostedZoneConfig,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("HostedZoneConfig");
  if (input.Comment !== undefined) {
    const memberNode = new __XmlNode("ResourceDescription").addChildNode(
      new __XmlText(input.Comment)
    );
    bodyNode.addChildNode(memberNode.withName("Comment"));
  }
  if (input.PrivateZone !== undefined) {
    const memberNode = new __XmlNode("IsPrivateZone").addChildNode(
      new __XmlText(String(input.PrivateZone))
    );
    bodyNode.addChildNode(memberNode.withName("PrivateZone"));
  }
  return bodyNode;
};

const serializeAws_restXmlResettableElementNameList = (
  input: Array<ResettableElementName | string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  (input || []).map(entry => {
    const node = new __XmlNode("ResettableElementName").addChildNode(
      new __XmlText(entry)
    );
    collectedNodes.push(node.withName("ResettableElementName"));
  });
  return collectedNodes;
};

const serializeAws_restXmlResourceRecord = (
  input: ResourceRecord,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ResourceRecord");
  if (input.Value !== undefined) {
    const memberNode = new __XmlNode("RData").addChildNode(
      new __XmlText(input.Value)
    );
    bodyNode.addChildNode(memberNode.withName("Value"));
  }
  return bodyNode;
};

const serializeAws_restXmlResourceRecordSet = (
  input: ResourceRecordSet,
  context: __SerdeContext
): any => {
  const bodyNode = new __XmlNode("ResourceRecordSet");
  if (input.AliasTarget !== undefined) {
    const memberNode = serializeAws_restXmlAliasTarget(
      input.AliasTarget,
      context
    );
    bodyNode.addChildNode(memberNode.withName("AliasTarget"));
  }
  if (input.Failover !== undefined) {
    const memberNode = new __XmlNode("ResourceRecordSetFailover").addChildNode(
      new __XmlText(input.Failover)
    );
    bodyNode.addChildNode(memberNode.withName("Failover"));
  }
  if (input.GeoLocation !== undefined) {
    const memberNode = serializeAws_restXmlGeoLocation(
      input.GeoLocation,
      context
    );
    bodyNode.addChildNode(memberNode.withName("GeoLocation"));
  }
  if (input.HealthCheckId !== undefined) {
    const memberNode = new __XmlNode("HealthCheckId").addChildNode(
      new __XmlText(input.HealthCheckId)
    );
    bodyNode.addChildNode(memberNode.withName("HealthCheckId"));
  }
  if (input.MultiValueAnswer !== undefined) {
    const memberNode = new __XmlNode(
      "ResourceRecordSetMultiValueAnswer"
    ).addChildNode(new __XmlText(String(input.MultiValueAnswer)));
    bodyNode.addChildNode(memberNode.withName("MultiValueAnswer"));
  }
  if (input.Name !== undefined) {
    const memberNode = new __XmlNode("DNSName").addChildNode(
      new __XmlText(input.Name)
    );
    bodyNode.addChildNode(memberNode.withName("Name"));
  }
  if (input.Region !== undefined) {
    const memberNode = new __XmlNode("ResourceRecordSetRegion").addChildNode(
      new __XmlText(input.Region)
    );
    bodyNode.addChildNode(memberNode.withName("Region"));
  }
  if (input.ResourceRecords !== undefined) {
    const nodes = serializeAws_restXmlResourceRecords(
      input.ResourceRecords,
      context
    );
    const containerNode = new __XmlNode("ResourceRecords");
    nodes.map((node: any) => {
      containerNode.addChildNode(node);
    });
    bodyNode.addChildNode(containerNode);
  }
  if (input.SetIdentifier !== undefined) {
    const memberNode = new __XmlNode(
      "ResourceRecordSetIdentifier"
    ).addChildNode(new __XmlText(input.SetIdentifier));
    bodyNode.addChildNode(memberNode.withName("SetIdentifier"));
  }
  if (input.TTL !== undefined) {
    const memberNode = new __XmlNode("TTL").addChildNode(
      new __XmlText(String(input.TTL))
    );
    bodyNode.addChildNode(memberNode.withName("TTL"));
  }
  if (input.TrafficPolicyInstanceId !== undefined) {
    const memberNode = new __XmlNode("TrafficPolicyInstanceId").addChildNode(
      new __XmlText(input.TrafficPolicyInstanceId)
    );
    bodyNode.addChildNode(memberNode.withName("TrafficPolicyInstanceId"));
  }
  if (input.Type !== undefined) {
    const memberNode = new __XmlNode("RRType").addChildNode(
      new __XmlText(input.Type)
    );
    bodyNode.addChildNode(memberNode.withName("Type"));
  }
  if (input.Weight !== undefined) {
    const memberNode = new __XmlNode("ResourceRecordSetWeight").addChildNode(
      new __XmlText(String(input.Weight))
    );
    bodyNode.addChildNode(memberNode.withName("Weight"));
  }
  return bodyNode;
};

const serializeAws_restXmlResourceRecords = (
  input: Array<ResourceRecord>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  (input || []).map(entry => {
    const node = serializeAws_restXmlResourceRecord(entry, context);
    collectedNodes.push(node.withName("ResourceRecord"));
  });
  return collectedNodes;
};

const serializeAws_restXmlTag = (input: Tag, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("Tag");
  if (input.Key !== undefined) {
    const memberNode = new __XmlNode("TagKey").addChildNode(
      new __XmlText(input.Key)
    );
    bodyNode.addChildNode(memberNode.withName("Key"));
  }
  if (input.Value !== undefined) {
    const memberNode = new __XmlNode("TagValue").addChildNode(
      new __XmlText(input.Value)
    );
    bodyNode.addChildNode(memberNode.withName("Value"));
  }
  return bodyNode;
};

const serializeAws_restXmlTagKeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  (input || []).map(entry => {
    const node = new __XmlNode("TagKey").addChildNode(new __XmlText(entry));
    collectedNodes.push(node.withName("Key"));
  });
  return collectedNodes;
};

const serializeAws_restXmlTagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  (input || []).map(entry => {
    const node = serializeAws_restXmlTag(entry, context);
    collectedNodes.push(node.withName("Tag"));
  });
  return collectedNodes;
};

const serializeAws_restXmlTagResourceIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const collectedNodes: any = [];
  (input || []).map(entry => {
    const node = new __XmlNode("TagResourceId").addChildNode(
      new __XmlText(entry)
    );
    collectedNodes.push(node.withName("ResourceId"));
  });
  return collectedNodes;
};

const serializeAws_restXmlVPC = (input: VPC, context: __SerdeContext): any => {
  const bodyNode = new __XmlNode("VPC");
  if (input.VPCId !== undefined) {
    const memberNode = new __XmlNode("VPCId").addChildNode(
      new __XmlText(input.VPCId)
    );
    bodyNode.addChildNode(memberNode.withName("VPCId"));
  }
  if (input.VPCRegion !== undefined) {
    const memberNode = new __XmlNode("VPCRegion").addChildNode(
      new __XmlText(input.VPCRegion)
    );
    bodyNode.addChildNode(memberNode.withName("VPCRegion"));
  }
  return bodyNode;
};

const deserializeAws_restXmlAccountLimit = (
  output: any,
  context: __SerdeContext
): AccountLimit => {
  let contents: any = {
    __type: "AccountLimit",
    Type: undefined,
    Value: undefined
  };
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = parseInt(output["Value"]);
  }
  return contents;
};

const deserializeAws_restXmlAlarmIdentifier = (
  output: any,
  context: __SerdeContext
): AlarmIdentifier => {
  let contents: any = {
    __type: "AlarmIdentifier",
    Name: undefined,
    Region: undefined
  };
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["Region"] !== undefined) {
    contents.Region = output["Region"];
  }
  return contents;
};

const deserializeAws_restXmlAliasTarget = (
  output: any,
  context: __SerdeContext
): AliasTarget => {
  let contents: any = {
    __type: "AliasTarget",
    DNSName: undefined,
    EvaluateTargetHealth: undefined,
    HostedZoneId: undefined
  };
  if (output["DNSName"] !== undefined) {
    contents.DNSName = output["DNSName"];
  }
  if (output["EvaluateTargetHealth"] !== undefined) {
    contents.EvaluateTargetHealth = output["EvaluateTargetHealth"] == "true";
  }
  if (output["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = output["HostedZoneId"];
  }
  return contents;
};

const deserializeAws_restXmlChangeInfo = (
  output: any,
  context: __SerdeContext
): ChangeInfo => {
  let contents: any = {
    __type: "ChangeInfo",
    Comment: undefined,
    Id: undefined,
    Status: undefined,
    SubmittedAt: undefined
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  if (output["SubmittedAt"] !== undefined) {
    contents.SubmittedAt = new Date(output["SubmittedAt"]);
  }
  return contents;
};

const deserializeAws_restXmlCheckerIpRanges = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlChildHealthCheckList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlCloudWatchAlarmConfiguration = (
  output: any,
  context: __SerdeContext
): CloudWatchAlarmConfiguration => {
  let contents: any = {
    __type: "CloudWatchAlarmConfiguration",
    ComparisonOperator: undefined,
    Dimensions: undefined,
    EvaluationPeriods: undefined,
    MetricName: undefined,
    Namespace: undefined,
    Period: undefined,
    Statistic: undefined,
    Threshold: undefined
  };
  if (output["ComparisonOperator"] !== undefined) {
    contents.ComparisonOperator = output["ComparisonOperator"];
  }
  if (output.Dimensions === "") {
    contents.Dimensions = [];
  }
  if (
    output["Dimensions"] !== undefined &&
    output["Dimensions"]["Dimension"] !== undefined
  ) {
    const wrappedItem =
      output["Dimensions"]["Dimension"] instanceof Array
        ? output["Dimensions"]["Dimension"]
        : [output["Dimensions"]["Dimension"]];
    contents.Dimensions = deserializeAws_restXmlDimensionList(
      wrappedItem,
      context
    );
  }
  if (output["EvaluationPeriods"] !== undefined) {
    contents.EvaluationPeriods = parseInt(output["EvaluationPeriods"]);
  }
  if (output["MetricName"] !== undefined) {
    contents.MetricName = output["MetricName"];
  }
  if (output["Namespace"] !== undefined) {
    contents.Namespace = output["Namespace"];
  }
  if (output["Period"] !== undefined) {
    contents.Period = parseInt(output["Period"]);
  }
  if (output["Statistic"] !== undefined) {
    contents.Statistic = output["Statistic"];
  }
  if (output["Threshold"] !== undefined) {
    contents.Threshold = parseFloat(output["Threshold"]);
  }
  return contents;
};

const deserializeAws_restXmlDelegationSet = (
  output: any,
  context: __SerdeContext
): DelegationSet => {
  let contents: any = {
    __type: "DelegationSet",
    CallerReference: undefined,
    Id: undefined,
    NameServers: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output.NameServers === "") {
    contents.NameServers = [];
  }
  if (
    output["NameServers"] !== undefined &&
    output["NameServers"]["NameServer"] !== undefined
  ) {
    const wrappedItem =
      output["NameServers"]["NameServer"] instanceof Array
        ? output["NameServers"]["NameServer"]
        : [output["NameServers"]["NameServer"]];
    contents.NameServers = deserializeAws_restXmlDelegationSetNameServers(
      wrappedItem,
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlDelegationSetNameServers = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlDelegationSets = (
  output: any,
  context: __SerdeContext
): Array<DelegationSet> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlDelegationSet(entry, context)
  );
};

const deserializeAws_restXmlDimension = (
  output: any,
  context: __SerdeContext
): Dimension => {
  let contents: any = {
    __type: "Dimension",
    Name: undefined,
    Value: undefined
  };
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_restXmlDimensionList = (
  output: any,
  context: __SerdeContext
): Array<Dimension> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlDimension(entry, context)
  );
};

const deserializeAws_restXmlErrorMessages = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlGeoLocation = (
  output: any,
  context: __SerdeContext
): GeoLocation => {
  let contents: any = {
    __type: "GeoLocation",
    ContinentCode: undefined,
    CountryCode: undefined,
    SubdivisionCode: undefined
  };
  if (output["ContinentCode"] !== undefined) {
    contents.ContinentCode = output["ContinentCode"];
  }
  if (output["CountryCode"] !== undefined) {
    contents.CountryCode = output["CountryCode"];
  }
  if (output["SubdivisionCode"] !== undefined) {
    contents.SubdivisionCode = output["SubdivisionCode"];
  }
  return contents;
};

const deserializeAws_restXmlGeoLocationDetails = (
  output: any,
  context: __SerdeContext
): GeoLocationDetails => {
  let contents: any = {
    __type: "GeoLocationDetails",
    ContinentCode: undefined,
    ContinentName: undefined,
    CountryCode: undefined,
    CountryName: undefined,
    SubdivisionCode: undefined,
    SubdivisionName: undefined
  };
  if (output["ContinentCode"] !== undefined) {
    contents.ContinentCode = output["ContinentCode"];
  }
  if (output["ContinentName"] !== undefined) {
    contents.ContinentName = output["ContinentName"];
  }
  if (output["CountryCode"] !== undefined) {
    contents.CountryCode = output["CountryCode"];
  }
  if (output["CountryName"] !== undefined) {
    contents.CountryName = output["CountryName"];
  }
  if (output["SubdivisionCode"] !== undefined) {
    contents.SubdivisionCode = output["SubdivisionCode"];
  }
  if (output["SubdivisionName"] !== undefined) {
    contents.SubdivisionName = output["SubdivisionName"];
  }
  return contents;
};

const deserializeAws_restXmlGeoLocationDetailsList = (
  output: any,
  context: __SerdeContext
): Array<GeoLocationDetails> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlGeoLocationDetails(entry, context)
  );
};

const deserializeAws_restXmlHealthCheck = (
  output: any,
  context: __SerdeContext
): HealthCheck => {
  let contents: any = {
    __type: "HealthCheck",
    CallerReference: undefined,
    CloudWatchAlarmConfiguration: undefined,
    HealthCheckConfig: undefined,
    HealthCheckVersion: undefined,
    Id: undefined,
    LinkedService: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["CloudWatchAlarmConfiguration"] !== undefined) {
    contents.CloudWatchAlarmConfiguration = deserializeAws_restXmlCloudWatchAlarmConfiguration(
      output["CloudWatchAlarmConfiguration"],
      context
    );
  }
  if (output["HealthCheckConfig"] !== undefined) {
    contents.HealthCheckConfig = deserializeAws_restXmlHealthCheckConfig(
      output["HealthCheckConfig"],
      context
    );
  }
  if (output["HealthCheckVersion"] !== undefined) {
    contents.HealthCheckVersion = parseInt(output["HealthCheckVersion"]);
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LinkedService"] !== undefined) {
    contents.LinkedService = deserializeAws_restXmlLinkedService(
      output["LinkedService"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlHealthCheckConfig = (
  output: any,
  context: __SerdeContext
): HealthCheckConfig => {
  let contents: any = {
    __type: "HealthCheckConfig",
    AlarmIdentifier: undefined,
    ChildHealthChecks: undefined,
    Disabled: undefined,
    EnableSNI: undefined,
    FailureThreshold: undefined,
    FullyQualifiedDomainName: undefined,
    HealthThreshold: undefined,
    IPAddress: undefined,
    InsufficientDataHealthStatus: undefined,
    Inverted: undefined,
    MeasureLatency: undefined,
    Port: undefined,
    Regions: undefined,
    RequestInterval: undefined,
    ResourcePath: undefined,
    SearchString: undefined,
    Type: undefined
  };
  if (output["AlarmIdentifier"] !== undefined) {
    contents.AlarmIdentifier = deserializeAws_restXmlAlarmIdentifier(
      output["AlarmIdentifier"],
      context
    );
  }
  if (output.ChildHealthChecks === "") {
    contents.ChildHealthChecks = [];
  }
  if (
    output["ChildHealthChecks"] !== undefined &&
    output["ChildHealthChecks"]["ChildHealthCheck"] !== undefined
  ) {
    const wrappedItem =
      output["ChildHealthChecks"]["ChildHealthCheck"] instanceof Array
        ? output["ChildHealthChecks"]["ChildHealthCheck"]
        : [output["ChildHealthChecks"]["ChildHealthCheck"]];
    contents.ChildHealthChecks = deserializeAws_restXmlChildHealthCheckList(
      wrappedItem,
      context
    );
  }
  if (output["Disabled"] !== undefined) {
    contents.Disabled = output["Disabled"] == "true";
  }
  if (output["EnableSNI"] !== undefined) {
    contents.EnableSNI = output["EnableSNI"] == "true";
  }
  if (output["FailureThreshold"] !== undefined) {
    contents.FailureThreshold = parseInt(output["FailureThreshold"]);
  }
  if (output["FullyQualifiedDomainName"] !== undefined) {
    contents.FullyQualifiedDomainName = output["FullyQualifiedDomainName"];
  }
  if (output["HealthThreshold"] !== undefined) {
    contents.HealthThreshold = parseInt(output["HealthThreshold"]);
  }
  if (output["IPAddress"] !== undefined) {
    contents.IPAddress = output["IPAddress"];
  }
  if (output["InsufficientDataHealthStatus"] !== undefined) {
    contents.InsufficientDataHealthStatus =
      output["InsufficientDataHealthStatus"];
  }
  if (output["Inverted"] !== undefined) {
    contents.Inverted = output["Inverted"] == "true";
  }
  if (output["MeasureLatency"] !== undefined) {
    contents.MeasureLatency = output["MeasureLatency"] == "true";
  }
  if (output["Port"] !== undefined) {
    contents.Port = parseInt(output["Port"]);
  }
  if (output.Regions === "") {
    contents.Regions = [];
  }
  if (
    output["Regions"] !== undefined &&
    output["Regions"]["Region"] !== undefined
  ) {
    const wrappedItem =
      output["Regions"]["Region"] instanceof Array
        ? output["Regions"]["Region"]
        : [output["Regions"]["Region"]];
    contents.Regions = deserializeAws_restXmlHealthCheckRegionList(
      wrappedItem,
      context
    );
  }
  if (output["RequestInterval"] !== undefined) {
    contents.RequestInterval = parseInt(output["RequestInterval"]);
  }
  if (output["ResourcePath"] !== undefined) {
    contents.ResourcePath = output["ResourcePath"];
  }
  if (output["SearchString"] !== undefined) {
    contents.SearchString = output["SearchString"];
  }
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  return contents;
};

const deserializeAws_restXmlHealthCheckObservation = (
  output: any,
  context: __SerdeContext
): HealthCheckObservation => {
  let contents: any = {
    __type: "HealthCheckObservation",
    IPAddress: undefined,
    Region: undefined,
    StatusReport: undefined
  };
  if (output["IPAddress"] !== undefined) {
    contents.IPAddress = output["IPAddress"];
  }
  if (output["Region"] !== undefined) {
    contents.Region = output["Region"];
  }
  if (output["StatusReport"] !== undefined) {
    contents.StatusReport = deserializeAws_restXmlStatusReport(
      output["StatusReport"],
      context
    );
  }
  return contents;
};

const deserializeAws_restXmlHealthCheckObservations = (
  output: any,
  context: __SerdeContext
): Array<HealthCheckObservation> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlHealthCheckObservation(entry, context)
  );
};

const deserializeAws_restXmlHealthCheckRegionList = (
  output: any,
  context: __SerdeContext
): Array<HealthCheckRegion | string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlHealthChecks = (
  output: any,
  context: __SerdeContext
): Array<HealthCheck> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlHealthCheck(entry, context)
  );
};

const deserializeAws_restXmlHostedZone = (
  output: any,
  context: __SerdeContext
): HostedZone => {
  let contents: any = {
    __type: "HostedZone",
    CallerReference: undefined,
    Config: undefined,
    Id: undefined,
    LinkedService: undefined,
    Name: undefined,
    ResourceRecordSetCount: undefined
  };
  if (output["CallerReference"] !== undefined) {
    contents.CallerReference = output["CallerReference"];
  }
  if (output["Config"] !== undefined) {
    contents.Config = deserializeAws_restXmlHostedZoneConfig(
      output["Config"],
      context
    );
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LinkedService"] !== undefined) {
    contents.LinkedService = deserializeAws_restXmlLinkedService(
      output["LinkedService"],
      context
    );
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["ResourceRecordSetCount"] !== undefined) {
    contents.ResourceRecordSetCount = parseInt(
      output["ResourceRecordSetCount"]
    );
  }
  return contents;
};

const deserializeAws_restXmlHostedZoneConfig = (
  output: any,
  context: __SerdeContext
): HostedZoneConfig => {
  let contents: any = {
    __type: "HostedZoneConfig",
    Comment: undefined,
    PrivateZone: undefined
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["PrivateZone"] !== undefined) {
    contents.PrivateZone = output["PrivateZone"] == "true";
  }
  return contents;
};

const deserializeAws_restXmlHostedZoneLimit = (
  output: any,
  context: __SerdeContext
): HostedZoneLimit => {
  let contents: any = {
    __type: "HostedZoneLimit",
    Type: undefined,
    Value: undefined
  };
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = parseInt(output["Value"]);
  }
  return contents;
};

const deserializeAws_restXmlHostedZones = (
  output: any,
  context: __SerdeContext
): Array<HostedZone> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlHostedZone(entry, context)
  );
};

const deserializeAws_restXmlLinkedService = (
  output: any,
  context: __SerdeContext
): LinkedService => {
  let contents: any = {
    __type: "LinkedService",
    Description: undefined,
    ServicePrincipal: undefined
  };
  if (output["Description"] !== undefined) {
    contents.Description = output["Description"];
  }
  if (output["ServicePrincipal"] !== undefined) {
    contents.ServicePrincipal = output["ServicePrincipal"];
  }
  return contents;
};

const deserializeAws_restXmlQueryLoggingConfig = (
  output: any,
  context: __SerdeContext
): QueryLoggingConfig => {
  let contents: any = {
    __type: "QueryLoggingConfig",
    CloudWatchLogsLogGroupArn: undefined,
    HostedZoneId: undefined,
    Id: undefined
  };
  if (output["CloudWatchLogsLogGroupArn"] !== undefined) {
    contents.CloudWatchLogsLogGroupArn = output["CloudWatchLogsLogGroupArn"];
  }
  if (output["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = output["HostedZoneId"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  return contents;
};

const deserializeAws_restXmlQueryLoggingConfigs = (
  output: any,
  context: __SerdeContext
): Array<QueryLoggingConfig> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlQueryLoggingConfig(entry, context)
  );
};

const deserializeAws_restXmlRecordData = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_restXmlResourceRecord = (
  output: any,
  context: __SerdeContext
): ResourceRecord => {
  let contents: any = {
    __type: "ResourceRecord",
    Value: undefined
  };
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_restXmlResourceRecordSet = (
  output: any,
  context: __SerdeContext
): ResourceRecordSet => {
  let contents: any = {
    __type: "ResourceRecordSet",
    AliasTarget: undefined,
    Failover: undefined,
    GeoLocation: undefined,
    HealthCheckId: undefined,
    MultiValueAnswer: undefined,
    Name: undefined,
    Region: undefined,
    ResourceRecords: undefined,
    SetIdentifier: undefined,
    TTL: undefined,
    TrafficPolicyInstanceId: undefined,
    Type: undefined,
    Weight: undefined
  };
  if (output["AliasTarget"] !== undefined) {
    contents.AliasTarget = deserializeAws_restXmlAliasTarget(
      output["AliasTarget"],
      context
    );
  }
  if (output["Failover"] !== undefined) {
    contents.Failover = output["Failover"];
  }
  if (output["GeoLocation"] !== undefined) {
    contents.GeoLocation = deserializeAws_restXmlGeoLocation(
      output["GeoLocation"],
      context
    );
  }
  if (output["HealthCheckId"] !== undefined) {
    contents.HealthCheckId = output["HealthCheckId"];
  }
  if (output["MultiValueAnswer"] !== undefined) {
    contents.MultiValueAnswer = output["MultiValueAnswer"] == "true";
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["Region"] !== undefined) {
    contents.Region = output["Region"];
  }
  if (output.ResourceRecords === "") {
    contents.ResourceRecords = [];
  }
  if (
    output["ResourceRecords"] !== undefined &&
    output["ResourceRecords"]["ResourceRecord"] !== undefined
  ) {
    const wrappedItem =
      output["ResourceRecords"]["ResourceRecord"] instanceof Array
        ? output["ResourceRecords"]["ResourceRecord"]
        : [output["ResourceRecords"]["ResourceRecord"]];
    contents.ResourceRecords = deserializeAws_restXmlResourceRecords(
      wrappedItem,
      context
    );
  }
  if (output["SetIdentifier"] !== undefined) {
    contents.SetIdentifier = output["SetIdentifier"];
  }
  if (output["TTL"] !== undefined) {
    contents.TTL = parseInt(output["TTL"]);
  }
  if (output["TrafficPolicyInstanceId"] !== undefined) {
    contents.TrafficPolicyInstanceId = output["TrafficPolicyInstanceId"];
  }
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  if (output["Weight"] !== undefined) {
    contents.Weight = parseInt(output["Weight"]);
  }
  return contents;
};

const deserializeAws_restXmlResourceRecordSets = (
  output: any,
  context: __SerdeContext
): Array<ResourceRecordSet> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlResourceRecordSet(entry, context)
  );
};

const deserializeAws_restXmlResourceRecords = (
  output: any,
  context: __SerdeContext
): Array<ResourceRecord> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlResourceRecord(entry, context)
  );
};

const deserializeAws_restXmlResourceTagSet = (
  output: any,
  context: __SerdeContext
): ResourceTagSet => {
  let contents: any = {
    __type: "ResourceTagSet",
    ResourceId: undefined,
    ResourceType: undefined,
    Tags: undefined
  };
  if (output["ResourceId"] !== undefined) {
    contents.ResourceId = output["ResourceId"];
  }
  if (output["ResourceType"] !== undefined) {
    contents.ResourceType = output["ResourceType"];
  }
  if (output.Tags === "") {
    contents.Tags = [];
  }
  if (output["Tags"] !== undefined && output["Tags"]["Tag"] !== undefined) {
    const wrappedItem =
      output["Tags"]["Tag"] instanceof Array
        ? output["Tags"]["Tag"]
        : [output["Tags"]["Tag"]];
    contents.Tags = deserializeAws_restXmlTagList(wrappedItem, context);
  }
  return contents;
};

const deserializeAws_restXmlResourceTagSetList = (
  output: any,
  context: __SerdeContext
): Array<ResourceTagSet> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlResourceTagSet(entry, context)
  );
};

const deserializeAws_restXmlReusableDelegationSetLimit = (
  output: any,
  context: __SerdeContext
): ReusableDelegationSetLimit => {
  let contents: any = {
    __type: "ReusableDelegationSetLimit",
    Type: undefined,
    Value: undefined
  };
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = parseInt(output["Value"]);
  }
  return contents;
};

const deserializeAws_restXmlStatusReport = (
  output: any,
  context: __SerdeContext
): StatusReport => {
  let contents: any = {
    __type: "StatusReport",
    CheckedTime: undefined,
    Status: undefined
  };
  if (output["CheckedTime"] !== undefined) {
    contents.CheckedTime = new Date(output["CheckedTime"]);
  }
  if (output["Status"] !== undefined) {
    contents.Status = output["Status"];
  }
  return contents;
};

const deserializeAws_restXmlTag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output["Key"] !== undefined) {
    contents.Key = output["Key"];
  }
  if (output["Value"] !== undefined) {
    contents.Value = output["Value"];
  }
  return contents;
};

const deserializeAws_restXmlTagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlTag(entry, context)
  );
};

const deserializeAws_restXmlTrafficPolicies = (
  output: any,
  context: __SerdeContext
): Array<TrafficPolicy> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlTrafficPolicy(entry, context)
  );
};

const deserializeAws_restXmlTrafficPolicy = (
  output: any,
  context: __SerdeContext
): TrafficPolicy => {
  let contents: any = {
    __type: "TrafficPolicy",
    Comment: undefined,
    Document: undefined,
    Id: undefined,
    Name: undefined,
    Type: undefined,
    Version: undefined
  };
  if (output["Comment"] !== undefined) {
    contents.Comment = output["Comment"];
  }
  if (output["Document"] !== undefined) {
    contents.Document = output["Document"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  if (output["Version"] !== undefined) {
    contents.Version = parseInt(output["Version"]);
  }
  return contents;
};

const deserializeAws_restXmlTrafficPolicyInstance = (
  output: any,
  context: __SerdeContext
): TrafficPolicyInstance => {
  let contents: any = {
    __type: "TrafficPolicyInstance",
    HostedZoneId: undefined,
    Id: undefined,
    Message: undefined,
    Name: undefined,
    State: undefined,
    TTL: undefined,
    TrafficPolicyId: undefined,
    TrafficPolicyType: undefined,
    TrafficPolicyVersion: undefined
  };
  if (output["HostedZoneId"] !== undefined) {
    contents.HostedZoneId = output["HostedZoneId"];
  }
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["Message"] !== undefined) {
    contents.Message = output["Message"];
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["State"] !== undefined) {
    contents.State = output["State"];
  }
  if (output["TTL"] !== undefined) {
    contents.TTL = parseInt(output["TTL"]);
  }
  if (output["TrafficPolicyId"] !== undefined) {
    contents.TrafficPolicyId = output["TrafficPolicyId"];
  }
  if (output["TrafficPolicyType"] !== undefined) {
    contents.TrafficPolicyType = output["TrafficPolicyType"];
  }
  if (output["TrafficPolicyVersion"] !== undefined) {
    contents.TrafficPolicyVersion = parseInt(output["TrafficPolicyVersion"]);
  }
  return contents;
};

const deserializeAws_restXmlTrafficPolicyInstances = (
  output: any,
  context: __SerdeContext
): Array<TrafficPolicyInstance> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlTrafficPolicyInstance(entry, context)
  );
};

const deserializeAws_restXmlTrafficPolicySummaries = (
  output: any,
  context: __SerdeContext
): Array<TrafficPolicySummary> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlTrafficPolicySummary(entry, context)
  );
};

const deserializeAws_restXmlTrafficPolicySummary = (
  output: any,
  context: __SerdeContext
): TrafficPolicySummary => {
  let contents: any = {
    __type: "TrafficPolicySummary",
    Id: undefined,
    LatestVersion: undefined,
    Name: undefined,
    TrafficPolicyCount: undefined,
    Type: undefined
  };
  if (output["Id"] !== undefined) {
    contents.Id = output["Id"];
  }
  if (output["LatestVersion"] !== undefined) {
    contents.LatestVersion = parseInt(output["LatestVersion"]);
  }
  if (output["Name"] !== undefined) {
    contents.Name = output["Name"];
  }
  if (output["TrafficPolicyCount"] !== undefined) {
    contents.TrafficPolicyCount = parseInt(output["TrafficPolicyCount"]);
  }
  if (output["Type"] !== undefined) {
    contents.Type = output["Type"];
  }
  return contents;
};

const deserializeAws_restXmlVPC = (
  output: any,
  context: __SerdeContext
): VPC => {
  let contents: any = {
    __type: "VPC",
    VPCId: undefined,
    VPCRegion: undefined
  };
  if (output["VPCId"] !== undefined) {
    contents.VPCId = output["VPCId"];
  }
  if (output["VPCRegion"] !== undefined) {
    contents.VPCRegion = output["VPCRegion"];
  }
  return contents;
};

const deserializeAws_restXmlVPCs = (
  output: any,
  context: __SerdeContext
): Array<VPC> => {
  return (output || []).map((entry: any) =>
    deserializeAws_restXmlVPC(entry, context)
  );
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      const parsedObj = xmlParse(encoded, {
        attributeNamePrefix: "",
        ignoreAttributes: false,
        parseNodeValue: false
      });
      return parsedObj[Object.keys(parsedObj)[0]];
    }
    return {};
  });
};

const loadRestXmlErrorCode = (output: __HttpResponse, data: any): string => {
  if (data.Error.Code !== undefined) {
    return data.Error.Code;
  }
  if (output.statusCode == 404) {
    return "NotFound";
  }
  return "";
};
