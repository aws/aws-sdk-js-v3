import {
  AddTagsToResourceCommandInput,
  AddTagsToResourceCommandOutput
} from "../commands/AddTagsToResourceCommand";
import {
  ApplyPendingMaintenanceActionCommandInput,
  ApplyPendingMaintenanceActionCommandOutput
} from "../commands/ApplyPendingMaintenanceActionCommand";
import {
  CreateEndpointCommandInput,
  CreateEndpointCommandOutput
} from "../commands/CreateEndpointCommand";
import {
  CreateEventSubscriptionCommandInput,
  CreateEventSubscriptionCommandOutput
} from "../commands/CreateEventSubscriptionCommand";
import {
  CreateReplicationInstanceCommandInput,
  CreateReplicationInstanceCommandOutput
} from "../commands/CreateReplicationInstanceCommand";
import {
  CreateReplicationSubnetGroupCommandInput,
  CreateReplicationSubnetGroupCommandOutput
} from "../commands/CreateReplicationSubnetGroupCommand";
import {
  CreateReplicationTaskCommandInput,
  CreateReplicationTaskCommandOutput
} from "../commands/CreateReplicationTaskCommand";
import {
  DeleteCertificateCommandInput,
  DeleteCertificateCommandOutput
} from "../commands/DeleteCertificateCommand";
import {
  DeleteConnectionCommandInput,
  DeleteConnectionCommandOutput
} from "../commands/DeleteConnectionCommand";
import {
  DeleteEndpointCommandInput,
  DeleteEndpointCommandOutput
} from "../commands/DeleteEndpointCommand";
import {
  DeleteEventSubscriptionCommandInput,
  DeleteEventSubscriptionCommandOutput
} from "../commands/DeleteEventSubscriptionCommand";
import {
  DeleteReplicationInstanceCommandInput,
  DeleteReplicationInstanceCommandOutput
} from "../commands/DeleteReplicationInstanceCommand";
import {
  DeleteReplicationSubnetGroupCommandInput,
  DeleteReplicationSubnetGroupCommandOutput
} from "../commands/DeleteReplicationSubnetGroupCommand";
import {
  DeleteReplicationTaskCommandInput,
  DeleteReplicationTaskCommandOutput
} from "../commands/DeleteReplicationTaskCommand";
import {
  DescribeAccountAttributesCommandInput,
  DescribeAccountAttributesCommandOutput
} from "../commands/DescribeAccountAttributesCommand";
import {
  DescribeCertificatesCommandInput,
  DescribeCertificatesCommandOutput
} from "../commands/DescribeCertificatesCommand";
import {
  DescribeConnectionsCommandInput,
  DescribeConnectionsCommandOutput
} from "../commands/DescribeConnectionsCommand";
import {
  DescribeEndpointTypesCommandInput,
  DescribeEndpointTypesCommandOutput
} from "../commands/DescribeEndpointTypesCommand";
import {
  DescribeEndpointsCommandInput,
  DescribeEndpointsCommandOutput
} from "../commands/DescribeEndpointsCommand";
import {
  DescribeEventCategoriesCommandInput,
  DescribeEventCategoriesCommandOutput
} from "../commands/DescribeEventCategoriesCommand";
import {
  DescribeEventSubscriptionsCommandInput,
  DescribeEventSubscriptionsCommandOutput
} from "../commands/DescribeEventSubscriptionsCommand";
import {
  DescribeEventsCommandInput,
  DescribeEventsCommandOutput
} from "../commands/DescribeEventsCommand";
import {
  DescribeOrderableReplicationInstancesCommandInput,
  DescribeOrderableReplicationInstancesCommandOutput
} from "../commands/DescribeOrderableReplicationInstancesCommand";
import {
  DescribePendingMaintenanceActionsCommandInput,
  DescribePendingMaintenanceActionsCommandOutput
} from "../commands/DescribePendingMaintenanceActionsCommand";
import {
  DescribeRefreshSchemasStatusCommandInput,
  DescribeRefreshSchemasStatusCommandOutput
} from "../commands/DescribeRefreshSchemasStatusCommand";
import {
  DescribeReplicationInstanceTaskLogsCommandInput,
  DescribeReplicationInstanceTaskLogsCommandOutput
} from "../commands/DescribeReplicationInstanceTaskLogsCommand";
import {
  DescribeReplicationInstancesCommandInput,
  DescribeReplicationInstancesCommandOutput
} from "../commands/DescribeReplicationInstancesCommand";
import {
  DescribeReplicationSubnetGroupsCommandInput,
  DescribeReplicationSubnetGroupsCommandOutput
} from "../commands/DescribeReplicationSubnetGroupsCommand";
import {
  DescribeReplicationTaskAssessmentResultsCommandInput,
  DescribeReplicationTaskAssessmentResultsCommandOutput
} from "../commands/DescribeReplicationTaskAssessmentResultsCommand";
import {
  DescribeReplicationTasksCommandInput,
  DescribeReplicationTasksCommandOutput
} from "../commands/DescribeReplicationTasksCommand";
import {
  DescribeSchemasCommandInput,
  DescribeSchemasCommandOutput
} from "../commands/DescribeSchemasCommand";
import {
  DescribeTableStatisticsCommandInput,
  DescribeTableStatisticsCommandOutput
} from "../commands/DescribeTableStatisticsCommand";
import {
  ImportCertificateCommandInput,
  ImportCertificateCommandOutput
} from "../commands/ImportCertificateCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ModifyEndpointCommandInput,
  ModifyEndpointCommandOutput
} from "../commands/ModifyEndpointCommand";
import {
  ModifyEventSubscriptionCommandInput,
  ModifyEventSubscriptionCommandOutput
} from "../commands/ModifyEventSubscriptionCommand";
import {
  ModifyReplicationInstanceCommandInput,
  ModifyReplicationInstanceCommandOutput
} from "../commands/ModifyReplicationInstanceCommand";
import {
  ModifyReplicationSubnetGroupCommandInput,
  ModifyReplicationSubnetGroupCommandOutput
} from "../commands/ModifyReplicationSubnetGroupCommand";
import {
  ModifyReplicationTaskCommandInput,
  ModifyReplicationTaskCommandOutput
} from "../commands/ModifyReplicationTaskCommand";
import {
  RebootReplicationInstanceCommandInput,
  RebootReplicationInstanceCommandOutput
} from "../commands/RebootReplicationInstanceCommand";
import {
  RefreshSchemasCommandInput,
  RefreshSchemasCommandOutput
} from "../commands/RefreshSchemasCommand";
import {
  ReloadTablesCommandInput,
  ReloadTablesCommandOutput
} from "../commands/ReloadTablesCommand";
import {
  RemoveTagsFromResourceCommandInput,
  RemoveTagsFromResourceCommandOutput
} from "../commands/RemoveTagsFromResourceCommand";
import {
  StartReplicationTaskAssessmentCommandInput,
  StartReplicationTaskAssessmentCommandOutput
} from "../commands/StartReplicationTaskAssessmentCommand";
import {
  StartReplicationTaskCommandInput,
  StartReplicationTaskCommandOutput
} from "../commands/StartReplicationTaskCommand";
import {
  StopReplicationTaskCommandInput,
  StopReplicationTaskCommandOutput
} from "../commands/StopReplicationTaskCommand";
import {
  TestConnectionCommandInput,
  TestConnectionCommandOutput
} from "../commands/TestConnectionCommand";
import {
  AccessDeniedFault,
  AccountQuota,
  AddTagsToResourceMessage,
  AddTagsToResourceResponse,
  ApplyPendingMaintenanceActionMessage,
  ApplyPendingMaintenanceActionResponse,
  AvailabilityZone,
  Certificate,
  Connection,
  CreateEndpointMessage,
  CreateEndpointResponse,
  CreateEventSubscriptionMessage,
  CreateEventSubscriptionResponse,
  CreateReplicationInstanceMessage,
  CreateReplicationInstanceResponse,
  CreateReplicationSubnetGroupMessage,
  CreateReplicationSubnetGroupResponse,
  CreateReplicationTaskMessage,
  CreateReplicationTaskResponse,
  DeleteCertificateMessage,
  DeleteCertificateResponse,
  DeleteConnectionMessage,
  DeleteConnectionResponse,
  DeleteEndpointMessage,
  DeleteEndpointResponse,
  DeleteEventSubscriptionMessage,
  DeleteEventSubscriptionResponse,
  DeleteReplicationInstanceMessage,
  DeleteReplicationInstanceResponse,
  DeleteReplicationSubnetGroupMessage,
  DeleteReplicationSubnetGroupResponse,
  DeleteReplicationTaskMessage,
  DeleteReplicationTaskResponse,
  DescribeAccountAttributesMessage,
  DescribeAccountAttributesResponse,
  DescribeCertificatesMessage,
  DescribeCertificatesResponse,
  DescribeConnectionsMessage,
  DescribeConnectionsResponse,
  DescribeEndpointTypesMessage,
  DescribeEndpointTypesResponse,
  DescribeEndpointsMessage,
  DescribeEndpointsResponse,
  DescribeEventCategoriesMessage,
  DescribeEventCategoriesResponse,
  DescribeEventSubscriptionsMessage,
  DescribeEventSubscriptionsResponse,
  DescribeEventsMessage,
  DescribeEventsResponse,
  DescribeOrderableReplicationInstancesMessage,
  DescribeOrderableReplicationInstancesResponse,
  DescribePendingMaintenanceActionsMessage,
  DescribePendingMaintenanceActionsResponse,
  DescribeRefreshSchemasStatusMessage,
  DescribeRefreshSchemasStatusResponse,
  DescribeReplicationInstanceTaskLogsMessage,
  DescribeReplicationInstanceTaskLogsResponse,
  DescribeReplicationInstancesMessage,
  DescribeReplicationInstancesResponse,
  DescribeReplicationSubnetGroupsMessage,
  DescribeReplicationSubnetGroupsResponse,
  DescribeReplicationTaskAssessmentResultsMessage,
  DescribeReplicationTaskAssessmentResultsResponse,
  DescribeReplicationTasksMessage,
  DescribeReplicationTasksResponse,
  DescribeSchemasMessage,
  DescribeSchemasResponse,
  DescribeTableStatisticsMessage,
  DescribeTableStatisticsResponse,
  DmsTransferSettings,
  DynamoDbSettings,
  ElasticsearchSettings,
  Endpoint,
  Event,
  EventCategoryGroup,
  EventSubscription,
  Filter,
  ImportCertificateMessage,
  ImportCertificateResponse,
  InsufficientResourceCapacityFault,
  InvalidCertificateFault,
  InvalidResourceStateFault,
  InvalidSubnet,
  KMSAccessDeniedFault,
  KMSDisabledFault,
  KMSInvalidStateFault,
  KMSKeyNotAccessibleFault,
  KMSNotFoundFault,
  KMSThrottlingFault,
  KinesisSettings,
  ListTagsForResourceMessage,
  ListTagsForResourceResponse,
  ModifyEndpointMessage,
  ModifyEndpointResponse,
  ModifyEventSubscriptionMessage,
  ModifyEventSubscriptionResponse,
  ModifyReplicationInstanceMessage,
  ModifyReplicationInstanceResponse,
  ModifyReplicationSubnetGroupMessage,
  ModifyReplicationSubnetGroupResponse,
  ModifyReplicationTaskMessage,
  ModifyReplicationTaskResponse,
  MongoDbSettings,
  OrderableReplicationInstance,
  PendingMaintenanceAction,
  RebootReplicationInstanceMessage,
  RebootReplicationInstanceResponse,
  RedshiftSettings,
  RefreshSchemasMessage,
  RefreshSchemasResponse,
  RefreshSchemasStatus,
  ReloadTablesMessage,
  ReloadTablesResponse,
  RemoveTagsFromResourceMessage,
  RemoveTagsFromResourceResponse,
  ReplicationInstance,
  ReplicationInstanceTaskLog,
  ReplicationPendingModifiedValues,
  ReplicationSubnetGroup,
  ReplicationSubnetGroupDoesNotCoverEnoughAZs,
  ReplicationTask,
  ReplicationTaskAssessmentResult,
  ReplicationTaskStats,
  ResourceAlreadyExistsFault,
  ResourceNotFoundFault,
  ResourcePendingMaintenanceActions,
  ResourceQuotaExceededFault,
  S3Settings,
  SNSInvalidTopicFault,
  SNSNoAuthorizationFault,
  StartReplicationTaskAssessmentMessage,
  StartReplicationTaskAssessmentResponse,
  StartReplicationTaskMessage,
  StartReplicationTaskResponse,
  StopReplicationTaskMessage,
  StopReplicationTaskResponse,
  StorageQuotaExceededFault,
  Subnet,
  SubnetAlreadyInUse,
  SupportedEndpointType,
  TableStatistics,
  TableToReload,
  Tag,
  TestConnectionMessage,
  TestConnectionResponse,
  UpgradeDependencyFailureFault,
  VpcSecurityGroupMembership
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_json1_1AddTagsToResourceCommand(
  input: AddTagsToResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.AddTagsToResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AddTagsToResourceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ApplyPendingMaintenanceActionCommand(
  input: ApplyPendingMaintenanceActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ApplyPendingMaintenanceAction";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ApplyPendingMaintenanceActionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateEndpointCommand(
  input: CreateEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.CreateEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateEndpointMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateEventSubscriptionCommand(
  input: CreateEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.CreateEventSubscription";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateEventSubscriptionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateReplicationInstanceCommand(
  input: CreateReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.CreateReplicationInstance";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateReplicationInstanceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateReplicationSubnetGroupCommand(
  input: CreateReplicationSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.CreateReplicationSubnetGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateReplicationSubnetGroupMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1CreateReplicationTaskCommand(
  input: CreateReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.CreateReplicationTask";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateReplicationTaskMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteCertificateCommand(
  input: DeleteCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteCertificate";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteCertificateMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteConnectionCommand(
  input: DeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteConnectionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteEndpointCommand(
  input: DeleteEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteEndpointMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteEventSubscriptionCommand(
  input: DeleteEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteEventSubscription";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteEventSubscriptionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteReplicationInstanceCommand(
  input: DeleteReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteReplicationInstance";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteReplicationInstanceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteReplicationSubnetGroupCommand(
  input: DeleteReplicationSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteReplicationSubnetGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteReplicationSubnetGroupMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DeleteReplicationTaskCommand(
  input: DeleteReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteReplicationTask";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteReplicationTaskMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeAccountAttributesCommand(
  input: DescribeAccountAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeAccountAttributes";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeAccountAttributesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeCertificatesCommand(
  input: DescribeCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeCertificates";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeCertificatesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeConnectionsCommand(
  input: DescribeConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeConnections";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeConnectionsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEndpointTypesCommand(
  input: DescribeEndpointTypesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeEndpointTypes";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEndpointTypesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEndpointsCommand(
  input: DescribeEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeEndpoints";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEndpointsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEventCategoriesCommand(
  input: DescribeEventCategoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeEventCategories";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEventCategoriesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEventSubscriptionsCommand(
  input: DescribeEventSubscriptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeEventSubscriptions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEventSubscriptionsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeEventsCommand(
  input: DescribeEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeEvents";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEventsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeOrderableReplicationInstancesCommand(
  input: DescribeOrderableReplicationInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonDMSv20160101.DescribeOrderableReplicationInstances";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeOrderableReplicationInstancesMessage(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribePendingMaintenanceActionsCommand(
  input: DescribePendingMaintenanceActionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonDMSv20160101.DescribePendingMaintenanceActions";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribePendingMaintenanceActionsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeRefreshSchemasStatusCommand(
  input: DescribeRefreshSchemasStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeRefreshSchemasStatus";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeRefreshSchemasStatusMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeReplicationInstanceTaskLogsCommand(
  input: DescribeReplicationInstanceTaskLogsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonDMSv20160101.DescribeReplicationInstanceTaskLogs";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeReplicationInstanceTaskLogsMessage(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeReplicationInstancesCommand(
  input: DescribeReplicationInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeReplicationInstances";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeReplicationInstancesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeReplicationSubnetGroupsCommand(
  input: DescribeReplicationSubnetGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonDMSv20160101.DescribeReplicationSubnetGroups";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeReplicationSubnetGroupsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommand(
  input: DescribeReplicationTaskAssessmentResultsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonDMSv20160101.DescribeReplicationTaskAssessmentResults";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeReplicationTaskAssessmentResultsMessage(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeReplicationTasksCommand(
  input: DescribeReplicationTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeReplicationTasks";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeReplicationTasksMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeSchemasCommand(
  input: DescribeSchemasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeSchemas";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeSchemasMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1DescribeTableStatisticsCommand(
  input: DescribeTableStatisticsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeTableStatistics";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeTableStatisticsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ImportCertificateCommand(
  input: ImportCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ImportCertificate";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ImportCertificateMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ListTagsForResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListTagsForResourceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ModifyEndpointCommand(
  input: ModifyEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ModifyEndpoint";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyEndpointMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ModifyEventSubscriptionCommand(
  input: ModifyEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ModifyEventSubscription";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyEventSubscriptionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ModifyReplicationInstanceCommand(
  input: ModifyReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ModifyReplicationInstance";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyReplicationInstanceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ModifyReplicationSubnetGroupCommand(
  input: ModifyReplicationSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ModifyReplicationSubnetGroup";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyReplicationSubnetGroupMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ModifyReplicationTaskCommand(
  input: ModifyReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ModifyReplicationTask";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyReplicationTaskMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RebootReplicationInstanceCommand(
  input: RebootReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.RebootReplicationInstance";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RebootReplicationInstanceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RefreshSchemasCommand(
  input: RefreshSchemasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.RefreshSchemas";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RefreshSchemasMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1ReloadTablesCommand(
  input: ReloadTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ReloadTables";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ReloadTablesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1RemoveTagsFromResourceCommand(
  input: RemoveTagsFromResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.RemoveTagsFromResource";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RemoveTagsFromResourceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartReplicationTaskCommand(
  input: StartReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.StartReplicationTask";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartReplicationTaskMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StartReplicationTaskAssessmentCommand(
  input: StartReplicationTaskAssessmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.StartReplicationTaskAssessment";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartReplicationTaskAssessmentMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1StopReplicationTaskCommand(
  input: StopReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.StopReplicationTask";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopReplicationTaskMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function serializeAws_json1_1TestConnectionCommand(
  input: TestConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: __HeaderBag = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.TestConnection";
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1TestConnectionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
}

export async function deserializeAws_json1_1AddTagsToResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AddTagsToResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AddTagsToResourceResponse(data, context);
  const response: AddTagsToResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AddTagsToResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AddTagsToResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ApplyPendingMaintenanceActionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApplyPendingMaintenanceActionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ApplyPendingMaintenanceActionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ApplyPendingMaintenanceActionResponse(
    data,
    context
  );
  const response: ApplyPendingMaintenanceActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApplyPendingMaintenanceActionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ApplyPendingMaintenanceActionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApplyPendingMaintenanceActionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEndpointResponse(data, context);
  const response: CreateEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateEventSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEventSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEventSubscriptionResponse(
    data,
    context
  );
  const response: CreateEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEventSubscriptionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateEventSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEventSubscriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "KMSAccessDeniedFault":
    case "com.amazonaws.dms#KMSAccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1KMSAccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSDisabledFault":
    case "com.amazonaws.dms#KMSDisabledFault":
      response = {
        ...(await deserializeAws_json1_1KMSDisabledFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSInvalidStateFault":
    case "com.amazonaws.dms#KMSInvalidStateFault":
      response = {
        ...(await deserializeAws_json1_1KMSInvalidStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSNotFoundFault":
    case "com.amazonaws.dms#KMSNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1KMSNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSThrottlingFault":
    case "com.amazonaws.dms#KMSThrottlingFault":
      response = {
        ...(await deserializeAws_json1_1KMSThrottlingFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSInvalidTopicFault":
    case "com.amazonaws.dms#SNSInvalidTopicFault":
      response = {
        ...(await deserializeAws_json1_1SNSInvalidTopicFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSNoAuthorizationFault":
    case "com.amazonaws.dms#SNSNoAuthorizationFault":
      response = {
        ...(await deserializeAws_json1_1SNSNoAuthorizationFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateReplicationInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateReplicationInstanceResponse(
    data,
    context
  );
  const response: CreateReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateReplicationInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientResourceCapacityFault":
    case "com.amazonaws.dms#InsufficientResourceCapacityFault":
      response = {
        ...(await deserializeAws_json1_1InsufficientResourceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "com.amazonaws.dms#InvalidSubnet":
      response = {
        ...(await deserializeAws_json1_1InvalidSubnetResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplicationSubnetGroupDoesNotCoverEnoughAZs":
    case "com.amazonaws.dms#ReplicationSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "com.amazonaws.dms#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1StorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateReplicationSubnetGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationSubnetGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateReplicationSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateReplicationSubnetGroupResponse(
    data,
    context
  );
  const response: CreateReplicationSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReplicationSubnetGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateReplicationSubnetGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationSubnetGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "com.amazonaws.dms#InvalidSubnet":
      response = {
        ...(await deserializeAws_json1_1InvalidSubnetResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplicationSubnetGroupDoesNotCoverEnoughAZs":
    case "com.amazonaws.dms#ReplicationSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1CreateReplicationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateReplicationTaskResponse(data, context);
  const response: CreateReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateReplicationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationTaskCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCertificateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteCertificateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteCertificateResponse(data, context);
  const response: DeleteCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteCertificateResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCertificateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteConnectionResponse(data, context);
  const response: DeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteEndpointResponse(data, context);
  const response: DeleteEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteEventSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteEventSubscriptionResponse(
    data,
    context
  );
  const response: DeleteEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEventSubscriptionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteEventSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventSubscriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteReplicationInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteReplicationInstanceResponse(
    data,
    context
  );
  const response: DeleteReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteReplicationInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteReplicationSubnetGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationSubnetGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteReplicationSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteReplicationSubnetGroupResponse(
    data,
    context
  );
  const response: DeleteReplicationSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReplicationSubnetGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteReplicationSubnetGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationSubnetGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DeleteReplicationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteReplicationTaskResponse(data, context);
  const response: DeleteReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteReplicationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationTaskCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeAccountAttributesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAccountAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAccountAttributesResponse(
    data,
    context
  );
  const response: DescribeAccountAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAccountAttributesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAccountAttributesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeCertificatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificatesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeCertificatesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeCertificatesResponse(data, context);
  const response: DescribeCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCertificatesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeCertificatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificatesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeConnectionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeConnectionsResponse(data, context);
  const response: DescribeConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeConnectionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeConnectionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEndpointTypesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointTypesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEndpointTypesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEndpointTypesResponse(data, context);
  const response: DescribeEndpointTypesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointTypesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEndpointTypesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointTypesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEndpointsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEndpointsResponse(data, context);
  const response: DescribeEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEndpointsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEventCategoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventCategoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEventCategoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEventCategoriesResponse(
    data,
    context
  );
  const response: DescribeEventCategoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventCategoriesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEventCategoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventCategoriesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEventSubscriptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventSubscriptionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEventSubscriptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEventSubscriptionsResponse(
    data,
    context
  );
  const response: DescribeEventSubscriptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventSubscriptionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEventSubscriptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventSubscriptionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeEventsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEventsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEventsResponse(data, context);
  const response: DescribeEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEventsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeOrderableReplicationInstancesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOrderableReplicationInstancesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeOrderableReplicationInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeOrderableReplicationInstancesResponse(
    data,
    context
  );
  const response: DescribeOrderableReplicationInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeOrderableReplicationInstancesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeOrderableReplicationInstancesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOrderableReplicationInstancesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribePendingMaintenanceActionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePendingMaintenanceActionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribePendingMaintenanceActionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribePendingMaintenanceActionsResponse(
    data,
    context
  );
  const response: DescribePendingMaintenanceActionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePendingMaintenanceActionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribePendingMaintenanceActionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePendingMaintenanceActionsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeRefreshSchemasStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRefreshSchemasStatusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeRefreshSchemasStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeRefreshSchemasStatusResponse(
    data,
    context
  );
  const response: DescribeRefreshSchemasStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeRefreshSchemasStatusResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeRefreshSchemasStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRefreshSchemasStatusCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeReplicationInstanceTaskLogsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstanceTaskLogsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationInstanceTaskLogsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationInstanceTaskLogsResponse(
    data,
    context
  );
  const response: DescribeReplicationInstanceTaskLogsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationInstanceTaskLogsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeReplicationInstanceTaskLogsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstanceTaskLogsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeReplicationInstancesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstancesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationInstancesResponse(
    data,
    context
  );
  const response: DescribeReplicationInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationInstancesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeReplicationInstancesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstancesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeReplicationSubnetGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationSubnetGroupsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationSubnetGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationSubnetGroupsResponse(
    data,
    context
  );
  const response: DescribeReplicationSubnetGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationSubnetGroupsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeReplicationSubnetGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationSubnetGroupsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTaskAssessmentResultsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsResponse(
    data,
    context
  );
  const response: DescribeReplicationTaskAssessmentResultsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationTaskAssessmentResultsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTaskAssessmentResultsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeReplicationTasksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTasksCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationTasksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationTasksResponse(
    data,
    context
  );
  const response: DescribeReplicationTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationTasksResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeReplicationTasksCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTasksCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeSchemasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSchemasCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeSchemasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeSchemasResponse(data, context);
  const response: DescribeSchemasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSchemasResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeSchemasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSchemasCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1DescribeTableStatisticsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTableStatisticsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTableStatisticsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTableStatisticsResponse(
    data,
    context
  );
  const response: DescribeTableStatisticsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTableStatisticsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeTableStatisticsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTableStatisticsCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ImportCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCertificateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ImportCertificateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ImportCertificateResponse(data, context);
  const response: ImportCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportCertificateResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ImportCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCertificateCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidCertificateFault":
    case "com.amazonaws.dms#InvalidCertificateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidCertificateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceResponse(data, context);
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ModifyEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyEndpointResponse(data, context);
  const response: ModifyEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEndpointCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ModifyEventSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEventSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyEventSubscriptionResponse(
    data,
    context
  );
  const response: ModifyEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyEventSubscriptionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyEventSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEventSubscriptionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "KMSAccessDeniedFault":
    case "com.amazonaws.dms#KMSAccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1KMSAccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSDisabledFault":
    case "com.amazonaws.dms#KMSDisabledFault":
      response = {
        ...(await deserializeAws_json1_1KMSDisabledFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSInvalidStateFault":
    case "com.amazonaws.dms#KMSInvalidStateFault":
      response = {
        ...(await deserializeAws_json1_1KMSInvalidStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSNotFoundFault":
    case "com.amazonaws.dms#KMSNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1KMSNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSThrottlingFault":
    case "com.amazonaws.dms#KMSThrottlingFault":
      response = {
        ...(await deserializeAws_json1_1KMSThrottlingFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSInvalidTopicFault":
    case "com.amazonaws.dms#SNSInvalidTopicFault":
      response = {
        ...(await deserializeAws_json1_1SNSInvalidTopicFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSNoAuthorizationFault":
    case "com.amazonaws.dms#SNSNoAuthorizationFault":
      response = {
        ...(await deserializeAws_json1_1SNSNoAuthorizationFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ModifyReplicationInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyReplicationInstanceResponse(
    data,
    context
  );
  const response: ModifyReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyReplicationInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientResourceCapacityFault":
    case "com.amazonaws.dms#InsufficientResourceCapacityFault":
      response = {
        ...(await deserializeAws_json1_1InsufficientResourceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "com.amazonaws.dms#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1StorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UpgradeDependencyFailureFault":
    case "com.amazonaws.dms#UpgradeDependencyFailureFault":
      response = {
        ...(await deserializeAws_json1_1UpgradeDependencyFailureFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ModifyReplicationSubnetGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationSubnetGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyReplicationSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyReplicationSubnetGroupResponse(
    data,
    context
  );
  const response: ModifyReplicationSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyReplicationSubnetGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyReplicationSubnetGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationSubnetGroupCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "com.amazonaws.dms#InvalidSubnet":
      response = {
        ...(await deserializeAws_json1_1InvalidSubnetResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplicationSubnetGroupDoesNotCoverEnoughAZs":
    case "com.amazonaws.dms#ReplicationSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubnetAlreadyInUse":
    case "com.amazonaws.dms#SubnetAlreadyInUse":
      response = {
        ...(await deserializeAws_json1_1SubnetAlreadyInUseResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ModifyReplicationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyReplicationTaskResponse(data, context);
  const response: ModifyReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyReplicationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationTaskCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RebootReplicationInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootReplicationInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RebootReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RebootReplicationInstanceResponse(
    data,
    context
  );
  const response: RebootReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RebootReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RebootReplicationInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootReplicationInstanceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RefreshSchemasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RefreshSchemasCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RefreshSchemasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RefreshSchemasResponse(data, context);
  const response: RefreshSchemasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RefreshSchemasResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RefreshSchemasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RefreshSchemasCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1ReloadTablesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReloadTablesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ReloadTablesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ReloadTablesResponse(data, context);
  const response: ReloadTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReloadTablesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ReloadTablesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReloadTablesCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1RemoveTagsFromResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RemoveTagsFromResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RemoveTagsFromResourceResponse(
    data,
    context
  );
  const response: RemoveTagsFromResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveTagsFromResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RemoveTagsFromResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartReplicationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartReplicationTaskResponse(data, context);
  const response: StartReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartReplicationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StartReplicationTaskAssessmentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskAssessmentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartReplicationTaskAssessmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartReplicationTaskAssessmentResponse(
    data,
    context
  );
  const response: StartReplicationTaskAssessmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartReplicationTaskAssessmentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartReplicationTaskAssessmentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskAssessmentCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1StopReplicationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopReplicationTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopReplicationTaskResponse(data, context);
  const response: StopReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopReplicationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopReplicationTaskCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

export async function deserializeAws_json1_1TestConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TestConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TestConnectionResponse(data, context);
  const response: TestConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TestConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestConnectionCommandOutput> {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: String = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
}

const deserializeAws_json1_1AccessDeniedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AccessDeniedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AccessDeniedFault(
    body,
    context
  );
  const contents: AccessDeniedFault = {
    name: "AccessDeniedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InsufficientResourceCapacityFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InsufficientResourceCapacityFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InsufficientResourceCapacityFault(
    body,
    context
  );
  const contents: InsufficientResourceCapacityFault = {
    name: "InsufficientResourceCapacityFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidCertificateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidCertificateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidCertificateFault(
    body,
    context
  );
  const contents: InvalidCertificateFault = {
    name: "InvalidCertificateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidResourceStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidResourceStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidResourceStateFault(
    body,
    context
  );
  const contents: InvalidResourceStateFault = {
    name: "InvalidResourceStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidSubnetResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSubnet> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidSubnet(body, context);
  const contents: InvalidSubnet = {
    name: "InvalidSubnet",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSAccessDeniedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSAccessDeniedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSAccessDeniedFault(
    body,
    context
  );
  const contents: KMSAccessDeniedFault = {
    name: "KMSAccessDeniedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSDisabledFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSDisabledFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSDisabledFault(
    body,
    context
  );
  const contents: KMSDisabledFault = {
    name: "KMSDisabledFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSInvalidStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSInvalidStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSInvalidStateFault(
    body,
    context
  );
  const contents: KMSInvalidStateFault = {
    name: "KMSInvalidStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSKeyNotAccessibleFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSKeyNotAccessibleFault(
    body,
    context
  );
  const contents: KMSKeyNotAccessibleFault = {
    name: "KMSKeyNotAccessibleFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSNotFoundFault(
    body,
    context
  );
  const contents: KMSNotFoundFault = {
    name: "KMSNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSThrottlingFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSThrottlingFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSThrottlingFault(
    body,
    context
  );
  const contents: KMSThrottlingFault = {
    name: "KMSThrottlingFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReplicationSubnetGroupDoesNotCoverEnoughAZs> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZs(
    body,
    context
  );
  const contents: ReplicationSubnetGroupDoesNotCoverEnoughAZs = {
    name: "ReplicationSubnetGroupDoesNotCoverEnoughAZs",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceAlreadyExistsFault(
    body,
    context
  );
  const contents: ResourceAlreadyExistsFault = {
    name: "ResourceAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceNotFoundFault(
    body,
    context
  );
  const contents: ResourceNotFoundFault = {
    name: "ResourceNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceQuotaExceededFault(
    body,
    context
  );
  const contents: ResourceQuotaExceededFault = {
    name: "ResourceQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SNSInvalidTopicFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SNSInvalidTopicFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SNSInvalidTopicFault(
    body,
    context
  );
  const contents: SNSInvalidTopicFault = {
    name: "SNSInvalidTopicFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SNSNoAuthorizationFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SNSNoAuthorizationFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SNSNoAuthorizationFault(
    body,
    context
  );
  const contents: SNSNoAuthorizationFault = {
    name: "SNSNoAuthorizationFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1StorageQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<StorageQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1StorageQuotaExceededFault(
    body,
    context
  );
  const contents: StorageQuotaExceededFault = {
    name: "StorageQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SubnetAlreadyInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubnetAlreadyInUse> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SubnetAlreadyInUse(
    body,
    context
  );
  const contents: SubnetAlreadyInUse = {
    name: "SubnetAlreadyInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UpgradeDependencyFailureFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UpgradeDependencyFailureFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UpgradeDependencyFailureFault(
    body,
    context
  );
  const contents: UpgradeDependencyFailureFault = {
    name: "UpgradeDependencyFailureFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1AddTagsToResourceMessage = (
  input: AddTagsToResourceMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1ApplyPendingMaintenanceActionMessage = (
  input: ApplyPendingMaintenanceActionMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ApplyAction !== undefined) {
    bodyParams["ApplyAction"] = input.ApplyAction;
  }
  if (input.OptInType !== undefined) {
    bodyParams["OptInType"] = input.OptInType;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEndpointMessage = (
  input: CreateEndpointMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateArn !== undefined) {
    bodyParams["CertificateArn"] = input.CertificateArn;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.DmsTransferSettings !== undefined) {
    bodyParams["DmsTransferSettings"] = serializeAws_json1_1DmsTransferSettings(
      input.DmsTransferSettings,
      context
    );
  }
  if (input.DynamoDbSettings !== undefined) {
    bodyParams["DynamoDbSettings"] = serializeAws_json1_1DynamoDbSettings(
      input.DynamoDbSettings,
      context
    );
  }
  if (input.ElasticsearchSettings !== undefined) {
    bodyParams[
      "ElasticsearchSettings"
    ] = serializeAws_json1_1ElasticsearchSettings(
      input.ElasticsearchSettings,
      context
    );
  }
  if (input.EndpointIdentifier !== undefined) {
    bodyParams["EndpointIdentifier"] = input.EndpointIdentifier;
  }
  if (input.EndpointType !== undefined) {
    bodyParams["EndpointType"] = input.EndpointType;
  }
  if (input.EngineName !== undefined) {
    bodyParams["EngineName"] = input.EngineName;
  }
  if (input.ExternalTableDefinition !== undefined) {
    bodyParams["ExternalTableDefinition"] = input.ExternalTableDefinition;
  }
  if (input.ExtraConnectionAttributes !== undefined) {
    bodyParams["ExtraConnectionAttributes"] = input.ExtraConnectionAttributes;
  }
  if (input.KinesisSettings !== undefined) {
    bodyParams["KinesisSettings"] = serializeAws_json1_1KinesisSettings(
      input.KinesisSettings,
      context
    );
  }
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MongoDbSettings !== undefined) {
    bodyParams["MongoDbSettings"] = serializeAws_json1_1MongoDbSettings(
      input.MongoDbSettings,
      context
    );
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  if (input.RedshiftSettings !== undefined) {
    bodyParams["RedshiftSettings"] = serializeAws_json1_1RedshiftSettings(
      input.RedshiftSettings,
      context
    );
  }
  if (input.S3Settings !== undefined) {
    bodyParams["S3Settings"] = serializeAws_json1_1S3Settings(
      input.S3Settings,
      context
    );
  }
  if (input.ServerName !== undefined) {
    bodyParams["ServerName"] = input.ServerName;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  if (input.SslMode !== undefined) {
    bodyParams["SslMode"] = input.SslMode;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEventSubscriptionMessage = (
  input: CreateEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.EventCategories !== undefined) {
    bodyParams["EventCategories"] = serializeAws_json1_1EventCategoriesList(
      input.EventCategories,
      context
    );
  }
  if (input.SnsTopicArn !== undefined) {
    bodyParams["SnsTopicArn"] = input.SnsTopicArn;
  }
  if (input.SourceIds !== undefined) {
    bodyParams["SourceIds"] = serializeAws_json1_1SourceIdsList(
      input.SourceIds,
      context
    );
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  if (input.SubscriptionName !== undefined) {
    bodyParams["SubscriptionName"] = input.SubscriptionName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateReplicationInstanceMessage = (
  input: CreateReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AllocatedStorage !== undefined) {
    bodyParams["AllocatedStorage"] = input.AllocatedStorage;
  }
  if (input.AutoMinorVersionUpgrade !== undefined) {
    bodyParams["AutoMinorVersionUpgrade"] = input.AutoMinorVersionUpgrade;
  }
  if (input.AvailabilityZone !== undefined) {
    bodyParams["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.DnsNameServers !== undefined) {
    bodyParams["DnsNameServers"] = input.DnsNameServers;
  }
  if (input.EngineVersion !== undefined) {
    bodyParams["EngineVersion"] = input.EngineVersion;
  }
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MultiAZ !== undefined) {
    bodyParams["MultiAZ"] = input.MultiAZ;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    bodyParams["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.PubliclyAccessible !== undefined) {
    bodyParams["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.ReplicationInstanceClass !== undefined) {
    bodyParams["ReplicationInstanceClass"] = input.ReplicationInstanceClass;
  }
  if (input.ReplicationInstanceIdentifier !== undefined) {
    bodyParams["ReplicationInstanceIdentifier"] =
      input.ReplicationInstanceIdentifier;
  }
  if (input.ReplicationSubnetGroupIdentifier !== undefined) {
    bodyParams["ReplicationSubnetGroupIdentifier"] =
      input.ReplicationSubnetGroupIdentifier;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    bodyParams[
      "VpcSecurityGroupIds"
    ] = serializeAws_json1_1VpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateReplicationSubnetGroupMessage = (
  input: CreateReplicationSubnetGroupMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ReplicationSubnetGroupDescription !== undefined) {
    bodyParams["ReplicationSubnetGroupDescription"] =
      input.ReplicationSubnetGroupDescription;
  }
  if (input.ReplicationSubnetGroupIdentifier !== undefined) {
    bodyParams["ReplicationSubnetGroupIdentifier"] =
      input.ReplicationSubnetGroupIdentifier;
  }
  if (input.SubnetIds !== undefined) {
    bodyParams["SubnetIds"] = serializeAws_json1_1SubnetIdentifierList(
      input.SubnetIds,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateReplicationTaskMessage = (
  input: CreateReplicationTaskMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CdcStartPosition !== undefined) {
    bodyParams["CdcStartPosition"] = input.CdcStartPosition;
  }
  if (input.CdcStartTime !== undefined) {
    bodyParams["CdcStartTime"] = Math.round(
      input.CdcStartTime.getTime() / 1000
    );
  }
  if (input.CdcStopPosition !== undefined) {
    bodyParams["CdcStopPosition"] = input.CdcStopPosition;
  }
  if (input.MigrationType !== undefined) {
    bodyParams["MigrationType"] = input.MigrationType;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  if (input.ReplicationTaskIdentifier !== undefined) {
    bodyParams["ReplicationTaskIdentifier"] = input.ReplicationTaskIdentifier;
  }
  if (input.ReplicationTaskSettings !== undefined) {
    bodyParams["ReplicationTaskSettings"] = input.ReplicationTaskSettings;
  }
  if (input.SourceEndpointArn !== undefined) {
    bodyParams["SourceEndpointArn"] = input.SourceEndpointArn;
  }
  if (input.TableMappings !== undefined) {
    bodyParams["TableMappings"] = input.TableMappings;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.TargetEndpointArn !== undefined) {
    bodyParams["TargetEndpointArn"] = input.TargetEndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteCertificateMessage = (
  input: DeleteCertificateMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateArn !== undefined) {
    bodyParams["CertificateArn"] = input.CertificateArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteConnectionMessage = (
  input: DeleteConnectionMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteEndpointMessage = (
  input: DeleteEndpointMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteEventSubscriptionMessage = (
  input: DeleteEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SubscriptionName !== undefined) {
    bodyParams["SubscriptionName"] = input.SubscriptionName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteReplicationInstanceMessage = (
  input: DeleteReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteReplicationSubnetGroupMessage = (
  input: DeleteReplicationSubnetGroupMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ReplicationSubnetGroupIdentifier !== undefined) {
    bodyParams["ReplicationSubnetGroupIdentifier"] =
      input.ReplicationSubnetGroupIdentifier;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteReplicationTaskMessage = (
  input: DeleteReplicationTaskMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAccountAttributesMessage = (
  input: DescribeAccountAttributesMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  return bodyParams;
};

const serializeAws_json1_1DescribeCertificatesMessage = (
  input: DescribeCertificatesMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeConnectionsMessage = (
  input: DescribeConnectionsMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEndpointTypesMessage = (
  input: DescribeEndpointTypesMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEndpointsMessage = (
  input: DescribeEndpointsMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEventCategoriesMessage = (
  input: DescribeEventCategoriesMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEventSubscriptionsMessage = (
  input: DescribeEventSubscriptionsMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.SubscriptionName !== undefined) {
    bodyParams["SubscriptionName"] = input.SubscriptionName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEventsMessage = (
  input: DescribeEventsMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Duration !== undefined) {
    bodyParams["Duration"] = input.Duration;
  }
  if (input.EndTime !== undefined) {
    bodyParams["EndTime"] = Math.round(input.EndTime.getTime() / 1000);
  }
  if (input.EventCategories !== undefined) {
    bodyParams["EventCategories"] = serializeAws_json1_1EventCategoriesList(
      input.EventCategories,
      context
    );
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.SourceIdentifier !== undefined) {
    bodyParams["SourceIdentifier"] = input.SourceIdentifier;
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  if (input.StartTime !== undefined) {
    bodyParams["StartTime"] = Math.round(input.StartTime.getTime() / 1000);
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeOrderableReplicationInstancesMessage = (
  input: DescribeOrderableReplicationInstancesMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribePendingMaintenanceActionsMessage = (
  input: DescribePendingMaintenanceActionsMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeRefreshSchemasStatusMessage = (
  input: DescribeRefreshSchemasStatusMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeReplicationInstanceTaskLogsMessage = (
  input: DescribeReplicationInstanceTaskLogsMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeReplicationInstancesMessage = (
  input: DescribeReplicationInstancesMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeReplicationSubnetGroupsMessage = (
  input: DescribeReplicationSubnetGroupsMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeReplicationTaskAssessmentResultsMessage = (
  input: DescribeReplicationTaskAssessmentResultsMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeReplicationTasksMessage = (
  input: DescribeReplicationTasksMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.WithoutSettings !== undefined) {
    bodyParams["WithoutSettings"] = input.WithoutSettings;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeSchemasMessage = (
  input: DescribeSchemasMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeTableStatisticsMessage = (
  input: DescribeTableStatisticsMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DmsTransferSettings = (
  input: DmsTransferSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BucketName !== undefined) {
    bodyParams["BucketName"] = input.BucketName;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DynamoDbSettings = (
  input: DynamoDbSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ElasticsearchSettings = (
  input: ElasticsearchSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointUri !== undefined) {
    bodyParams["EndpointUri"] = input.EndpointUri;
  }
  if (input.ErrorRetryDuration !== undefined) {
    bodyParams["ErrorRetryDuration"] = input.ErrorRetryDuration;
  }
  if (input.FullLoadErrorPercentage !== undefined) {
    bodyParams["FullLoadErrorPercentage"] = input.FullLoadErrorPercentage;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  return bodyParams;
};

const serializeAws_json1_1EventCategoriesList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1Filter = (
  input: Filter,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1FilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1FilterList = (
  input: Array<Filter>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Filter(entry, context));
  }
  return contents;
};

const serializeAws_json1_1FilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1ImportCertificateMessage = (
  input: ImportCertificateMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateIdentifier !== undefined) {
    bodyParams["CertificateIdentifier"] = input.CertificateIdentifier;
  }
  if (input.CertificatePem !== undefined) {
    bodyParams["CertificatePem"] = input.CertificatePem;
  }
  if (input.CertificateWallet !== undefined) {
    bodyParams["CertificateWallet"] = context.base64Encoder(
      input.CertificateWallet
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1KeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1KinesisSettings = (
  input: KinesisSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.MessageFormat !== undefined) {
    bodyParams["MessageFormat"] = input.MessageFormat;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  if (input.StreamArn !== undefined) {
    bodyParams["StreamArn"] = input.StreamArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsForResourceMessage = (
  input: ListTagsForResourceMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ModifyEndpointMessage = (
  input: ModifyEndpointMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CertificateArn !== undefined) {
    bodyParams["CertificateArn"] = input.CertificateArn;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.DmsTransferSettings !== undefined) {
    bodyParams["DmsTransferSettings"] = serializeAws_json1_1DmsTransferSettings(
      input.DmsTransferSettings,
      context
    );
  }
  if (input.DynamoDbSettings !== undefined) {
    bodyParams["DynamoDbSettings"] = serializeAws_json1_1DynamoDbSettings(
      input.DynamoDbSettings,
      context
    );
  }
  if (input.ElasticsearchSettings !== undefined) {
    bodyParams[
      "ElasticsearchSettings"
    ] = serializeAws_json1_1ElasticsearchSettings(
      input.ElasticsearchSettings,
      context
    );
  }
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.EndpointIdentifier !== undefined) {
    bodyParams["EndpointIdentifier"] = input.EndpointIdentifier;
  }
  if (input.EndpointType !== undefined) {
    bodyParams["EndpointType"] = input.EndpointType;
  }
  if (input.EngineName !== undefined) {
    bodyParams["EngineName"] = input.EngineName;
  }
  if (input.ExternalTableDefinition !== undefined) {
    bodyParams["ExternalTableDefinition"] = input.ExternalTableDefinition;
  }
  if (input.ExtraConnectionAttributes !== undefined) {
    bodyParams["ExtraConnectionAttributes"] = input.ExtraConnectionAttributes;
  }
  if (input.KinesisSettings !== undefined) {
    bodyParams["KinesisSettings"] = serializeAws_json1_1KinesisSettings(
      input.KinesisSettings,
      context
    );
  }
  if (input.MongoDbSettings !== undefined) {
    bodyParams["MongoDbSettings"] = serializeAws_json1_1MongoDbSettings(
      input.MongoDbSettings,
      context
    );
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  if (input.RedshiftSettings !== undefined) {
    bodyParams["RedshiftSettings"] = serializeAws_json1_1RedshiftSettings(
      input.RedshiftSettings,
      context
    );
  }
  if (input.S3Settings !== undefined) {
    bodyParams["S3Settings"] = serializeAws_json1_1S3Settings(
      input.S3Settings,
      context
    );
  }
  if (input.ServerName !== undefined) {
    bodyParams["ServerName"] = input.ServerName;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  if (input.SslMode !== undefined) {
    bodyParams["SslMode"] = input.SslMode;
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  return bodyParams;
};

const serializeAws_json1_1ModifyEventSubscriptionMessage = (
  input: ModifyEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.EventCategories !== undefined) {
    bodyParams["EventCategories"] = serializeAws_json1_1EventCategoriesList(
      input.EventCategories,
      context
    );
  }
  if (input.SnsTopicArn !== undefined) {
    bodyParams["SnsTopicArn"] = input.SnsTopicArn;
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  if (input.SubscriptionName !== undefined) {
    bodyParams["SubscriptionName"] = input.SubscriptionName;
  }
  return bodyParams;
};

const serializeAws_json1_1ModifyReplicationInstanceMessage = (
  input: ModifyReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AllocatedStorage !== undefined) {
    bodyParams["AllocatedStorage"] = input.AllocatedStorage;
  }
  if (input.AllowMajorVersionUpgrade !== undefined) {
    bodyParams["AllowMajorVersionUpgrade"] = input.AllowMajorVersionUpgrade;
  }
  if (input.ApplyImmediately !== undefined) {
    bodyParams["ApplyImmediately"] = input.ApplyImmediately;
  }
  if (input.AutoMinorVersionUpgrade !== undefined) {
    bodyParams["AutoMinorVersionUpgrade"] = input.AutoMinorVersionUpgrade;
  }
  if (input.EngineVersion !== undefined) {
    bodyParams["EngineVersion"] = input.EngineVersion;
  }
  if (input.MultiAZ !== undefined) {
    bodyParams["MultiAZ"] = input.MultiAZ;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    bodyParams["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  if (input.ReplicationInstanceClass !== undefined) {
    bodyParams["ReplicationInstanceClass"] = input.ReplicationInstanceClass;
  }
  if (input.ReplicationInstanceIdentifier !== undefined) {
    bodyParams["ReplicationInstanceIdentifier"] =
      input.ReplicationInstanceIdentifier;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    bodyParams[
      "VpcSecurityGroupIds"
    ] = serializeAws_json1_1VpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ModifyReplicationSubnetGroupMessage = (
  input: ModifyReplicationSubnetGroupMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ReplicationSubnetGroupDescription !== undefined) {
    bodyParams["ReplicationSubnetGroupDescription"] =
      input.ReplicationSubnetGroupDescription;
  }
  if (input.ReplicationSubnetGroupIdentifier !== undefined) {
    bodyParams["ReplicationSubnetGroupIdentifier"] =
      input.ReplicationSubnetGroupIdentifier;
  }
  if (input.SubnetIds !== undefined) {
    bodyParams["SubnetIds"] = serializeAws_json1_1SubnetIdentifierList(
      input.SubnetIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ModifyReplicationTaskMessage = (
  input: ModifyReplicationTaskMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CdcStartPosition !== undefined) {
    bodyParams["CdcStartPosition"] = input.CdcStartPosition;
  }
  if (input.CdcStartTime !== undefined) {
    bodyParams["CdcStartTime"] = Math.round(
      input.CdcStartTime.getTime() / 1000
    );
  }
  if (input.CdcStopPosition !== undefined) {
    bodyParams["CdcStopPosition"] = input.CdcStopPosition;
  }
  if (input.MigrationType !== undefined) {
    bodyParams["MigrationType"] = input.MigrationType;
  }
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  if (input.ReplicationTaskIdentifier !== undefined) {
    bodyParams["ReplicationTaskIdentifier"] = input.ReplicationTaskIdentifier;
  }
  if (input.ReplicationTaskSettings !== undefined) {
    bodyParams["ReplicationTaskSettings"] = input.ReplicationTaskSettings;
  }
  if (input.TableMappings !== undefined) {
    bodyParams["TableMappings"] = input.TableMappings;
  }
  return bodyParams;
};

const serializeAws_json1_1MongoDbSettings = (
  input: MongoDbSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AuthMechanism !== undefined) {
    bodyParams["AuthMechanism"] = input.AuthMechanism;
  }
  if (input.AuthSource !== undefined) {
    bodyParams["AuthSource"] = input.AuthSource;
  }
  if (input.AuthType !== undefined) {
    bodyParams["AuthType"] = input.AuthType;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.DocsToInvestigate !== undefined) {
    bodyParams["DocsToInvestigate"] = input.DocsToInvestigate;
  }
  if (input.ExtractDocId !== undefined) {
    bodyParams["ExtractDocId"] = input.ExtractDocId;
  }
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.NestingLevel !== undefined) {
    bodyParams["NestingLevel"] = input.NestingLevel;
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  if (input.ServerName !== undefined) {
    bodyParams["ServerName"] = input.ServerName;
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  return bodyParams;
};

const serializeAws_json1_1RebootReplicationInstanceMessage = (
  input: RebootReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ForceFailover !== undefined) {
    bodyParams["ForceFailover"] = input.ForceFailover;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1RedshiftSettings = (
  input: RedshiftSettings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.AcceptAnyDate !== undefined) {
    bodyParams["AcceptAnyDate"] = input.AcceptAnyDate;
  }
  if (input.AfterConnectScript !== undefined) {
    bodyParams["AfterConnectScript"] = input.AfterConnectScript;
  }
  if (input.BucketFolder !== undefined) {
    bodyParams["BucketFolder"] = input.BucketFolder;
  }
  if (input.BucketName !== undefined) {
    bodyParams["BucketName"] = input.BucketName;
  }
  if (input.ConnectionTimeout !== undefined) {
    bodyParams["ConnectionTimeout"] = input.ConnectionTimeout;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.DateFormat !== undefined) {
    bodyParams["DateFormat"] = input.DateFormat;
  }
  if (input.EmptyAsNull !== undefined) {
    bodyParams["EmptyAsNull"] = input.EmptyAsNull;
  }
  if (input.EncryptionMode !== undefined) {
    bodyParams["EncryptionMode"] = input.EncryptionMode;
  }
  if (input.FileTransferUploadStreams !== undefined) {
    bodyParams["FileTransferUploadStreams"] = input.FileTransferUploadStreams;
  }
  if (input.LoadTimeout !== undefined) {
    bodyParams["LoadTimeout"] = input.LoadTimeout;
  }
  if (input.MaxFileSize !== undefined) {
    bodyParams["MaxFileSize"] = input.MaxFileSize;
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  if (input.RemoveQuotes !== undefined) {
    bodyParams["RemoveQuotes"] = input.RemoveQuotes;
  }
  if (input.ReplaceChars !== undefined) {
    bodyParams["ReplaceChars"] = input.ReplaceChars;
  }
  if (input.ReplaceInvalidChars !== undefined) {
    bodyParams["ReplaceInvalidChars"] = input.ReplaceInvalidChars;
  }
  if (input.ServerName !== undefined) {
    bodyParams["ServerName"] = input.ServerName;
  }
  if (input.ServerSideEncryptionKmsKeyId !== undefined) {
    bodyParams["ServerSideEncryptionKmsKeyId"] =
      input.ServerSideEncryptionKmsKeyId;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  if (input.TimeFormat !== undefined) {
    bodyParams["TimeFormat"] = input.TimeFormat;
  }
  if (input.TrimBlanks !== undefined) {
    bodyParams["TrimBlanks"] = input.TrimBlanks;
  }
  if (input.TruncateColumns !== undefined) {
    bodyParams["TruncateColumns"] = input.TruncateColumns;
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  if (input.WriteBufferSize !== undefined) {
    bodyParams["WriteBufferSize"] = input.WriteBufferSize;
  }
  return bodyParams;
};

const serializeAws_json1_1RefreshSchemasMessage = (
  input: RefreshSchemasMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ReloadTablesMessage = (
  input: ReloadTablesMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ReloadOption !== undefined) {
    bodyParams["ReloadOption"] = input.ReloadOption;
  }
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  if (input.TablesToReload !== undefined) {
    bodyParams["TablesToReload"] = serializeAws_json1_1TableListToReload(
      input.TablesToReload,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1RemoveTagsFromResourceMessage = (
  input: RemoveTagsFromResourceMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.TagKeys !== undefined) {
    bodyParams["TagKeys"] = serializeAws_json1_1KeyList(input.TagKeys, context);
  }
  return bodyParams;
};

const serializeAws_json1_1S3Settings = (
  input: S3Settings,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.BucketFolder !== undefined) {
    bodyParams["BucketFolder"] = input.BucketFolder;
  }
  if (input.BucketName !== undefined) {
    bodyParams["BucketName"] = input.BucketName;
  }
  if (input.CdcInsertsOnly !== undefined) {
    bodyParams["CdcInsertsOnly"] = input.CdcInsertsOnly;
  }
  if (input.CompressionType !== undefined) {
    bodyParams["CompressionType"] = input.CompressionType;
  }
  if (input.CsvDelimiter !== undefined) {
    bodyParams["CsvDelimiter"] = input.CsvDelimiter;
  }
  if (input.CsvRowDelimiter !== undefined) {
    bodyParams["CsvRowDelimiter"] = input.CsvRowDelimiter;
  }
  if (input.DataFormat !== undefined) {
    bodyParams["DataFormat"] = input.DataFormat;
  }
  if (input.DataPageSize !== undefined) {
    bodyParams["DataPageSize"] = input.DataPageSize;
  }
  if (input.DictPageSizeLimit !== undefined) {
    bodyParams["DictPageSizeLimit"] = input.DictPageSizeLimit;
  }
  if (input.EnableStatistics !== undefined) {
    bodyParams["EnableStatistics"] = input.EnableStatistics;
  }
  if (input.EncodingType !== undefined) {
    bodyParams["EncodingType"] = input.EncodingType;
  }
  if (input.EncryptionMode !== undefined) {
    bodyParams["EncryptionMode"] = input.EncryptionMode;
  }
  if (input.ExternalTableDefinition !== undefined) {
    bodyParams["ExternalTableDefinition"] = input.ExternalTableDefinition;
  }
  if (input.IncludeOpForFullLoad !== undefined) {
    bodyParams["IncludeOpForFullLoad"] = input.IncludeOpForFullLoad;
  }
  if (input.ParquetTimestampInMillisecond !== undefined) {
    bodyParams["ParquetTimestampInMillisecond"] =
      input.ParquetTimestampInMillisecond;
  }
  if (input.ParquetVersion !== undefined) {
    bodyParams["ParquetVersion"] = input.ParquetVersion;
  }
  if (input.RowGroupLength !== undefined) {
    bodyParams["RowGroupLength"] = input.RowGroupLength;
  }
  if (input.ServerSideEncryptionKmsKeyId !== undefined) {
    bodyParams["ServerSideEncryptionKmsKeyId"] =
      input.ServerSideEncryptionKmsKeyId;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  if (input.TimestampColumnName !== undefined) {
    bodyParams["TimestampColumnName"] = input.TimestampColumnName;
  }
  return bodyParams;
};

const serializeAws_json1_1SourceIdsList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1StartReplicationTaskAssessmentMessage = (
  input: StartReplicationTaskAssessmentMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  return bodyParams;
};

const serializeAws_json1_1StartReplicationTaskMessage = (
  input: StartReplicationTaskMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.CdcStartPosition !== undefined) {
    bodyParams["CdcStartPosition"] = input.CdcStartPosition;
  }
  if (input.CdcStartTime !== undefined) {
    bodyParams["CdcStartTime"] = Math.round(
      input.CdcStartTime.getTime() / 1000
    );
  }
  if (input.CdcStopPosition !== undefined) {
    bodyParams["CdcStopPosition"] = input.CdcStopPosition;
  }
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  if (input.StartReplicationTaskType !== undefined) {
    bodyParams["StartReplicationTaskType"] = input.StartReplicationTaskType;
  }
  return bodyParams;
};

const serializeAws_json1_1StopReplicationTaskMessage = (
  input: StopReplicationTaskMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  return bodyParams;
};

const serializeAws_json1_1SubnetIdentifierList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const serializeAws_json1_1TableListToReload = (
  input: Array<TableToReload>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1TableToReload(entry, context));
  }
  return contents;
};

const serializeAws_json1_1TableToReload = (
  input: TableToReload,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.SchemaName !== undefined) {
    bodyParams["SchemaName"] = input.SchemaName;
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  const bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(serializeAws_json1_1Tag(entry, context));
  }
  return contents;
};

const serializeAws_json1_1TestConnectionMessage = (
  input: TestConnectionMessage,
  context: __SerdeContext
): any => {
  const bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1VpcSecurityGroupIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  const contents = [];
  for (let entry of input) {
    contents.push(entry);
  }
  return contents;
};

const deserializeAws_json1_1AccessDeniedFault = (
  output: any,
  context: __SerdeContext
): AccessDeniedFault => {
  let contents: any = {
    __type: "AccessDeniedFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InsufficientResourceCapacityFault = (
  output: any,
  context: __SerdeContext
): InsufficientResourceCapacityFault => {
  let contents: any = {
    __type: "InsufficientResourceCapacityFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidCertificateFault = (
  output: any,
  context: __SerdeContext
): InvalidCertificateFault => {
  let contents: any = {
    __type: "InvalidCertificateFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidResourceStateFault = (
  output: any,
  context: __SerdeContext
): InvalidResourceStateFault => {
  let contents: any = {
    __type: "InvalidResourceStateFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidSubnet = (
  output: any,
  context: __SerdeContext
): InvalidSubnet => {
  let contents: any = {
    __type: "InvalidSubnet",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSAccessDeniedFault = (
  output: any,
  context: __SerdeContext
): KMSAccessDeniedFault => {
  let contents: any = {
    __type: "KMSAccessDeniedFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSDisabledFault = (
  output: any,
  context: __SerdeContext
): KMSDisabledFault => {
  let contents: any = {
    __type: "KMSDisabledFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSInvalidStateFault = (
  output: any,
  context: __SerdeContext
): KMSInvalidStateFault => {
  let contents: any = {
    __type: "KMSInvalidStateFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSKeyNotAccessibleFault = (
  output: any,
  context: __SerdeContext
): KMSKeyNotAccessibleFault => {
  let contents: any = {
    __type: "KMSKeyNotAccessibleFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSNotFoundFault = (
  output: any,
  context: __SerdeContext
): KMSNotFoundFault => {
  let contents: any = {
    __type: "KMSNotFoundFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSThrottlingFault = (
  output: any,
  context: __SerdeContext
): KMSThrottlingFault => {
  let contents: any = {
    __type: "KMSThrottlingFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZs = (
  output: any,
  context: __SerdeContext
): ReplicationSubnetGroupDoesNotCoverEnoughAZs => {
  let contents: any = {
    __type: "ReplicationSubnetGroupDoesNotCoverEnoughAZs",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ResourceAlreadyExistsFault => {
  let contents: any = {
    __type: "ResourceAlreadyExistsFault",
    message: undefined,
    resourceArn: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  if (output.resourceArn !== undefined && output.resourceArn !== null) {
    contents.resourceArn = output.resourceArn;
  }
  return contents;
};

const deserializeAws_json1_1ResourceNotFoundFault = (
  output: any,
  context: __SerdeContext
): ResourceNotFoundFault => {
  let contents: any = {
    __type: "ResourceNotFoundFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ResourceQuotaExceededFault => {
  let contents: any = {
    __type: "ResourceQuotaExceededFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SNSInvalidTopicFault = (
  output: any,
  context: __SerdeContext
): SNSInvalidTopicFault => {
  let contents: any = {
    __type: "SNSInvalidTopicFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SNSNoAuthorizationFault = (
  output: any,
  context: __SerdeContext
): SNSNoAuthorizationFault => {
  let contents: any = {
    __type: "SNSNoAuthorizationFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1StorageQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): StorageQuotaExceededFault => {
  let contents: any = {
    __type: "StorageQuotaExceededFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SubnetAlreadyInUse = (
  output: any,
  context: __SerdeContext
): SubnetAlreadyInUse => {
  let contents: any = {
    __type: "SubnetAlreadyInUse",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1UpgradeDependencyFailureFault = (
  output: any,
  context: __SerdeContext
): UpgradeDependencyFailureFault => {
  let contents: any = {
    __type: "UpgradeDependencyFailureFault",
    message: undefined
  };
  if (output.message !== undefined && output.message !== null) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1AccountQuota = (
  output: any,
  context: __SerdeContext
): AccountQuota => {
  let contents: any = {
    __type: "AccountQuota",
    AccountQuotaName: undefined,
    Max: undefined,
    Used: undefined
  };
  if (
    output.AccountQuotaName !== undefined &&
    output.AccountQuotaName !== null
  ) {
    contents.AccountQuotaName = output.AccountQuotaName;
  }
  if (output.Max !== undefined && output.Max !== null) {
    contents.Max = output.Max;
  }
  if (output.Used !== undefined && output.Used !== null) {
    contents.Used = output.Used;
  }
  return contents;
};

const deserializeAws_json1_1AccountQuotaList = (
  output: any,
  context: __SerdeContext
): Array<AccountQuota> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AccountQuota(entry, context)
  );
};

const deserializeAws_json1_1AddTagsToResourceResponse = (
  output: any,
  context: __SerdeContext
): AddTagsToResourceResponse => {
  let contents: any = {
    __type: "AddTagsToResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1ApplyPendingMaintenanceActionResponse = (
  output: any,
  context: __SerdeContext
): ApplyPendingMaintenanceActionResponse => {
  let contents: any = {
    __type: "ApplyPendingMaintenanceActionResponse",
    ResourcePendingMaintenanceActions: undefined
  };
  if (
    output.ResourcePendingMaintenanceActions !== undefined &&
    output.ResourcePendingMaintenanceActions !== null
  ) {
    contents.ResourcePendingMaintenanceActions = deserializeAws_json1_1ResourcePendingMaintenanceActions(
      output.ResourcePendingMaintenanceActions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1AvailabilityZone = (
  output: any,
  context: __SerdeContext
): AvailabilityZone => {
  let contents: any = {
    __type: "AvailabilityZone",
    Name: undefined
  };
  if (output.Name !== undefined && output.Name !== null) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1AvailabilityZonesList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Certificate = (
  output: any,
  context: __SerdeContext
): Certificate => {
  let contents: any = {
    __type: "Certificate",
    CertificateArn: undefined,
    CertificateCreationDate: undefined,
    CertificateIdentifier: undefined,
    CertificateOwner: undefined,
    CertificatePem: undefined,
    CertificateWallet: undefined,
    KeyLength: undefined,
    SigningAlgorithm: undefined,
    ValidFromDate: undefined,
    ValidToDate: undefined
  };
  if (output.CertificateArn !== undefined && output.CertificateArn !== null) {
    contents.CertificateArn = output.CertificateArn;
  }
  if (
    output.CertificateCreationDate !== undefined &&
    output.CertificateCreationDate !== null
  ) {
    contents.CertificateCreationDate = new Date(
      Math.round(output.CertificateCreationDate * 1000)
    );
  }
  if (
    output.CertificateIdentifier !== undefined &&
    output.CertificateIdentifier !== null
  ) {
    contents.CertificateIdentifier = output.CertificateIdentifier;
  }
  if (
    output.CertificateOwner !== undefined &&
    output.CertificateOwner !== null
  ) {
    contents.CertificateOwner = output.CertificateOwner;
  }
  if (output.CertificatePem !== undefined && output.CertificatePem !== null) {
    contents.CertificatePem = output.CertificatePem;
  }
  if (
    output.CertificateWallet !== undefined &&
    output.CertificateWallet !== null
  ) {
    contents.CertificateWallet = context.base64Decoder(
      output.CertificateWallet
    );
  }
  if (output.KeyLength !== undefined && output.KeyLength !== null) {
    contents.KeyLength = output.KeyLength;
  }
  if (
    output.SigningAlgorithm !== undefined &&
    output.SigningAlgorithm !== null
  ) {
    contents.SigningAlgorithm = output.SigningAlgorithm;
  }
  if (output.ValidFromDate !== undefined && output.ValidFromDate !== null) {
    contents.ValidFromDate = new Date(Math.round(output.ValidFromDate * 1000));
  }
  if (output.ValidToDate !== undefined && output.ValidToDate !== null) {
    contents.ValidToDate = new Date(Math.round(output.ValidToDate * 1000));
  }
  return contents;
};

const deserializeAws_json1_1CertificateList = (
  output: any,
  context: __SerdeContext
): Array<Certificate> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Certificate(entry, context)
  );
};

const deserializeAws_json1_1Connection = (
  output: any,
  context: __SerdeContext
): Connection => {
  let contents: any = {
    __type: "Connection",
    EndpointArn: undefined,
    EndpointIdentifier: undefined,
    LastFailureMessage: undefined,
    ReplicationInstanceArn: undefined,
    ReplicationInstanceIdentifier: undefined,
    Status: undefined
  };
  if (output.EndpointArn !== undefined && output.EndpointArn !== null) {
    contents.EndpointArn = output.EndpointArn;
  }
  if (
    output.EndpointIdentifier !== undefined &&
    output.EndpointIdentifier !== null
  ) {
    contents.EndpointIdentifier = output.EndpointIdentifier;
  }
  if (
    output.LastFailureMessage !== undefined &&
    output.LastFailureMessage !== null
  ) {
    contents.LastFailureMessage = output.LastFailureMessage;
  }
  if (
    output.ReplicationInstanceArn !== undefined &&
    output.ReplicationInstanceArn !== null
  ) {
    contents.ReplicationInstanceArn = output.ReplicationInstanceArn;
  }
  if (
    output.ReplicationInstanceIdentifier !== undefined &&
    output.ReplicationInstanceIdentifier !== null
  ) {
    contents.ReplicationInstanceIdentifier =
      output.ReplicationInstanceIdentifier;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1ConnectionList = (
  output: any,
  context: __SerdeContext
): Array<Connection> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Connection(entry, context)
  );
};

const deserializeAws_json1_1CreateEndpointResponse = (
  output: any,
  context: __SerdeContext
): CreateEndpointResponse => {
  let contents: any = {
    __type: "CreateEndpointResponse",
    Endpoint: undefined
  };
  if (output.Endpoint !== undefined && output.Endpoint !== null) {
    contents.Endpoint = deserializeAws_json1_1Endpoint(
      output.Endpoint,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateEventSubscriptionResponse = (
  output: any,
  context: __SerdeContext
): CreateEventSubscriptionResponse => {
  let contents: any = {
    __type: "CreateEventSubscriptionResponse",
    EventSubscription: undefined
  };
  if (
    output.EventSubscription !== undefined &&
    output.EventSubscription !== null
  ) {
    contents.EventSubscription = deserializeAws_json1_1EventSubscription(
      output.EventSubscription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): CreateReplicationInstanceResponse => {
  let contents: any = {
    __type: "CreateReplicationInstanceResponse",
    ReplicationInstance: undefined
  };
  if (
    output.ReplicationInstance !== undefined &&
    output.ReplicationInstance !== null
  ) {
    contents.ReplicationInstance = deserializeAws_json1_1ReplicationInstance(
      output.ReplicationInstance,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateReplicationSubnetGroupResponse = (
  output: any,
  context: __SerdeContext
): CreateReplicationSubnetGroupResponse => {
  let contents: any = {
    __type: "CreateReplicationSubnetGroupResponse",
    ReplicationSubnetGroup: undefined
  };
  if (
    output.ReplicationSubnetGroup !== undefined &&
    output.ReplicationSubnetGroup !== null
  ) {
    contents.ReplicationSubnetGroup = deserializeAws_json1_1ReplicationSubnetGroup(
      output.ReplicationSubnetGroup,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): CreateReplicationTaskResponse => {
  let contents: any = {
    __type: "CreateReplicationTaskResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined && output.ReplicationTask !== null) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteCertificateResponse = (
  output: any,
  context: __SerdeContext
): DeleteCertificateResponse => {
  let contents: any = {
    __type: "DeleteCertificateResponse",
    Certificate: undefined
  };
  if (output.Certificate !== undefined && output.Certificate !== null) {
    contents.Certificate = deserializeAws_json1_1Certificate(
      output.Certificate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteConnectionResponse = (
  output: any,
  context: __SerdeContext
): DeleteConnectionResponse => {
  let contents: any = {
    __type: "DeleteConnectionResponse",
    Connection: undefined
  };
  if (output.Connection !== undefined && output.Connection !== null) {
    contents.Connection = deserializeAws_json1_1Connection(
      output.Connection,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteEndpointResponse = (
  output: any,
  context: __SerdeContext
): DeleteEndpointResponse => {
  let contents: any = {
    __type: "DeleteEndpointResponse",
    Endpoint: undefined
  };
  if (output.Endpoint !== undefined && output.Endpoint !== null) {
    contents.Endpoint = deserializeAws_json1_1Endpoint(
      output.Endpoint,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteEventSubscriptionResponse = (
  output: any,
  context: __SerdeContext
): DeleteEventSubscriptionResponse => {
  let contents: any = {
    __type: "DeleteEventSubscriptionResponse",
    EventSubscription: undefined
  };
  if (
    output.EventSubscription !== undefined &&
    output.EventSubscription !== null
  ) {
    contents.EventSubscription = deserializeAws_json1_1EventSubscription(
      output.EventSubscription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): DeleteReplicationInstanceResponse => {
  let contents: any = {
    __type: "DeleteReplicationInstanceResponse",
    ReplicationInstance: undefined
  };
  if (
    output.ReplicationInstance !== undefined &&
    output.ReplicationInstance !== null
  ) {
    contents.ReplicationInstance = deserializeAws_json1_1ReplicationInstance(
      output.ReplicationInstance,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteReplicationSubnetGroupResponse = (
  output: any,
  context: __SerdeContext
): DeleteReplicationSubnetGroupResponse => {
  let contents: any = {
    __type: "DeleteReplicationSubnetGroupResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): DeleteReplicationTaskResponse => {
  let contents: any = {
    __type: "DeleteReplicationTaskResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined && output.ReplicationTask !== null) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeAccountAttributesResponse = (
  output: any,
  context: __SerdeContext
): DescribeAccountAttributesResponse => {
  let contents: any = {
    __type: "DescribeAccountAttributesResponse",
    AccountQuotas: undefined,
    UniqueAccountIdentifier: undefined
  };
  if (output.AccountQuotas !== undefined && output.AccountQuotas !== null) {
    contents.AccountQuotas = deserializeAws_json1_1AccountQuotaList(
      output.AccountQuotas,
      context
    );
  }
  if (
    output.UniqueAccountIdentifier !== undefined &&
    output.UniqueAccountIdentifier !== null
  ) {
    contents.UniqueAccountIdentifier = output.UniqueAccountIdentifier;
  }
  return contents;
};

const deserializeAws_json1_1DescribeCertificatesResponse = (
  output: any,
  context: __SerdeContext
): DescribeCertificatesResponse => {
  let contents: any = {
    __type: "DescribeCertificatesResponse",
    Certificates: undefined,
    Marker: undefined
  };
  if (output.Certificates !== undefined && output.Certificates !== null) {
    contents.Certificates = deserializeAws_json1_1CertificateList(
      output.Certificates,
      context
    );
  }
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  return contents;
};

const deserializeAws_json1_1DescribeConnectionsResponse = (
  output: any,
  context: __SerdeContext
): DescribeConnectionsResponse => {
  let contents: any = {
    __type: "DescribeConnectionsResponse",
    Connections: undefined,
    Marker: undefined
  };
  if (output.Connections !== undefined && output.Connections !== null) {
    contents.Connections = deserializeAws_json1_1ConnectionList(
      output.Connections,
      context
    );
  }
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  return contents;
};

const deserializeAws_json1_1DescribeEndpointTypesResponse = (
  output: any,
  context: __SerdeContext
): DescribeEndpointTypesResponse => {
  let contents: any = {
    __type: "DescribeEndpointTypesResponse",
    Marker: undefined,
    SupportedEndpointTypes: undefined
  };
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  if (
    output.SupportedEndpointTypes !== undefined &&
    output.SupportedEndpointTypes !== null
  ) {
    contents.SupportedEndpointTypes = deserializeAws_json1_1SupportedEndpointTypeList(
      output.SupportedEndpointTypes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEndpointsResponse = (
  output: any,
  context: __SerdeContext
): DescribeEndpointsResponse => {
  let contents: any = {
    __type: "DescribeEndpointsResponse",
    Endpoints: undefined,
    Marker: undefined
  };
  if (output.Endpoints !== undefined && output.Endpoints !== null) {
    contents.Endpoints = deserializeAws_json1_1EndpointList(
      output.Endpoints,
      context
    );
  }
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  return contents;
};

const deserializeAws_json1_1DescribeEventCategoriesResponse = (
  output: any,
  context: __SerdeContext
): DescribeEventCategoriesResponse => {
  let contents: any = {
    __type: "DescribeEventCategoriesResponse",
    EventCategoryGroupList: undefined
  };
  if (
    output.EventCategoryGroupList !== undefined &&
    output.EventCategoryGroupList !== null
  ) {
    contents.EventCategoryGroupList = deserializeAws_json1_1EventCategoryGroupList(
      output.EventCategoryGroupList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEventSubscriptionsResponse = (
  output: any,
  context: __SerdeContext
): DescribeEventSubscriptionsResponse => {
  let contents: any = {
    __type: "DescribeEventSubscriptionsResponse",
    EventSubscriptionsList: undefined,
    Marker: undefined
  };
  if (
    output.EventSubscriptionsList !== undefined &&
    output.EventSubscriptionsList !== null
  ) {
    contents.EventSubscriptionsList = deserializeAws_json1_1EventSubscriptionsList(
      output.EventSubscriptionsList,
      context
    );
  }
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  return contents;
};

const deserializeAws_json1_1DescribeEventsResponse = (
  output: any,
  context: __SerdeContext
): DescribeEventsResponse => {
  let contents: any = {
    __type: "DescribeEventsResponse",
    Events: undefined,
    Marker: undefined
  };
  if (output.Events !== undefined && output.Events !== null) {
    contents.Events = deserializeAws_json1_1EventList(output.Events, context);
  }
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  return contents;
};

const deserializeAws_json1_1DescribeOrderableReplicationInstancesResponse = (
  output: any,
  context: __SerdeContext
): DescribeOrderableReplicationInstancesResponse => {
  let contents: any = {
    __type: "DescribeOrderableReplicationInstancesResponse",
    Marker: undefined,
    OrderableReplicationInstances: undefined
  };
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  if (
    output.OrderableReplicationInstances !== undefined &&
    output.OrderableReplicationInstances !== null
  ) {
    contents.OrderableReplicationInstances = deserializeAws_json1_1OrderableReplicationInstanceList(
      output.OrderableReplicationInstances,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribePendingMaintenanceActionsResponse = (
  output: any,
  context: __SerdeContext
): DescribePendingMaintenanceActionsResponse => {
  let contents: any = {
    __type: "DescribePendingMaintenanceActionsResponse",
    Marker: undefined,
    PendingMaintenanceActions: undefined
  };
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  if (
    output.PendingMaintenanceActions !== undefined &&
    output.PendingMaintenanceActions !== null
  ) {
    contents.PendingMaintenanceActions = deserializeAws_json1_1PendingMaintenanceActions(
      output.PendingMaintenanceActions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeRefreshSchemasStatusResponse = (
  output: any,
  context: __SerdeContext
): DescribeRefreshSchemasStatusResponse => {
  let contents: any = {
    __type: "DescribeRefreshSchemasStatusResponse",
    RefreshSchemasStatus: undefined
  };
  if (
    output.RefreshSchemasStatus !== undefined &&
    output.RefreshSchemasStatus !== null
  ) {
    contents.RefreshSchemasStatus = deserializeAws_json1_1RefreshSchemasStatus(
      output.RefreshSchemasStatus,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeReplicationInstanceTaskLogsResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationInstanceTaskLogsResponse => {
  let contents: any = {
    __type: "DescribeReplicationInstanceTaskLogsResponse",
    Marker: undefined,
    ReplicationInstanceArn: undefined,
    ReplicationInstanceTaskLogs: undefined
  };
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  if (
    output.ReplicationInstanceArn !== undefined &&
    output.ReplicationInstanceArn !== null
  ) {
    contents.ReplicationInstanceArn = output.ReplicationInstanceArn;
  }
  if (
    output.ReplicationInstanceTaskLogs !== undefined &&
    output.ReplicationInstanceTaskLogs !== null
  ) {
    contents.ReplicationInstanceTaskLogs = deserializeAws_json1_1ReplicationInstanceTaskLogsList(
      output.ReplicationInstanceTaskLogs,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeReplicationInstancesResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationInstancesResponse => {
  let contents: any = {
    __type: "DescribeReplicationInstancesResponse",
    Marker: undefined,
    ReplicationInstances: undefined
  };
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  if (
    output.ReplicationInstances !== undefined &&
    output.ReplicationInstances !== null
  ) {
    contents.ReplicationInstances = deserializeAws_json1_1ReplicationInstanceList(
      output.ReplicationInstances,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeReplicationSubnetGroupsResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationSubnetGroupsResponse => {
  let contents: any = {
    __type: "DescribeReplicationSubnetGroupsResponse",
    Marker: undefined,
    ReplicationSubnetGroups: undefined
  };
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  if (
    output.ReplicationSubnetGroups !== undefined &&
    output.ReplicationSubnetGroups !== null
  ) {
    contents.ReplicationSubnetGroups = deserializeAws_json1_1ReplicationSubnetGroups(
      output.ReplicationSubnetGroups,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationTaskAssessmentResultsResponse => {
  let contents: any = {
    __type: "DescribeReplicationTaskAssessmentResultsResponse",
    BucketName: undefined,
    Marker: undefined,
    ReplicationTaskAssessmentResults: undefined
  };
  if (output.BucketName !== undefined && output.BucketName !== null) {
    contents.BucketName = output.BucketName;
  }
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  if (
    output.ReplicationTaskAssessmentResults !== undefined &&
    output.ReplicationTaskAssessmentResults !== null
  ) {
    contents.ReplicationTaskAssessmentResults = deserializeAws_json1_1ReplicationTaskAssessmentResultList(
      output.ReplicationTaskAssessmentResults,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeReplicationTasksResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationTasksResponse => {
  let contents: any = {
    __type: "DescribeReplicationTasksResponse",
    Marker: undefined,
    ReplicationTasks: undefined
  };
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  if (
    output.ReplicationTasks !== undefined &&
    output.ReplicationTasks !== null
  ) {
    contents.ReplicationTasks = deserializeAws_json1_1ReplicationTaskList(
      output.ReplicationTasks,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeSchemasResponse = (
  output: any,
  context: __SerdeContext
): DescribeSchemasResponse => {
  let contents: any = {
    __type: "DescribeSchemasResponse",
    Marker: undefined,
    Schemas: undefined
  };
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  if (output.Schemas !== undefined && output.Schemas !== null) {
    contents.Schemas = deserializeAws_json1_1SchemaList(
      output.Schemas,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeTableStatisticsResponse = (
  output: any,
  context: __SerdeContext
): DescribeTableStatisticsResponse => {
  let contents: any = {
    __type: "DescribeTableStatisticsResponse",
    Marker: undefined,
    ReplicationTaskArn: undefined,
    TableStatistics: undefined
  };
  if (output.Marker !== undefined && output.Marker !== null) {
    contents.Marker = output.Marker;
  }
  if (
    output.ReplicationTaskArn !== undefined &&
    output.ReplicationTaskArn !== null
  ) {
    contents.ReplicationTaskArn = output.ReplicationTaskArn;
  }
  if (output.TableStatistics !== undefined && output.TableStatistics !== null) {
    contents.TableStatistics = deserializeAws_json1_1TableStatisticsList(
      output.TableStatistics,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DmsTransferSettings = (
  output: any,
  context: __SerdeContext
): DmsTransferSettings => {
  let contents: any = {
    __type: "DmsTransferSettings",
    BucketName: undefined,
    ServiceAccessRoleArn: undefined
  };
  if (output.BucketName !== undefined && output.BucketName !== null) {
    contents.BucketName = output.BucketName;
  }
  if (
    output.ServiceAccessRoleArn !== undefined &&
    output.ServiceAccessRoleArn !== null
  ) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  return contents;
};

const deserializeAws_json1_1DynamoDbSettings = (
  output: any,
  context: __SerdeContext
): DynamoDbSettings => {
  let contents: any = {
    __type: "DynamoDbSettings",
    ServiceAccessRoleArn: undefined
  };
  if (
    output.ServiceAccessRoleArn !== undefined &&
    output.ServiceAccessRoleArn !== null
  ) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  return contents;
};

const deserializeAws_json1_1ElasticsearchSettings = (
  output: any,
  context: __SerdeContext
): ElasticsearchSettings => {
  let contents: any = {
    __type: "ElasticsearchSettings",
    EndpointUri: undefined,
    ErrorRetryDuration: undefined,
    FullLoadErrorPercentage: undefined,
    ServiceAccessRoleArn: undefined
  };
  if (output.EndpointUri !== undefined && output.EndpointUri !== null) {
    contents.EndpointUri = output.EndpointUri;
  }
  if (
    output.ErrorRetryDuration !== undefined &&
    output.ErrorRetryDuration !== null
  ) {
    contents.ErrorRetryDuration = output.ErrorRetryDuration;
  }
  if (
    output.FullLoadErrorPercentage !== undefined &&
    output.FullLoadErrorPercentage !== null
  ) {
    contents.FullLoadErrorPercentage = output.FullLoadErrorPercentage;
  }
  if (
    output.ServiceAccessRoleArn !== undefined &&
    output.ServiceAccessRoleArn !== null
  ) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  return contents;
};

const deserializeAws_json1_1Endpoint = (
  output: any,
  context: __SerdeContext
): Endpoint => {
  let contents: any = {
    __type: "Endpoint",
    CertificateArn: undefined,
    DatabaseName: undefined,
    DmsTransferSettings: undefined,
    DynamoDbSettings: undefined,
    ElasticsearchSettings: undefined,
    EndpointArn: undefined,
    EndpointIdentifier: undefined,
    EndpointType: undefined,
    EngineDisplayName: undefined,
    EngineName: undefined,
    ExternalId: undefined,
    ExternalTableDefinition: undefined,
    ExtraConnectionAttributes: undefined,
    KinesisSettings: undefined,
    KmsKeyId: undefined,
    MongoDbSettings: undefined,
    Port: undefined,
    RedshiftSettings: undefined,
    S3Settings: undefined,
    ServerName: undefined,
    ServiceAccessRoleArn: undefined,
    SslMode: undefined,
    Status: undefined,
    Username: undefined
  };
  if (output.CertificateArn !== undefined && output.CertificateArn !== null) {
    contents.CertificateArn = output.CertificateArn;
  }
  if (output.DatabaseName !== undefined && output.DatabaseName !== null) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (
    output.DmsTransferSettings !== undefined &&
    output.DmsTransferSettings !== null
  ) {
    contents.DmsTransferSettings = deserializeAws_json1_1DmsTransferSettings(
      output.DmsTransferSettings,
      context
    );
  }
  if (
    output.DynamoDbSettings !== undefined &&
    output.DynamoDbSettings !== null
  ) {
    contents.DynamoDbSettings = deserializeAws_json1_1DynamoDbSettings(
      output.DynamoDbSettings,
      context
    );
  }
  if (
    output.ElasticsearchSettings !== undefined &&
    output.ElasticsearchSettings !== null
  ) {
    contents.ElasticsearchSettings = deserializeAws_json1_1ElasticsearchSettings(
      output.ElasticsearchSettings,
      context
    );
  }
  if (output.EndpointArn !== undefined && output.EndpointArn !== null) {
    contents.EndpointArn = output.EndpointArn;
  }
  if (
    output.EndpointIdentifier !== undefined &&
    output.EndpointIdentifier !== null
  ) {
    contents.EndpointIdentifier = output.EndpointIdentifier;
  }
  if (output.EndpointType !== undefined && output.EndpointType !== null) {
    contents.EndpointType = output.EndpointType;
  }
  if (
    output.EngineDisplayName !== undefined &&
    output.EngineDisplayName !== null
  ) {
    contents.EngineDisplayName = output.EngineDisplayName;
  }
  if (output.EngineName !== undefined && output.EngineName !== null) {
    contents.EngineName = output.EngineName;
  }
  if (output.ExternalId !== undefined && output.ExternalId !== null) {
    contents.ExternalId = output.ExternalId;
  }
  if (
    output.ExternalTableDefinition !== undefined &&
    output.ExternalTableDefinition !== null
  ) {
    contents.ExternalTableDefinition = output.ExternalTableDefinition;
  }
  if (
    output.ExtraConnectionAttributes !== undefined &&
    output.ExtraConnectionAttributes !== null
  ) {
    contents.ExtraConnectionAttributes = output.ExtraConnectionAttributes;
  }
  if (output.KinesisSettings !== undefined && output.KinesisSettings !== null) {
    contents.KinesisSettings = deserializeAws_json1_1KinesisSettings(
      output.KinesisSettings,
      context
    );
  }
  if (output.KmsKeyId !== undefined && output.KmsKeyId !== null) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.MongoDbSettings !== undefined && output.MongoDbSettings !== null) {
    contents.MongoDbSettings = deserializeAws_json1_1MongoDbSettings(
      output.MongoDbSettings,
      context
    );
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  if (
    output.RedshiftSettings !== undefined &&
    output.RedshiftSettings !== null
  ) {
    contents.RedshiftSettings = deserializeAws_json1_1RedshiftSettings(
      output.RedshiftSettings,
      context
    );
  }
  if (output.S3Settings !== undefined && output.S3Settings !== null) {
    contents.S3Settings = deserializeAws_json1_1S3Settings(
      output.S3Settings,
      context
    );
  }
  if (output.ServerName !== undefined && output.ServerName !== null) {
    contents.ServerName = output.ServerName;
  }
  if (
    output.ServiceAccessRoleArn !== undefined &&
    output.ServiceAccessRoleArn !== null
  ) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  if (output.SslMode !== undefined && output.SslMode !== null) {
    contents.SslMode = output.SslMode;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.Username !== undefined && output.Username !== null) {
    contents.Username = output.Username;
  }
  return contents;
};

const deserializeAws_json1_1EndpointList = (
  output: any,
  context: __SerdeContext
): Array<Endpoint> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Endpoint(entry, context)
  );
};

const deserializeAws_json1_1Event = (
  output: any,
  context: __SerdeContext
): Event => {
  let contents: any = {
    __type: "Event",
    Date: undefined,
    EventCategories: undefined,
    Message: undefined,
    SourceIdentifier: undefined,
    SourceType: undefined
  };
  if (output.Date !== undefined && output.Date !== null) {
    contents.Date = new Date(Math.round(output.Date * 1000));
  }
  if (output.EventCategories !== undefined && output.EventCategories !== null) {
    contents.EventCategories = deserializeAws_json1_1EventCategoriesList(
      output.EventCategories,
      context
    );
  }
  if (output.Message !== undefined && output.Message !== null) {
    contents.Message = output.Message;
  }
  if (
    output.SourceIdentifier !== undefined &&
    output.SourceIdentifier !== null
  ) {
    contents.SourceIdentifier = output.SourceIdentifier;
  }
  if (output.SourceType !== undefined && output.SourceType !== null) {
    contents.SourceType = output.SourceType;
  }
  return contents;
};

const deserializeAws_json1_1EventCategoriesList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1EventCategoryGroup = (
  output: any,
  context: __SerdeContext
): EventCategoryGroup => {
  let contents: any = {
    __type: "EventCategoryGroup",
    EventCategories: undefined,
    SourceType: undefined
  };
  if (output.EventCategories !== undefined && output.EventCategories !== null) {
    contents.EventCategories = deserializeAws_json1_1EventCategoriesList(
      output.EventCategories,
      context
    );
  }
  if (output.SourceType !== undefined && output.SourceType !== null) {
    contents.SourceType = output.SourceType;
  }
  return contents;
};

const deserializeAws_json1_1EventCategoryGroupList = (
  output: any,
  context: __SerdeContext
): Array<EventCategoryGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EventCategoryGroup(entry, context)
  );
};

const deserializeAws_json1_1EventList = (
  output: any,
  context: __SerdeContext
): Array<Event> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Event(entry, context)
  );
};

const deserializeAws_json1_1EventSubscription = (
  output: any,
  context: __SerdeContext
): EventSubscription => {
  let contents: any = {
    __type: "EventSubscription",
    CustSubscriptionId: undefined,
    CustomerAwsId: undefined,
    Enabled: undefined,
    EventCategoriesList: undefined,
    SnsTopicArn: undefined,
    SourceIdsList: undefined,
    SourceType: undefined,
    Status: undefined,
    SubscriptionCreationTime: undefined
  };
  if (
    output.CustSubscriptionId !== undefined &&
    output.CustSubscriptionId !== null
  ) {
    contents.CustSubscriptionId = output.CustSubscriptionId;
  }
  if (output.CustomerAwsId !== undefined && output.CustomerAwsId !== null) {
    contents.CustomerAwsId = output.CustomerAwsId;
  }
  if (output.Enabled !== undefined && output.Enabled !== null) {
    contents.Enabled = output.Enabled;
  }
  if (
    output.EventCategoriesList !== undefined &&
    output.EventCategoriesList !== null
  ) {
    contents.EventCategoriesList = deserializeAws_json1_1EventCategoriesList(
      output.EventCategoriesList,
      context
    );
  }
  if (output.SnsTopicArn !== undefined && output.SnsTopicArn !== null) {
    contents.SnsTopicArn = output.SnsTopicArn;
  }
  if (output.SourceIdsList !== undefined && output.SourceIdsList !== null) {
    contents.SourceIdsList = deserializeAws_json1_1SourceIdsList(
      output.SourceIdsList,
      context
    );
  }
  if (output.SourceType !== undefined && output.SourceType !== null) {
    contents.SourceType = output.SourceType;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (
    output.SubscriptionCreationTime !== undefined &&
    output.SubscriptionCreationTime !== null
  ) {
    contents.SubscriptionCreationTime = output.SubscriptionCreationTime;
  }
  return contents;
};

const deserializeAws_json1_1EventSubscriptionsList = (
  output: any,
  context: __SerdeContext
): Array<EventSubscription> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EventSubscription(entry, context)
  );
};

const deserializeAws_json1_1ImportCertificateResponse = (
  output: any,
  context: __SerdeContext
): ImportCertificateResponse => {
  let contents: any = {
    __type: "ImportCertificateResponse",
    Certificate: undefined
  };
  if (output.Certificate !== undefined && output.Certificate !== null) {
    contents.Certificate = deserializeAws_json1_1Certificate(
      output.Certificate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1KinesisSettings = (
  output: any,
  context: __SerdeContext
): KinesisSettings => {
  let contents: any = {
    __type: "KinesisSettings",
    MessageFormat: undefined,
    ServiceAccessRoleArn: undefined,
    StreamArn: undefined
  };
  if (output.MessageFormat !== undefined && output.MessageFormat !== null) {
    contents.MessageFormat = output.MessageFormat;
  }
  if (
    output.ServiceAccessRoleArn !== undefined &&
    output.ServiceAccessRoleArn !== null
  ) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  if (output.StreamArn !== undefined && output.StreamArn !== null) {
    contents.StreamArn = output.StreamArn;
  }
  return contents;
};

const deserializeAws_json1_1ListTagsForResourceResponse = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceResponse => {
  let contents: any = {
    __type: "ListTagsForResourceResponse",
    TagList: undefined
  };
  if (output.TagList !== undefined && output.TagList !== null) {
    contents.TagList = deserializeAws_json1_1TagList(output.TagList, context);
  }
  return contents;
};

const deserializeAws_json1_1ModifyEndpointResponse = (
  output: any,
  context: __SerdeContext
): ModifyEndpointResponse => {
  let contents: any = {
    __type: "ModifyEndpointResponse",
    Endpoint: undefined
  };
  if (output.Endpoint !== undefined && output.Endpoint !== null) {
    contents.Endpoint = deserializeAws_json1_1Endpoint(
      output.Endpoint,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ModifyEventSubscriptionResponse = (
  output: any,
  context: __SerdeContext
): ModifyEventSubscriptionResponse => {
  let contents: any = {
    __type: "ModifyEventSubscriptionResponse",
    EventSubscription: undefined
  };
  if (
    output.EventSubscription !== undefined &&
    output.EventSubscription !== null
  ) {
    contents.EventSubscription = deserializeAws_json1_1EventSubscription(
      output.EventSubscription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ModifyReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): ModifyReplicationInstanceResponse => {
  let contents: any = {
    __type: "ModifyReplicationInstanceResponse",
    ReplicationInstance: undefined
  };
  if (
    output.ReplicationInstance !== undefined &&
    output.ReplicationInstance !== null
  ) {
    contents.ReplicationInstance = deserializeAws_json1_1ReplicationInstance(
      output.ReplicationInstance,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ModifyReplicationSubnetGroupResponse = (
  output: any,
  context: __SerdeContext
): ModifyReplicationSubnetGroupResponse => {
  let contents: any = {
    __type: "ModifyReplicationSubnetGroupResponse",
    ReplicationSubnetGroup: undefined
  };
  if (
    output.ReplicationSubnetGroup !== undefined &&
    output.ReplicationSubnetGroup !== null
  ) {
    contents.ReplicationSubnetGroup = deserializeAws_json1_1ReplicationSubnetGroup(
      output.ReplicationSubnetGroup,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ModifyReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): ModifyReplicationTaskResponse => {
  let contents: any = {
    __type: "ModifyReplicationTaskResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined && output.ReplicationTask !== null) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MongoDbSettings = (
  output: any,
  context: __SerdeContext
): MongoDbSettings => {
  let contents: any = {
    __type: "MongoDbSettings",
    AuthMechanism: undefined,
    AuthSource: undefined,
    AuthType: undefined,
    DatabaseName: undefined,
    DocsToInvestigate: undefined,
    ExtractDocId: undefined,
    KmsKeyId: undefined,
    NestingLevel: undefined,
    Password: undefined,
    Port: undefined,
    ServerName: undefined,
    Username: undefined
  };
  if (output.AuthMechanism !== undefined && output.AuthMechanism !== null) {
    contents.AuthMechanism = output.AuthMechanism;
  }
  if (output.AuthSource !== undefined && output.AuthSource !== null) {
    contents.AuthSource = output.AuthSource;
  }
  if (output.AuthType !== undefined && output.AuthType !== null) {
    contents.AuthType = output.AuthType;
  }
  if (output.DatabaseName !== undefined && output.DatabaseName !== null) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (
    output.DocsToInvestigate !== undefined &&
    output.DocsToInvestigate !== null
  ) {
    contents.DocsToInvestigate = output.DocsToInvestigate;
  }
  if (output.ExtractDocId !== undefined && output.ExtractDocId !== null) {
    contents.ExtractDocId = output.ExtractDocId;
  }
  if (output.KmsKeyId !== undefined && output.KmsKeyId !== null) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.NestingLevel !== undefined && output.NestingLevel !== null) {
    contents.NestingLevel = output.NestingLevel;
  }
  if (output.Password !== undefined && output.Password !== null) {
    contents.Password = output.Password;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  if (output.ServerName !== undefined && output.ServerName !== null) {
    contents.ServerName = output.ServerName;
  }
  if (output.Username !== undefined && output.Username !== null) {
    contents.Username = output.Username;
  }
  return contents;
};

const deserializeAws_json1_1OrderableReplicationInstance = (
  output: any,
  context: __SerdeContext
): OrderableReplicationInstance => {
  let contents: any = {
    __type: "OrderableReplicationInstance",
    AvailabilityZones: undefined,
    DefaultAllocatedStorage: undefined,
    EngineVersion: undefined,
    IncludedAllocatedStorage: undefined,
    MaxAllocatedStorage: undefined,
    MinAllocatedStorage: undefined,
    ReleaseStatus: undefined,
    ReplicationInstanceClass: undefined,
    StorageType: undefined
  };
  if (
    output.AvailabilityZones !== undefined &&
    output.AvailabilityZones !== null
  ) {
    contents.AvailabilityZones = deserializeAws_json1_1AvailabilityZonesList(
      output.AvailabilityZones,
      context
    );
  }
  if (
    output.DefaultAllocatedStorage !== undefined &&
    output.DefaultAllocatedStorage !== null
  ) {
    contents.DefaultAllocatedStorage = output.DefaultAllocatedStorage;
  }
  if (output.EngineVersion !== undefined && output.EngineVersion !== null) {
    contents.EngineVersion = output.EngineVersion;
  }
  if (
    output.IncludedAllocatedStorage !== undefined &&
    output.IncludedAllocatedStorage !== null
  ) {
    contents.IncludedAllocatedStorage = output.IncludedAllocatedStorage;
  }
  if (
    output.MaxAllocatedStorage !== undefined &&
    output.MaxAllocatedStorage !== null
  ) {
    contents.MaxAllocatedStorage = output.MaxAllocatedStorage;
  }
  if (
    output.MinAllocatedStorage !== undefined &&
    output.MinAllocatedStorage !== null
  ) {
    contents.MinAllocatedStorage = output.MinAllocatedStorage;
  }
  if (output.ReleaseStatus !== undefined && output.ReleaseStatus !== null) {
    contents.ReleaseStatus = output.ReleaseStatus;
  }
  if (
    output.ReplicationInstanceClass !== undefined &&
    output.ReplicationInstanceClass !== null
  ) {
    contents.ReplicationInstanceClass = output.ReplicationInstanceClass;
  }
  if (output.StorageType !== undefined && output.StorageType !== null) {
    contents.StorageType = output.StorageType;
  }
  return contents;
};

const deserializeAws_json1_1OrderableReplicationInstanceList = (
  output: any,
  context: __SerdeContext
): Array<OrderableReplicationInstance> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1OrderableReplicationInstance(entry, context)
  );
};

const deserializeAws_json1_1PendingMaintenanceAction = (
  output: any,
  context: __SerdeContext
): PendingMaintenanceAction => {
  let contents: any = {
    __type: "PendingMaintenanceAction",
    Action: undefined,
    AutoAppliedAfterDate: undefined,
    CurrentApplyDate: undefined,
    Description: undefined,
    ForcedApplyDate: undefined,
    OptInStatus: undefined
  };
  if (output.Action !== undefined && output.Action !== null) {
    contents.Action = output.Action;
  }
  if (
    output.AutoAppliedAfterDate !== undefined &&
    output.AutoAppliedAfterDate !== null
  ) {
    contents.AutoAppliedAfterDate = new Date(
      Math.round(output.AutoAppliedAfterDate * 1000)
    );
  }
  if (
    output.CurrentApplyDate !== undefined &&
    output.CurrentApplyDate !== null
  ) {
    contents.CurrentApplyDate = new Date(
      Math.round(output.CurrentApplyDate * 1000)
    );
  }
  if (output.Description !== undefined && output.Description !== null) {
    contents.Description = output.Description;
  }
  if (output.ForcedApplyDate !== undefined && output.ForcedApplyDate !== null) {
    contents.ForcedApplyDate = new Date(
      Math.round(output.ForcedApplyDate * 1000)
    );
  }
  if (output.OptInStatus !== undefined && output.OptInStatus !== null) {
    contents.OptInStatus = output.OptInStatus;
  }
  return contents;
};

const deserializeAws_json1_1PendingMaintenanceActionDetails = (
  output: any,
  context: __SerdeContext
): Array<PendingMaintenanceAction> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PendingMaintenanceAction(entry, context)
  );
};

const deserializeAws_json1_1PendingMaintenanceActions = (
  output: any,
  context: __SerdeContext
): Array<ResourcePendingMaintenanceActions> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ResourcePendingMaintenanceActions(entry, context)
  );
};

const deserializeAws_json1_1RebootReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): RebootReplicationInstanceResponse => {
  let contents: any = {
    __type: "RebootReplicationInstanceResponse",
    ReplicationInstance: undefined
  };
  if (
    output.ReplicationInstance !== undefined &&
    output.ReplicationInstance !== null
  ) {
    contents.ReplicationInstance = deserializeAws_json1_1ReplicationInstance(
      output.ReplicationInstance,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1RedshiftSettings = (
  output: any,
  context: __SerdeContext
): RedshiftSettings => {
  let contents: any = {
    __type: "RedshiftSettings",
    AcceptAnyDate: undefined,
    AfterConnectScript: undefined,
    BucketFolder: undefined,
    BucketName: undefined,
    ConnectionTimeout: undefined,
    DatabaseName: undefined,
    DateFormat: undefined,
    EmptyAsNull: undefined,
    EncryptionMode: undefined,
    FileTransferUploadStreams: undefined,
    LoadTimeout: undefined,
    MaxFileSize: undefined,
    Password: undefined,
    Port: undefined,
    RemoveQuotes: undefined,
    ReplaceChars: undefined,
    ReplaceInvalidChars: undefined,
    ServerName: undefined,
    ServerSideEncryptionKmsKeyId: undefined,
    ServiceAccessRoleArn: undefined,
    TimeFormat: undefined,
    TrimBlanks: undefined,
    TruncateColumns: undefined,
    Username: undefined,
    WriteBufferSize: undefined
  };
  if (output.AcceptAnyDate !== undefined && output.AcceptAnyDate !== null) {
    contents.AcceptAnyDate = output.AcceptAnyDate;
  }
  if (
    output.AfterConnectScript !== undefined &&
    output.AfterConnectScript !== null
  ) {
    contents.AfterConnectScript = output.AfterConnectScript;
  }
  if (output.BucketFolder !== undefined && output.BucketFolder !== null) {
    contents.BucketFolder = output.BucketFolder;
  }
  if (output.BucketName !== undefined && output.BucketName !== null) {
    contents.BucketName = output.BucketName;
  }
  if (
    output.ConnectionTimeout !== undefined &&
    output.ConnectionTimeout !== null
  ) {
    contents.ConnectionTimeout = output.ConnectionTimeout;
  }
  if (output.DatabaseName !== undefined && output.DatabaseName !== null) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (output.DateFormat !== undefined && output.DateFormat !== null) {
    contents.DateFormat = output.DateFormat;
  }
  if (output.EmptyAsNull !== undefined && output.EmptyAsNull !== null) {
    contents.EmptyAsNull = output.EmptyAsNull;
  }
  if (output.EncryptionMode !== undefined && output.EncryptionMode !== null) {
    contents.EncryptionMode = output.EncryptionMode;
  }
  if (
    output.FileTransferUploadStreams !== undefined &&
    output.FileTransferUploadStreams !== null
  ) {
    contents.FileTransferUploadStreams = output.FileTransferUploadStreams;
  }
  if (output.LoadTimeout !== undefined && output.LoadTimeout !== null) {
    contents.LoadTimeout = output.LoadTimeout;
  }
  if (output.MaxFileSize !== undefined && output.MaxFileSize !== null) {
    contents.MaxFileSize = output.MaxFileSize;
  }
  if (output.Password !== undefined && output.Password !== null) {
    contents.Password = output.Password;
  }
  if (output.Port !== undefined && output.Port !== null) {
    contents.Port = output.Port;
  }
  if (output.RemoveQuotes !== undefined && output.RemoveQuotes !== null) {
    contents.RemoveQuotes = output.RemoveQuotes;
  }
  if (output.ReplaceChars !== undefined && output.ReplaceChars !== null) {
    contents.ReplaceChars = output.ReplaceChars;
  }
  if (
    output.ReplaceInvalidChars !== undefined &&
    output.ReplaceInvalidChars !== null
  ) {
    contents.ReplaceInvalidChars = output.ReplaceInvalidChars;
  }
  if (output.ServerName !== undefined && output.ServerName !== null) {
    contents.ServerName = output.ServerName;
  }
  if (
    output.ServerSideEncryptionKmsKeyId !== undefined &&
    output.ServerSideEncryptionKmsKeyId !== null
  ) {
    contents.ServerSideEncryptionKmsKeyId = output.ServerSideEncryptionKmsKeyId;
  }
  if (
    output.ServiceAccessRoleArn !== undefined &&
    output.ServiceAccessRoleArn !== null
  ) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  if (output.TimeFormat !== undefined && output.TimeFormat !== null) {
    contents.TimeFormat = output.TimeFormat;
  }
  if (output.TrimBlanks !== undefined && output.TrimBlanks !== null) {
    contents.TrimBlanks = output.TrimBlanks;
  }
  if (output.TruncateColumns !== undefined && output.TruncateColumns !== null) {
    contents.TruncateColumns = output.TruncateColumns;
  }
  if (output.Username !== undefined && output.Username !== null) {
    contents.Username = output.Username;
  }
  if (output.WriteBufferSize !== undefined && output.WriteBufferSize !== null) {
    contents.WriteBufferSize = output.WriteBufferSize;
  }
  return contents;
};

const deserializeAws_json1_1RefreshSchemasResponse = (
  output: any,
  context: __SerdeContext
): RefreshSchemasResponse => {
  let contents: any = {
    __type: "RefreshSchemasResponse",
    RefreshSchemasStatus: undefined
  };
  if (
    output.RefreshSchemasStatus !== undefined &&
    output.RefreshSchemasStatus !== null
  ) {
    contents.RefreshSchemasStatus = deserializeAws_json1_1RefreshSchemasStatus(
      output.RefreshSchemasStatus,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1RefreshSchemasStatus = (
  output: any,
  context: __SerdeContext
): RefreshSchemasStatus => {
  let contents: any = {
    __type: "RefreshSchemasStatus",
    EndpointArn: undefined,
    LastFailureMessage: undefined,
    LastRefreshDate: undefined,
    ReplicationInstanceArn: undefined,
    Status: undefined
  };
  if (output.EndpointArn !== undefined && output.EndpointArn !== null) {
    contents.EndpointArn = output.EndpointArn;
  }
  if (
    output.LastFailureMessage !== undefined &&
    output.LastFailureMessage !== null
  ) {
    contents.LastFailureMessage = output.LastFailureMessage;
  }
  if (output.LastRefreshDate !== undefined && output.LastRefreshDate !== null) {
    contents.LastRefreshDate = new Date(
      Math.round(output.LastRefreshDate * 1000)
    );
  }
  if (
    output.ReplicationInstanceArn !== undefined &&
    output.ReplicationInstanceArn !== null
  ) {
    contents.ReplicationInstanceArn = output.ReplicationInstanceArn;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1ReloadTablesResponse = (
  output: any,
  context: __SerdeContext
): ReloadTablesResponse => {
  let contents: any = {
    __type: "ReloadTablesResponse",
    ReplicationTaskArn: undefined
  };
  if (
    output.ReplicationTaskArn !== undefined &&
    output.ReplicationTaskArn !== null
  ) {
    contents.ReplicationTaskArn = output.ReplicationTaskArn;
  }
  return contents;
};

const deserializeAws_json1_1RemoveTagsFromResourceResponse = (
  output: any,
  context: __SerdeContext
): RemoveTagsFromResourceResponse => {
  let contents: any = {
    __type: "RemoveTagsFromResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1ReplicationInstance = (
  output: any,
  context: __SerdeContext
): ReplicationInstance => {
  let contents: any = {
    __type: "ReplicationInstance",
    AllocatedStorage: undefined,
    AutoMinorVersionUpgrade: undefined,
    AvailabilityZone: undefined,
    DnsNameServers: undefined,
    EngineVersion: undefined,
    FreeUntil: undefined,
    InstanceCreateTime: undefined,
    KmsKeyId: undefined,
    MultiAZ: undefined,
    PendingModifiedValues: undefined,
    PreferredMaintenanceWindow: undefined,
    PubliclyAccessible: undefined,
    ReplicationInstanceArn: undefined,
    ReplicationInstanceClass: undefined,
    ReplicationInstanceIdentifier: undefined,
    ReplicationInstancePrivateIpAddress: undefined,
    ReplicationInstancePrivateIpAddresses: undefined,
    ReplicationInstancePublicIpAddress: undefined,
    ReplicationInstancePublicIpAddresses: undefined,
    ReplicationInstanceStatus: undefined,
    ReplicationSubnetGroup: undefined,
    SecondaryAvailabilityZone: undefined,
    VpcSecurityGroups: undefined
  };
  if (
    output.AllocatedStorage !== undefined &&
    output.AllocatedStorage !== null
  ) {
    contents.AllocatedStorage = output.AllocatedStorage;
  }
  if (
    output.AutoMinorVersionUpgrade !== undefined &&
    output.AutoMinorVersionUpgrade !== null
  ) {
    contents.AutoMinorVersionUpgrade = output.AutoMinorVersionUpgrade;
  }
  if (
    output.AvailabilityZone !== undefined &&
    output.AvailabilityZone !== null
  ) {
    contents.AvailabilityZone = output.AvailabilityZone;
  }
  if (output.DnsNameServers !== undefined && output.DnsNameServers !== null) {
    contents.DnsNameServers = output.DnsNameServers;
  }
  if (output.EngineVersion !== undefined && output.EngineVersion !== null) {
    contents.EngineVersion = output.EngineVersion;
  }
  if (output.FreeUntil !== undefined && output.FreeUntil !== null) {
    contents.FreeUntil = new Date(Math.round(output.FreeUntil * 1000));
  }
  if (
    output.InstanceCreateTime !== undefined &&
    output.InstanceCreateTime !== null
  ) {
    contents.InstanceCreateTime = new Date(
      Math.round(output.InstanceCreateTime * 1000)
    );
  }
  if (output.KmsKeyId !== undefined && output.KmsKeyId !== null) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.MultiAZ !== undefined && output.MultiAZ !== null) {
    contents.MultiAZ = output.MultiAZ;
  }
  if (
    output.PendingModifiedValues !== undefined &&
    output.PendingModifiedValues !== null
  ) {
    contents.PendingModifiedValues = deserializeAws_json1_1ReplicationPendingModifiedValues(
      output.PendingModifiedValues,
      context
    );
  }
  if (
    output.PreferredMaintenanceWindow !== undefined &&
    output.PreferredMaintenanceWindow !== null
  ) {
    contents.PreferredMaintenanceWindow = output.PreferredMaintenanceWindow;
  }
  if (
    output.PubliclyAccessible !== undefined &&
    output.PubliclyAccessible !== null
  ) {
    contents.PubliclyAccessible = output.PubliclyAccessible;
  }
  if (
    output.ReplicationInstanceArn !== undefined &&
    output.ReplicationInstanceArn !== null
  ) {
    contents.ReplicationInstanceArn = output.ReplicationInstanceArn;
  }
  if (
    output.ReplicationInstanceClass !== undefined &&
    output.ReplicationInstanceClass !== null
  ) {
    contents.ReplicationInstanceClass = output.ReplicationInstanceClass;
  }
  if (
    output.ReplicationInstanceIdentifier !== undefined &&
    output.ReplicationInstanceIdentifier !== null
  ) {
    contents.ReplicationInstanceIdentifier =
      output.ReplicationInstanceIdentifier;
  }
  if (
    output.ReplicationInstancePrivateIpAddress !== undefined &&
    output.ReplicationInstancePrivateIpAddress !== null
  ) {
    contents.ReplicationInstancePrivateIpAddress =
      output.ReplicationInstancePrivateIpAddress;
  }
  if (
    output.ReplicationInstancePrivateIpAddresses !== undefined &&
    output.ReplicationInstancePrivateIpAddresses !== null
  ) {
    contents.ReplicationInstancePrivateIpAddresses = deserializeAws_json1_1ReplicationInstancePrivateIpAddressList(
      output.ReplicationInstancePrivateIpAddresses,
      context
    );
  }
  if (
    output.ReplicationInstancePublicIpAddress !== undefined &&
    output.ReplicationInstancePublicIpAddress !== null
  ) {
    contents.ReplicationInstancePublicIpAddress =
      output.ReplicationInstancePublicIpAddress;
  }
  if (
    output.ReplicationInstancePublicIpAddresses !== undefined &&
    output.ReplicationInstancePublicIpAddresses !== null
  ) {
    contents.ReplicationInstancePublicIpAddresses = deserializeAws_json1_1ReplicationInstancePublicIpAddressList(
      output.ReplicationInstancePublicIpAddresses,
      context
    );
  }
  if (
    output.ReplicationInstanceStatus !== undefined &&
    output.ReplicationInstanceStatus !== null
  ) {
    contents.ReplicationInstanceStatus = output.ReplicationInstanceStatus;
  }
  if (
    output.ReplicationSubnetGroup !== undefined &&
    output.ReplicationSubnetGroup !== null
  ) {
    contents.ReplicationSubnetGroup = deserializeAws_json1_1ReplicationSubnetGroup(
      output.ReplicationSubnetGroup,
      context
    );
  }
  if (
    output.SecondaryAvailabilityZone !== undefined &&
    output.SecondaryAvailabilityZone !== null
  ) {
    contents.SecondaryAvailabilityZone = output.SecondaryAvailabilityZone;
  }
  if (
    output.VpcSecurityGroups !== undefined &&
    output.VpcSecurityGroups !== null
  ) {
    contents.VpcSecurityGroups = deserializeAws_json1_1VpcSecurityGroupMembershipList(
      output.VpcSecurityGroups,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ReplicationInstanceList = (
  output: any,
  context: __SerdeContext
): Array<ReplicationInstance> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationInstance(entry, context)
  );
};

const deserializeAws_json1_1ReplicationInstancePrivateIpAddressList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ReplicationInstancePublicIpAddressList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ReplicationInstanceTaskLog = (
  output: any,
  context: __SerdeContext
): ReplicationInstanceTaskLog => {
  let contents: any = {
    __type: "ReplicationInstanceTaskLog",
    ReplicationInstanceTaskLogSize: undefined,
    ReplicationTaskArn: undefined,
    ReplicationTaskName: undefined
  };
  if (
    output.ReplicationInstanceTaskLogSize !== undefined &&
    output.ReplicationInstanceTaskLogSize !== null
  ) {
    contents.ReplicationInstanceTaskLogSize =
      output.ReplicationInstanceTaskLogSize;
  }
  if (
    output.ReplicationTaskArn !== undefined &&
    output.ReplicationTaskArn !== null
  ) {
    contents.ReplicationTaskArn = output.ReplicationTaskArn;
  }
  if (
    output.ReplicationTaskName !== undefined &&
    output.ReplicationTaskName !== null
  ) {
    contents.ReplicationTaskName = output.ReplicationTaskName;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationInstanceTaskLogsList = (
  output: any,
  context: __SerdeContext
): Array<ReplicationInstanceTaskLog> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationInstanceTaskLog(entry, context)
  );
};

const deserializeAws_json1_1ReplicationPendingModifiedValues = (
  output: any,
  context: __SerdeContext
): ReplicationPendingModifiedValues => {
  let contents: any = {
    __type: "ReplicationPendingModifiedValues",
    AllocatedStorage: undefined,
    EngineVersion: undefined,
    MultiAZ: undefined,
    ReplicationInstanceClass: undefined
  };
  if (
    output.AllocatedStorage !== undefined &&
    output.AllocatedStorage !== null
  ) {
    contents.AllocatedStorage = output.AllocatedStorage;
  }
  if (output.EngineVersion !== undefined && output.EngineVersion !== null) {
    contents.EngineVersion = output.EngineVersion;
  }
  if (output.MultiAZ !== undefined && output.MultiAZ !== null) {
    contents.MultiAZ = output.MultiAZ;
  }
  if (
    output.ReplicationInstanceClass !== undefined &&
    output.ReplicationInstanceClass !== null
  ) {
    contents.ReplicationInstanceClass = output.ReplicationInstanceClass;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationSubnetGroup = (
  output: any,
  context: __SerdeContext
): ReplicationSubnetGroup => {
  let contents: any = {
    __type: "ReplicationSubnetGroup",
    ReplicationSubnetGroupDescription: undefined,
    ReplicationSubnetGroupIdentifier: undefined,
    SubnetGroupStatus: undefined,
    Subnets: undefined,
    VpcId: undefined
  };
  if (
    output.ReplicationSubnetGroupDescription !== undefined &&
    output.ReplicationSubnetGroupDescription !== null
  ) {
    contents.ReplicationSubnetGroupDescription =
      output.ReplicationSubnetGroupDescription;
  }
  if (
    output.ReplicationSubnetGroupIdentifier !== undefined &&
    output.ReplicationSubnetGroupIdentifier !== null
  ) {
    contents.ReplicationSubnetGroupIdentifier =
      output.ReplicationSubnetGroupIdentifier;
  }
  if (
    output.SubnetGroupStatus !== undefined &&
    output.SubnetGroupStatus !== null
  ) {
    contents.SubnetGroupStatus = output.SubnetGroupStatus;
  }
  if (output.Subnets !== undefined && output.Subnets !== null) {
    contents.Subnets = deserializeAws_json1_1SubnetList(
      output.Subnets,
      context
    );
  }
  if (output.VpcId !== undefined && output.VpcId !== null) {
    contents.VpcId = output.VpcId;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationSubnetGroups = (
  output: any,
  context: __SerdeContext
): Array<ReplicationSubnetGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationSubnetGroup(entry, context)
  );
};

const deserializeAws_json1_1ReplicationTask = (
  output: any,
  context: __SerdeContext
): ReplicationTask => {
  let contents: any = {
    __type: "ReplicationTask",
    CdcStartPosition: undefined,
    CdcStopPosition: undefined,
    LastFailureMessage: undefined,
    MigrationType: undefined,
    RecoveryCheckpoint: undefined,
    ReplicationInstanceArn: undefined,
    ReplicationTaskArn: undefined,
    ReplicationTaskCreationDate: undefined,
    ReplicationTaskIdentifier: undefined,
    ReplicationTaskSettings: undefined,
    ReplicationTaskStartDate: undefined,
    ReplicationTaskStats: undefined,
    SourceEndpointArn: undefined,
    Status: undefined,
    StopReason: undefined,
    TableMappings: undefined,
    TargetEndpointArn: undefined
  };
  if (
    output.CdcStartPosition !== undefined &&
    output.CdcStartPosition !== null
  ) {
    contents.CdcStartPosition = output.CdcStartPosition;
  }
  if (output.CdcStopPosition !== undefined && output.CdcStopPosition !== null) {
    contents.CdcStopPosition = output.CdcStopPosition;
  }
  if (
    output.LastFailureMessage !== undefined &&
    output.LastFailureMessage !== null
  ) {
    contents.LastFailureMessage = output.LastFailureMessage;
  }
  if (output.MigrationType !== undefined && output.MigrationType !== null) {
    contents.MigrationType = output.MigrationType;
  }
  if (
    output.RecoveryCheckpoint !== undefined &&
    output.RecoveryCheckpoint !== null
  ) {
    contents.RecoveryCheckpoint = output.RecoveryCheckpoint;
  }
  if (
    output.ReplicationInstanceArn !== undefined &&
    output.ReplicationInstanceArn !== null
  ) {
    contents.ReplicationInstanceArn = output.ReplicationInstanceArn;
  }
  if (
    output.ReplicationTaskArn !== undefined &&
    output.ReplicationTaskArn !== null
  ) {
    contents.ReplicationTaskArn = output.ReplicationTaskArn;
  }
  if (
    output.ReplicationTaskCreationDate !== undefined &&
    output.ReplicationTaskCreationDate !== null
  ) {
    contents.ReplicationTaskCreationDate = new Date(
      Math.round(output.ReplicationTaskCreationDate * 1000)
    );
  }
  if (
    output.ReplicationTaskIdentifier !== undefined &&
    output.ReplicationTaskIdentifier !== null
  ) {
    contents.ReplicationTaskIdentifier = output.ReplicationTaskIdentifier;
  }
  if (
    output.ReplicationTaskSettings !== undefined &&
    output.ReplicationTaskSettings !== null
  ) {
    contents.ReplicationTaskSettings = output.ReplicationTaskSettings;
  }
  if (
    output.ReplicationTaskStartDate !== undefined &&
    output.ReplicationTaskStartDate !== null
  ) {
    contents.ReplicationTaskStartDate = new Date(
      Math.round(output.ReplicationTaskStartDate * 1000)
    );
  }
  if (
    output.ReplicationTaskStats !== undefined &&
    output.ReplicationTaskStats !== null
  ) {
    contents.ReplicationTaskStats = deserializeAws_json1_1ReplicationTaskStats(
      output.ReplicationTaskStats,
      context
    );
  }
  if (
    output.SourceEndpointArn !== undefined &&
    output.SourceEndpointArn !== null
  ) {
    contents.SourceEndpointArn = output.SourceEndpointArn;
  }
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (output.StopReason !== undefined && output.StopReason !== null) {
    contents.StopReason = output.StopReason;
  }
  if (output.TableMappings !== undefined && output.TableMappings !== null) {
    contents.TableMappings = output.TableMappings;
  }
  if (
    output.TargetEndpointArn !== undefined &&
    output.TargetEndpointArn !== null
  ) {
    contents.TargetEndpointArn = output.TargetEndpointArn;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationTaskAssessmentResult = (
  output: any,
  context: __SerdeContext
): ReplicationTaskAssessmentResult => {
  let contents: any = {
    __type: "ReplicationTaskAssessmentResult",
    AssessmentResults: undefined,
    AssessmentResultsFile: undefined,
    AssessmentStatus: undefined,
    ReplicationTaskArn: undefined,
    ReplicationTaskIdentifier: undefined,
    ReplicationTaskLastAssessmentDate: undefined,
    S3ObjectUrl: undefined
  };
  if (
    output.AssessmentResults !== undefined &&
    output.AssessmentResults !== null
  ) {
    contents.AssessmentResults = output.AssessmentResults;
  }
  if (
    output.AssessmentResultsFile !== undefined &&
    output.AssessmentResultsFile !== null
  ) {
    contents.AssessmentResultsFile = output.AssessmentResultsFile;
  }
  if (
    output.AssessmentStatus !== undefined &&
    output.AssessmentStatus !== null
  ) {
    contents.AssessmentStatus = output.AssessmentStatus;
  }
  if (
    output.ReplicationTaskArn !== undefined &&
    output.ReplicationTaskArn !== null
  ) {
    contents.ReplicationTaskArn = output.ReplicationTaskArn;
  }
  if (
    output.ReplicationTaskIdentifier !== undefined &&
    output.ReplicationTaskIdentifier !== null
  ) {
    contents.ReplicationTaskIdentifier = output.ReplicationTaskIdentifier;
  }
  if (
    output.ReplicationTaskLastAssessmentDate !== undefined &&
    output.ReplicationTaskLastAssessmentDate !== null
  ) {
    contents.ReplicationTaskLastAssessmentDate = new Date(
      Math.round(output.ReplicationTaskLastAssessmentDate * 1000)
    );
  }
  if (output.S3ObjectUrl !== undefined && output.S3ObjectUrl !== null) {
    contents.S3ObjectUrl = output.S3ObjectUrl;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationTaskAssessmentResultList = (
  output: any,
  context: __SerdeContext
): Array<ReplicationTaskAssessmentResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationTaskAssessmentResult(entry, context)
  );
};

const deserializeAws_json1_1ReplicationTaskList = (
  output: any,
  context: __SerdeContext
): Array<ReplicationTask> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationTask(entry, context)
  );
};

const deserializeAws_json1_1ReplicationTaskStats = (
  output: any,
  context: __SerdeContext
): ReplicationTaskStats => {
  let contents: any = {
    __type: "ReplicationTaskStats",
    ElapsedTimeMillis: undefined,
    FreshStartDate: undefined,
    FullLoadFinishDate: undefined,
    FullLoadProgressPercent: undefined,
    FullLoadStartDate: undefined,
    StartDate: undefined,
    StopDate: undefined,
    TablesErrored: undefined,
    TablesLoaded: undefined,
    TablesLoading: undefined,
    TablesQueued: undefined
  };
  if (
    output.ElapsedTimeMillis !== undefined &&
    output.ElapsedTimeMillis !== null
  ) {
    contents.ElapsedTimeMillis = output.ElapsedTimeMillis;
  }
  if (output.FreshStartDate !== undefined && output.FreshStartDate !== null) {
    contents.FreshStartDate = new Date(
      Math.round(output.FreshStartDate * 1000)
    );
  }
  if (
    output.FullLoadFinishDate !== undefined &&
    output.FullLoadFinishDate !== null
  ) {
    contents.FullLoadFinishDate = new Date(
      Math.round(output.FullLoadFinishDate * 1000)
    );
  }
  if (
    output.FullLoadProgressPercent !== undefined &&
    output.FullLoadProgressPercent !== null
  ) {
    contents.FullLoadProgressPercent = output.FullLoadProgressPercent;
  }
  if (
    output.FullLoadStartDate !== undefined &&
    output.FullLoadStartDate !== null
  ) {
    contents.FullLoadStartDate = new Date(
      Math.round(output.FullLoadStartDate * 1000)
    );
  }
  if (output.StartDate !== undefined && output.StartDate !== null) {
    contents.StartDate = new Date(Math.round(output.StartDate * 1000));
  }
  if (output.StopDate !== undefined && output.StopDate !== null) {
    contents.StopDate = new Date(Math.round(output.StopDate * 1000));
  }
  if (output.TablesErrored !== undefined && output.TablesErrored !== null) {
    contents.TablesErrored = output.TablesErrored;
  }
  if (output.TablesLoaded !== undefined && output.TablesLoaded !== null) {
    contents.TablesLoaded = output.TablesLoaded;
  }
  if (output.TablesLoading !== undefined && output.TablesLoading !== null) {
    contents.TablesLoading = output.TablesLoading;
  }
  if (output.TablesQueued !== undefined && output.TablesQueued !== null) {
    contents.TablesQueued = output.TablesQueued;
  }
  return contents;
};

const deserializeAws_json1_1ResourcePendingMaintenanceActions = (
  output: any,
  context: __SerdeContext
): ResourcePendingMaintenanceActions => {
  let contents: any = {
    __type: "ResourcePendingMaintenanceActions",
    PendingMaintenanceActionDetails: undefined,
    ResourceIdentifier: undefined
  };
  if (
    output.PendingMaintenanceActionDetails !== undefined &&
    output.PendingMaintenanceActionDetails !== null
  ) {
    contents.PendingMaintenanceActionDetails = deserializeAws_json1_1PendingMaintenanceActionDetails(
      output.PendingMaintenanceActionDetails,
      context
    );
  }
  if (
    output.ResourceIdentifier !== undefined &&
    output.ResourceIdentifier !== null
  ) {
    contents.ResourceIdentifier = output.ResourceIdentifier;
  }
  return contents;
};

const deserializeAws_json1_1S3Settings = (
  output: any,
  context: __SerdeContext
): S3Settings => {
  let contents: any = {
    __type: "S3Settings",
    BucketFolder: undefined,
    BucketName: undefined,
    CdcInsertsOnly: undefined,
    CompressionType: undefined,
    CsvDelimiter: undefined,
    CsvRowDelimiter: undefined,
    DataFormat: undefined,
    DataPageSize: undefined,
    DictPageSizeLimit: undefined,
    EnableStatistics: undefined,
    EncodingType: undefined,
    EncryptionMode: undefined,
    ExternalTableDefinition: undefined,
    IncludeOpForFullLoad: undefined,
    ParquetTimestampInMillisecond: undefined,
    ParquetVersion: undefined,
    RowGroupLength: undefined,
    ServerSideEncryptionKmsKeyId: undefined,
    ServiceAccessRoleArn: undefined,
    TimestampColumnName: undefined
  };
  if (output.BucketFolder !== undefined && output.BucketFolder !== null) {
    contents.BucketFolder = output.BucketFolder;
  }
  if (output.BucketName !== undefined && output.BucketName !== null) {
    contents.BucketName = output.BucketName;
  }
  if (output.CdcInsertsOnly !== undefined && output.CdcInsertsOnly !== null) {
    contents.CdcInsertsOnly = output.CdcInsertsOnly;
  }
  if (output.CompressionType !== undefined && output.CompressionType !== null) {
    contents.CompressionType = output.CompressionType;
  }
  if (output.CsvDelimiter !== undefined && output.CsvDelimiter !== null) {
    contents.CsvDelimiter = output.CsvDelimiter;
  }
  if (output.CsvRowDelimiter !== undefined && output.CsvRowDelimiter !== null) {
    contents.CsvRowDelimiter = output.CsvRowDelimiter;
  }
  if (output.DataFormat !== undefined && output.DataFormat !== null) {
    contents.DataFormat = output.DataFormat;
  }
  if (output.DataPageSize !== undefined && output.DataPageSize !== null) {
    contents.DataPageSize = output.DataPageSize;
  }
  if (
    output.DictPageSizeLimit !== undefined &&
    output.DictPageSizeLimit !== null
  ) {
    contents.DictPageSizeLimit = output.DictPageSizeLimit;
  }
  if (
    output.EnableStatistics !== undefined &&
    output.EnableStatistics !== null
  ) {
    contents.EnableStatistics = output.EnableStatistics;
  }
  if (output.EncodingType !== undefined && output.EncodingType !== null) {
    contents.EncodingType = output.EncodingType;
  }
  if (output.EncryptionMode !== undefined && output.EncryptionMode !== null) {
    contents.EncryptionMode = output.EncryptionMode;
  }
  if (
    output.ExternalTableDefinition !== undefined &&
    output.ExternalTableDefinition !== null
  ) {
    contents.ExternalTableDefinition = output.ExternalTableDefinition;
  }
  if (
    output.IncludeOpForFullLoad !== undefined &&
    output.IncludeOpForFullLoad !== null
  ) {
    contents.IncludeOpForFullLoad = output.IncludeOpForFullLoad;
  }
  if (
    output.ParquetTimestampInMillisecond !== undefined &&
    output.ParquetTimestampInMillisecond !== null
  ) {
    contents.ParquetTimestampInMillisecond =
      output.ParquetTimestampInMillisecond;
  }
  if (output.ParquetVersion !== undefined && output.ParquetVersion !== null) {
    contents.ParquetVersion = output.ParquetVersion;
  }
  if (output.RowGroupLength !== undefined && output.RowGroupLength !== null) {
    contents.RowGroupLength = output.RowGroupLength;
  }
  if (
    output.ServerSideEncryptionKmsKeyId !== undefined &&
    output.ServerSideEncryptionKmsKeyId !== null
  ) {
    contents.ServerSideEncryptionKmsKeyId = output.ServerSideEncryptionKmsKeyId;
  }
  if (
    output.ServiceAccessRoleArn !== undefined &&
    output.ServiceAccessRoleArn !== null
  ) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  if (
    output.TimestampColumnName !== undefined &&
    output.TimestampColumnName !== null
  ) {
    contents.TimestampColumnName = output.TimestampColumnName;
  }
  return contents;
};

const deserializeAws_json1_1SchemaList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SourceIdsList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1StartReplicationTaskAssessmentResponse = (
  output: any,
  context: __SerdeContext
): StartReplicationTaskAssessmentResponse => {
  let contents: any = {
    __type: "StartReplicationTaskAssessmentResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined && output.ReplicationTask !== null) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1StartReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): StartReplicationTaskResponse => {
  let contents: any = {
    __type: "StartReplicationTaskResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined && output.ReplicationTask !== null) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1StopReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): StopReplicationTaskResponse => {
  let contents: any = {
    __type: "StopReplicationTaskResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined && output.ReplicationTask !== null) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1Subnet = (
  output: any,
  context: __SerdeContext
): Subnet => {
  let contents: any = {
    __type: "Subnet",
    SubnetAvailabilityZone: undefined,
    SubnetIdentifier: undefined,
    SubnetStatus: undefined
  };
  if (
    output.SubnetAvailabilityZone !== undefined &&
    output.SubnetAvailabilityZone !== null
  ) {
    contents.SubnetAvailabilityZone = deserializeAws_json1_1AvailabilityZone(
      output.SubnetAvailabilityZone,
      context
    );
  }
  if (
    output.SubnetIdentifier !== undefined &&
    output.SubnetIdentifier !== null
  ) {
    contents.SubnetIdentifier = output.SubnetIdentifier;
  }
  if (output.SubnetStatus !== undefined && output.SubnetStatus !== null) {
    contents.SubnetStatus = output.SubnetStatus;
  }
  return contents;
};

const deserializeAws_json1_1SubnetList = (
  output: any,
  context: __SerdeContext
): Array<Subnet> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Subnet(entry, context)
  );
};

const deserializeAws_json1_1SupportedEndpointType = (
  output: any,
  context: __SerdeContext
): SupportedEndpointType => {
  let contents: any = {
    __type: "SupportedEndpointType",
    EndpointType: undefined,
    EngineDisplayName: undefined,
    EngineName: undefined,
    SupportsCDC: undefined
  };
  if (output.EndpointType !== undefined && output.EndpointType !== null) {
    contents.EndpointType = output.EndpointType;
  }
  if (
    output.EngineDisplayName !== undefined &&
    output.EngineDisplayName !== null
  ) {
    contents.EngineDisplayName = output.EngineDisplayName;
  }
  if (output.EngineName !== undefined && output.EngineName !== null) {
    contents.EngineName = output.EngineName;
  }
  if (output.SupportsCDC !== undefined && output.SupportsCDC !== null) {
    contents.SupportsCDC = output.SupportsCDC;
  }
  return contents;
};

const deserializeAws_json1_1SupportedEndpointTypeList = (
  output: any,
  context: __SerdeContext
): Array<SupportedEndpointType> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SupportedEndpointType(entry, context)
  );
};

const deserializeAws_json1_1TableStatistics = (
  output: any,
  context: __SerdeContext
): TableStatistics => {
  let contents: any = {
    __type: "TableStatistics",
    Ddls: undefined,
    Deletes: undefined,
    FullLoadCondtnlChkFailedRows: undefined,
    FullLoadErrorRows: undefined,
    FullLoadRows: undefined,
    Inserts: undefined,
    LastUpdateTime: undefined,
    SchemaName: undefined,
    TableName: undefined,
    TableState: undefined,
    Updates: undefined,
    ValidationFailedRecords: undefined,
    ValidationPendingRecords: undefined,
    ValidationState: undefined,
    ValidationStateDetails: undefined,
    ValidationSuspendedRecords: undefined
  };
  if (output.Ddls !== undefined && output.Ddls !== null) {
    contents.Ddls = output.Ddls;
  }
  if (output.Deletes !== undefined && output.Deletes !== null) {
    contents.Deletes = output.Deletes;
  }
  if (
    output.FullLoadCondtnlChkFailedRows !== undefined &&
    output.FullLoadCondtnlChkFailedRows !== null
  ) {
    contents.FullLoadCondtnlChkFailedRows = output.FullLoadCondtnlChkFailedRows;
  }
  if (
    output.FullLoadErrorRows !== undefined &&
    output.FullLoadErrorRows !== null
  ) {
    contents.FullLoadErrorRows = output.FullLoadErrorRows;
  }
  if (output.FullLoadRows !== undefined && output.FullLoadRows !== null) {
    contents.FullLoadRows = output.FullLoadRows;
  }
  if (output.Inserts !== undefined && output.Inserts !== null) {
    contents.Inserts = output.Inserts;
  }
  if (output.LastUpdateTime !== undefined && output.LastUpdateTime !== null) {
    contents.LastUpdateTime = new Date(
      Math.round(output.LastUpdateTime * 1000)
    );
  }
  if (output.SchemaName !== undefined && output.SchemaName !== null) {
    contents.SchemaName = output.SchemaName;
  }
  if (output.TableName !== undefined && output.TableName !== null) {
    contents.TableName = output.TableName;
  }
  if (output.TableState !== undefined && output.TableState !== null) {
    contents.TableState = output.TableState;
  }
  if (output.Updates !== undefined && output.Updates !== null) {
    contents.Updates = output.Updates;
  }
  if (
    output.ValidationFailedRecords !== undefined &&
    output.ValidationFailedRecords !== null
  ) {
    contents.ValidationFailedRecords = output.ValidationFailedRecords;
  }
  if (
    output.ValidationPendingRecords !== undefined &&
    output.ValidationPendingRecords !== null
  ) {
    contents.ValidationPendingRecords = output.ValidationPendingRecords;
  }
  if (output.ValidationState !== undefined && output.ValidationState !== null) {
    contents.ValidationState = output.ValidationState;
  }
  if (
    output.ValidationStateDetails !== undefined &&
    output.ValidationStateDetails !== null
  ) {
    contents.ValidationStateDetails = output.ValidationStateDetails;
  }
  if (
    output.ValidationSuspendedRecords !== undefined &&
    output.ValidationSuspendedRecords !== null
  ) {
    contents.ValidationSuspendedRecords = output.ValidationSuspendedRecords;
  }
  return contents;
};

const deserializeAws_json1_1TableStatisticsList = (
  output: any,
  context: __SerdeContext
): Array<TableStatistics> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TableStatistics(entry, context)
  );
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined && output.Key !== null) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined && output.Value !== null) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1TestConnectionResponse = (
  output: any,
  context: __SerdeContext
): TestConnectionResponse => {
  let contents: any = {
    __type: "TestConnectionResponse",
    Connection: undefined
  };
  if (output.Connection !== undefined && output.Connection !== null) {
    contents.Connection = deserializeAws_json1_1Connection(
      output.Connection,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1VpcSecurityGroupMembership = (
  output: any,
  context: __SerdeContext
): VpcSecurityGroupMembership => {
  let contents: any = {
    __type: "VpcSecurityGroupMembership",
    Status: undefined,
    VpcSecurityGroupId: undefined
  };
  if (output.Status !== undefined && output.Status !== null) {
    contents.Status = output.Status;
  }
  if (
    output.VpcSecurityGroupId !== undefined &&
    output.VpcSecurityGroupId !== null
  ) {
    contents.VpcSecurityGroupId = output.VpcSecurityGroupId;
  }
  return contents;
};

const deserializeAws_json1_1VpcSecurityGroupMembershipList = (
  output: any,
  context: __SerdeContext
): Array<VpcSecurityGroupMembership> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1VpcSecurityGroupMembership(entry, context)
  );
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any,
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> => {
  return collectBody(streamBody, context).then(body =>
    context.utf8Encoder(body)
  );
};

const buildHttpRpcRequest = (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): __HttpRequest => {
  const contents: any = {
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: path,
    headers: headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
