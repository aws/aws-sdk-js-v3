import {
  AddTagsToResourceCommandInput,
  AddTagsToResourceCommandOutput
} from "../commands/AddTagsToResourceCommand";
import {
  ApplyPendingMaintenanceActionCommandInput,
  ApplyPendingMaintenanceActionCommandOutput
} from "../commands/ApplyPendingMaintenanceActionCommand";
import {
  CreateEndpointCommandInput,
  CreateEndpointCommandOutput
} from "../commands/CreateEndpointCommand";
import {
  CreateEventSubscriptionCommandInput,
  CreateEventSubscriptionCommandOutput
} from "../commands/CreateEventSubscriptionCommand";
import {
  CreateReplicationInstanceCommandInput,
  CreateReplicationInstanceCommandOutput
} from "../commands/CreateReplicationInstanceCommand";
import {
  CreateReplicationSubnetGroupCommandInput,
  CreateReplicationSubnetGroupCommandOutput
} from "../commands/CreateReplicationSubnetGroupCommand";
import {
  CreateReplicationTaskCommandInput,
  CreateReplicationTaskCommandOutput
} from "../commands/CreateReplicationTaskCommand";
import {
  DeleteCertificateCommandInput,
  DeleteCertificateCommandOutput
} from "../commands/DeleteCertificateCommand";
import {
  DeleteConnectionCommandInput,
  DeleteConnectionCommandOutput
} from "../commands/DeleteConnectionCommand";
import {
  DeleteEndpointCommandInput,
  DeleteEndpointCommandOutput
} from "../commands/DeleteEndpointCommand";
import {
  DeleteEventSubscriptionCommandInput,
  DeleteEventSubscriptionCommandOutput
} from "../commands/DeleteEventSubscriptionCommand";
import {
  DeleteReplicationInstanceCommandInput,
  DeleteReplicationInstanceCommandOutput
} from "../commands/DeleteReplicationInstanceCommand";
import {
  DeleteReplicationSubnetGroupCommandInput,
  DeleteReplicationSubnetGroupCommandOutput
} from "../commands/DeleteReplicationSubnetGroupCommand";
import {
  DeleteReplicationTaskCommandInput,
  DeleteReplicationTaskCommandOutput
} from "../commands/DeleteReplicationTaskCommand";
import {
  DescribeAccountAttributesCommandInput,
  DescribeAccountAttributesCommandOutput
} from "../commands/DescribeAccountAttributesCommand";
import {
  DescribeCertificatesCommandInput,
  DescribeCertificatesCommandOutput
} from "../commands/DescribeCertificatesCommand";
import {
  DescribeConnectionsCommandInput,
  DescribeConnectionsCommandOutput
} from "../commands/DescribeConnectionsCommand";
import {
  DescribeEndpointTypesCommandInput,
  DescribeEndpointTypesCommandOutput
} from "../commands/DescribeEndpointTypesCommand";
import {
  DescribeEndpointsCommandInput,
  DescribeEndpointsCommandOutput
} from "../commands/DescribeEndpointsCommand";
import {
  DescribeEventCategoriesCommandInput,
  DescribeEventCategoriesCommandOutput
} from "../commands/DescribeEventCategoriesCommand";
import {
  DescribeEventSubscriptionsCommandInput,
  DescribeEventSubscriptionsCommandOutput
} from "../commands/DescribeEventSubscriptionsCommand";
import {
  DescribeEventsCommandInput,
  DescribeEventsCommandOutput
} from "../commands/DescribeEventsCommand";
import {
  DescribeOrderableReplicationInstancesCommandInput,
  DescribeOrderableReplicationInstancesCommandOutput
} from "../commands/DescribeOrderableReplicationInstancesCommand";
import {
  DescribePendingMaintenanceActionsCommandInput,
  DescribePendingMaintenanceActionsCommandOutput
} from "../commands/DescribePendingMaintenanceActionsCommand";
import {
  DescribeRefreshSchemasStatusCommandInput,
  DescribeRefreshSchemasStatusCommandOutput
} from "../commands/DescribeRefreshSchemasStatusCommand";
import {
  DescribeReplicationInstanceTaskLogsCommandInput,
  DescribeReplicationInstanceTaskLogsCommandOutput
} from "../commands/DescribeReplicationInstanceTaskLogsCommand";
import {
  DescribeReplicationInstancesCommandInput,
  DescribeReplicationInstancesCommandOutput
} from "../commands/DescribeReplicationInstancesCommand";
import {
  DescribeReplicationSubnetGroupsCommandInput,
  DescribeReplicationSubnetGroupsCommandOutput
} from "../commands/DescribeReplicationSubnetGroupsCommand";
import {
  DescribeReplicationTaskAssessmentResultsCommandInput,
  DescribeReplicationTaskAssessmentResultsCommandOutput
} from "../commands/DescribeReplicationTaskAssessmentResultsCommand";
import {
  DescribeReplicationTasksCommandInput,
  DescribeReplicationTasksCommandOutput
} from "../commands/DescribeReplicationTasksCommand";
import {
  DescribeSchemasCommandInput,
  DescribeSchemasCommandOutput
} from "../commands/DescribeSchemasCommand";
import {
  DescribeTableStatisticsCommandInput,
  DescribeTableStatisticsCommandOutput
} from "../commands/DescribeTableStatisticsCommand";
import {
  ImportCertificateCommandInput,
  ImportCertificateCommandOutput
} from "../commands/ImportCertificateCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ModifyEndpointCommandInput,
  ModifyEndpointCommandOutput
} from "../commands/ModifyEndpointCommand";
import {
  ModifyEventSubscriptionCommandInput,
  ModifyEventSubscriptionCommandOutput
} from "../commands/ModifyEventSubscriptionCommand";
import {
  ModifyReplicationInstanceCommandInput,
  ModifyReplicationInstanceCommandOutput
} from "../commands/ModifyReplicationInstanceCommand";
import {
  ModifyReplicationSubnetGroupCommandInput,
  ModifyReplicationSubnetGroupCommandOutput
} from "../commands/ModifyReplicationSubnetGroupCommand";
import {
  ModifyReplicationTaskCommandInput,
  ModifyReplicationTaskCommandOutput
} from "../commands/ModifyReplicationTaskCommand";
import {
  RebootReplicationInstanceCommandInput,
  RebootReplicationInstanceCommandOutput
} from "../commands/RebootReplicationInstanceCommand";
import {
  RefreshSchemasCommandInput,
  RefreshSchemasCommandOutput
} from "../commands/RefreshSchemasCommand";
import {
  ReloadTablesCommandInput,
  ReloadTablesCommandOutput
} from "../commands/ReloadTablesCommand";
import {
  RemoveTagsFromResourceCommandInput,
  RemoveTagsFromResourceCommandOutput
} from "../commands/RemoveTagsFromResourceCommand";
import {
  StartReplicationTaskAssessmentCommandInput,
  StartReplicationTaskAssessmentCommandOutput
} from "../commands/StartReplicationTaskAssessmentCommand";
import {
  StartReplicationTaskCommandInput,
  StartReplicationTaskCommandOutput
} from "../commands/StartReplicationTaskCommand";
import {
  StopReplicationTaskCommandInput,
  StopReplicationTaskCommandOutput
} from "../commands/StopReplicationTaskCommand";
import {
  TestConnectionCommandInput,
  TestConnectionCommandOutput
} from "../commands/TestConnectionCommand";
import {
  AccessDeniedFault,
  AccountQuota,
  AddTagsToResourceMessage,
  AddTagsToResourceResponse,
  ApplyPendingMaintenanceActionMessage,
  ApplyPendingMaintenanceActionResponse,
  AvailabilityZone,
  Certificate,
  Connection,
  CreateEndpointMessage,
  CreateEndpointResponse,
  CreateEventSubscriptionMessage,
  CreateEventSubscriptionResponse,
  CreateReplicationInstanceMessage,
  CreateReplicationInstanceResponse,
  CreateReplicationSubnetGroupMessage,
  CreateReplicationSubnetGroupResponse,
  CreateReplicationTaskMessage,
  CreateReplicationTaskResponse,
  DeleteCertificateMessage,
  DeleteCertificateResponse,
  DeleteConnectionMessage,
  DeleteConnectionResponse,
  DeleteEndpointMessage,
  DeleteEndpointResponse,
  DeleteEventSubscriptionMessage,
  DeleteEventSubscriptionResponse,
  DeleteReplicationInstanceMessage,
  DeleteReplicationInstanceResponse,
  DeleteReplicationSubnetGroupMessage,
  DeleteReplicationSubnetGroupResponse,
  DeleteReplicationTaskMessage,
  DeleteReplicationTaskResponse,
  DescribeAccountAttributesMessage,
  DescribeAccountAttributesResponse,
  DescribeCertificatesMessage,
  DescribeCertificatesResponse,
  DescribeConnectionsMessage,
  DescribeConnectionsResponse,
  DescribeEndpointTypesMessage,
  DescribeEndpointTypesResponse,
  DescribeEndpointsMessage,
  DescribeEndpointsResponse,
  DescribeEventCategoriesMessage,
  DescribeEventCategoriesResponse,
  DescribeEventSubscriptionsMessage,
  DescribeEventSubscriptionsResponse,
  DescribeEventsMessage,
  DescribeEventsResponse,
  DescribeOrderableReplicationInstancesMessage,
  DescribeOrderableReplicationInstancesResponse,
  DescribePendingMaintenanceActionsMessage,
  DescribePendingMaintenanceActionsResponse,
  DescribeRefreshSchemasStatusMessage,
  DescribeRefreshSchemasStatusResponse,
  DescribeReplicationInstanceTaskLogsMessage,
  DescribeReplicationInstanceTaskLogsResponse,
  DescribeReplicationInstancesMessage,
  DescribeReplicationInstancesResponse,
  DescribeReplicationSubnetGroupsMessage,
  DescribeReplicationSubnetGroupsResponse,
  DescribeReplicationTaskAssessmentResultsMessage,
  DescribeReplicationTaskAssessmentResultsResponse,
  DescribeReplicationTasksMessage,
  DescribeReplicationTasksResponse,
  DescribeSchemasMessage,
  DescribeSchemasResponse,
  DescribeTableStatisticsMessage,
  DescribeTableStatisticsResponse,
  DmsTransferSettings,
  DynamoDbSettings,
  ElasticsearchSettings,
  Endpoint,
  Event,
  EventCategoryGroup,
  EventSubscription,
  Filter,
  ImportCertificateMessage,
  ImportCertificateResponse,
  InsufficientResourceCapacityFault,
  InvalidCertificateFault,
  InvalidResourceStateFault,
  InvalidSubnet,
  KMSAccessDeniedFault,
  KMSDisabledFault,
  KMSInvalidStateFault,
  KMSKeyNotAccessibleFault,
  KMSNotFoundFault,
  KMSThrottlingFault,
  KinesisSettings,
  ListTagsForResourceMessage,
  ListTagsForResourceResponse,
  ModifyEndpointMessage,
  ModifyEndpointResponse,
  ModifyEventSubscriptionMessage,
  ModifyEventSubscriptionResponse,
  ModifyReplicationInstanceMessage,
  ModifyReplicationInstanceResponse,
  ModifyReplicationSubnetGroupMessage,
  ModifyReplicationSubnetGroupResponse,
  ModifyReplicationTaskMessage,
  ModifyReplicationTaskResponse,
  MongoDbSettings,
  OrderableReplicationInstance,
  PendingMaintenanceAction,
  RebootReplicationInstanceMessage,
  RebootReplicationInstanceResponse,
  RedshiftSettings,
  RefreshSchemasMessage,
  RefreshSchemasResponse,
  RefreshSchemasStatus,
  ReloadTablesMessage,
  ReloadTablesResponse,
  RemoveTagsFromResourceMessage,
  RemoveTagsFromResourceResponse,
  ReplicationInstance,
  ReplicationInstanceTaskLog,
  ReplicationPendingModifiedValues,
  ReplicationSubnetGroup,
  ReplicationSubnetGroupDoesNotCoverEnoughAZs,
  ReplicationTask,
  ReplicationTaskAssessmentResult,
  ReplicationTaskStats,
  ResourceAlreadyExistsFault,
  ResourceNotFoundFault,
  ResourcePendingMaintenanceActions,
  ResourceQuotaExceededFault,
  S3Settings,
  SNSInvalidTopicFault,
  SNSNoAuthorizationFault,
  StartReplicationTaskAssessmentMessage,
  StartReplicationTaskAssessmentResponse,
  StartReplicationTaskMessage,
  StartReplicationTaskResponse,
  StopReplicationTaskMessage,
  StopReplicationTaskResponse,
  StorageQuotaExceededFault,
  Subnet,
  SubnetAlreadyInUse,
  SupportedEndpointType,
  TableStatistics,
  TableToReload,
  Tag,
  TestConnectionMessage,
  TestConnectionResponse,
  UpgradeDependencyFailureFault,
  VpcSecurityGroupMembership
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export async function serializeAws_json1_1AddTagsToResourceCommand(
  input: AddTagsToResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.AddTagsToResource";
  let body: any = {};
  const wrappedBody: any = {
    AddTagsToResourceMessage: serializeAws_json1_1AddTagsToResourceMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/AddTagsToResource",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ApplyPendingMaintenanceActionCommand(
  input: ApplyPendingMaintenanceActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ApplyPendingMaintenanceAction";
  let body: any = {};
  const wrappedBody: any = {
    ApplyPendingMaintenanceActionMessage: serializeAws_json1_1ApplyPendingMaintenanceActionMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ApplyPendingMaintenanceAction",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateEndpointCommand(
  input: CreateEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.CreateEndpoint";
  let body: any = {};
  const wrappedBody: any = {
    CreateEndpointMessage: serializeAws_json1_1CreateEndpointMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/CreateEndpoint",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateEventSubscriptionCommand(
  input: CreateEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.CreateEventSubscription";
  let body: any = {};
  const wrappedBody: any = {
    CreateEventSubscriptionMessage: serializeAws_json1_1CreateEventSubscriptionMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/CreateEventSubscription",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateReplicationInstanceCommand(
  input: CreateReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.CreateReplicationInstance";
  let body: any = {};
  const wrappedBody: any = {
    CreateReplicationInstanceMessage: serializeAws_json1_1CreateReplicationInstanceMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/CreateReplicationInstance",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateReplicationSubnetGroupCommand(
  input: CreateReplicationSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.CreateReplicationSubnetGroup";
  let body: any = {};
  const wrappedBody: any = {
    CreateReplicationSubnetGroupMessage: serializeAws_json1_1CreateReplicationSubnetGroupMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/CreateReplicationSubnetGroup",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1CreateReplicationTaskCommand(
  input: CreateReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.CreateReplicationTask";
  let body: any = {};
  const wrappedBody: any = {
    CreateReplicationTaskMessage: serializeAws_json1_1CreateReplicationTaskMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/CreateReplicationTask",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteCertificateCommand(
  input: DeleteCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteCertificate";
  let body: any = {};
  const wrappedBody: any = {
    DeleteCertificateMessage: serializeAws_json1_1DeleteCertificateMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DeleteCertificate",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteConnectionCommand(
  input: DeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteConnection";
  let body: any = {};
  const wrappedBody: any = {
    DeleteConnectionMessage: serializeAws_json1_1DeleteConnectionMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DeleteConnection",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteEndpointCommand(
  input: DeleteEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteEndpoint";
  let body: any = {};
  const wrappedBody: any = {
    DeleteEndpointMessage: serializeAws_json1_1DeleteEndpointMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DeleteEndpoint",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteEventSubscriptionCommand(
  input: DeleteEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteEventSubscription";
  let body: any = {};
  const wrappedBody: any = {
    DeleteEventSubscriptionMessage: serializeAws_json1_1DeleteEventSubscriptionMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DeleteEventSubscription",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteReplicationInstanceCommand(
  input: DeleteReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteReplicationInstance";
  let body: any = {};
  const wrappedBody: any = {
    DeleteReplicationInstanceMessage: serializeAws_json1_1DeleteReplicationInstanceMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DeleteReplicationInstance",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteReplicationSubnetGroupCommand(
  input: DeleteReplicationSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteReplicationSubnetGroup";
  let body: any = {};
  const wrappedBody: any = {
    DeleteReplicationSubnetGroupMessage: serializeAws_json1_1DeleteReplicationSubnetGroupMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DeleteReplicationSubnetGroup",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DeleteReplicationTaskCommand(
  input: DeleteReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DeleteReplicationTask";
  let body: any = {};
  const wrappedBody: any = {
    DeleteReplicationTaskMessage: serializeAws_json1_1DeleteReplicationTaskMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DeleteReplicationTask",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeAccountAttributesCommand(
  input: DescribeAccountAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeAccountAttributes";
  let body: any = {};
  const wrappedBody: any = {
    DescribeAccountAttributesMessage: serializeAws_json1_1DescribeAccountAttributesMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeAccountAttributes",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeCertificatesCommand(
  input: DescribeCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeCertificates";
  let body: any = {};
  const wrappedBody: any = {
    DescribeCertificatesMessage: serializeAws_json1_1DescribeCertificatesMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeCertificates",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeConnectionsCommand(
  input: DescribeConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeConnections";
  let body: any = {};
  const wrappedBody: any = {
    DescribeConnectionsMessage: serializeAws_json1_1DescribeConnectionsMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeConnections",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeEndpointTypesCommand(
  input: DescribeEndpointTypesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeEndpointTypes";
  let body: any = {};
  const wrappedBody: any = {
    DescribeEndpointTypesMessage: serializeAws_json1_1DescribeEndpointTypesMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeEndpointTypes",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeEndpointsCommand(
  input: DescribeEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeEndpoints";
  let body: any = {};
  const wrappedBody: any = {
    DescribeEndpointsMessage: serializeAws_json1_1DescribeEndpointsMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeEndpoints",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeEventCategoriesCommand(
  input: DescribeEventCategoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeEventCategories";
  let body: any = {};
  const wrappedBody: any = {
    DescribeEventCategoriesMessage: serializeAws_json1_1DescribeEventCategoriesMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeEventCategories",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeEventSubscriptionsCommand(
  input: DescribeEventSubscriptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeEventSubscriptions";
  let body: any = {};
  const wrappedBody: any = {
    DescribeEventSubscriptionsMessage: serializeAws_json1_1DescribeEventSubscriptionsMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeEventSubscriptions",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeEventsCommand(
  input: DescribeEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeEvents";
  let body: any = {};
  const wrappedBody: any = {
    DescribeEventsMessage: serializeAws_json1_1DescribeEventsMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeEvents",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeOrderableReplicationInstancesCommand(
  input: DescribeOrderableReplicationInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonDMSv20160101.DescribeOrderableReplicationInstances";
  let body: any = {};
  const wrappedBody: any = {
    DescribeOrderableReplicationInstancesMessage: serializeAws_json1_1DescribeOrderableReplicationInstancesMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeOrderableReplicationInstances",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribePendingMaintenanceActionsCommand(
  input: DescribePendingMaintenanceActionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonDMSv20160101.DescribePendingMaintenanceActions";
  let body: any = {};
  const wrappedBody: any = {
    DescribePendingMaintenanceActionsMessage: serializeAws_json1_1DescribePendingMaintenanceActionsMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribePendingMaintenanceActions",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeRefreshSchemasStatusCommand(
  input: DescribeRefreshSchemasStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeRefreshSchemasStatus";
  let body: any = {};
  const wrappedBody: any = {
    DescribeRefreshSchemasStatusMessage: serializeAws_json1_1DescribeRefreshSchemasStatusMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeRefreshSchemasStatus",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeReplicationInstanceTaskLogsCommand(
  input: DescribeReplicationInstanceTaskLogsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonDMSv20160101.DescribeReplicationInstanceTaskLogs";
  let body: any = {};
  const wrappedBody: any = {
    DescribeReplicationInstanceTaskLogsMessage: serializeAws_json1_1DescribeReplicationInstanceTaskLogsMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeReplicationInstanceTaskLogs",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeReplicationInstancesCommand(
  input: DescribeReplicationInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeReplicationInstances";
  let body: any = {};
  const wrappedBody: any = {
    DescribeReplicationInstancesMessage: serializeAws_json1_1DescribeReplicationInstancesMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeReplicationInstances",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeReplicationSubnetGroupsCommand(
  input: DescribeReplicationSubnetGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonDMSv20160101.DescribeReplicationSubnetGroups";
  let body: any = {};
  const wrappedBody: any = {
    DescribeReplicationSubnetGroupsMessage: serializeAws_json1_1DescribeReplicationSubnetGroupsMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeReplicationSubnetGroups",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommand(
  input: DescribeReplicationTaskAssessmentResultsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] =
    "AmazonDMSv20160101.DescribeReplicationTaskAssessmentResults";
  let body: any = {};
  const wrappedBody: any = {
    DescribeReplicationTaskAssessmentResultsMessage: serializeAws_json1_1DescribeReplicationTaskAssessmentResultsMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeReplicationTaskAssessmentResults",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeReplicationTasksCommand(
  input: DescribeReplicationTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeReplicationTasks";
  let body: any = {};
  const wrappedBody: any = {
    DescribeReplicationTasksMessage: serializeAws_json1_1DescribeReplicationTasksMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeReplicationTasks",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeSchemasCommand(
  input: DescribeSchemasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeSchemas";
  let body: any = {};
  const wrappedBody: any = {
    DescribeSchemasMessage: serializeAws_json1_1DescribeSchemasMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeSchemas",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1DescribeTableStatisticsCommand(
  input: DescribeTableStatisticsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.DescribeTableStatistics";
  let body: any = {};
  const wrappedBody: any = {
    DescribeTableStatisticsMessage: serializeAws_json1_1DescribeTableStatisticsMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/DescribeTableStatistics",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ImportCertificateCommand(
  input: ImportCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ImportCertificate";
  let body: any = {};
  const wrappedBody: any = {
    ImportCertificateMessage: serializeAws_json1_1ImportCertificateMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ImportCertificate",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ListTagsForResourceCommand(
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ListTagsForResource";
  let body: any = {};
  const wrappedBody: any = {
    ListTagsForResourceMessage: serializeAws_json1_1ListTagsForResourceMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ListTagsForResource",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ModifyEndpointCommand(
  input: ModifyEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ModifyEndpoint";
  let body: any = {};
  const wrappedBody: any = {
    ModifyEndpointMessage: serializeAws_json1_1ModifyEndpointMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ModifyEndpoint",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ModifyEventSubscriptionCommand(
  input: ModifyEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ModifyEventSubscription";
  let body: any = {};
  const wrappedBody: any = {
    ModifyEventSubscriptionMessage: serializeAws_json1_1ModifyEventSubscriptionMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ModifyEventSubscription",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ModifyReplicationInstanceCommand(
  input: ModifyReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ModifyReplicationInstance";
  let body: any = {};
  const wrappedBody: any = {
    ModifyReplicationInstanceMessage: serializeAws_json1_1ModifyReplicationInstanceMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ModifyReplicationInstance",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ModifyReplicationSubnetGroupCommand(
  input: ModifyReplicationSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ModifyReplicationSubnetGroup";
  let body: any = {};
  const wrappedBody: any = {
    ModifyReplicationSubnetGroupMessage: serializeAws_json1_1ModifyReplicationSubnetGroupMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ModifyReplicationSubnetGroup",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ModifyReplicationTaskCommand(
  input: ModifyReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ModifyReplicationTask";
  let body: any = {};
  const wrappedBody: any = {
    ModifyReplicationTaskMessage: serializeAws_json1_1ModifyReplicationTaskMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ModifyReplicationTask",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1RebootReplicationInstanceCommand(
  input: RebootReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.RebootReplicationInstance";
  let body: any = {};
  const wrappedBody: any = {
    RebootReplicationInstanceMessage: serializeAws_json1_1RebootReplicationInstanceMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/RebootReplicationInstance",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1RefreshSchemasCommand(
  input: RefreshSchemasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.RefreshSchemas";
  let body: any = {};
  const wrappedBody: any = {
    RefreshSchemasMessage: serializeAws_json1_1RefreshSchemasMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/RefreshSchemas",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1ReloadTablesCommand(
  input: ReloadTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.ReloadTables";
  let body: any = {};
  const wrappedBody: any = {
    ReloadTablesMessage: serializeAws_json1_1ReloadTablesMessage(input, context)
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/ReloadTables",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1RemoveTagsFromResourceCommand(
  input: RemoveTagsFromResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.RemoveTagsFromResource";
  let body: any = {};
  const wrappedBody: any = {
    RemoveTagsFromResourceMessage: serializeAws_json1_1RemoveTagsFromResourceMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/RemoveTagsFromResource",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StartReplicationTaskCommand(
  input: StartReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.StartReplicationTask";
  let body: any = {};
  const wrappedBody: any = {
    StartReplicationTaskMessage: serializeAws_json1_1StartReplicationTaskMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StartReplicationTask",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StartReplicationTaskAssessmentCommand(
  input: StartReplicationTaskAssessmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.StartReplicationTaskAssessment";
  let body: any = {};
  const wrappedBody: any = {
    StartReplicationTaskAssessmentMessage: serializeAws_json1_1StartReplicationTaskAssessmentMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StartReplicationTaskAssessment",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1StopReplicationTaskCommand(
  input: StopReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.StopReplicationTask";
  let body: any = {};
  const wrappedBody: any = {
    StopReplicationTaskMessage: serializeAws_json1_1StopReplicationTaskMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/StopReplicationTask",
    headers: headers,
    body: body
  });
}

export async function serializeAws_json1_1TestConnectionCommand(
  input: TestConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> {
  const headers: any = {};
  headers["Content-Type"] = "application/x-amz-json-1.1";
  headers["X-Amz-Target"] = "AmazonDMSv20160101.TestConnection";
  let body: any = {};
  const wrappedBody: any = {
    TestConnectionMessage: serializeAws_json1_1TestConnectionMessage(
      input,
      context
    )
  };
  body = JSON.stringify(wrappedBody);
  return new __HttpRequest({
    ...context.endpoint,
    protocol: "https",
    method: "POST",
    path: "/TestConnection",
    headers: headers,
    body: body
  });
}

export async function deserializeAws_json1_1AddTagsToResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AddTagsToResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AddTagsToResourceResponse(
    data.AddTagsToResourceResponse,
    context
  );
  const response: AddTagsToResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AddTagsToResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1AddTagsToResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ApplyPendingMaintenanceActionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApplyPendingMaintenanceActionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ApplyPendingMaintenanceActionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ApplyPendingMaintenanceActionResponse(
    data.ApplyPendingMaintenanceActionResponse,
    context
  );
  const response: ApplyPendingMaintenanceActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApplyPendingMaintenanceActionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ApplyPendingMaintenanceActionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApplyPendingMaintenanceActionCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1CreateEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEndpointResponse(
    data.CreateEndpointResponse,
    context
  );
  const response: CreateEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = await deserializeAws_json1_1AccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1CreateEventSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEventSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEventSubscriptionResponse(
    data.CreateEventSubscriptionResponse,
    context
  );
  const response: CreateEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEventSubscriptionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateEventSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEventSubscriptionCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "KMSAccessDeniedFault":
    case "com.amazonaws.dms#KMSAccessDeniedFault":
      response = await deserializeAws_json1_1KMSAccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSDisabledFault":
    case "com.amazonaws.dms#KMSDisabledFault":
      response = await deserializeAws_json1_1KMSDisabledFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSInvalidStateFault":
    case "com.amazonaws.dms#KMSInvalidStateFault":
      response = await deserializeAws_json1_1KMSInvalidStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSNotFoundFault":
    case "com.amazonaws.dms#KMSNotFoundFault":
      response = await deserializeAws_json1_1KMSNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSThrottlingFault":
    case "com.amazonaws.dms#KMSThrottlingFault":
      response = await deserializeAws_json1_1KMSThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SNSInvalidTopicFault":
    case "com.amazonaws.dms#SNSInvalidTopicFault":
      response = await deserializeAws_json1_1SNSInvalidTopicFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SNSNoAuthorizationFault":
    case "com.amazonaws.dms#SNSNoAuthorizationFault":
      response = await deserializeAws_json1_1SNSNoAuthorizationFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1CreateReplicationInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateReplicationInstanceResponse(
    data.CreateReplicationInstanceResponse,
    context
  );
  const response: CreateReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateReplicationInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationInstanceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = await deserializeAws_json1_1AccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientResourceCapacityFault":
    case "com.amazonaws.dms#InsufficientResourceCapacityFault":
      response = await deserializeAws_json1_1InsufficientResourceCapacityFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidSubnet":
    case "com.amazonaws.dms#InvalidSubnet":
      response = await deserializeAws_json1_1InvalidSubnetResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ReplicationSubnetGroupDoesNotCoverEnoughAZs":
    case "com.amazonaws.dms#ReplicationSubnetGroupDoesNotCoverEnoughAZs":
      response = await deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "StorageQuotaExceededFault":
    case "com.amazonaws.dms#StorageQuotaExceededFault":
      response = await deserializeAws_json1_1StorageQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1CreateReplicationSubnetGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationSubnetGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateReplicationSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateReplicationSubnetGroupResponse(
    data.CreateReplicationSubnetGroupResponse,
    context
  );
  const response: CreateReplicationSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReplicationSubnetGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateReplicationSubnetGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationSubnetGroupCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = await deserializeAws_json1_1AccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidSubnet":
    case "com.amazonaws.dms#InvalidSubnet":
      response = await deserializeAws_json1_1InvalidSubnetResponse(
        parsedOutput,
        context
      );
      break;
    case "ReplicationSubnetGroupDoesNotCoverEnoughAZs":
    case "com.amazonaws.dms#ReplicationSubnetGroupDoesNotCoverEnoughAZs":
      response = await deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1CreateReplicationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateReplicationTaskResponse(
    data.CreateReplicationTaskResponse,
    context
  );
  const response: CreateReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1CreateReplicationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationTaskCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = await deserializeAws_json1_1AccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DeleteCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCertificateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteCertificateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteCertificateResponse(
    data.DeleteCertificateResponse,
    context
  );
  const response: DeleteCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteCertificateResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCertificateCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DeleteConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteConnectionResponse(
    data.DeleteConnectionResponse,
    context
  );
  const response: DeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = await deserializeAws_json1_1AccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DeleteEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteEndpointResponse(
    data.DeleteEndpointResponse,
    context
  );
  const response: DeleteEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DeleteEventSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteEventSubscriptionResponse(
    data.DeleteEventSubscriptionResponse,
    context
  );
  const response: DeleteEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEventSubscriptionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteEventSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventSubscriptionCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DeleteReplicationInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteReplicationInstanceResponse(
    data.DeleteReplicationInstanceResponse,
    context
  );
  const response: DeleteReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteReplicationInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationInstanceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DeleteReplicationSubnetGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationSubnetGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteReplicationSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteReplicationSubnetGroupResponse(
    data.DeleteReplicationSubnetGroupResponse,
    context
  );
  const response: DeleteReplicationSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReplicationSubnetGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteReplicationSubnetGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationSubnetGroupCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DeleteReplicationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteReplicationTaskResponse(
    data.DeleteReplicationTaskResponse,
    context
  );
  const response: DeleteReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DeleteReplicationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationTaskCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeAccountAttributesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAccountAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAccountAttributesResponse(
    data.DescribeAccountAttributesResponse,
    context
  );
  const response: DescribeAccountAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAccountAttributesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeAccountAttributesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeCertificatesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificatesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeCertificatesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeCertificatesResponse(
    data.DescribeCertificatesResponse,
    context
  );
  const response: DescribeCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCertificatesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeCertificatesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificatesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeConnectionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeConnectionsResponse(
    data.DescribeConnectionsResponse,
    context
  );
  const response: DescribeConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeConnectionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeConnectionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeEndpointTypesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointTypesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEndpointTypesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEndpointTypesResponse(
    data.DescribeEndpointTypesResponse,
    context
  );
  const response: DescribeEndpointTypesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointTypesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEndpointTypesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointTypesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeEndpointsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEndpointsResponse(
    data.DescribeEndpointsResponse,
    context
  );
  const response: DescribeEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEndpointsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeEventCategoriesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventCategoriesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEventCategoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEventCategoriesResponse(
    data.DescribeEventCategoriesResponse,
    context
  );
  const response: DescribeEventCategoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventCategoriesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEventCategoriesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventCategoriesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeEventSubscriptionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventSubscriptionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEventSubscriptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEventSubscriptionsResponse(
    data.DescribeEventSubscriptionsResponse,
    context
  );
  const response: DescribeEventSubscriptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventSubscriptionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEventSubscriptionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventSubscriptionsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeEventsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEventsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEventsResponse(
    data.DescribeEventsResponse,
    context
  );
  const response: DescribeEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeEventsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeOrderableReplicationInstancesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOrderableReplicationInstancesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeOrderableReplicationInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeOrderableReplicationInstancesResponse(
    data.DescribeOrderableReplicationInstancesResponse,
    context
  );
  const response: DescribeOrderableReplicationInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeOrderableReplicationInstancesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeOrderableReplicationInstancesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOrderableReplicationInstancesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribePendingMaintenanceActionsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePendingMaintenanceActionsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribePendingMaintenanceActionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribePendingMaintenanceActionsResponse(
    data.DescribePendingMaintenanceActionsResponse,
    context
  );
  const response: DescribePendingMaintenanceActionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePendingMaintenanceActionsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribePendingMaintenanceActionsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePendingMaintenanceActionsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeRefreshSchemasStatusCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRefreshSchemasStatusCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeRefreshSchemasStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeRefreshSchemasStatusResponse(
    data.DescribeRefreshSchemasStatusResponse,
    context
  );
  const response: DescribeRefreshSchemasStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeRefreshSchemasStatusResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeRefreshSchemasStatusCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRefreshSchemasStatusCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeReplicationInstanceTaskLogsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstanceTaskLogsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationInstanceTaskLogsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationInstanceTaskLogsResponse(
    data.DescribeReplicationInstanceTaskLogsResponse,
    context
  );
  const response: DescribeReplicationInstanceTaskLogsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationInstanceTaskLogsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeReplicationInstanceTaskLogsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstanceTaskLogsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeReplicationInstancesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstancesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationInstancesResponse(
    data.DescribeReplicationInstancesResponse,
    context
  );
  const response: DescribeReplicationInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationInstancesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeReplicationInstancesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstancesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeReplicationSubnetGroupsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationSubnetGroupsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationSubnetGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationSubnetGroupsResponse(
    data.DescribeReplicationSubnetGroupsResponse,
    context
  );
  const response: DescribeReplicationSubnetGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationSubnetGroupsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeReplicationSubnetGroupsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationSubnetGroupsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTaskAssessmentResultsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsResponse(
    data.DescribeReplicationTaskAssessmentResultsResponse,
    context
  );
  const response: DescribeReplicationTaskAssessmentResultsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationTaskAssessmentResultsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTaskAssessmentResultsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeReplicationTasksCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTasksCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationTasksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationTasksResponse(
    data.DescribeReplicationTasksResponse,
    context
  );
  const response: DescribeReplicationTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationTasksResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeReplicationTasksCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTasksCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeSchemasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSchemasCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeSchemasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeSchemasResponse(
    data.DescribeSchemasResponse,
    context
  );
  const response: DescribeSchemasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSchemasResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeSchemasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSchemasCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1DescribeTableStatisticsCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTableStatisticsCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTableStatisticsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTableStatisticsResponse(
    data.DescribeTableStatisticsResponse,
    context
  );
  const response: DescribeTableStatisticsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTableStatisticsResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1DescribeTableStatisticsCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTableStatisticsCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ImportCertificateCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCertificateCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ImportCertificateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ImportCertificateResponse(
    data.ImportCertificateResponse,
    context
  );
  const response: ImportCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportCertificateResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ImportCertificateCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCertificateCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidCertificateFault":
    case "com.amazonaws.dms#InvalidCertificateFault":
      response = await deserializeAws_json1_1InvalidCertificateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ListTagsForResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceResponse(
    data.ListTagsForResourceResponse,
    context
  );
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ListTagsForResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ModifyEndpointCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEndpointCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyEndpointResponse(
    data.ModifyEndpointResponse,
    context
  );
  const response: ModifyEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyEndpointCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEndpointCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = await deserializeAws_json1_1AccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ModifyEventSubscriptionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEventSubscriptionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyEventSubscriptionResponse(
    data.ModifyEventSubscriptionResponse,
    context
  );
  const response: ModifyEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyEventSubscriptionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyEventSubscriptionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEventSubscriptionCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "KMSAccessDeniedFault":
    case "com.amazonaws.dms#KMSAccessDeniedFault":
      response = await deserializeAws_json1_1KMSAccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSDisabledFault":
    case "com.amazonaws.dms#KMSDisabledFault":
      response = await deserializeAws_json1_1KMSDisabledFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSInvalidStateFault":
    case "com.amazonaws.dms#KMSInvalidStateFault":
      response = await deserializeAws_json1_1KMSInvalidStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSNotFoundFault":
    case "com.amazonaws.dms#KMSNotFoundFault":
      response = await deserializeAws_json1_1KMSNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSThrottlingFault":
    case "com.amazonaws.dms#KMSThrottlingFault":
      response = await deserializeAws_json1_1KMSThrottlingFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SNSInvalidTopicFault":
    case "com.amazonaws.dms#SNSInvalidTopicFault":
      response = await deserializeAws_json1_1SNSInvalidTopicFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SNSNoAuthorizationFault":
    case "com.amazonaws.dms#SNSNoAuthorizationFault":
      response = await deserializeAws_json1_1SNSNoAuthorizationFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ModifyReplicationInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyReplicationInstanceResponse(
    data.ModifyReplicationInstanceResponse,
    context
  );
  const response: ModifyReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyReplicationInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationInstanceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = await deserializeAws_json1_1AccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InsufficientResourceCapacityFault":
    case "com.amazonaws.dms#InsufficientResourceCapacityFault":
      response = await deserializeAws_json1_1InsufficientResourceCapacityFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "StorageQuotaExceededFault":
    case "com.amazonaws.dms#StorageQuotaExceededFault":
      response = await deserializeAws_json1_1StorageQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "UpgradeDependencyFailureFault":
    case "com.amazonaws.dms#UpgradeDependencyFailureFault":
      response = await deserializeAws_json1_1UpgradeDependencyFailureFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ModifyReplicationSubnetGroupCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationSubnetGroupCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyReplicationSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyReplicationSubnetGroupResponse(
    data.ModifyReplicationSubnetGroupResponse,
    context
  );
  const response: ModifyReplicationSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyReplicationSubnetGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyReplicationSubnetGroupCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationSubnetGroupCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = await deserializeAws_json1_1AccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidSubnet":
    case "com.amazonaws.dms#InvalidSubnet":
      response = await deserializeAws_json1_1InvalidSubnetResponse(
        parsedOutput,
        context
      );
      break;
    case "ReplicationSubnetGroupDoesNotCoverEnoughAZs":
    case "com.amazonaws.dms#ReplicationSubnetGroupDoesNotCoverEnoughAZs":
      response = await deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "SubnetAlreadyInUse":
    case "com.amazonaws.dms#SubnetAlreadyInUse":
      response = await deserializeAws_json1_1SubnetAlreadyInUseResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ModifyReplicationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyReplicationTaskResponse(
    data.ModifyReplicationTaskResponse,
    context
  );
  const response: ModifyReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ModifyReplicationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationTaskCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.dms#ResourceAlreadyExistsFault":
      response = await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1RebootReplicationInstanceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootReplicationInstanceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RebootReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RebootReplicationInstanceResponse(
    data.RebootReplicationInstanceResponse,
    context
  );
  const response: RebootReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RebootReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RebootReplicationInstanceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootReplicationInstanceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1RefreshSchemasCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RefreshSchemasCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RefreshSchemasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RefreshSchemasResponse(
    data.RefreshSchemasResponse,
    context
  );
  const response: RefreshSchemasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RefreshSchemasResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RefreshSchemasCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RefreshSchemasCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1ReloadTablesCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReloadTablesCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ReloadTablesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ReloadTablesResponse(
    data.ReloadTablesResponse,
    context
  );
  const response: ReloadTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReloadTablesResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1ReloadTablesCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReloadTablesCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1RemoveTagsFromResourceCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RemoveTagsFromResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RemoveTagsFromResourceResponse(
    data.RemoveTagsFromResourceResponse,
    context
  );
  const response: RemoveTagsFromResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveTagsFromResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1RemoveTagsFromResourceCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StartReplicationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartReplicationTaskResponse(
    data.StartReplicationTaskResponse,
    context
  );
  const response: StartReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartReplicationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.dms#AccessDeniedFault":
      response = await deserializeAws_json1_1AccessDeniedFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StartReplicationTaskAssessmentCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskAssessmentCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartReplicationTaskAssessmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartReplicationTaskAssessmentResponse(
    data.StartReplicationTaskAssessmentResponse,
    context
  );
  const response: StartReplicationTaskAssessmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartReplicationTaskAssessmentResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StartReplicationTaskAssessmentCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskAssessmentCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1StopReplicationTaskCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopReplicationTaskCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopReplicationTaskResponse(
    data.StopReplicationTaskResponse,
    context
  );
  const response: StopReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1StopReplicationTaskCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopReplicationTaskCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

export async function deserializeAws_json1_1TestConnectionCommand(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestConnectionCommandOutput> {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TestConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TestConnectionResponse(
    data.TestConnectionResponse,
    context
  );
  const response: TestConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
}

async function deserializeAws_json1_1TestConnectionCommandError(
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestConnectionCommandOutput> {
  const data: any = await parseBody(output.body, context);
  const parsedOutput: any = {
    ...output,
    body: data
  };
  let response: __SmithyException & __MetadataBearer;
  let errorCode: String;
  const errorTypeParts: String = data["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.dms#InvalidResourceStateFault":
      response = await deserializeAws_json1_1InvalidResourceStateFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.dms#KMSKeyNotAccessibleFault":
      response = await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.dms#ResourceNotFoundFault":
      response = await deserializeAws_json1_1ResourceNotFoundFaultResponse(
        parsedOutput,
        context
      );
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.dms#ResourceQuotaExceededFault":
      response = await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
        parsedOutput,
        context
      );
      break;
    default:
      errorCode = errorCode || "UnknownError";
      response = {
        __type: `com.amazonaws.dms.v20160101#${errorCode}`,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      };
  }
  return Promise.reject(Object.assign(new Error(response.__type), response));
}

const deserializeAws_json1_1AccessDeniedFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<AccessDeniedFault> => {
  const deserialized: any = deserializeAws_json1_1AccessDeniedFault(
    output.body,
    context
  );
  const contents: AccessDeniedFault = {
    __type: "AccessDeniedFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InsufficientResourceCapacityFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InsufficientResourceCapacityFault> => {
  const deserialized: any = deserializeAws_json1_1InsufficientResourceCapacityFault(
    output.body,
    context
  );
  const contents: InsufficientResourceCapacityFault = {
    __type: "InsufficientResourceCapacityFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidCertificateFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InvalidCertificateFault> => {
  const deserialized: any = deserializeAws_json1_1InvalidCertificateFault(
    output.body,
    context
  );
  const contents: InvalidCertificateFault = {
    __type: "InvalidCertificateFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidResourceStateFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InvalidResourceStateFault> => {
  const deserialized: any = deserializeAws_json1_1InvalidResourceStateFault(
    output.body,
    context
  );
  const contents: InvalidResourceStateFault = {
    __type: "InvalidResourceStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidSubnetResponse = async (
  output: any,
  context: __SerdeContext
): Promise<InvalidSubnet> => {
  const deserialized: any = deserializeAws_json1_1InvalidSubnet(
    output.body,
    context
  );
  const contents: InvalidSubnet = {
    __type: "InvalidSubnet",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSAccessDeniedFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<KMSAccessDeniedFault> => {
  const deserialized: any = deserializeAws_json1_1KMSAccessDeniedFault(
    output.body,
    context
  );
  const contents: KMSAccessDeniedFault = {
    __type: "KMSAccessDeniedFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSDisabledFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<KMSDisabledFault> => {
  const deserialized: any = deserializeAws_json1_1KMSDisabledFault(
    output.body,
    context
  );
  const contents: KMSDisabledFault = {
    __type: "KMSDisabledFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSInvalidStateFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<KMSInvalidStateFault> => {
  const deserialized: any = deserializeAws_json1_1KMSInvalidStateFault(
    output.body,
    context
  );
  const contents: KMSInvalidStateFault = {
    __type: "KMSInvalidStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<KMSKeyNotAccessibleFault> => {
  const deserialized: any = deserializeAws_json1_1KMSKeyNotAccessibleFault(
    output.body,
    context
  );
  const contents: KMSKeyNotAccessibleFault = {
    __type: "KMSKeyNotAccessibleFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSNotFoundFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<KMSNotFoundFault> => {
  const deserialized: any = deserializeAws_json1_1KMSNotFoundFault(
    output.body,
    context
  );
  const contents: KMSNotFoundFault = {
    __type: "KMSNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSThrottlingFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<KMSThrottlingFault> => {
  const deserialized: any = deserializeAws_json1_1KMSThrottlingFault(
    output.body,
    context
  );
  const contents: KMSThrottlingFault = {
    __type: "KMSThrottlingFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ReplicationSubnetGroupDoesNotCoverEnoughAZs> => {
  const deserialized: any = deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZs(
    output.body,
    context
  );
  const contents: ReplicationSubnetGroupDoesNotCoverEnoughAZs = {
    __type: "ReplicationSubnetGroupDoesNotCoverEnoughAZs",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceAlreadyExistsFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceAlreadyExistsFault> => {
  const deserialized: any = deserializeAws_json1_1ResourceAlreadyExistsFault(
    output.body,
    context
  );
  const contents: ResourceAlreadyExistsFault = {
    __type: "ResourceAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceNotFoundFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceNotFoundFault> => {
  const deserialized: any = deserializeAws_json1_1ResourceNotFoundFault(
    output.body,
    context
  );
  const contents: ResourceNotFoundFault = {
    __type: "ResourceNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceQuotaExceededFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<ResourceQuotaExceededFault> => {
  const deserialized: any = deserializeAws_json1_1ResourceQuotaExceededFault(
    output.body,
    context
  );
  const contents: ResourceQuotaExceededFault = {
    __type: "ResourceQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SNSInvalidTopicFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<SNSInvalidTopicFault> => {
  const deserialized: any = deserializeAws_json1_1SNSInvalidTopicFault(
    output.body,
    context
  );
  const contents: SNSInvalidTopicFault = {
    __type: "SNSInvalidTopicFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SNSNoAuthorizationFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<SNSNoAuthorizationFault> => {
  const deserialized: any = deserializeAws_json1_1SNSNoAuthorizationFault(
    output.body,
    context
  );
  const contents: SNSNoAuthorizationFault = {
    __type: "SNSNoAuthorizationFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1StorageQuotaExceededFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<StorageQuotaExceededFault> => {
  const deserialized: any = deserializeAws_json1_1StorageQuotaExceededFault(
    output.body,
    context
  );
  const contents: StorageQuotaExceededFault = {
    __type: "StorageQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SubnetAlreadyInUseResponse = async (
  output: any,
  context: __SerdeContext
): Promise<SubnetAlreadyInUse> => {
  const deserialized: any = deserializeAws_json1_1SubnetAlreadyInUse(
    output.body,
    context
  );
  const contents: SubnetAlreadyInUse = {
    __type: "SubnetAlreadyInUse",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UpgradeDependencyFailureFaultResponse = async (
  output: any,
  context: __SerdeContext
): Promise<UpgradeDependencyFailureFault> => {
  const deserialized: any = deserializeAws_json1_1UpgradeDependencyFailureFault(
    output.body,
    context
  );
  const contents: UpgradeDependencyFailureFault = {
    __type: "UpgradeDependencyFailureFault",
    $fault: "client",
    $metadata: deserializeMetadata(output),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1AddTagsToResourceMessage = (
  input: AddTagsToResourceMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1ApplyPendingMaintenanceActionMessage = (
  input: ApplyPendingMaintenanceActionMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ApplyAction !== undefined) {
    bodyParams["ApplyAction"] = input.ApplyAction;
  }
  if (input.OptInType !== undefined) {
    bodyParams["OptInType"] = input.OptInType;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEndpointMessage = (
  input: CreateEndpointMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CertificateArn !== undefined) {
    bodyParams["CertificateArn"] = input.CertificateArn;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.DmsTransferSettings !== undefined) {
    bodyParams["DmsTransferSettings"] = serializeAws_json1_1DmsTransferSettings(
      input.DmsTransferSettings,
      context
    );
  }
  if (input.DynamoDbSettings !== undefined) {
    bodyParams["DynamoDbSettings"] = serializeAws_json1_1DynamoDbSettings(
      input.DynamoDbSettings,
      context
    );
  }
  if (input.ElasticsearchSettings !== undefined) {
    bodyParams[
      "ElasticsearchSettings"
    ] = serializeAws_json1_1ElasticsearchSettings(
      input.ElasticsearchSettings,
      context
    );
  }
  if (input.EndpointIdentifier !== undefined) {
    bodyParams["EndpointIdentifier"] = input.EndpointIdentifier;
  }
  if (input.EndpointType !== undefined) {
    bodyParams["EndpointType"] = input.EndpointType;
  }
  if (input.EngineName !== undefined) {
    bodyParams["EngineName"] = input.EngineName;
  }
  if (input.ExternalTableDefinition !== undefined) {
    bodyParams["ExternalTableDefinition"] = input.ExternalTableDefinition;
  }
  if (input.ExtraConnectionAttributes !== undefined) {
    bodyParams["ExtraConnectionAttributes"] = input.ExtraConnectionAttributes;
  }
  if (input.KinesisSettings !== undefined) {
    bodyParams["KinesisSettings"] = serializeAws_json1_1KinesisSettings(
      input.KinesisSettings,
      context
    );
  }
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MongoDbSettings !== undefined) {
    bodyParams["MongoDbSettings"] = serializeAws_json1_1MongoDbSettings(
      input.MongoDbSettings,
      context
    );
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  if (input.RedshiftSettings !== undefined) {
    bodyParams["RedshiftSettings"] = serializeAws_json1_1RedshiftSettings(
      input.RedshiftSettings,
      context
    );
  }
  if (input.S3Settings !== undefined) {
    bodyParams["S3Settings"] = serializeAws_json1_1S3Settings(
      input.S3Settings,
      context
    );
  }
  if (input.ServerName !== undefined) {
    bodyParams["ServerName"] = input.ServerName;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  if (input.SslMode !== undefined) {
    bodyParams["SslMode"] = input.SslMode;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  return bodyParams;
};

const serializeAws_json1_1CreateEventSubscriptionMessage = (
  input: CreateEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.EventCategories !== undefined) {
    bodyParams["EventCategories"] = serializeAws_json1_1EventCategoriesList(
      input.EventCategories,
      context
    );
  }
  if (input.SnsTopicArn !== undefined) {
    bodyParams["SnsTopicArn"] = input.SnsTopicArn;
  }
  if (input.SourceIds !== undefined) {
    bodyParams["SourceIds"] = serializeAws_json1_1SourceIdsList(
      input.SourceIds,
      context
    );
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  if (input.SubscriptionName !== undefined) {
    bodyParams["SubscriptionName"] = input.SubscriptionName;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateReplicationInstanceMessage = (
  input: CreateReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AllocatedStorage !== undefined) {
    bodyParams["AllocatedStorage"] = input.AllocatedStorage;
  }
  if (input.AutoMinorVersionUpgrade !== undefined) {
    bodyParams["AutoMinorVersionUpgrade"] = input.AutoMinorVersionUpgrade;
  }
  if (input.AvailabilityZone !== undefined) {
    bodyParams["AvailabilityZone"] = input.AvailabilityZone;
  }
  if (input.DnsNameServers !== undefined) {
    bodyParams["DnsNameServers"] = input.DnsNameServers;
  }
  if (input.EngineVersion !== undefined) {
    bodyParams["EngineVersion"] = input.EngineVersion;
  }
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.MultiAZ !== undefined) {
    bodyParams["MultiAZ"] = input.MultiAZ;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    bodyParams["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.PubliclyAccessible !== undefined) {
    bodyParams["PubliclyAccessible"] = input.PubliclyAccessible;
  }
  if (input.ReplicationInstanceClass !== undefined) {
    bodyParams["ReplicationInstanceClass"] = input.ReplicationInstanceClass;
  }
  if (input.ReplicationInstanceIdentifier !== undefined) {
    bodyParams["ReplicationInstanceIdentifier"] =
      input.ReplicationInstanceIdentifier;
  }
  if (input.ReplicationSubnetGroupIdentifier !== undefined) {
    bodyParams["ReplicationSubnetGroupIdentifier"] =
      input.ReplicationSubnetGroupIdentifier;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    bodyParams[
      "VpcSecurityGroupIds"
    ] = serializeAws_json1_1VpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1CreateReplicationSubnetGroupMessage = (
  input: CreateReplicationSubnetGroupMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ReplicationSubnetGroupDescription !== undefined) {
    bodyParams["ReplicationSubnetGroupDescription"] =
      input.ReplicationSubnetGroupDescription;
  }
  if (input.ReplicationSubnetGroupIdentifier !== undefined) {
    bodyParams["ReplicationSubnetGroupIdentifier"] =
      input.ReplicationSubnetGroupIdentifier;
  }
  if (input.SubnetIds !== undefined) {
    bodyParams["SubnetIds"] = serializeAws_json1_1SubnetIdentifierList(
      input.SubnetIds,
      context
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1CreateReplicationTaskMessage = (
  input: CreateReplicationTaskMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CdcStartPosition !== undefined) {
    bodyParams["CdcStartPosition"] = input.CdcStartPosition;
  }
  if (input.CdcStartTime !== undefined) {
    bodyParams["CdcStartTime"] = Math.round(
      input.CdcStartTime.getTime() / 1000
    );
  }
  if (input.CdcStopPosition !== undefined) {
    bodyParams["CdcStopPosition"] = input.CdcStopPosition;
  }
  if (input.MigrationType !== undefined) {
    bodyParams["MigrationType"] = input.MigrationType;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  if (input.ReplicationTaskIdentifier !== undefined) {
    bodyParams["ReplicationTaskIdentifier"] = input.ReplicationTaskIdentifier;
  }
  if (input.ReplicationTaskSettings !== undefined) {
    bodyParams["ReplicationTaskSettings"] = input.ReplicationTaskSettings;
  }
  if (input.SourceEndpointArn !== undefined) {
    bodyParams["SourceEndpointArn"] = input.SourceEndpointArn;
  }
  if (input.TableMappings !== undefined) {
    bodyParams["TableMappings"] = input.TableMappings;
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  if (input.TargetEndpointArn !== undefined) {
    bodyParams["TargetEndpointArn"] = input.TargetEndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteCertificateMessage = (
  input: DeleteCertificateMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CertificateArn !== undefined) {
    bodyParams["CertificateArn"] = input.CertificateArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteConnectionMessage = (
  input: DeleteConnectionMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteEndpointMessage = (
  input: DeleteEndpointMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteEventSubscriptionMessage = (
  input: DeleteEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.SubscriptionName !== undefined) {
    bodyParams["SubscriptionName"] = input.SubscriptionName;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteReplicationInstanceMessage = (
  input: DeleteReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteReplicationSubnetGroupMessage = (
  input: DeleteReplicationSubnetGroupMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ReplicationSubnetGroupIdentifier !== undefined) {
    bodyParams["ReplicationSubnetGroupIdentifier"] =
      input.ReplicationSubnetGroupIdentifier;
  }
  return bodyParams;
};

const serializeAws_json1_1DeleteReplicationTaskMessage = (
  input: DeleteReplicationTaskMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeAccountAttributesMessage = (
  input: DescribeAccountAttributesMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  return bodyParams;
};

const serializeAws_json1_1DescribeCertificatesMessage = (
  input: DescribeCertificatesMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeConnectionsMessage = (
  input: DescribeConnectionsMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEndpointTypesMessage = (
  input: DescribeEndpointTypesMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEndpointsMessage = (
  input: DescribeEndpointsMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEventCategoriesMessage = (
  input: DescribeEventCategoriesMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEventSubscriptionsMessage = (
  input: DescribeEventSubscriptionsMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.SubscriptionName !== undefined) {
    bodyParams["SubscriptionName"] = input.SubscriptionName;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeEventsMessage = (
  input: DescribeEventsMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Duration !== undefined) {
    bodyParams["Duration"] = input.Duration;
  }
  if (input.EndTime !== undefined) {
    bodyParams["EndTime"] = Math.round(input.EndTime.getTime() / 1000);
  }
  if (input.EventCategories !== undefined) {
    bodyParams["EventCategories"] = serializeAws_json1_1EventCategoriesList(
      input.EventCategories,
      context
    );
  }
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.SourceIdentifier !== undefined) {
    bodyParams["SourceIdentifier"] = input.SourceIdentifier;
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  if (input.StartTime !== undefined) {
    bodyParams["StartTime"] = Math.round(input.StartTime.getTime() / 1000);
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeOrderableReplicationInstancesMessage = (
  input: DescribeOrderableReplicationInstancesMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribePendingMaintenanceActionsMessage = (
  input: DescribePendingMaintenanceActionsMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeRefreshSchemasStatusMessage = (
  input: DescribeRefreshSchemasStatusMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeReplicationInstanceTaskLogsMessage = (
  input: DescribeReplicationInstanceTaskLogsMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeReplicationInstancesMessage = (
  input: DescribeReplicationInstancesMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeReplicationSubnetGroupsMessage = (
  input: DescribeReplicationSubnetGroupsMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeReplicationTaskAssessmentResultsMessage = (
  input: DescribeReplicationTaskAssessmentResultsMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeReplicationTasksMessage = (
  input: DescribeReplicationTasksMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.WithoutSettings !== undefined) {
    bodyParams["WithoutSettings"] = input.WithoutSettings;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeSchemasMessage = (
  input: DescribeSchemasMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  return bodyParams;
};

const serializeAws_json1_1DescribeTableStatisticsMessage = (
  input: DescribeTableStatisticsMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Filters !== undefined) {
    bodyParams["Filters"] = serializeAws_json1_1FilterList(
      input.Filters,
      context
    );
  }
  if (input.Marker !== undefined) {
    bodyParams["Marker"] = input.Marker;
  }
  if (input.MaxRecords !== undefined) {
    bodyParams["MaxRecords"] = input.MaxRecords;
  }
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DmsTransferSettings = (
  input: DmsTransferSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.BucketName !== undefined) {
    bodyParams["BucketName"] = input.BucketName;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  return bodyParams;
};

const serializeAws_json1_1DynamoDbSettings = (
  input: DynamoDbSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ElasticsearchSettings = (
  input: ElasticsearchSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointUri !== undefined) {
    bodyParams["EndpointUri"] = input.EndpointUri;
  }
  if (input.ErrorRetryDuration !== undefined) {
    bodyParams["ErrorRetryDuration"] = input.ErrorRetryDuration;
  }
  if (input.FullLoadErrorPercentage !== undefined) {
    bodyParams["FullLoadErrorPercentage"] = input.FullLoadErrorPercentage;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  return bodyParams;
};

const serializeAws_json1_1EventCategoriesList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1Filter = (
  input: Filter,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Name !== undefined) {
    bodyParams["Name"] = input.Name;
  }
  if (input.Values !== undefined) {
    bodyParams["Values"] = serializeAws_json1_1FilterValueList(
      input.Values,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1FilterList = (
  input: Array<Filter>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => serializeAws_json1_1Filter(entry, context));
};

const serializeAws_json1_1FilterValueList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1ImportCertificateMessage = (
  input: ImportCertificateMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CertificateIdentifier !== undefined) {
    bodyParams["CertificateIdentifier"] = input.CertificateIdentifier;
  }
  if (input.CertificatePem !== undefined) {
    bodyParams["CertificatePem"] = input.CertificatePem;
  }
  if (input.CertificateWallet !== undefined) {
    bodyParams["CertificateWallet"] = context.base64Encoder(
      input.CertificateWallet
    );
  }
  if (input.Tags !== undefined) {
    bodyParams["Tags"] = serializeAws_json1_1TagList(input.Tags, context);
  }
  return bodyParams;
};

const serializeAws_json1_1KeyList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1KinesisSettings = (
  input: KinesisSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.MessageFormat !== undefined) {
    bodyParams["MessageFormat"] = input.MessageFormat;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  if (input.StreamArn !== undefined) {
    bodyParams["StreamArn"] = input.StreamArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ListTagsForResourceMessage = (
  input: ListTagsForResourceMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ModifyEndpointMessage = (
  input: ModifyEndpointMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CertificateArn !== undefined) {
    bodyParams["CertificateArn"] = input.CertificateArn;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.DmsTransferSettings !== undefined) {
    bodyParams["DmsTransferSettings"] = serializeAws_json1_1DmsTransferSettings(
      input.DmsTransferSettings,
      context
    );
  }
  if (input.DynamoDbSettings !== undefined) {
    bodyParams["DynamoDbSettings"] = serializeAws_json1_1DynamoDbSettings(
      input.DynamoDbSettings,
      context
    );
  }
  if (input.ElasticsearchSettings !== undefined) {
    bodyParams[
      "ElasticsearchSettings"
    ] = serializeAws_json1_1ElasticsearchSettings(
      input.ElasticsearchSettings,
      context
    );
  }
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.EndpointIdentifier !== undefined) {
    bodyParams["EndpointIdentifier"] = input.EndpointIdentifier;
  }
  if (input.EndpointType !== undefined) {
    bodyParams["EndpointType"] = input.EndpointType;
  }
  if (input.EngineName !== undefined) {
    bodyParams["EngineName"] = input.EngineName;
  }
  if (input.ExternalTableDefinition !== undefined) {
    bodyParams["ExternalTableDefinition"] = input.ExternalTableDefinition;
  }
  if (input.ExtraConnectionAttributes !== undefined) {
    bodyParams["ExtraConnectionAttributes"] = input.ExtraConnectionAttributes;
  }
  if (input.KinesisSettings !== undefined) {
    bodyParams["KinesisSettings"] = serializeAws_json1_1KinesisSettings(
      input.KinesisSettings,
      context
    );
  }
  if (input.MongoDbSettings !== undefined) {
    bodyParams["MongoDbSettings"] = serializeAws_json1_1MongoDbSettings(
      input.MongoDbSettings,
      context
    );
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  if (input.RedshiftSettings !== undefined) {
    bodyParams["RedshiftSettings"] = serializeAws_json1_1RedshiftSettings(
      input.RedshiftSettings,
      context
    );
  }
  if (input.S3Settings !== undefined) {
    bodyParams["S3Settings"] = serializeAws_json1_1S3Settings(
      input.S3Settings,
      context
    );
  }
  if (input.ServerName !== undefined) {
    bodyParams["ServerName"] = input.ServerName;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  if (input.SslMode !== undefined) {
    bodyParams["SslMode"] = input.SslMode;
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  return bodyParams;
};

const serializeAws_json1_1ModifyEventSubscriptionMessage = (
  input: ModifyEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.Enabled !== undefined) {
    bodyParams["Enabled"] = input.Enabled;
  }
  if (input.EventCategories !== undefined) {
    bodyParams["EventCategories"] = serializeAws_json1_1EventCategoriesList(
      input.EventCategories,
      context
    );
  }
  if (input.SnsTopicArn !== undefined) {
    bodyParams["SnsTopicArn"] = input.SnsTopicArn;
  }
  if (input.SourceType !== undefined) {
    bodyParams["SourceType"] = input.SourceType;
  }
  if (input.SubscriptionName !== undefined) {
    bodyParams["SubscriptionName"] = input.SubscriptionName;
  }
  return bodyParams;
};

const serializeAws_json1_1ModifyReplicationInstanceMessage = (
  input: ModifyReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AllocatedStorage !== undefined) {
    bodyParams["AllocatedStorage"] = input.AllocatedStorage;
  }
  if (input.AllowMajorVersionUpgrade !== undefined) {
    bodyParams["AllowMajorVersionUpgrade"] = input.AllowMajorVersionUpgrade;
  }
  if (input.ApplyImmediately !== undefined) {
    bodyParams["ApplyImmediately"] = input.ApplyImmediately;
  }
  if (input.AutoMinorVersionUpgrade !== undefined) {
    bodyParams["AutoMinorVersionUpgrade"] = input.AutoMinorVersionUpgrade;
  }
  if (input.EngineVersion !== undefined) {
    bodyParams["EngineVersion"] = input.EngineVersion;
  }
  if (input.MultiAZ !== undefined) {
    bodyParams["MultiAZ"] = input.MultiAZ;
  }
  if (input.PreferredMaintenanceWindow !== undefined) {
    bodyParams["PreferredMaintenanceWindow"] = input.PreferredMaintenanceWindow;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  if (input.ReplicationInstanceClass !== undefined) {
    bodyParams["ReplicationInstanceClass"] = input.ReplicationInstanceClass;
  }
  if (input.ReplicationInstanceIdentifier !== undefined) {
    bodyParams["ReplicationInstanceIdentifier"] =
      input.ReplicationInstanceIdentifier;
  }
  if (input.VpcSecurityGroupIds !== undefined) {
    bodyParams[
      "VpcSecurityGroupIds"
    ] = serializeAws_json1_1VpcSecurityGroupIdList(
      input.VpcSecurityGroupIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ModifyReplicationSubnetGroupMessage = (
  input: ModifyReplicationSubnetGroupMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ReplicationSubnetGroupDescription !== undefined) {
    bodyParams["ReplicationSubnetGroupDescription"] =
      input.ReplicationSubnetGroupDescription;
  }
  if (input.ReplicationSubnetGroupIdentifier !== undefined) {
    bodyParams["ReplicationSubnetGroupIdentifier"] =
      input.ReplicationSubnetGroupIdentifier;
  }
  if (input.SubnetIds !== undefined) {
    bodyParams["SubnetIds"] = serializeAws_json1_1SubnetIdentifierList(
      input.SubnetIds,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1ModifyReplicationTaskMessage = (
  input: ModifyReplicationTaskMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CdcStartPosition !== undefined) {
    bodyParams["CdcStartPosition"] = input.CdcStartPosition;
  }
  if (input.CdcStartTime !== undefined) {
    bodyParams["CdcStartTime"] = Math.round(
      input.CdcStartTime.getTime() / 1000
    );
  }
  if (input.CdcStopPosition !== undefined) {
    bodyParams["CdcStopPosition"] = input.CdcStopPosition;
  }
  if (input.MigrationType !== undefined) {
    bodyParams["MigrationType"] = input.MigrationType;
  }
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  if (input.ReplicationTaskIdentifier !== undefined) {
    bodyParams["ReplicationTaskIdentifier"] = input.ReplicationTaskIdentifier;
  }
  if (input.ReplicationTaskSettings !== undefined) {
    bodyParams["ReplicationTaskSettings"] = input.ReplicationTaskSettings;
  }
  if (input.TableMappings !== undefined) {
    bodyParams["TableMappings"] = input.TableMappings;
  }
  return bodyParams;
};

const serializeAws_json1_1MongoDbSettings = (
  input: MongoDbSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AuthMechanism !== undefined) {
    bodyParams["AuthMechanism"] = input.AuthMechanism;
  }
  if (input.AuthSource !== undefined) {
    bodyParams["AuthSource"] = input.AuthSource;
  }
  if (input.AuthType !== undefined) {
    bodyParams["AuthType"] = input.AuthType;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.DocsToInvestigate !== undefined) {
    bodyParams["DocsToInvestigate"] = input.DocsToInvestigate;
  }
  if (input.ExtractDocId !== undefined) {
    bodyParams["ExtractDocId"] = input.ExtractDocId;
  }
  if (input.KmsKeyId !== undefined) {
    bodyParams["KmsKeyId"] = input.KmsKeyId;
  }
  if (input.NestingLevel !== undefined) {
    bodyParams["NestingLevel"] = input.NestingLevel;
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  if (input.ServerName !== undefined) {
    bodyParams["ServerName"] = input.ServerName;
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  return bodyParams;
};

const serializeAws_json1_1RebootReplicationInstanceMessage = (
  input: RebootReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ForceFailover !== undefined) {
    bodyParams["ForceFailover"] = input.ForceFailover;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1RedshiftSettings = (
  input: RedshiftSettings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.AcceptAnyDate !== undefined) {
    bodyParams["AcceptAnyDate"] = input.AcceptAnyDate;
  }
  if (input.AfterConnectScript !== undefined) {
    bodyParams["AfterConnectScript"] = input.AfterConnectScript;
  }
  if (input.BucketFolder !== undefined) {
    bodyParams["BucketFolder"] = input.BucketFolder;
  }
  if (input.BucketName !== undefined) {
    bodyParams["BucketName"] = input.BucketName;
  }
  if (input.ConnectionTimeout !== undefined) {
    bodyParams["ConnectionTimeout"] = input.ConnectionTimeout;
  }
  if (input.DatabaseName !== undefined) {
    bodyParams["DatabaseName"] = input.DatabaseName;
  }
  if (input.DateFormat !== undefined) {
    bodyParams["DateFormat"] = input.DateFormat;
  }
  if (input.EmptyAsNull !== undefined) {
    bodyParams["EmptyAsNull"] = input.EmptyAsNull;
  }
  if (input.EncryptionMode !== undefined) {
    bodyParams["EncryptionMode"] = input.EncryptionMode;
  }
  if (input.FileTransferUploadStreams !== undefined) {
    bodyParams["FileTransferUploadStreams"] = input.FileTransferUploadStreams;
  }
  if (input.LoadTimeout !== undefined) {
    bodyParams["LoadTimeout"] = input.LoadTimeout;
  }
  if (input.MaxFileSize !== undefined) {
    bodyParams["MaxFileSize"] = input.MaxFileSize;
  }
  if (input.Password !== undefined) {
    bodyParams["Password"] = input.Password;
  }
  if (input.Port !== undefined) {
    bodyParams["Port"] = input.Port;
  }
  if (input.RemoveQuotes !== undefined) {
    bodyParams["RemoveQuotes"] = input.RemoveQuotes;
  }
  if (input.ReplaceChars !== undefined) {
    bodyParams["ReplaceChars"] = input.ReplaceChars;
  }
  if (input.ReplaceInvalidChars !== undefined) {
    bodyParams["ReplaceInvalidChars"] = input.ReplaceInvalidChars;
  }
  if (input.ServerName !== undefined) {
    bodyParams["ServerName"] = input.ServerName;
  }
  if (input.ServerSideEncryptionKmsKeyId !== undefined) {
    bodyParams["ServerSideEncryptionKmsKeyId"] =
      input.ServerSideEncryptionKmsKeyId;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  if (input.TimeFormat !== undefined) {
    bodyParams["TimeFormat"] = input.TimeFormat;
  }
  if (input.TrimBlanks !== undefined) {
    bodyParams["TrimBlanks"] = input.TrimBlanks;
  }
  if (input.TruncateColumns !== undefined) {
    bodyParams["TruncateColumns"] = input.TruncateColumns;
  }
  if (input.Username !== undefined) {
    bodyParams["Username"] = input.Username;
  }
  if (input.WriteBufferSize !== undefined) {
    bodyParams["WriteBufferSize"] = input.WriteBufferSize;
  }
  return bodyParams;
};

const serializeAws_json1_1RefreshSchemasMessage = (
  input: RefreshSchemasMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1ReloadTablesMessage = (
  input: ReloadTablesMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ReloadOption !== undefined) {
    bodyParams["ReloadOption"] = input.ReloadOption;
  }
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  if (input.TablesToReload !== undefined) {
    bodyParams["TablesToReload"] = serializeAws_json1_1TableListToReload(
      input.TablesToReload,
      context
    );
  }
  return bodyParams;
};

const serializeAws_json1_1RemoveTagsFromResourceMessage = (
  input: RemoveTagsFromResourceMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ResourceArn !== undefined) {
    bodyParams["ResourceArn"] = input.ResourceArn;
  }
  if (input.TagKeys !== undefined) {
    bodyParams["TagKeys"] = serializeAws_json1_1KeyList(input.TagKeys, context);
  }
  return bodyParams;
};

const serializeAws_json1_1S3Settings = (
  input: S3Settings,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.BucketFolder !== undefined) {
    bodyParams["BucketFolder"] = input.BucketFolder;
  }
  if (input.BucketName !== undefined) {
    bodyParams["BucketName"] = input.BucketName;
  }
  if (input.CdcInsertsOnly !== undefined) {
    bodyParams["CdcInsertsOnly"] = input.CdcInsertsOnly;
  }
  if (input.CompressionType !== undefined) {
    bodyParams["CompressionType"] = input.CompressionType;
  }
  if (input.CsvDelimiter !== undefined) {
    bodyParams["CsvDelimiter"] = input.CsvDelimiter;
  }
  if (input.CsvRowDelimiter !== undefined) {
    bodyParams["CsvRowDelimiter"] = input.CsvRowDelimiter;
  }
  if (input.DataFormat !== undefined) {
    bodyParams["DataFormat"] = input.DataFormat;
  }
  if (input.DataPageSize !== undefined) {
    bodyParams["DataPageSize"] = input.DataPageSize;
  }
  if (input.DictPageSizeLimit !== undefined) {
    bodyParams["DictPageSizeLimit"] = input.DictPageSizeLimit;
  }
  if (input.EnableStatistics !== undefined) {
    bodyParams["EnableStatistics"] = input.EnableStatistics;
  }
  if (input.EncodingType !== undefined) {
    bodyParams["EncodingType"] = input.EncodingType;
  }
  if (input.EncryptionMode !== undefined) {
    bodyParams["EncryptionMode"] = input.EncryptionMode;
  }
  if (input.ExternalTableDefinition !== undefined) {
    bodyParams["ExternalTableDefinition"] = input.ExternalTableDefinition;
  }
  if (input.IncludeOpForFullLoad !== undefined) {
    bodyParams["IncludeOpForFullLoad"] = input.IncludeOpForFullLoad;
  }
  if (input.ParquetTimestampInMillisecond !== undefined) {
    bodyParams["ParquetTimestampInMillisecond"] =
      input.ParquetTimestampInMillisecond;
  }
  if (input.ParquetVersion !== undefined) {
    bodyParams["ParquetVersion"] = input.ParquetVersion;
  }
  if (input.RowGroupLength !== undefined) {
    bodyParams["RowGroupLength"] = input.RowGroupLength;
  }
  if (input.ServerSideEncryptionKmsKeyId !== undefined) {
    bodyParams["ServerSideEncryptionKmsKeyId"] =
      input.ServerSideEncryptionKmsKeyId;
  }
  if (input.ServiceAccessRoleArn !== undefined) {
    bodyParams["ServiceAccessRoleArn"] = input.ServiceAccessRoleArn;
  }
  if (input.TimestampColumnName !== undefined) {
    bodyParams["TimestampColumnName"] = input.TimestampColumnName;
  }
  return bodyParams;
};

const serializeAws_json1_1SourceIdsList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1StartReplicationTaskAssessmentMessage = (
  input: StartReplicationTaskAssessmentMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  return bodyParams;
};

const serializeAws_json1_1StartReplicationTaskMessage = (
  input: StartReplicationTaskMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.CdcStartPosition !== undefined) {
    bodyParams["CdcStartPosition"] = input.CdcStartPosition;
  }
  if (input.CdcStartTime !== undefined) {
    bodyParams["CdcStartTime"] = Math.round(
      input.CdcStartTime.getTime() / 1000
    );
  }
  if (input.CdcStopPosition !== undefined) {
    bodyParams["CdcStopPosition"] = input.CdcStopPosition;
  }
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  if (input.StartReplicationTaskType !== undefined) {
    bodyParams["StartReplicationTaskType"] = input.StartReplicationTaskType;
  }
  return bodyParams;
};

const serializeAws_json1_1StopReplicationTaskMessage = (
  input: StopReplicationTaskMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.ReplicationTaskArn !== undefined) {
    bodyParams["ReplicationTaskArn"] = input.ReplicationTaskArn;
  }
  return bodyParams;
};

const serializeAws_json1_1SubnetIdentifierList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const serializeAws_json1_1TableListToReload = (
  input: Array<TableToReload>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry =>
    serializeAws_json1_1TableToReload(entry, context)
  );
};

const serializeAws_json1_1TableToReload = (
  input: TableToReload,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.SchemaName !== undefined) {
    bodyParams["SchemaName"] = input.SchemaName;
  }
  if (input.TableName !== undefined) {
    bodyParams["TableName"] = input.TableName;
  }
  return bodyParams;
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  let bodyParams: any = {};
  if (input.Key !== undefined) {
    bodyParams["Key"] = input.Key;
  }
  if (input.Value !== undefined) {
    bodyParams["Value"] = input.Value;
  }
  return bodyParams;
};

const serializeAws_json1_1TagList = (
  input: Array<Tag>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => serializeAws_json1_1Tag(entry, context));
};

const serializeAws_json1_1TestConnectionMessage = (
  input: TestConnectionMessage,
  context: __SerdeContext
): any => {
  let bodyParams: any = {};
  if (input.EndpointArn !== undefined) {
    bodyParams["EndpointArn"] = input.EndpointArn;
  }
  if (input.ReplicationInstanceArn !== undefined) {
    bodyParams["ReplicationInstanceArn"] = input.ReplicationInstanceArn;
  }
  return bodyParams;
};

const serializeAws_json1_1VpcSecurityGroupIdList = (
  input: Array<string>,
  context: __SerdeContext
): any => {
  return (input || []).map(entry => entry);
};

const deserializeAws_json1_1AccessDeniedFault = (
  output: any,
  context: __SerdeContext
): AccessDeniedFault => {
  let contents: any = {
    __type: "AccessDeniedFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InsufficientResourceCapacityFault = (
  output: any,
  context: __SerdeContext
): InsufficientResourceCapacityFault => {
  let contents: any = {
    __type: "InsufficientResourceCapacityFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidCertificateFault = (
  output: any,
  context: __SerdeContext
): InvalidCertificateFault => {
  let contents: any = {
    __type: "InvalidCertificateFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidResourceStateFault = (
  output: any,
  context: __SerdeContext
): InvalidResourceStateFault => {
  let contents: any = {
    __type: "InvalidResourceStateFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1InvalidSubnet = (
  output: any,
  context: __SerdeContext
): InvalidSubnet => {
  let contents: any = {
    __type: "InvalidSubnet",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSAccessDeniedFault = (
  output: any,
  context: __SerdeContext
): KMSAccessDeniedFault => {
  let contents: any = {
    __type: "KMSAccessDeniedFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSDisabledFault = (
  output: any,
  context: __SerdeContext
): KMSDisabledFault => {
  let contents: any = {
    __type: "KMSDisabledFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSInvalidStateFault = (
  output: any,
  context: __SerdeContext
): KMSInvalidStateFault => {
  let contents: any = {
    __type: "KMSInvalidStateFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSKeyNotAccessibleFault = (
  output: any,
  context: __SerdeContext
): KMSKeyNotAccessibleFault => {
  let contents: any = {
    __type: "KMSKeyNotAccessibleFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSNotFoundFault = (
  output: any,
  context: __SerdeContext
): KMSNotFoundFault => {
  let contents: any = {
    __type: "KMSNotFoundFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1KMSThrottlingFault = (
  output: any,
  context: __SerdeContext
): KMSThrottlingFault => {
  let contents: any = {
    __type: "KMSThrottlingFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZs = (
  output: any,
  context: __SerdeContext
): ReplicationSubnetGroupDoesNotCoverEnoughAZs => {
  let contents: any = {
    __type: "ReplicationSubnetGroupDoesNotCoverEnoughAZs",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ResourceAlreadyExistsFault => {
  let contents: any = {
    __type: "ResourceAlreadyExistsFault",
    message: undefined,
    resourceArn: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  if (output.resourceArn !== undefined) {
    contents.resourceArn = output.resourceArn;
  }
  return contents;
};

const deserializeAws_json1_1ResourceNotFoundFault = (
  output: any,
  context: __SerdeContext
): ResourceNotFoundFault => {
  let contents: any = {
    __type: "ResourceNotFoundFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1ResourceQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ResourceQuotaExceededFault => {
  let contents: any = {
    __type: "ResourceQuotaExceededFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SNSInvalidTopicFault = (
  output: any,
  context: __SerdeContext
): SNSInvalidTopicFault => {
  let contents: any = {
    __type: "SNSInvalidTopicFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SNSNoAuthorizationFault = (
  output: any,
  context: __SerdeContext
): SNSNoAuthorizationFault => {
  let contents: any = {
    __type: "SNSNoAuthorizationFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1StorageQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): StorageQuotaExceededFault => {
  let contents: any = {
    __type: "StorageQuotaExceededFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1SubnetAlreadyInUse = (
  output: any,
  context: __SerdeContext
): SubnetAlreadyInUse => {
  let contents: any = {
    __type: "SubnetAlreadyInUse",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1UpgradeDependencyFailureFault = (
  output: any,
  context: __SerdeContext
): UpgradeDependencyFailureFault => {
  let contents: any = {
    __type: "UpgradeDependencyFailureFault",
    message: undefined
  };
  if (output.message !== undefined) {
    contents.message = output.message;
  }
  return contents;
};

const deserializeAws_json1_1AccountQuota = (
  output: any,
  context: __SerdeContext
): AccountQuota => {
  let contents: any = {
    __type: "AccountQuota",
    AccountQuotaName: undefined,
    Max: undefined,
    Used: undefined
  };
  if (output.AccountQuotaName !== undefined) {
    contents.AccountQuotaName = output.AccountQuotaName;
  }
  if (output.Max !== undefined) {
    contents.Max = output.Max;
  }
  if (output.Used !== undefined) {
    contents.Used = output.Used;
  }
  return contents;
};

const deserializeAws_json1_1AccountQuotaList = (
  output: any,
  context: __SerdeContext
): Array<AccountQuota> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AccountQuota(entry, context)
  );
};

const deserializeAws_json1_1AddTagsToResourceResponse = (
  output: any,
  context: __SerdeContext
): AddTagsToResourceResponse => {
  let contents: any = {
    __type: "AddTagsToResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1ApplyPendingMaintenanceActionResponse = (
  output: any,
  context: __SerdeContext
): ApplyPendingMaintenanceActionResponse => {
  let contents: any = {
    __type: "ApplyPendingMaintenanceActionResponse",
    ResourcePendingMaintenanceActions: undefined
  };
  if (output.ResourcePendingMaintenanceActions !== undefined) {
    contents.ResourcePendingMaintenanceActions = deserializeAws_json1_1ResourcePendingMaintenanceActions(
      output.ResourcePendingMaintenanceActions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1AvailabilityZone = (
  output: any,
  context: __SerdeContext
): AvailabilityZone => {
  let contents: any = {
    __type: "AvailabilityZone",
    Name: undefined
  };
  if (output.Name !== undefined) {
    contents.Name = output.Name;
  }
  return contents;
};

const deserializeAws_json1_1AvailabilityZonesList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Certificate = (
  output: any,
  context: __SerdeContext
): Certificate => {
  let contents: any = {
    __type: "Certificate",
    CertificateArn: undefined,
    CertificateCreationDate: undefined,
    CertificateIdentifier: undefined,
    CertificateOwner: undefined,
    CertificatePem: undefined,
    CertificateWallet: undefined,
    KeyLength: undefined,
    SigningAlgorithm: undefined,
    ValidFromDate: undefined,
    ValidToDate: undefined
  };
  if (output.CertificateArn !== undefined) {
    contents.CertificateArn = output.CertificateArn;
  }
  if (output.CertificateCreationDate !== undefined) {
    contents.CertificateCreationDate = new Date(
      output.CertificateCreationDate % 1 != 0
        ? Math.round(output.CertificateCreationDate * 1000)
        : output.CertificateCreationDate
    );
  }
  if (output.CertificateIdentifier !== undefined) {
    contents.CertificateIdentifier = output.CertificateIdentifier;
  }
  if (output.CertificateOwner !== undefined) {
    contents.CertificateOwner = output.CertificateOwner;
  }
  if (output.CertificatePem !== undefined) {
    contents.CertificatePem = output.CertificatePem;
  }
  if (output.CertificateWallet !== undefined) {
    contents.CertificateWallet = context.base64Decoder(
      output.CertificateWallet
    );
  }
  if (output.KeyLength !== undefined) {
    contents.KeyLength = output.KeyLength;
  }
  if (output.SigningAlgorithm !== undefined) {
    contents.SigningAlgorithm = output.SigningAlgorithm;
  }
  if (output.ValidFromDate !== undefined) {
    contents.ValidFromDate = new Date(
      output.ValidFromDate % 1 != 0
        ? Math.round(output.ValidFromDate * 1000)
        : output.ValidFromDate
    );
  }
  if (output.ValidToDate !== undefined) {
    contents.ValidToDate = new Date(
      output.ValidToDate % 1 != 0
        ? Math.round(output.ValidToDate * 1000)
        : output.ValidToDate
    );
  }
  return contents;
};

const deserializeAws_json1_1CertificateList = (
  output: any,
  context: __SerdeContext
): Array<Certificate> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Certificate(entry, context)
  );
};

const deserializeAws_json1_1Connection = (
  output: any,
  context: __SerdeContext
): Connection => {
  let contents: any = {
    __type: "Connection",
    EndpointArn: undefined,
    EndpointIdentifier: undefined,
    LastFailureMessage: undefined,
    ReplicationInstanceArn: undefined,
    ReplicationInstanceIdentifier: undefined,
    Status: undefined
  };
  if (output.EndpointArn !== undefined) {
    contents.EndpointArn = output.EndpointArn;
  }
  if (output.EndpointIdentifier !== undefined) {
    contents.EndpointIdentifier = output.EndpointIdentifier;
  }
  if (output.LastFailureMessage !== undefined) {
    contents.LastFailureMessage = output.LastFailureMessage;
  }
  if (output.ReplicationInstanceArn !== undefined) {
    contents.ReplicationInstanceArn = output.ReplicationInstanceArn;
  }
  if (output.ReplicationInstanceIdentifier !== undefined) {
    contents.ReplicationInstanceIdentifier =
      output.ReplicationInstanceIdentifier;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1ConnectionList = (
  output: any,
  context: __SerdeContext
): Array<Connection> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Connection(entry, context)
  );
};

const deserializeAws_json1_1CreateEndpointResponse = (
  output: any,
  context: __SerdeContext
): CreateEndpointResponse => {
  let contents: any = {
    __type: "CreateEndpointResponse",
    Endpoint: undefined
  };
  if (output.Endpoint !== undefined) {
    contents.Endpoint = deserializeAws_json1_1Endpoint(
      output.Endpoint,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateEventSubscriptionResponse = (
  output: any,
  context: __SerdeContext
): CreateEventSubscriptionResponse => {
  let contents: any = {
    __type: "CreateEventSubscriptionResponse",
    EventSubscription: undefined
  };
  if (output.EventSubscription !== undefined) {
    contents.EventSubscription = deserializeAws_json1_1EventSubscription(
      output.EventSubscription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): CreateReplicationInstanceResponse => {
  let contents: any = {
    __type: "CreateReplicationInstanceResponse",
    ReplicationInstance: undefined
  };
  if (output.ReplicationInstance !== undefined) {
    contents.ReplicationInstance = deserializeAws_json1_1ReplicationInstance(
      output.ReplicationInstance,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateReplicationSubnetGroupResponse = (
  output: any,
  context: __SerdeContext
): CreateReplicationSubnetGroupResponse => {
  let contents: any = {
    __type: "CreateReplicationSubnetGroupResponse",
    ReplicationSubnetGroup: undefined
  };
  if (output.ReplicationSubnetGroup !== undefined) {
    contents.ReplicationSubnetGroup = deserializeAws_json1_1ReplicationSubnetGroup(
      output.ReplicationSubnetGroup,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1CreateReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): CreateReplicationTaskResponse => {
  let contents: any = {
    __type: "CreateReplicationTaskResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteCertificateResponse = (
  output: any,
  context: __SerdeContext
): DeleteCertificateResponse => {
  let contents: any = {
    __type: "DeleteCertificateResponse",
    Certificate: undefined
  };
  if (output.Certificate !== undefined) {
    contents.Certificate = deserializeAws_json1_1Certificate(
      output.Certificate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteConnectionResponse = (
  output: any,
  context: __SerdeContext
): DeleteConnectionResponse => {
  let contents: any = {
    __type: "DeleteConnectionResponse",
    Connection: undefined
  };
  if (output.Connection !== undefined) {
    contents.Connection = deserializeAws_json1_1Connection(
      output.Connection,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteEndpointResponse = (
  output: any,
  context: __SerdeContext
): DeleteEndpointResponse => {
  let contents: any = {
    __type: "DeleteEndpointResponse",
    Endpoint: undefined
  };
  if (output.Endpoint !== undefined) {
    contents.Endpoint = deserializeAws_json1_1Endpoint(
      output.Endpoint,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteEventSubscriptionResponse = (
  output: any,
  context: __SerdeContext
): DeleteEventSubscriptionResponse => {
  let contents: any = {
    __type: "DeleteEventSubscriptionResponse",
    EventSubscription: undefined
  };
  if (output.EventSubscription !== undefined) {
    contents.EventSubscription = deserializeAws_json1_1EventSubscription(
      output.EventSubscription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): DeleteReplicationInstanceResponse => {
  let contents: any = {
    __type: "DeleteReplicationInstanceResponse",
    ReplicationInstance: undefined
  };
  if (output.ReplicationInstance !== undefined) {
    contents.ReplicationInstance = deserializeAws_json1_1ReplicationInstance(
      output.ReplicationInstance,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DeleteReplicationSubnetGroupResponse = (
  output: any,
  context: __SerdeContext
): DeleteReplicationSubnetGroupResponse => {
  let contents: any = {
    __type: "DeleteReplicationSubnetGroupResponse"
  };
  return contents;
};

const deserializeAws_json1_1DeleteReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): DeleteReplicationTaskResponse => {
  let contents: any = {
    __type: "DeleteReplicationTaskResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeAccountAttributesResponse = (
  output: any,
  context: __SerdeContext
): DescribeAccountAttributesResponse => {
  let contents: any = {
    __type: "DescribeAccountAttributesResponse",
    AccountQuotas: undefined,
    UniqueAccountIdentifier: undefined
  };
  if (output.AccountQuotas !== undefined) {
    contents.AccountQuotas = deserializeAws_json1_1AccountQuotaList(
      output.AccountQuotas,
      context
    );
  }
  if (output.UniqueAccountIdentifier !== undefined) {
    contents.UniqueAccountIdentifier = output.UniqueAccountIdentifier;
  }
  return contents;
};

const deserializeAws_json1_1DescribeCertificatesResponse = (
  output: any,
  context: __SerdeContext
): DescribeCertificatesResponse => {
  let contents: any = {
    __type: "DescribeCertificatesResponse",
    Certificates: undefined,
    Marker: undefined
  };
  if (output.Certificates !== undefined) {
    contents.Certificates = deserializeAws_json1_1CertificateList(
      output.Certificates,
      context
    );
  }
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  return contents;
};

const deserializeAws_json1_1DescribeConnectionsResponse = (
  output: any,
  context: __SerdeContext
): DescribeConnectionsResponse => {
  let contents: any = {
    __type: "DescribeConnectionsResponse",
    Connections: undefined,
    Marker: undefined
  };
  if (output.Connections !== undefined) {
    contents.Connections = deserializeAws_json1_1ConnectionList(
      output.Connections,
      context
    );
  }
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  return contents;
};

const deserializeAws_json1_1DescribeEndpointTypesResponse = (
  output: any,
  context: __SerdeContext
): DescribeEndpointTypesResponse => {
  let contents: any = {
    __type: "DescribeEndpointTypesResponse",
    Marker: undefined,
    SupportedEndpointTypes: undefined
  };
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  if (output.SupportedEndpointTypes !== undefined) {
    contents.SupportedEndpointTypes = deserializeAws_json1_1SupportedEndpointTypeList(
      output.SupportedEndpointTypes,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEndpointsResponse = (
  output: any,
  context: __SerdeContext
): DescribeEndpointsResponse => {
  let contents: any = {
    __type: "DescribeEndpointsResponse",
    Endpoints: undefined,
    Marker: undefined
  };
  if (output.Endpoints !== undefined) {
    contents.Endpoints = deserializeAws_json1_1EndpointList(
      output.Endpoints,
      context
    );
  }
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  return contents;
};

const deserializeAws_json1_1DescribeEventCategoriesResponse = (
  output: any,
  context: __SerdeContext
): DescribeEventCategoriesResponse => {
  let contents: any = {
    __type: "DescribeEventCategoriesResponse",
    EventCategoryGroupList: undefined
  };
  if (output.EventCategoryGroupList !== undefined) {
    contents.EventCategoryGroupList = deserializeAws_json1_1EventCategoryGroupList(
      output.EventCategoryGroupList,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeEventSubscriptionsResponse = (
  output: any,
  context: __SerdeContext
): DescribeEventSubscriptionsResponse => {
  let contents: any = {
    __type: "DescribeEventSubscriptionsResponse",
    EventSubscriptionsList: undefined,
    Marker: undefined
  };
  if (output.EventSubscriptionsList !== undefined) {
    contents.EventSubscriptionsList = deserializeAws_json1_1EventSubscriptionsList(
      output.EventSubscriptionsList,
      context
    );
  }
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  return contents;
};

const deserializeAws_json1_1DescribeEventsResponse = (
  output: any,
  context: __SerdeContext
): DescribeEventsResponse => {
  let contents: any = {
    __type: "DescribeEventsResponse",
    Events: undefined,
    Marker: undefined
  };
  if (output.Events !== undefined) {
    contents.Events = deserializeAws_json1_1EventList(output.Events, context);
  }
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  return contents;
};

const deserializeAws_json1_1DescribeOrderableReplicationInstancesResponse = (
  output: any,
  context: __SerdeContext
): DescribeOrderableReplicationInstancesResponse => {
  let contents: any = {
    __type: "DescribeOrderableReplicationInstancesResponse",
    Marker: undefined,
    OrderableReplicationInstances: undefined
  };
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  if (output.OrderableReplicationInstances !== undefined) {
    contents.OrderableReplicationInstances = deserializeAws_json1_1OrderableReplicationInstanceList(
      output.OrderableReplicationInstances,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribePendingMaintenanceActionsResponse = (
  output: any,
  context: __SerdeContext
): DescribePendingMaintenanceActionsResponse => {
  let contents: any = {
    __type: "DescribePendingMaintenanceActionsResponse",
    Marker: undefined,
    PendingMaintenanceActions: undefined
  };
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  if (output.PendingMaintenanceActions !== undefined) {
    contents.PendingMaintenanceActions = deserializeAws_json1_1PendingMaintenanceActions(
      output.PendingMaintenanceActions,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeRefreshSchemasStatusResponse = (
  output: any,
  context: __SerdeContext
): DescribeRefreshSchemasStatusResponse => {
  let contents: any = {
    __type: "DescribeRefreshSchemasStatusResponse",
    RefreshSchemasStatus: undefined
  };
  if (output.RefreshSchemasStatus !== undefined) {
    contents.RefreshSchemasStatus = deserializeAws_json1_1RefreshSchemasStatus(
      output.RefreshSchemasStatus,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeReplicationInstanceTaskLogsResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationInstanceTaskLogsResponse => {
  let contents: any = {
    __type: "DescribeReplicationInstanceTaskLogsResponse",
    Marker: undefined,
    ReplicationInstanceArn: undefined,
    ReplicationInstanceTaskLogs: undefined
  };
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  if (output.ReplicationInstanceArn !== undefined) {
    contents.ReplicationInstanceArn = output.ReplicationInstanceArn;
  }
  if (output.ReplicationInstanceTaskLogs !== undefined) {
    contents.ReplicationInstanceTaskLogs = deserializeAws_json1_1ReplicationInstanceTaskLogsList(
      output.ReplicationInstanceTaskLogs,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeReplicationInstancesResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationInstancesResponse => {
  let contents: any = {
    __type: "DescribeReplicationInstancesResponse",
    Marker: undefined,
    ReplicationInstances: undefined
  };
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  if (output.ReplicationInstances !== undefined) {
    contents.ReplicationInstances = deserializeAws_json1_1ReplicationInstanceList(
      output.ReplicationInstances,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeReplicationSubnetGroupsResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationSubnetGroupsResponse => {
  let contents: any = {
    __type: "DescribeReplicationSubnetGroupsResponse",
    Marker: undefined,
    ReplicationSubnetGroups: undefined
  };
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  if (output.ReplicationSubnetGroups !== undefined) {
    contents.ReplicationSubnetGroups = deserializeAws_json1_1ReplicationSubnetGroups(
      output.ReplicationSubnetGroups,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationTaskAssessmentResultsResponse => {
  let contents: any = {
    __type: "DescribeReplicationTaskAssessmentResultsResponse",
    BucketName: undefined,
    Marker: undefined,
    ReplicationTaskAssessmentResults: undefined
  };
  if (output.BucketName !== undefined) {
    contents.BucketName = output.BucketName;
  }
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  if (output.ReplicationTaskAssessmentResults !== undefined) {
    contents.ReplicationTaskAssessmentResults = deserializeAws_json1_1ReplicationTaskAssessmentResultList(
      output.ReplicationTaskAssessmentResults,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeReplicationTasksResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationTasksResponse => {
  let contents: any = {
    __type: "DescribeReplicationTasksResponse",
    Marker: undefined,
    ReplicationTasks: undefined
  };
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  if (output.ReplicationTasks !== undefined) {
    contents.ReplicationTasks = deserializeAws_json1_1ReplicationTaskList(
      output.ReplicationTasks,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeSchemasResponse = (
  output: any,
  context: __SerdeContext
): DescribeSchemasResponse => {
  let contents: any = {
    __type: "DescribeSchemasResponse",
    Marker: undefined,
    Schemas: undefined
  };
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  if (output.Schemas !== undefined) {
    contents.Schemas = deserializeAws_json1_1SchemaList(
      output.Schemas,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DescribeTableStatisticsResponse = (
  output: any,
  context: __SerdeContext
): DescribeTableStatisticsResponse => {
  let contents: any = {
    __type: "DescribeTableStatisticsResponse",
    Marker: undefined,
    ReplicationTaskArn: undefined,
    TableStatistics: undefined
  };
  if (output.Marker !== undefined) {
    contents.Marker = output.Marker;
  }
  if (output.ReplicationTaskArn !== undefined) {
    contents.ReplicationTaskArn = output.ReplicationTaskArn;
  }
  if (output.TableStatistics !== undefined) {
    contents.TableStatistics = deserializeAws_json1_1TableStatisticsList(
      output.TableStatistics,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1DmsTransferSettings = (
  output: any,
  context: __SerdeContext
): DmsTransferSettings => {
  let contents: any = {
    __type: "DmsTransferSettings",
    BucketName: undefined,
    ServiceAccessRoleArn: undefined
  };
  if (output.BucketName !== undefined) {
    contents.BucketName = output.BucketName;
  }
  if (output.ServiceAccessRoleArn !== undefined) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  return contents;
};

const deserializeAws_json1_1DynamoDbSettings = (
  output: any,
  context: __SerdeContext
): DynamoDbSettings => {
  let contents: any = {
    __type: "DynamoDbSettings",
    ServiceAccessRoleArn: undefined
  };
  if (output.ServiceAccessRoleArn !== undefined) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  return contents;
};

const deserializeAws_json1_1ElasticsearchSettings = (
  output: any,
  context: __SerdeContext
): ElasticsearchSettings => {
  let contents: any = {
    __type: "ElasticsearchSettings",
    EndpointUri: undefined,
    ErrorRetryDuration: undefined,
    FullLoadErrorPercentage: undefined,
    ServiceAccessRoleArn: undefined
  };
  if (output.EndpointUri !== undefined) {
    contents.EndpointUri = output.EndpointUri;
  }
  if (output.ErrorRetryDuration !== undefined) {
    contents.ErrorRetryDuration = output.ErrorRetryDuration;
  }
  if (output.FullLoadErrorPercentage !== undefined) {
    contents.FullLoadErrorPercentage = output.FullLoadErrorPercentage;
  }
  if (output.ServiceAccessRoleArn !== undefined) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  return contents;
};

const deserializeAws_json1_1Endpoint = (
  output: any,
  context: __SerdeContext
): Endpoint => {
  let contents: any = {
    __type: "Endpoint",
    CertificateArn: undefined,
    DatabaseName: undefined,
    DmsTransferSettings: undefined,
    DynamoDbSettings: undefined,
    ElasticsearchSettings: undefined,
    EndpointArn: undefined,
    EndpointIdentifier: undefined,
    EndpointType: undefined,
    EngineDisplayName: undefined,
    EngineName: undefined,
    ExternalId: undefined,
    ExternalTableDefinition: undefined,
    ExtraConnectionAttributes: undefined,
    KinesisSettings: undefined,
    KmsKeyId: undefined,
    MongoDbSettings: undefined,
    Port: undefined,
    RedshiftSettings: undefined,
    S3Settings: undefined,
    ServerName: undefined,
    ServiceAccessRoleArn: undefined,
    SslMode: undefined,
    Status: undefined,
    Username: undefined
  };
  if (output.CertificateArn !== undefined) {
    contents.CertificateArn = output.CertificateArn;
  }
  if (output.DatabaseName !== undefined) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (output.DmsTransferSettings !== undefined) {
    contents.DmsTransferSettings = deserializeAws_json1_1DmsTransferSettings(
      output.DmsTransferSettings,
      context
    );
  }
  if (output.DynamoDbSettings !== undefined) {
    contents.DynamoDbSettings = deserializeAws_json1_1DynamoDbSettings(
      output.DynamoDbSettings,
      context
    );
  }
  if (output.ElasticsearchSettings !== undefined) {
    contents.ElasticsearchSettings = deserializeAws_json1_1ElasticsearchSettings(
      output.ElasticsearchSettings,
      context
    );
  }
  if (output.EndpointArn !== undefined) {
    contents.EndpointArn = output.EndpointArn;
  }
  if (output.EndpointIdentifier !== undefined) {
    contents.EndpointIdentifier = output.EndpointIdentifier;
  }
  if (output.EndpointType !== undefined) {
    contents.EndpointType = output.EndpointType;
  }
  if (output.EngineDisplayName !== undefined) {
    contents.EngineDisplayName = output.EngineDisplayName;
  }
  if (output.EngineName !== undefined) {
    contents.EngineName = output.EngineName;
  }
  if (output.ExternalId !== undefined) {
    contents.ExternalId = output.ExternalId;
  }
  if (output.ExternalTableDefinition !== undefined) {
    contents.ExternalTableDefinition = output.ExternalTableDefinition;
  }
  if (output.ExtraConnectionAttributes !== undefined) {
    contents.ExtraConnectionAttributes = output.ExtraConnectionAttributes;
  }
  if (output.KinesisSettings !== undefined) {
    contents.KinesisSettings = deserializeAws_json1_1KinesisSettings(
      output.KinesisSettings,
      context
    );
  }
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.MongoDbSettings !== undefined) {
    contents.MongoDbSettings = deserializeAws_json1_1MongoDbSettings(
      output.MongoDbSettings,
      context
    );
  }
  if (output.Port !== undefined) {
    contents.Port = output.Port;
  }
  if (output.RedshiftSettings !== undefined) {
    contents.RedshiftSettings = deserializeAws_json1_1RedshiftSettings(
      output.RedshiftSettings,
      context
    );
  }
  if (output.S3Settings !== undefined) {
    contents.S3Settings = deserializeAws_json1_1S3Settings(
      output.S3Settings,
      context
    );
  }
  if (output.ServerName !== undefined) {
    contents.ServerName = output.ServerName;
  }
  if (output.ServiceAccessRoleArn !== undefined) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  if (output.SslMode !== undefined) {
    contents.SslMode = output.SslMode;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.Username !== undefined) {
    contents.Username = output.Username;
  }
  return contents;
};

const deserializeAws_json1_1EndpointList = (
  output: any,
  context: __SerdeContext
): Array<Endpoint> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Endpoint(entry, context)
  );
};

const deserializeAws_json1_1Event = (
  output: any,
  context: __SerdeContext
): Event => {
  let contents: any = {
    __type: "Event",
    Date: undefined,
    EventCategories: undefined,
    Message: undefined,
    SourceIdentifier: undefined,
    SourceType: undefined
  };
  if (output.Date !== undefined) {
    contents.Date = new Date(
      output.Date % 1 != 0 ? Math.round(output.Date * 1000) : output.Date
    );
  }
  if (output.EventCategories !== undefined) {
    contents.EventCategories = deserializeAws_json1_1EventCategoriesList(
      output.EventCategories,
      context
    );
  }
  if (output.Message !== undefined) {
    contents.Message = output.Message;
  }
  if (output.SourceIdentifier !== undefined) {
    contents.SourceIdentifier = output.SourceIdentifier;
  }
  if (output.SourceType !== undefined) {
    contents.SourceType = output.SourceType;
  }
  return contents;
};

const deserializeAws_json1_1EventCategoriesList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1EventCategoryGroup = (
  output: any,
  context: __SerdeContext
): EventCategoryGroup => {
  let contents: any = {
    __type: "EventCategoryGroup",
    EventCategories: undefined,
    SourceType: undefined
  };
  if (output.EventCategories !== undefined) {
    contents.EventCategories = deserializeAws_json1_1EventCategoriesList(
      output.EventCategories,
      context
    );
  }
  if (output.SourceType !== undefined) {
    contents.SourceType = output.SourceType;
  }
  return contents;
};

const deserializeAws_json1_1EventCategoryGroupList = (
  output: any,
  context: __SerdeContext
): Array<EventCategoryGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EventCategoryGroup(entry, context)
  );
};

const deserializeAws_json1_1EventList = (
  output: any,
  context: __SerdeContext
): Array<Event> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Event(entry, context)
  );
};

const deserializeAws_json1_1EventSubscription = (
  output: any,
  context: __SerdeContext
): EventSubscription => {
  let contents: any = {
    __type: "EventSubscription",
    CustSubscriptionId: undefined,
    CustomerAwsId: undefined,
    Enabled: undefined,
    EventCategoriesList: undefined,
    SnsTopicArn: undefined,
    SourceIdsList: undefined,
    SourceType: undefined,
    Status: undefined,
    SubscriptionCreationTime: undefined
  };
  if (output.CustSubscriptionId !== undefined) {
    contents.CustSubscriptionId = output.CustSubscriptionId;
  }
  if (output.CustomerAwsId !== undefined) {
    contents.CustomerAwsId = output.CustomerAwsId;
  }
  if (output.Enabled !== undefined) {
    contents.Enabled = output.Enabled;
  }
  if (output.EventCategoriesList !== undefined) {
    contents.EventCategoriesList = deserializeAws_json1_1EventCategoriesList(
      output.EventCategoriesList,
      context
    );
  }
  if (output.SnsTopicArn !== undefined) {
    contents.SnsTopicArn = output.SnsTopicArn;
  }
  if (output.SourceIdsList !== undefined) {
    contents.SourceIdsList = deserializeAws_json1_1SourceIdsList(
      output.SourceIdsList,
      context
    );
  }
  if (output.SourceType !== undefined) {
    contents.SourceType = output.SourceType;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.SubscriptionCreationTime !== undefined) {
    contents.SubscriptionCreationTime = output.SubscriptionCreationTime;
  }
  return contents;
};

const deserializeAws_json1_1EventSubscriptionsList = (
  output: any,
  context: __SerdeContext
): Array<EventSubscription> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EventSubscription(entry, context)
  );
};

const deserializeAws_json1_1ImportCertificateResponse = (
  output: any,
  context: __SerdeContext
): ImportCertificateResponse => {
  let contents: any = {
    __type: "ImportCertificateResponse",
    Certificate: undefined
  };
  if (output.Certificate !== undefined) {
    contents.Certificate = deserializeAws_json1_1Certificate(
      output.Certificate,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1KinesisSettings = (
  output: any,
  context: __SerdeContext
): KinesisSettings => {
  let contents: any = {
    __type: "KinesisSettings",
    MessageFormat: undefined,
    ServiceAccessRoleArn: undefined,
    StreamArn: undefined
  };
  if (output.MessageFormat !== undefined) {
    contents.MessageFormat = output.MessageFormat;
  }
  if (output.ServiceAccessRoleArn !== undefined) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  if (output.StreamArn !== undefined) {
    contents.StreamArn = output.StreamArn;
  }
  return contents;
};

const deserializeAws_json1_1ListTagsForResourceResponse = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceResponse => {
  let contents: any = {
    __type: "ListTagsForResourceResponse",
    TagList: undefined
  };
  if (output.TagList !== undefined) {
    contents.TagList = deserializeAws_json1_1TagList(output.TagList, context);
  }
  return contents;
};

const deserializeAws_json1_1ModifyEndpointResponse = (
  output: any,
  context: __SerdeContext
): ModifyEndpointResponse => {
  let contents: any = {
    __type: "ModifyEndpointResponse",
    Endpoint: undefined
  };
  if (output.Endpoint !== undefined) {
    contents.Endpoint = deserializeAws_json1_1Endpoint(
      output.Endpoint,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ModifyEventSubscriptionResponse = (
  output: any,
  context: __SerdeContext
): ModifyEventSubscriptionResponse => {
  let contents: any = {
    __type: "ModifyEventSubscriptionResponse",
    EventSubscription: undefined
  };
  if (output.EventSubscription !== undefined) {
    contents.EventSubscription = deserializeAws_json1_1EventSubscription(
      output.EventSubscription,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ModifyReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): ModifyReplicationInstanceResponse => {
  let contents: any = {
    __type: "ModifyReplicationInstanceResponse",
    ReplicationInstance: undefined
  };
  if (output.ReplicationInstance !== undefined) {
    contents.ReplicationInstance = deserializeAws_json1_1ReplicationInstance(
      output.ReplicationInstance,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ModifyReplicationSubnetGroupResponse = (
  output: any,
  context: __SerdeContext
): ModifyReplicationSubnetGroupResponse => {
  let contents: any = {
    __type: "ModifyReplicationSubnetGroupResponse",
    ReplicationSubnetGroup: undefined
  };
  if (output.ReplicationSubnetGroup !== undefined) {
    contents.ReplicationSubnetGroup = deserializeAws_json1_1ReplicationSubnetGroup(
      output.ReplicationSubnetGroup,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ModifyReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): ModifyReplicationTaskResponse => {
  let contents: any = {
    __type: "ModifyReplicationTaskResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1MongoDbSettings = (
  output: any,
  context: __SerdeContext
): MongoDbSettings => {
  let contents: any = {
    __type: "MongoDbSettings",
    AuthMechanism: undefined,
    AuthSource: undefined,
    AuthType: undefined,
    DatabaseName: undefined,
    DocsToInvestigate: undefined,
    ExtractDocId: undefined,
    KmsKeyId: undefined,
    NestingLevel: undefined,
    Password: undefined,
    Port: undefined,
    ServerName: undefined,
    Username: undefined
  };
  if (output.AuthMechanism !== undefined) {
    contents.AuthMechanism = output.AuthMechanism;
  }
  if (output.AuthSource !== undefined) {
    contents.AuthSource = output.AuthSource;
  }
  if (output.AuthType !== undefined) {
    contents.AuthType = output.AuthType;
  }
  if (output.DatabaseName !== undefined) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (output.DocsToInvestigate !== undefined) {
    contents.DocsToInvestigate = output.DocsToInvestigate;
  }
  if (output.ExtractDocId !== undefined) {
    contents.ExtractDocId = output.ExtractDocId;
  }
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.NestingLevel !== undefined) {
    contents.NestingLevel = output.NestingLevel;
  }
  if (output.Password !== undefined) {
    contents.Password = output.Password;
  }
  if (output.Port !== undefined) {
    contents.Port = output.Port;
  }
  if (output.ServerName !== undefined) {
    contents.ServerName = output.ServerName;
  }
  if (output.Username !== undefined) {
    contents.Username = output.Username;
  }
  return contents;
};

const deserializeAws_json1_1OrderableReplicationInstance = (
  output: any,
  context: __SerdeContext
): OrderableReplicationInstance => {
  let contents: any = {
    __type: "OrderableReplicationInstance",
    AvailabilityZones: undefined,
    DefaultAllocatedStorage: undefined,
    EngineVersion: undefined,
    IncludedAllocatedStorage: undefined,
    MaxAllocatedStorage: undefined,
    MinAllocatedStorage: undefined,
    ReleaseStatus: undefined,
    ReplicationInstanceClass: undefined,
    StorageType: undefined
  };
  if (output.AvailabilityZones !== undefined) {
    contents.AvailabilityZones = deserializeAws_json1_1AvailabilityZonesList(
      output.AvailabilityZones,
      context
    );
  }
  if (output.DefaultAllocatedStorage !== undefined) {
    contents.DefaultAllocatedStorage = output.DefaultAllocatedStorage;
  }
  if (output.EngineVersion !== undefined) {
    contents.EngineVersion = output.EngineVersion;
  }
  if (output.IncludedAllocatedStorage !== undefined) {
    contents.IncludedAllocatedStorage = output.IncludedAllocatedStorage;
  }
  if (output.MaxAllocatedStorage !== undefined) {
    contents.MaxAllocatedStorage = output.MaxAllocatedStorage;
  }
  if (output.MinAllocatedStorage !== undefined) {
    contents.MinAllocatedStorage = output.MinAllocatedStorage;
  }
  if (output.ReleaseStatus !== undefined) {
    contents.ReleaseStatus = output.ReleaseStatus;
  }
  if (output.ReplicationInstanceClass !== undefined) {
    contents.ReplicationInstanceClass = output.ReplicationInstanceClass;
  }
  if (output.StorageType !== undefined) {
    contents.StorageType = output.StorageType;
  }
  return contents;
};

const deserializeAws_json1_1OrderableReplicationInstanceList = (
  output: any,
  context: __SerdeContext
): Array<OrderableReplicationInstance> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1OrderableReplicationInstance(entry, context)
  );
};

const deserializeAws_json1_1PendingMaintenanceAction = (
  output: any,
  context: __SerdeContext
): PendingMaintenanceAction => {
  let contents: any = {
    __type: "PendingMaintenanceAction",
    Action: undefined,
    AutoAppliedAfterDate: undefined,
    CurrentApplyDate: undefined,
    Description: undefined,
    ForcedApplyDate: undefined,
    OptInStatus: undefined
  };
  if (output.Action !== undefined) {
    contents.Action = output.Action;
  }
  if (output.AutoAppliedAfterDate !== undefined) {
    contents.AutoAppliedAfterDate = new Date(
      output.AutoAppliedAfterDate % 1 != 0
        ? Math.round(output.AutoAppliedAfterDate * 1000)
        : output.AutoAppliedAfterDate
    );
  }
  if (output.CurrentApplyDate !== undefined) {
    contents.CurrentApplyDate = new Date(
      output.CurrentApplyDate % 1 != 0
        ? Math.round(output.CurrentApplyDate * 1000)
        : output.CurrentApplyDate
    );
  }
  if (output.Description !== undefined) {
    contents.Description = output.Description;
  }
  if (output.ForcedApplyDate !== undefined) {
    contents.ForcedApplyDate = new Date(
      output.ForcedApplyDate % 1 != 0
        ? Math.round(output.ForcedApplyDate * 1000)
        : output.ForcedApplyDate
    );
  }
  if (output.OptInStatus !== undefined) {
    contents.OptInStatus = output.OptInStatus;
  }
  return contents;
};

const deserializeAws_json1_1PendingMaintenanceActionDetails = (
  output: any,
  context: __SerdeContext
): Array<PendingMaintenanceAction> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PendingMaintenanceAction(entry, context)
  );
};

const deserializeAws_json1_1PendingMaintenanceActions = (
  output: any,
  context: __SerdeContext
): Array<ResourcePendingMaintenanceActions> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ResourcePendingMaintenanceActions(entry, context)
  );
};

const deserializeAws_json1_1RebootReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): RebootReplicationInstanceResponse => {
  let contents: any = {
    __type: "RebootReplicationInstanceResponse",
    ReplicationInstance: undefined
  };
  if (output.ReplicationInstance !== undefined) {
    contents.ReplicationInstance = deserializeAws_json1_1ReplicationInstance(
      output.ReplicationInstance,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1RedshiftSettings = (
  output: any,
  context: __SerdeContext
): RedshiftSettings => {
  let contents: any = {
    __type: "RedshiftSettings",
    AcceptAnyDate: undefined,
    AfterConnectScript: undefined,
    BucketFolder: undefined,
    BucketName: undefined,
    ConnectionTimeout: undefined,
    DatabaseName: undefined,
    DateFormat: undefined,
    EmptyAsNull: undefined,
    EncryptionMode: undefined,
    FileTransferUploadStreams: undefined,
    LoadTimeout: undefined,
    MaxFileSize: undefined,
    Password: undefined,
    Port: undefined,
    RemoveQuotes: undefined,
    ReplaceChars: undefined,
    ReplaceInvalidChars: undefined,
    ServerName: undefined,
    ServerSideEncryptionKmsKeyId: undefined,
    ServiceAccessRoleArn: undefined,
    TimeFormat: undefined,
    TrimBlanks: undefined,
    TruncateColumns: undefined,
    Username: undefined,
    WriteBufferSize: undefined
  };
  if (output.AcceptAnyDate !== undefined) {
    contents.AcceptAnyDate = output.AcceptAnyDate;
  }
  if (output.AfterConnectScript !== undefined) {
    contents.AfterConnectScript = output.AfterConnectScript;
  }
  if (output.BucketFolder !== undefined) {
    contents.BucketFolder = output.BucketFolder;
  }
  if (output.BucketName !== undefined) {
    contents.BucketName = output.BucketName;
  }
  if (output.ConnectionTimeout !== undefined) {
    contents.ConnectionTimeout = output.ConnectionTimeout;
  }
  if (output.DatabaseName !== undefined) {
    contents.DatabaseName = output.DatabaseName;
  }
  if (output.DateFormat !== undefined) {
    contents.DateFormat = output.DateFormat;
  }
  if (output.EmptyAsNull !== undefined) {
    contents.EmptyAsNull = output.EmptyAsNull;
  }
  if (output.EncryptionMode !== undefined) {
    contents.EncryptionMode = output.EncryptionMode;
  }
  if (output.FileTransferUploadStreams !== undefined) {
    contents.FileTransferUploadStreams = output.FileTransferUploadStreams;
  }
  if (output.LoadTimeout !== undefined) {
    contents.LoadTimeout = output.LoadTimeout;
  }
  if (output.MaxFileSize !== undefined) {
    contents.MaxFileSize = output.MaxFileSize;
  }
  if (output.Password !== undefined) {
    contents.Password = output.Password;
  }
  if (output.Port !== undefined) {
    contents.Port = output.Port;
  }
  if (output.RemoveQuotes !== undefined) {
    contents.RemoveQuotes = output.RemoveQuotes;
  }
  if (output.ReplaceChars !== undefined) {
    contents.ReplaceChars = output.ReplaceChars;
  }
  if (output.ReplaceInvalidChars !== undefined) {
    contents.ReplaceInvalidChars = output.ReplaceInvalidChars;
  }
  if (output.ServerName !== undefined) {
    contents.ServerName = output.ServerName;
  }
  if (output.ServerSideEncryptionKmsKeyId !== undefined) {
    contents.ServerSideEncryptionKmsKeyId = output.ServerSideEncryptionKmsKeyId;
  }
  if (output.ServiceAccessRoleArn !== undefined) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  if (output.TimeFormat !== undefined) {
    contents.TimeFormat = output.TimeFormat;
  }
  if (output.TrimBlanks !== undefined) {
    contents.TrimBlanks = output.TrimBlanks;
  }
  if (output.TruncateColumns !== undefined) {
    contents.TruncateColumns = output.TruncateColumns;
  }
  if (output.Username !== undefined) {
    contents.Username = output.Username;
  }
  if (output.WriteBufferSize !== undefined) {
    contents.WriteBufferSize = output.WriteBufferSize;
  }
  return contents;
};

const deserializeAws_json1_1RefreshSchemasResponse = (
  output: any,
  context: __SerdeContext
): RefreshSchemasResponse => {
  let contents: any = {
    __type: "RefreshSchemasResponse",
    RefreshSchemasStatus: undefined
  };
  if (output.RefreshSchemasStatus !== undefined) {
    contents.RefreshSchemasStatus = deserializeAws_json1_1RefreshSchemasStatus(
      output.RefreshSchemasStatus,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1RefreshSchemasStatus = (
  output: any,
  context: __SerdeContext
): RefreshSchemasStatus => {
  let contents: any = {
    __type: "RefreshSchemasStatus",
    EndpointArn: undefined,
    LastFailureMessage: undefined,
    LastRefreshDate: undefined,
    ReplicationInstanceArn: undefined,
    Status: undefined
  };
  if (output.EndpointArn !== undefined) {
    contents.EndpointArn = output.EndpointArn;
  }
  if (output.LastFailureMessage !== undefined) {
    contents.LastFailureMessage = output.LastFailureMessage;
  }
  if (output.LastRefreshDate !== undefined) {
    contents.LastRefreshDate = new Date(
      output.LastRefreshDate % 1 != 0
        ? Math.round(output.LastRefreshDate * 1000)
        : output.LastRefreshDate
    );
  }
  if (output.ReplicationInstanceArn !== undefined) {
    contents.ReplicationInstanceArn = output.ReplicationInstanceArn;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  return contents;
};

const deserializeAws_json1_1ReloadTablesResponse = (
  output: any,
  context: __SerdeContext
): ReloadTablesResponse => {
  let contents: any = {
    __type: "ReloadTablesResponse",
    ReplicationTaskArn: undefined
  };
  if (output.ReplicationTaskArn !== undefined) {
    contents.ReplicationTaskArn = output.ReplicationTaskArn;
  }
  return contents;
};

const deserializeAws_json1_1RemoveTagsFromResourceResponse = (
  output: any,
  context: __SerdeContext
): RemoveTagsFromResourceResponse => {
  let contents: any = {
    __type: "RemoveTagsFromResourceResponse"
  };
  return contents;
};

const deserializeAws_json1_1ReplicationInstance = (
  output: any,
  context: __SerdeContext
): ReplicationInstance => {
  let contents: any = {
    __type: "ReplicationInstance",
    AllocatedStorage: undefined,
    AutoMinorVersionUpgrade: undefined,
    AvailabilityZone: undefined,
    DnsNameServers: undefined,
    EngineVersion: undefined,
    FreeUntil: undefined,
    InstanceCreateTime: undefined,
    KmsKeyId: undefined,
    MultiAZ: undefined,
    PendingModifiedValues: undefined,
    PreferredMaintenanceWindow: undefined,
    PubliclyAccessible: undefined,
    ReplicationInstanceArn: undefined,
    ReplicationInstanceClass: undefined,
    ReplicationInstanceIdentifier: undefined,
    ReplicationInstancePrivateIpAddress: undefined,
    ReplicationInstancePrivateIpAddresses: undefined,
    ReplicationInstancePublicIpAddress: undefined,
    ReplicationInstancePublicIpAddresses: undefined,
    ReplicationInstanceStatus: undefined,
    ReplicationSubnetGroup: undefined,
    SecondaryAvailabilityZone: undefined,
    VpcSecurityGroups: undefined
  };
  if (output.AllocatedStorage !== undefined) {
    contents.AllocatedStorage = output.AllocatedStorage;
  }
  if (output.AutoMinorVersionUpgrade !== undefined) {
    contents.AutoMinorVersionUpgrade = output.AutoMinorVersionUpgrade;
  }
  if (output.AvailabilityZone !== undefined) {
    contents.AvailabilityZone = output.AvailabilityZone;
  }
  if (output.DnsNameServers !== undefined) {
    contents.DnsNameServers = output.DnsNameServers;
  }
  if (output.EngineVersion !== undefined) {
    contents.EngineVersion = output.EngineVersion;
  }
  if (output.FreeUntil !== undefined) {
    contents.FreeUntil = new Date(
      output.FreeUntil % 1 != 0
        ? Math.round(output.FreeUntil * 1000)
        : output.FreeUntil
    );
  }
  if (output.InstanceCreateTime !== undefined) {
    contents.InstanceCreateTime = new Date(
      output.InstanceCreateTime % 1 != 0
        ? Math.round(output.InstanceCreateTime * 1000)
        : output.InstanceCreateTime
    );
  }
  if (output.KmsKeyId !== undefined) {
    contents.KmsKeyId = output.KmsKeyId;
  }
  if (output.MultiAZ !== undefined) {
    contents.MultiAZ = output.MultiAZ;
  }
  if (output.PendingModifiedValues !== undefined) {
    contents.PendingModifiedValues = deserializeAws_json1_1ReplicationPendingModifiedValues(
      output.PendingModifiedValues,
      context
    );
  }
  if (output.PreferredMaintenanceWindow !== undefined) {
    contents.PreferredMaintenanceWindow = output.PreferredMaintenanceWindow;
  }
  if (output.PubliclyAccessible !== undefined) {
    contents.PubliclyAccessible = output.PubliclyAccessible;
  }
  if (output.ReplicationInstanceArn !== undefined) {
    contents.ReplicationInstanceArn = output.ReplicationInstanceArn;
  }
  if (output.ReplicationInstanceClass !== undefined) {
    contents.ReplicationInstanceClass = output.ReplicationInstanceClass;
  }
  if (output.ReplicationInstanceIdentifier !== undefined) {
    contents.ReplicationInstanceIdentifier =
      output.ReplicationInstanceIdentifier;
  }
  if (output.ReplicationInstancePrivateIpAddress !== undefined) {
    contents.ReplicationInstancePrivateIpAddress =
      output.ReplicationInstancePrivateIpAddress;
  }
  if (output.ReplicationInstancePrivateIpAddresses !== undefined) {
    contents.ReplicationInstancePrivateIpAddresses = deserializeAws_json1_1ReplicationInstancePrivateIpAddressList(
      output.ReplicationInstancePrivateIpAddresses,
      context
    );
  }
  if (output.ReplicationInstancePublicIpAddress !== undefined) {
    contents.ReplicationInstancePublicIpAddress =
      output.ReplicationInstancePublicIpAddress;
  }
  if (output.ReplicationInstancePublicIpAddresses !== undefined) {
    contents.ReplicationInstancePublicIpAddresses = deserializeAws_json1_1ReplicationInstancePublicIpAddressList(
      output.ReplicationInstancePublicIpAddresses,
      context
    );
  }
  if (output.ReplicationInstanceStatus !== undefined) {
    contents.ReplicationInstanceStatus = output.ReplicationInstanceStatus;
  }
  if (output.ReplicationSubnetGroup !== undefined) {
    contents.ReplicationSubnetGroup = deserializeAws_json1_1ReplicationSubnetGroup(
      output.ReplicationSubnetGroup,
      context
    );
  }
  if (output.SecondaryAvailabilityZone !== undefined) {
    contents.SecondaryAvailabilityZone = output.SecondaryAvailabilityZone;
  }
  if (output.VpcSecurityGroups !== undefined) {
    contents.VpcSecurityGroups = deserializeAws_json1_1VpcSecurityGroupMembershipList(
      output.VpcSecurityGroups,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1ReplicationInstanceList = (
  output: any,
  context: __SerdeContext
): Array<ReplicationInstance> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationInstance(entry, context)
  );
};

const deserializeAws_json1_1ReplicationInstancePrivateIpAddressList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ReplicationInstancePublicIpAddressList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ReplicationInstanceTaskLog = (
  output: any,
  context: __SerdeContext
): ReplicationInstanceTaskLog => {
  let contents: any = {
    __type: "ReplicationInstanceTaskLog",
    ReplicationInstanceTaskLogSize: undefined,
    ReplicationTaskArn: undefined,
    ReplicationTaskName: undefined
  };
  if (output.ReplicationInstanceTaskLogSize !== undefined) {
    contents.ReplicationInstanceTaskLogSize =
      output.ReplicationInstanceTaskLogSize;
  }
  if (output.ReplicationTaskArn !== undefined) {
    contents.ReplicationTaskArn = output.ReplicationTaskArn;
  }
  if (output.ReplicationTaskName !== undefined) {
    contents.ReplicationTaskName = output.ReplicationTaskName;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationInstanceTaskLogsList = (
  output: any,
  context: __SerdeContext
): Array<ReplicationInstanceTaskLog> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationInstanceTaskLog(entry, context)
  );
};

const deserializeAws_json1_1ReplicationPendingModifiedValues = (
  output: any,
  context: __SerdeContext
): ReplicationPendingModifiedValues => {
  let contents: any = {
    __type: "ReplicationPendingModifiedValues",
    AllocatedStorage: undefined,
    EngineVersion: undefined,
    MultiAZ: undefined,
    ReplicationInstanceClass: undefined
  };
  if (output.AllocatedStorage !== undefined) {
    contents.AllocatedStorage = output.AllocatedStorage;
  }
  if (output.EngineVersion !== undefined) {
    contents.EngineVersion = output.EngineVersion;
  }
  if (output.MultiAZ !== undefined) {
    contents.MultiAZ = output.MultiAZ;
  }
  if (output.ReplicationInstanceClass !== undefined) {
    contents.ReplicationInstanceClass = output.ReplicationInstanceClass;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationSubnetGroup = (
  output: any,
  context: __SerdeContext
): ReplicationSubnetGroup => {
  let contents: any = {
    __type: "ReplicationSubnetGroup",
    ReplicationSubnetGroupDescription: undefined,
    ReplicationSubnetGroupIdentifier: undefined,
    SubnetGroupStatus: undefined,
    Subnets: undefined,
    VpcId: undefined
  };
  if (output.ReplicationSubnetGroupDescription !== undefined) {
    contents.ReplicationSubnetGroupDescription =
      output.ReplicationSubnetGroupDescription;
  }
  if (output.ReplicationSubnetGroupIdentifier !== undefined) {
    contents.ReplicationSubnetGroupIdentifier =
      output.ReplicationSubnetGroupIdentifier;
  }
  if (output.SubnetGroupStatus !== undefined) {
    contents.SubnetGroupStatus = output.SubnetGroupStatus;
  }
  if (output.Subnets !== undefined) {
    contents.Subnets = deserializeAws_json1_1SubnetList(
      output.Subnets,
      context
    );
  }
  if (output.VpcId !== undefined) {
    contents.VpcId = output.VpcId;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationSubnetGroups = (
  output: any,
  context: __SerdeContext
): Array<ReplicationSubnetGroup> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationSubnetGroup(entry, context)
  );
};

const deserializeAws_json1_1ReplicationTask = (
  output: any,
  context: __SerdeContext
): ReplicationTask => {
  let contents: any = {
    __type: "ReplicationTask",
    CdcStartPosition: undefined,
    CdcStopPosition: undefined,
    LastFailureMessage: undefined,
    MigrationType: undefined,
    RecoveryCheckpoint: undefined,
    ReplicationInstanceArn: undefined,
    ReplicationTaskArn: undefined,
    ReplicationTaskCreationDate: undefined,
    ReplicationTaskIdentifier: undefined,
    ReplicationTaskSettings: undefined,
    ReplicationTaskStartDate: undefined,
    ReplicationTaskStats: undefined,
    SourceEndpointArn: undefined,
    Status: undefined,
    StopReason: undefined,
    TableMappings: undefined,
    TargetEndpointArn: undefined
  };
  if (output.CdcStartPosition !== undefined) {
    contents.CdcStartPosition = output.CdcStartPosition;
  }
  if (output.CdcStopPosition !== undefined) {
    contents.CdcStopPosition = output.CdcStopPosition;
  }
  if (output.LastFailureMessage !== undefined) {
    contents.LastFailureMessage = output.LastFailureMessage;
  }
  if (output.MigrationType !== undefined) {
    contents.MigrationType = output.MigrationType;
  }
  if (output.RecoveryCheckpoint !== undefined) {
    contents.RecoveryCheckpoint = output.RecoveryCheckpoint;
  }
  if (output.ReplicationInstanceArn !== undefined) {
    contents.ReplicationInstanceArn = output.ReplicationInstanceArn;
  }
  if (output.ReplicationTaskArn !== undefined) {
    contents.ReplicationTaskArn = output.ReplicationTaskArn;
  }
  if (output.ReplicationTaskCreationDate !== undefined) {
    contents.ReplicationTaskCreationDate = new Date(
      output.ReplicationTaskCreationDate % 1 != 0
        ? Math.round(output.ReplicationTaskCreationDate * 1000)
        : output.ReplicationTaskCreationDate
    );
  }
  if (output.ReplicationTaskIdentifier !== undefined) {
    contents.ReplicationTaskIdentifier = output.ReplicationTaskIdentifier;
  }
  if (output.ReplicationTaskSettings !== undefined) {
    contents.ReplicationTaskSettings = output.ReplicationTaskSettings;
  }
  if (output.ReplicationTaskStartDate !== undefined) {
    contents.ReplicationTaskStartDate = new Date(
      output.ReplicationTaskStartDate % 1 != 0
        ? Math.round(output.ReplicationTaskStartDate * 1000)
        : output.ReplicationTaskStartDate
    );
  }
  if (output.ReplicationTaskStats !== undefined) {
    contents.ReplicationTaskStats = deserializeAws_json1_1ReplicationTaskStats(
      output.ReplicationTaskStats,
      context
    );
  }
  if (output.SourceEndpointArn !== undefined) {
    contents.SourceEndpointArn = output.SourceEndpointArn;
  }
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.StopReason !== undefined) {
    contents.StopReason = output.StopReason;
  }
  if (output.TableMappings !== undefined) {
    contents.TableMappings = output.TableMappings;
  }
  if (output.TargetEndpointArn !== undefined) {
    contents.TargetEndpointArn = output.TargetEndpointArn;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationTaskAssessmentResult = (
  output: any,
  context: __SerdeContext
): ReplicationTaskAssessmentResult => {
  let contents: any = {
    __type: "ReplicationTaskAssessmentResult",
    AssessmentResults: undefined,
    AssessmentResultsFile: undefined,
    AssessmentStatus: undefined,
    ReplicationTaskArn: undefined,
    ReplicationTaskIdentifier: undefined,
    ReplicationTaskLastAssessmentDate: undefined,
    S3ObjectUrl: undefined
  };
  if (output.AssessmentResults !== undefined) {
    contents.AssessmentResults = output.AssessmentResults;
  }
  if (output.AssessmentResultsFile !== undefined) {
    contents.AssessmentResultsFile = output.AssessmentResultsFile;
  }
  if (output.AssessmentStatus !== undefined) {
    contents.AssessmentStatus = output.AssessmentStatus;
  }
  if (output.ReplicationTaskArn !== undefined) {
    contents.ReplicationTaskArn = output.ReplicationTaskArn;
  }
  if (output.ReplicationTaskIdentifier !== undefined) {
    contents.ReplicationTaskIdentifier = output.ReplicationTaskIdentifier;
  }
  if (output.ReplicationTaskLastAssessmentDate !== undefined) {
    contents.ReplicationTaskLastAssessmentDate = new Date(
      output.ReplicationTaskLastAssessmentDate % 1 != 0
        ? Math.round(output.ReplicationTaskLastAssessmentDate * 1000)
        : output.ReplicationTaskLastAssessmentDate
    );
  }
  if (output.S3ObjectUrl !== undefined) {
    contents.S3ObjectUrl = output.S3ObjectUrl;
  }
  return contents;
};

const deserializeAws_json1_1ReplicationTaskAssessmentResultList = (
  output: any,
  context: __SerdeContext
): Array<ReplicationTaskAssessmentResult> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationTaskAssessmentResult(entry, context)
  );
};

const deserializeAws_json1_1ReplicationTaskList = (
  output: any,
  context: __SerdeContext
): Array<ReplicationTask> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationTask(entry, context)
  );
};

const deserializeAws_json1_1ReplicationTaskStats = (
  output: any,
  context: __SerdeContext
): ReplicationTaskStats => {
  let contents: any = {
    __type: "ReplicationTaskStats",
    ElapsedTimeMillis: undefined,
    FreshStartDate: undefined,
    FullLoadFinishDate: undefined,
    FullLoadProgressPercent: undefined,
    FullLoadStartDate: undefined,
    StartDate: undefined,
    StopDate: undefined,
    TablesErrored: undefined,
    TablesLoaded: undefined,
    TablesLoading: undefined,
    TablesQueued: undefined
  };
  if (output.ElapsedTimeMillis !== undefined) {
    contents.ElapsedTimeMillis = output.ElapsedTimeMillis;
  }
  if (output.FreshStartDate !== undefined) {
    contents.FreshStartDate = new Date(
      output.FreshStartDate % 1 != 0
        ? Math.round(output.FreshStartDate * 1000)
        : output.FreshStartDate
    );
  }
  if (output.FullLoadFinishDate !== undefined) {
    contents.FullLoadFinishDate = new Date(
      output.FullLoadFinishDate % 1 != 0
        ? Math.round(output.FullLoadFinishDate * 1000)
        : output.FullLoadFinishDate
    );
  }
  if (output.FullLoadProgressPercent !== undefined) {
    contents.FullLoadProgressPercent = output.FullLoadProgressPercent;
  }
  if (output.FullLoadStartDate !== undefined) {
    contents.FullLoadStartDate = new Date(
      output.FullLoadStartDate % 1 != 0
        ? Math.round(output.FullLoadStartDate * 1000)
        : output.FullLoadStartDate
    );
  }
  if (output.StartDate !== undefined) {
    contents.StartDate = new Date(
      output.StartDate % 1 != 0
        ? Math.round(output.StartDate * 1000)
        : output.StartDate
    );
  }
  if (output.StopDate !== undefined) {
    contents.StopDate = new Date(
      output.StopDate % 1 != 0
        ? Math.round(output.StopDate * 1000)
        : output.StopDate
    );
  }
  if (output.TablesErrored !== undefined) {
    contents.TablesErrored = output.TablesErrored;
  }
  if (output.TablesLoaded !== undefined) {
    contents.TablesLoaded = output.TablesLoaded;
  }
  if (output.TablesLoading !== undefined) {
    contents.TablesLoading = output.TablesLoading;
  }
  if (output.TablesQueued !== undefined) {
    contents.TablesQueued = output.TablesQueued;
  }
  return contents;
};

const deserializeAws_json1_1ResourcePendingMaintenanceActions = (
  output: any,
  context: __SerdeContext
): ResourcePendingMaintenanceActions => {
  let contents: any = {
    __type: "ResourcePendingMaintenanceActions",
    PendingMaintenanceActionDetails: undefined,
    ResourceIdentifier: undefined
  };
  if (output.PendingMaintenanceActionDetails !== undefined) {
    contents.PendingMaintenanceActionDetails = deserializeAws_json1_1PendingMaintenanceActionDetails(
      output.PendingMaintenanceActionDetails,
      context
    );
  }
  if (output.ResourceIdentifier !== undefined) {
    contents.ResourceIdentifier = output.ResourceIdentifier;
  }
  return contents;
};

const deserializeAws_json1_1S3Settings = (
  output: any,
  context: __SerdeContext
): S3Settings => {
  let contents: any = {
    __type: "S3Settings",
    BucketFolder: undefined,
    BucketName: undefined,
    CdcInsertsOnly: undefined,
    CompressionType: undefined,
    CsvDelimiter: undefined,
    CsvRowDelimiter: undefined,
    DataFormat: undefined,
    DataPageSize: undefined,
    DictPageSizeLimit: undefined,
    EnableStatistics: undefined,
    EncodingType: undefined,
    EncryptionMode: undefined,
    ExternalTableDefinition: undefined,
    IncludeOpForFullLoad: undefined,
    ParquetTimestampInMillisecond: undefined,
    ParquetVersion: undefined,
    RowGroupLength: undefined,
    ServerSideEncryptionKmsKeyId: undefined,
    ServiceAccessRoleArn: undefined,
    TimestampColumnName: undefined
  };
  if (output.BucketFolder !== undefined) {
    contents.BucketFolder = output.BucketFolder;
  }
  if (output.BucketName !== undefined) {
    contents.BucketName = output.BucketName;
  }
  if (output.CdcInsertsOnly !== undefined) {
    contents.CdcInsertsOnly = output.CdcInsertsOnly;
  }
  if (output.CompressionType !== undefined) {
    contents.CompressionType = output.CompressionType;
  }
  if (output.CsvDelimiter !== undefined) {
    contents.CsvDelimiter = output.CsvDelimiter;
  }
  if (output.CsvRowDelimiter !== undefined) {
    contents.CsvRowDelimiter = output.CsvRowDelimiter;
  }
  if (output.DataFormat !== undefined) {
    contents.DataFormat = output.DataFormat;
  }
  if (output.DataPageSize !== undefined) {
    contents.DataPageSize = output.DataPageSize;
  }
  if (output.DictPageSizeLimit !== undefined) {
    contents.DictPageSizeLimit = output.DictPageSizeLimit;
  }
  if (output.EnableStatistics !== undefined) {
    contents.EnableStatistics = output.EnableStatistics;
  }
  if (output.EncodingType !== undefined) {
    contents.EncodingType = output.EncodingType;
  }
  if (output.EncryptionMode !== undefined) {
    contents.EncryptionMode = output.EncryptionMode;
  }
  if (output.ExternalTableDefinition !== undefined) {
    contents.ExternalTableDefinition = output.ExternalTableDefinition;
  }
  if (output.IncludeOpForFullLoad !== undefined) {
    contents.IncludeOpForFullLoad = output.IncludeOpForFullLoad;
  }
  if (output.ParquetTimestampInMillisecond !== undefined) {
    contents.ParquetTimestampInMillisecond =
      output.ParquetTimestampInMillisecond;
  }
  if (output.ParquetVersion !== undefined) {
    contents.ParquetVersion = output.ParquetVersion;
  }
  if (output.RowGroupLength !== undefined) {
    contents.RowGroupLength = output.RowGroupLength;
  }
  if (output.ServerSideEncryptionKmsKeyId !== undefined) {
    contents.ServerSideEncryptionKmsKeyId = output.ServerSideEncryptionKmsKeyId;
  }
  if (output.ServiceAccessRoleArn !== undefined) {
    contents.ServiceAccessRoleArn = output.ServiceAccessRoleArn;
  }
  if (output.TimestampColumnName !== undefined) {
    contents.TimestampColumnName = output.TimestampColumnName;
  }
  return contents;
};

const deserializeAws_json1_1SchemaList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SourceIdsList = (
  output: any,
  context: __SerdeContext
): Array<string> => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1StartReplicationTaskAssessmentResponse = (
  output: any,
  context: __SerdeContext
): StartReplicationTaskAssessmentResponse => {
  let contents: any = {
    __type: "StartReplicationTaskAssessmentResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1StartReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): StartReplicationTaskResponse => {
  let contents: any = {
    __type: "StartReplicationTaskResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1StopReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): StopReplicationTaskResponse => {
  let contents: any = {
    __type: "StopReplicationTaskResponse",
    ReplicationTask: undefined
  };
  if (output.ReplicationTask !== undefined) {
    contents.ReplicationTask = deserializeAws_json1_1ReplicationTask(
      output.ReplicationTask,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1Subnet = (
  output: any,
  context: __SerdeContext
): Subnet => {
  let contents: any = {
    __type: "Subnet",
    SubnetAvailabilityZone: undefined,
    SubnetIdentifier: undefined,
    SubnetStatus: undefined
  };
  if (output.SubnetAvailabilityZone !== undefined) {
    contents.SubnetAvailabilityZone = deserializeAws_json1_1AvailabilityZone(
      output.SubnetAvailabilityZone,
      context
    );
  }
  if (output.SubnetIdentifier !== undefined) {
    contents.SubnetIdentifier = output.SubnetIdentifier;
  }
  if (output.SubnetStatus !== undefined) {
    contents.SubnetStatus = output.SubnetStatus;
  }
  return contents;
};

const deserializeAws_json1_1SubnetList = (
  output: any,
  context: __SerdeContext
): Array<Subnet> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Subnet(entry, context)
  );
};

const deserializeAws_json1_1SupportedEndpointType = (
  output: any,
  context: __SerdeContext
): SupportedEndpointType => {
  let contents: any = {
    __type: "SupportedEndpointType",
    EndpointType: undefined,
    EngineDisplayName: undefined,
    EngineName: undefined,
    SupportsCDC: undefined
  };
  if (output.EndpointType !== undefined) {
    contents.EndpointType = output.EndpointType;
  }
  if (output.EngineDisplayName !== undefined) {
    contents.EngineDisplayName = output.EngineDisplayName;
  }
  if (output.EngineName !== undefined) {
    contents.EngineName = output.EngineName;
  }
  if (output.SupportsCDC !== undefined) {
    contents.SupportsCDC = output.SupportsCDC;
  }
  return contents;
};

const deserializeAws_json1_1SupportedEndpointTypeList = (
  output: any,
  context: __SerdeContext
): Array<SupportedEndpointType> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SupportedEndpointType(entry, context)
  );
};

const deserializeAws_json1_1TableStatistics = (
  output: any,
  context: __SerdeContext
): TableStatistics => {
  let contents: any = {
    __type: "TableStatistics",
    Ddls: undefined,
    Deletes: undefined,
    FullLoadCondtnlChkFailedRows: undefined,
    FullLoadErrorRows: undefined,
    FullLoadRows: undefined,
    Inserts: undefined,
    LastUpdateTime: undefined,
    SchemaName: undefined,
    TableName: undefined,
    TableState: undefined,
    Updates: undefined,
    ValidationFailedRecords: undefined,
    ValidationPendingRecords: undefined,
    ValidationState: undefined,
    ValidationStateDetails: undefined,
    ValidationSuspendedRecords: undefined
  };
  if (output.Ddls !== undefined) {
    contents.Ddls = output.Ddls;
  }
  if (output.Deletes !== undefined) {
    contents.Deletes = output.Deletes;
  }
  if (output.FullLoadCondtnlChkFailedRows !== undefined) {
    contents.FullLoadCondtnlChkFailedRows = output.FullLoadCondtnlChkFailedRows;
  }
  if (output.FullLoadErrorRows !== undefined) {
    contents.FullLoadErrorRows = output.FullLoadErrorRows;
  }
  if (output.FullLoadRows !== undefined) {
    contents.FullLoadRows = output.FullLoadRows;
  }
  if (output.Inserts !== undefined) {
    contents.Inserts = output.Inserts;
  }
  if (output.LastUpdateTime !== undefined) {
    contents.LastUpdateTime = new Date(
      output.LastUpdateTime % 1 != 0
        ? Math.round(output.LastUpdateTime * 1000)
        : output.LastUpdateTime
    );
  }
  if (output.SchemaName !== undefined) {
    contents.SchemaName = output.SchemaName;
  }
  if (output.TableName !== undefined) {
    contents.TableName = output.TableName;
  }
  if (output.TableState !== undefined) {
    contents.TableState = output.TableState;
  }
  if (output.Updates !== undefined) {
    contents.Updates = output.Updates;
  }
  if (output.ValidationFailedRecords !== undefined) {
    contents.ValidationFailedRecords = output.ValidationFailedRecords;
  }
  if (output.ValidationPendingRecords !== undefined) {
    contents.ValidationPendingRecords = output.ValidationPendingRecords;
  }
  if (output.ValidationState !== undefined) {
    contents.ValidationState = output.ValidationState;
  }
  if (output.ValidationStateDetails !== undefined) {
    contents.ValidationStateDetails = output.ValidationStateDetails;
  }
  if (output.ValidationSuspendedRecords !== undefined) {
    contents.ValidationSuspendedRecords = output.ValidationSuspendedRecords;
  }
  return contents;
};

const deserializeAws_json1_1TableStatisticsList = (
  output: any,
  context: __SerdeContext
): Array<TableStatistics> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TableStatistics(entry, context)
  );
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  let contents: any = {
    __type: "Tag",
    Key: undefined,
    Value: undefined
  };
  if (output.Key !== undefined) {
    contents.Key = output.Key;
  }
  if (output.Value !== undefined) {
    contents.Value = output.Value;
  }
  return contents;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Array<Tag> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1TestConnectionResponse = (
  output: any,
  context: __SerdeContext
): TestConnectionResponse => {
  let contents: any = {
    __type: "TestConnectionResponse",
    Connection: undefined
  };
  if (output.Connection !== undefined) {
    contents.Connection = deserializeAws_json1_1Connection(
      output.Connection,
      context
    );
  }
  return contents;
};

const deserializeAws_json1_1VpcSecurityGroupMembership = (
  output: any,
  context: __SerdeContext
): VpcSecurityGroupMembership => {
  let contents: any = {
    __type: "VpcSecurityGroupMembership",
    Status: undefined,
    VpcSecurityGroupId: undefined
  };
  if (output.Status !== undefined) {
    contents.Status = output.Status;
  }
  if (output.VpcSecurityGroupId !== undefined) {
    contents.VpcSecurityGroupId = output.VpcSecurityGroupId;
  }
  return contents;
};

const deserializeAws_json1_1VpcSecurityGroupMembershipList = (
  output: any,
  context: __SerdeContext
): Array<VpcSecurityGroupMembership> => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1VpcSecurityGroupMembership(entry, context)
  );
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

const parseBody = (streamBody: any, context: __SerdeContext): any => {
  return context.streamCollector(streamBody).then((body: any) => {
    const encoded = context.utf8Encoder(body);
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
