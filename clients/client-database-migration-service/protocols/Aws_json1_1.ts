import {
  AddTagsToResourceCommandInput,
  AddTagsToResourceCommandOutput
} from "../commands/AddTagsToResourceCommand";
import {
  ApplyPendingMaintenanceActionCommandInput,
  ApplyPendingMaintenanceActionCommandOutput
} from "../commands/ApplyPendingMaintenanceActionCommand";
import {
  CreateEndpointCommandInput,
  CreateEndpointCommandOutput
} from "../commands/CreateEndpointCommand";
import {
  CreateEventSubscriptionCommandInput,
  CreateEventSubscriptionCommandOutput
} from "../commands/CreateEventSubscriptionCommand";
import {
  CreateReplicationInstanceCommandInput,
  CreateReplicationInstanceCommandOutput
} from "../commands/CreateReplicationInstanceCommand";
import {
  CreateReplicationSubnetGroupCommandInput,
  CreateReplicationSubnetGroupCommandOutput
} from "../commands/CreateReplicationSubnetGroupCommand";
import {
  CreateReplicationTaskCommandInput,
  CreateReplicationTaskCommandOutput
} from "../commands/CreateReplicationTaskCommand";
import {
  DeleteCertificateCommandInput,
  DeleteCertificateCommandOutput
} from "../commands/DeleteCertificateCommand";
import {
  DeleteConnectionCommandInput,
  DeleteConnectionCommandOutput
} from "../commands/DeleteConnectionCommand";
import {
  DeleteEndpointCommandInput,
  DeleteEndpointCommandOutput
} from "../commands/DeleteEndpointCommand";
import {
  DeleteEventSubscriptionCommandInput,
  DeleteEventSubscriptionCommandOutput
} from "../commands/DeleteEventSubscriptionCommand";
import {
  DeleteReplicationInstanceCommandInput,
  DeleteReplicationInstanceCommandOutput
} from "../commands/DeleteReplicationInstanceCommand";
import {
  DeleteReplicationSubnetGroupCommandInput,
  DeleteReplicationSubnetGroupCommandOutput
} from "../commands/DeleteReplicationSubnetGroupCommand";
import {
  DeleteReplicationTaskCommandInput,
  DeleteReplicationTaskCommandOutput
} from "../commands/DeleteReplicationTaskCommand";
import {
  DescribeAccountAttributesCommandInput,
  DescribeAccountAttributesCommandOutput
} from "../commands/DescribeAccountAttributesCommand";
import {
  DescribeCertificatesCommandInput,
  DescribeCertificatesCommandOutput
} from "../commands/DescribeCertificatesCommand";
import {
  DescribeConnectionsCommandInput,
  DescribeConnectionsCommandOutput
} from "../commands/DescribeConnectionsCommand";
import {
  DescribeEndpointTypesCommandInput,
  DescribeEndpointTypesCommandOutput
} from "../commands/DescribeEndpointTypesCommand";
import {
  DescribeEndpointsCommandInput,
  DescribeEndpointsCommandOutput
} from "../commands/DescribeEndpointsCommand";
import {
  DescribeEventCategoriesCommandInput,
  DescribeEventCategoriesCommandOutput
} from "../commands/DescribeEventCategoriesCommand";
import {
  DescribeEventSubscriptionsCommandInput,
  DescribeEventSubscriptionsCommandOutput
} from "../commands/DescribeEventSubscriptionsCommand";
import {
  DescribeEventsCommandInput,
  DescribeEventsCommandOutput
} from "../commands/DescribeEventsCommand";
import {
  DescribeOrderableReplicationInstancesCommandInput,
  DescribeOrderableReplicationInstancesCommandOutput
} from "../commands/DescribeOrderableReplicationInstancesCommand";
import {
  DescribePendingMaintenanceActionsCommandInput,
  DescribePendingMaintenanceActionsCommandOutput
} from "../commands/DescribePendingMaintenanceActionsCommand";
import {
  DescribeRefreshSchemasStatusCommandInput,
  DescribeRefreshSchemasStatusCommandOutput
} from "../commands/DescribeRefreshSchemasStatusCommand";
import {
  DescribeReplicationInstanceTaskLogsCommandInput,
  DescribeReplicationInstanceTaskLogsCommandOutput
} from "../commands/DescribeReplicationInstanceTaskLogsCommand";
import {
  DescribeReplicationInstancesCommandInput,
  DescribeReplicationInstancesCommandOutput
} from "../commands/DescribeReplicationInstancesCommand";
import {
  DescribeReplicationSubnetGroupsCommandInput,
  DescribeReplicationSubnetGroupsCommandOutput
} from "../commands/DescribeReplicationSubnetGroupsCommand";
import {
  DescribeReplicationTaskAssessmentResultsCommandInput,
  DescribeReplicationTaskAssessmentResultsCommandOutput
} from "../commands/DescribeReplicationTaskAssessmentResultsCommand";
import {
  DescribeReplicationTasksCommandInput,
  DescribeReplicationTasksCommandOutput
} from "../commands/DescribeReplicationTasksCommand";
import {
  DescribeSchemasCommandInput,
  DescribeSchemasCommandOutput
} from "../commands/DescribeSchemasCommand";
import {
  DescribeTableStatisticsCommandInput,
  DescribeTableStatisticsCommandOutput
} from "../commands/DescribeTableStatisticsCommand";
import {
  ImportCertificateCommandInput,
  ImportCertificateCommandOutput
} from "../commands/ImportCertificateCommand";
import {
  ListTagsForResourceCommandInput,
  ListTagsForResourceCommandOutput
} from "../commands/ListTagsForResourceCommand";
import {
  ModifyEndpointCommandInput,
  ModifyEndpointCommandOutput
} from "../commands/ModifyEndpointCommand";
import {
  ModifyEventSubscriptionCommandInput,
  ModifyEventSubscriptionCommandOutput
} from "../commands/ModifyEventSubscriptionCommand";
import {
  ModifyReplicationInstanceCommandInput,
  ModifyReplicationInstanceCommandOutput
} from "../commands/ModifyReplicationInstanceCommand";
import {
  ModifyReplicationSubnetGroupCommandInput,
  ModifyReplicationSubnetGroupCommandOutput
} from "../commands/ModifyReplicationSubnetGroupCommand";
import {
  ModifyReplicationTaskCommandInput,
  ModifyReplicationTaskCommandOutput
} from "../commands/ModifyReplicationTaskCommand";
import {
  RebootReplicationInstanceCommandInput,
  RebootReplicationInstanceCommandOutput
} from "../commands/RebootReplicationInstanceCommand";
import {
  RefreshSchemasCommandInput,
  RefreshSchemasCommandOutput
} from "../commands/RefreshSchemasCommand";
import {
  ReloadTablesCommandInput,
  ReloadTablesCommandOutput
} from "../commands/ReloadTablesCommand";
import {
  RemoveTagsFromResourceCommandInput,
  RemoveTagsFromResourceCommandOutput
} from "../commands/RemoveTagsFromResourceCommand";
import {
  StartReplicationTaskAssessmentCommandInput,
  StartReplicationTaskAssessmentCommandOutput
} from "../commands/StartReplicationTaskAssessmentCommand";
import {
  StartReplicationTaskCommandInput,
  StartReplicationTaskCommandOutput
} from "../commands/StartReplicationTaskCommand";
import {
  StopReplicationTaskCommandInput,
  StopReplicationTaskCommandOutput
} from "../commands/StopReplicationTaskCommand";
import {
  TestConnectionCommandInput,
  TestConnectionCommandOutput
} from "../commands/TestConnectionCommand";
import {
  AccessDeniedFault,
  AccountQuota,
  AddTagsToResourceMessage,
  AddTagsToResourceResponse,
  ApplyPendingMaintenanceActionMessage,
  ApplyPendingMaintenanceActionResponse,
  AvailabilityZone,
  Certificate,
  Connection,
  CreateEndpointMessage,
  CreateEndpointResponse,
  CreateEventSubscriptionMessage,
  CreateEventSubscriptionResponse,
  CreateReplicationInstanceMessage,
  CreateReplicationInstanceResponse,
  CreateReplicationSubnetGroupMessage,
  CreateReplicationSubnetGroupResponse,
  CreateReplicationTaskMessage,
  CreateReplicationTaskResponse,
  DeleteCertificateMessage,
  DeleteCertificateResponse,
  DeleteConnectionMessage,
  DeleteConnectionResponse,
  DeleteEndpointMessage,
  DeleteEndpointResponse,
  DeleteEventSubscriptionMessage,
  DeleteEventSubscriptionResponse,
  DeleteReplicationInstanceMessage,
  DeleteReplicationInstanceResponse,
  DeleteReplicationSubnetGroupMessage,
  DeleteReplicationSubnetGroupResponse,
  DeleteReplicationTaskMessage,
  DeleteReplicationTaskResponse,
  DescribeAccountAttributesMessage,
  DescribeAccountAttributesResponse,
  DescribeCertificatesMessage,
  DescribeCertificatesResponse,
  DescribeConnectionsMessage,
  DescribeConnectionsResponse,
  DescribeEndpointTypesMessage,
  DescribeEndpointTypesResponse,
  DescribeEndpointsMessage,
  DescribeEndpointsResponse,
  DescribeEventCategoriesMessage,
  DescribeEventCategoriesResponse,
  DescribeEventSubscriptionsMessage,
  DescribeEventSubscriptionsResponse,
  DescribeEventsMessage,
  DescribeEventsResponse,
  DescribeOrderableReplicationInstancesMessage,
  DescribeOrderableReplicationInstancesResponse,
  DescribePendingMaintenanceActionsMessage,
  DescribePendingMaintenanceActionsResponse,
  DescribeRefreshSchemasStatusMessage,
  DescribeRefreshSchemasStatusResponse,
  DescribeReplicationInstanceTaskLogsMessage,
  DescribeReplicationInstanceTaskLogsResponse,
  DescribeReplicationInstancesMessage,
  DescribeReplicationInstancesResponse,
  DescribeReplicationSubnetGroupsMessage,
  DescribeReplicationSubnetGroupsResponse,
  DescribeReplicationTaskAssessmentResultsMessage,
  DescribeReplicationTaskAssessmentResultsResponse,
  DescribeReplicationTasksMessage,
  DescribeReplicationTasksResponse,
  DescribeSchemasMessage,
  DescribeSchemasResponse,
  DescribeTableStatisticsMessage,
  DescribeTableStatisticsResponse,
  DmsTransferSettings,
  DynamoDbSettings,
  ElasticsearchSettings,
  Endpoint,
  Event,
  EventCategoryGroup,
  EventSubscription,
  Filter,
  ImportCertificateMessage,
  ImportCertificateResponse,
  InsufficientResourceCapacityFault,
  InvalidCertificateFault,
  InvalidResourceStateFault,
  InvalidSubnet,
  KMSAccessDeniedFault,
  KMSDisabledFault,
  KMSInvalidStateFault,
  KMSKeyNotAccessibleFault,
  KMSNotFoundFault,
  KMSThrottlingFault,
  KinesisSettings,
  ListTagsForResourceMessage,
  ListTagsForResourceResponse,
  ModifyEndpointMessage,
  ModifyEndpointResponse,
  ModifyEventSubscriptionMessage,
  ModifyEventSubscriptionResponse,
  ModifyReplicationInstanceMessage,
  ModifyReplicationInstanceResponse,
  ModifyReplicationSubnetGroupMessage,
  ModifyReplicationSubnetGroupResponse,
  ModifyReplicationTaskMessage,
  ModifyReplicationTaskResponse,
  MongoDbSettings,
  OrderableReplicationInstance,
  PendingMaintenanceAction,
  RebootReplicationInstanceMessage,
  RebootReplicationInstanceResponse,
  RedshiftSettings,
  RefreshSchemasMessage,
  RefreshSchemasResponse,
  RefreshSchemasStatus,
  ReloadTablesMessage,
  ReloadTablesResponse,
  RemoveTagsFromResourceMessage,
  RemoveTagsFromResourceResponse,
  ReplicationInstance,
  ReplicationInstanceTaskLog,
  ReplicationPendingModifiedValues,
  ReplicationSubnetGroup,
  ReplicationSubnetGroupDoesNotCoverEnoughAZs,
  ReplicationTask,
  ReplicationTaskAssessmentResult,
  ReplicationTaskStats,
  ResourceAlreadyExistsFault,
  ResourceNotFoundFault,
  ResourcePendingMaintenanceActions,
  ResourceQuotaExceededFault,
  S3Settings,
  SNSInvalidTopicFault,
  SNSNoAuthorizationFault,
  StartReplicationTaskAssessmentMessage,
  StartReplicationTaskAssessmentResponse,
  StartReplicationTaskMessage,
  StartReplicationTaskResponse,
  StopReplicationTaskMessage,
  StopReplicationTaskResponse,
  StorageQuotaExceededFault,
  Subnet,
  SubnetAlreadyInUse,
  SupportedEndpointType,
  TableStatistics,
  TableToReload,
  Tag,
  TestConnectionMessage,
  TestConnectionResponse,
  UpgradeDependencyFailureFault,
  VpcSecurityGroupMembership
} from "../models/index";
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse
} from "@aws-sdk/protocol-http";
import { SmithyException as __SmithyException } from "@aws-sdk/smithy-client";
import {
  Endpoint as __Endpoint,
  HeaderBag as __HeaderBag,
  MetadataBearer as __MetadataBearer,
  ResponseMetadata as __ResponseMetadata,
  SerdeContext as __SerdeContext
} from "@aws-sdk/types";

export const serializeAws_json1_1AddTagsToResourceCommand = async (
  input: AddTagsToResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.AddTagsToResource"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1AddTagsToResourceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ApplyPendingMaintenanceActionCommand = async (
  input: ApplyPendingMaintenanceActionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.ApplyPendingMaintenanceAction"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ApplyPendingMaintenanceActionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateEndpointCommand = async (
  input: CreateEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.CreateEndpoint"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateEndpointMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateEventSubscriptionCommand = async (
  input: CreateEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.CreateEventSubscription"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateEventSubscriptionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateReplicationInstanceCommand = async (
  input: CreateReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.CreateReplicationInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateReplicationInstanceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateReplicationSubnetGroupCommand = async (
  input: CreateReplicationSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.CreateReplicationSubnetGroup"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateReplicationSubnetGroupMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1CreateReplicationTaskCommand = async (
  input: CreateReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.CreateReplicationTask"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1CreateReplicationTaskMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteCertificateCommand = async (
  input: DeleteCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DeleteCertificate"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteCertificateMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteConnectionCommand = async (
  input: DeleteConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DeleteConnection"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteConnectionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteEndpointCommand = async (
  input: DeleteEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DeleteEndpoint"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteEndpointMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteEventSubscriptionCommand = async (
  input: DeleteEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DeleteEventSubscription"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteEventSubscriptionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteReplicationInstanceCommand = async (
  input: DeleteReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DeleteReplicationInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteReplicationInstanceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteReplicationSubnetGroupCommand = async (
  input: DeleteReplicationSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DeleteReplicationSubnetGroup"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteReplicationSubnetGroupMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DeleteReplicationTaskCommand = async (
  input: DeleteReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DeleteReplicationTask"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DeleteReplicationTaskMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeAccountAttributesCommand = async (
  input: DescribeAccountAttributesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeAccountAttributes"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeAccountAttributesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeCertificatesCommand = async (
  input: DescribeCertificatesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeCertificates"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeCertificatesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeConnectionsCommand = async (
  input: DescribeConnectionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeConnections"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeConnectionsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeEndpointsCommand = async (
  input: DescribeEndpointsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeEndpoints"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEndpointsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeEndpointTypesCommand = async (
  input: DescribeEndpointTypesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeEndpointTypes"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEndpointTypesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeEventCategoriesCommand = async (
  input: DescribeEventCategoriesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeEventCategories"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEventCategoriesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeEventsCommand = async (
  input: DescribeEventsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeEvents"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEventsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeEventSubscriptionsCommand = async (
  input: DescribeEventSubscriptionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeEventSubscriptions"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeEventSubscriptionsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeOrderableReplicationInstancesCommand = async (
  input: DescribeOrderableReplicationInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeOrderableReplicationInstances"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeOrderableReplicationInstancesMessage(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribePendingMaintenanceActionsCommand = async (
  input: DescribePendingMaintenanceActionsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribePendingMaintenanceActions"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribePendingMaintenanceActionsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeRefreshSchemasStatusCommand = async (
  input: DescribeRefreshSchemasStatusCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeRefreshSchemasStatus"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeRefreshSchemasStatusMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeReplicationInstancesCommand = async (
  input: DescribeReplicationInstancesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeReplicationInstances"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeReplicationInstancesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeReplicationInstanceTaskLogsCommand = async (
  input: DescribeReplicationInstanceTaskLogsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeReplicationInstanceTaskLogs"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeReplicationInstanceTaskLogsMessage(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeReplicationSubnetGroupsCommand = async (
  input: DescribeReplicationSubnetGroupsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeReplicationSubnetGroups"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeReplicationSubnetGroupsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommand = async (
  input: DescribeReplicationTaskAssessmentResultsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target":
      "AmazonDMSv20160101.DescribeReplicationTaskAssessmentResults"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeReplicationTaskAssessmentResultsMessage(
      input,
      context
    )
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeReplicationTasksCommand = async (
  input: DescribeReplicationTasksCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeReplicationTasks"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeReplicationTasksMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeSchemasCommand = async (
  input: DescribeSchemasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeSchemas"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeSchemasMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1DescribeTableStatisticsCommand = async (
  input: DescribeTableStatisticsCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.DescribeTableStatistics"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1DescribeTableStatisticsMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ImportCertificateCommand = async (
  input: ImportCertificateCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.ImportCertificate"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ImportCertificateMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ListTagsForResourceCommand = async (
  input: ListTagsForResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.ListTagsForResource"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ListTagsForResourceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ModifyEndpointCommand = async (
  input: ModifyEndpointCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.ModifyEndpoint"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyEndpointMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ModifyEventSubscriptionCommand = async (
  input: ModifyEventSubscriptionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.ModifyEventSubscription"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyEventSubscriptionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ModifyReplicationInstanceCommand = async (
  input: ModifyReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.ModifyReplicationInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyReplicationInstanceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ModifyReplicationSubnetGroupCommand = async (
  input: ModifyReplicationSubnetGroupCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.ModifyReplicationSubnetGroup"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyReplicationSubnetGroupMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ModifyReplicationTaskCommand = async (
  input: ModifyReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.ModifyReplicationTask"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ModifyReplicationTaskMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1RebootReplicationInstanceCommand = async (
  input: RebootReplicationInstanceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.RebootReplicationInstance"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RebootReplicationInstanceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1RefreshSchemasCommand = async (
  input: RefreshSchemasCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.RefreshSchemas"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RefreshSchemasMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1ReloadTablesCommand = async (
  input: ReloadTablesCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.ReloadTables"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1ReloadTablesMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1RemoveTagsFromResourceCommand = async (
  input: RemoveTagsFromResourceCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.RemoveTagsFromResource"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1RemoveTagsFromResourceMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartReplicationTaskCommand = async (
  input: StartReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.StartReplicationTask"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartReplicationTaskMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StartReplicationTaskAssessmentCommand = async (
  input: StartReplicationTaskAssessmentCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.StartReplicationTaskAssessment"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StartReplicationTaskAssessmentMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1StopReplicationTaskCommand = async (
  input: StopReplicationTaskCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.StopReplicationTask"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1StopReplicationTaskMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const serializeAws_json1_1TestConnectionCommand = async (
  input: TestConnectionCommandInput,
  context: __SerdeContext
): Promise<__HttpRequest> => {
  const headers: __HeaderBag = {
    "Content-Type": "application/x-amz-json-1.1",
    "X-Amz-Target": "AmazonDMSv20160101.TestConnection"
  };
  let body: any;
  body = JSON.stringify(
    serializeAws_json1_1TestConnectionMessage(input, context)
  );
  return buildHttpRpcRequest(context, headers, "/", undefined, body);
};

export const deserializeAws_json1_1AddTagsToResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1AddTagsToResourceCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1AddTagsToResourceResponse(data, context);
  const response: AddTagsToResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "AddTagsToResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1AddTagsToResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<AddTagsToResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ApplyPendingMaintenanceActionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApplyPendingMaintenanceActionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ApplyPendingMaintenanceActionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ApplyPendingMaintenanceActionResponse(
    data,
    context
  );
  const response: ApplyPendingMaintenanceActionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ApplyPendingMaintenanceActionResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ApplyPendingMaintenanceActionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ApplyPendingMaintenanceActionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEndpointResponse(data, context);
  const response: CreateEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.databasemigrationservice#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.databasemigrationservice#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateEventSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEventSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateEventSubscriptionResponse(
    data,
    context
  );
  const response: CreateEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateEventSubscriptionResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateEventSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateEventSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "KMSAccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#KMSAccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1KMSAccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSDisabledFault":
    case "com.amazonaws.databasemigrationservice#KMSDisabledFault":
      response = {
        ...(await deserializeAws_json1_1KMSDisabledFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSInvalidStateFault":
    case "com.amazonaws.databasemigrationservice#KMSInvalidStateFault":
      response = {
        ...(await deserializeAws_json1_1KMSInvalidStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSNotFoundFault":
    case "com.amazonaws.databasemigrationservice#KMSNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1KMSNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSThrottlingFault":
    case "com.amazonaws.databasemigrationservice#KMSThrottlingFault":
      response = {
        ...(await deserializeAws_json1_1KMSThrottlingFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.databasemigrationservice#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSInvalidTopicFault":
    case "com.amazonaws.databasemigrationservice#SNSInvalidTopicFault":
      response = {
        ...(await deserializeAws_json1_1SNSInvalidTopicFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSNoAuthorizationFault":
    case "com.amazonaws.databasemigrationservice#SNSNoAuthorizationFault":
      response = {
        ...(await deserializeAws_json1_1SNSNoAuthorizationFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateReplicationInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateReplicationInstanceResponse(
    data,
    context
  );
  const response: CreateReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateReplicationInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientResourceCapacityFault":
    case "com.amazonaws.databasemigrationservice#InsufficientResourceCapacityFault":
      response = {
        ...(await deserializeAws_json1_1InsufficientResourceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "com.amazonaws.databasemigrationservice#InvalidSubnet":
      response = {
        ...(await deserializeAws_json1_1InvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.databasemigrationservice#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplicationSubnetGroupDoesNotCoverEnoughAZs":
    case "com.amazonaws.databasemigrationservice#ReplicationSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.databasemigrationservice#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1StorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateReplicationSubnetGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationSubnetGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateReplicationSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateReplicationSubnetGroupResponse(
    data,
    context
  );
  const response: CreateReplicationSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReplicationSubnetGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateReplicationSubnetGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationSubnetGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "com.amazonaws.databasemigrationservice#InvalidSubnet":
      response = {
        ...(await deserializeAws_json1_1InvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplicationSubnetGroupDoesNotCoverEnoughAZs":
    case "com.amazonaws.databasemigrationservice#ReplicationSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.databasemigrationservice#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1CreateReplicationTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationTaskCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1CreateReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1CreateReplicationTaskResponse(data, context);
  const response: CreateReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "CreateReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1CreateReplicationTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<CreateReplicationTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.databasemigrationservice#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.databasemigrationservice#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCertificateCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteCertificateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteCertificateResponse(data, context);
  const response: DeleteCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteCertificateResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteConnectionResponse(data, context);
  const response: DeleteConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteEndpointResponse(data, context);
  const response: DeleteEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteEventSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteEventSubscriptionResponse(
    data,
    context
  );
  const response: DeleteEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteEventSubscriptionResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteEventSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteEventSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteReplicationInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteReplicationInstanceResponse(
    data,
    context
  );
  const response: DeleteReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteReplicationInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteReplicationSubnetGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationSubnetGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteReplicationSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteReplicationSubnetGroupResponse(
    data,
    context
  );
  const response: DeleteReplicationSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReplicationSubnetGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteReplicationSubnetGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationSubnetGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DeleteReplicationTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationTaskCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DeleteReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DeleteReplicationTaskResponse(data, context);
  const response: DeleteReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DeleteReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DeleteReplicationTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DeleteReplicationTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeAccountAttributesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeAccountAttributesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeAccountAttributesResponse(
    data,
    context
  );
  const response: DescribeAccountAttributesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeAccountAttributesResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeAccountAttributesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeAccountAttributesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeCertificatesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificatesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeCertificatesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeCertificatesResponse(data, context);
  const response: DescribeCertificatesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeCertificatesResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeCertificatesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeCertificatesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeConnectionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeConnectionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeConnectionsResponse(data, context);
  const response: DescribeConnectionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeConnectionsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeConnectionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeConnectionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeEndpointsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEndpointsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEndpointsResponse(data, context);
  const response: DescribeEndpointsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeEndpointsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeEndpointTypesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointTypesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEndpointTypesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEndpointTypesResponse(data, context);
  const response: DescribeEndpointTypesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEndpointTypesResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeEndpointTypesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEndpointTypesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeEventCategoriesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventCategoriesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEventCategoriesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEventCategoriesResponse(
    data,
    context
  );
  const response: DescribeEventCategoriesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventCategoriesResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeEventCategoriesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventCategoriesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeEventsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEventsCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEventsResponse(data, context);
  const response: DescribeEventsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeEventsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeEventSubscriptionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventSubscriptionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeEventSubscriptionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeEventSubscriptionsResponse(
    data,
    context
  );
  const response: DescribeEventSubscriptionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeEventSubscriptionsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeEventSubscriptionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeEventSubscriptionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeOrderableReplicationInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOrderableReplicationInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeOrderableReplicationInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeOrderableReplicationInstancesResponse(
    data,
    context
  );
  const response: DescribeOrderableReplicationInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeOrderableReplicationInstancesResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeOrderableReplicationInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeOrderableReplicationInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribePendingMaintenanceActionsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePendingMaintenanceActionsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribePendingMaintenanceActionsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribePendingMaintenanceActionsResponse(
    data,
    context
  );
  const response: DescribePendingMaintenanceActionsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribePendingMaintenanceActionsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribePendingMaintenanceActionsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribePendingMaintenanceActionsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeRefreshSchemasStatusCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRefreshSchemasStatusCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeRefreshSchemasStatusCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeRefreshSchemasStatusResponse(
    data,
    context
  );
  const response: DescribeRefreshSchemasStatusCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeRefreshSchemasStatusResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeRefreshSchemasStatusCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeRefreshSchemasStatusCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeReplicationInstancesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstancesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationInstancesCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationInstancesResponse(
    data,
    context
  );
  const response: DescribeReplicationInstancesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationInstancesResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeReplicationInstancesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstancesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeReplicationInstanceTaskLogsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstanceTaskLogsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationInstanceTaskLogsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationInstanceTaskLogsResponse(
    data,
    context
  );
  const response: DescribeReplicationInstanceTaskLogsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationInstanceTaskLogsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeReplicationInstanceTaskLogsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationInstanceTaskLogsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeReplicationSubnetGroupsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationSubnetGroupsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationSubnetGroupsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationSubnetGroupsResponse(
    data,
    context
  );
  const response: DescribeReplicationSubnetGroupsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationSubnetGroupsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeReplicationSubnetGroupsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationSubnetGroupsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTaskAssessmentResultsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsResponse(
    data,
    context
  );
  const response: DescribeReplicationTaskAssessmentResultsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationTaskAssessmentResultsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTaskAssessmentResultsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeReplicationTasksCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTasksCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeReplicationTasksCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeReplicationTasksResponse(
    data,
    context
  );
  const response: DescribeReplicationTasksCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeReplicationTasksResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeReplicationTasksCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeReplicationTasksCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeSchemasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSchemasCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeSchemasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeSchemasResponse(data, context);
  const response: DescribeSchemasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeSchemasResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeSchemasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeSchemasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1DescribeTableStatisticsCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTableStatisticsCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1DescribeTableStatisticsCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1DescribeTableStatisticsResponse(
    data,
    context
  );
  const response: DescribeTableStatisticsCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "DescribeTableStatisticsResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1DescribeTableStatisticsCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<DescribeTableStatisticsCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ImportCertificateCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCertificateCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ImportCertificateCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ImportCertificateResponse(data, context);
  const response: ImportCertificateCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ImportCertificateResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ImportCertificateCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ImportCertificateCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidCertificateFault":
    case "com.amazonaws.databasemigrationservice#InvalidCertificateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidCertificateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.databasemigrationservice#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ListTagsForResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ListTagsForResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ListTagsForResourceResponse(data, context);
  const response: ListTagsForResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ListTagsForResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ListTagsForResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ListTagsForResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ModifyEndpointCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEndpointCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyEndpointCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyEndpointResponse(data, context);
  const response: ModifyEndpointCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyEndpointResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ModifyEndpointCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEndpointCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.databasemigrationservice#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.databasemigrationservice#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ModifyEventSubscriptionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEventSubscriptionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyEventSubscriptionCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyEventSubscriptionResponse(
    data,
    context
  );
  const response: ModifyEventSubscriptionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyEventSubscriptionResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ModifyEventSubscriptionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyEventSubscriptionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "KMSAccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#KMSAccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1KMSAccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSDisabledFault":
    case "com.amazonaws.databasemigrationservice#KMSDisabledFault":
      response = {
        ...(await deserializeAws_json1_1KMSDisabledFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSInvalidStateFault":
    case "com.amazonaws.databasemigrationservice#KMSInvalidStateFault":
      response = {
        ...(await deserializeAws_json1_1KMSInvalidStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSNotFoundFault":
    case "com.amazonaws.databasemigrationservice#KMSNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1KMSNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSThrottlingFault":
    case "com.amazonaws.databasemigrationservice#KMSThrottlingFault":
      response = {
        ...(await deserializeAws_json1_1KMSThrottlingFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSInvalidTopicFault":
    case "com.amazonaws.databasemigrationservice#SNSInvalidTopicFault":
      response = {
        ...(await deserializeAws_json1_1SNSInvalidTopicFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SNSNoAuthorizationFault":
    case "com.amazonaws.databasemigrationservice#SNSNoAuthorizationFault":
      response = {
        ...(await deserializeAws_json1_1SNSNoAuthorizationFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ModifyReplicationInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyReplicationInstanceResponse(
    data,
    context
  );
  const response: ModifyReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ModifyReplicationInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InsufficientResourceCapacityFault":
    case "com.amazonaws.databasemigrationservice#InsufficientResourceCapacityFault":
      response = {
        ...(await deserializeAws_json1_1InsufficientResourceCapacityFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.databasemigrationservice#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "StorageQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#StorageQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1StorageQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "UpgradeDependencyFailureFault":
    case "com.amazonaws.databasemigrationservice#UpgradeDependencyFailureFault":
      response = {
        ...(await deserializeAws_json1_1UpgradeDependencyFailureFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ModifyReplicationSubnetGroupCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationSubnetGroupCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyReplicationSubnetGroupCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyReplicationSubnetGroupResponse(
    data,
    context
  );
  const response: ModifyReplicationSubnetGroupCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyReplicationSubnetGroupResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ModifyReplicationSubnetGroupCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationSubnetGroupCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidSubnet":
    case "com.amazonaws.databasemigrationservice#InvalidSubnet":
      response = {
        ...(await deserializeAws_json1_1InvalidSubnetResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ReplicationSubnetGroupDoesNotCoverEnoughAZs":
    case "com.amazonaws.databasemigrationservice#ReplicationSubnetGroupDoesNotCoverEnoughAZs":
      response = {
        ...(await deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "SubnetAlreadyInUse":
    case "com.amazonaws.databasemigrationservice#SubnetAlreadyInUse":
      response = {
        ...(await deserializeAws_json1_1SubnetAlreadyInUseResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ModifyReplicationTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationTaskCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ModifyReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ModifyReplicationTaskResponse(data, context);
  const response: ModifyReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ModifyReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ModifyReplicationTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ModifyReplicationTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.databasemigrationservice#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceAlreadyExistsFault":
    case "com.amazonaws.databasemigrationservice#ResourceAlreadyExistsFault":
      response = {
        ...(await deserializeAws_json1_1ResourceAlreadyExistsFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1RebootReplicationInstanceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootReplicationInstanceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RebootReplicationInstanceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RebootReplicationInstanceResponse(
    data,
    context
  );
  const response: RebootReplicationInstanceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RebootReplicationInstanceResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1RebootReplicationInstanceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RebootReplicationInstanceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1RefreshSchemasCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RefreshSchemasCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RefreshSchemasCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RefreshSchemasResponse(data, context);
  const response: RefreshSchemasCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RefreshSchemasResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1RefreshSchemasCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RefreshSchemasCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.databasemigrationservice#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1ReloadTablesCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReloadTablesCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1ReloadTablesCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1ReloadTablesResponse(data, context);
  const response: ReloadTablesCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "ReloadTablesResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1ReloadTablesCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<ReloadTablesCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1RemoveTagsFromResourceCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1RemoveTagsFromResourceCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1RemoveTagsFromResourceResponse(
    data,
    context
  );
  const response: RemoveTagsFromResourceCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "RemoveTagsFromResourceResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1RemoveTagsFromResourceCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<RemoveTagsFromResourceCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartReplicationTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartReplicationTaskResponse(data, context);
  const response: StartReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartReplicationTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "AccessDeniedFault":
    case "com.amazonaws.databasemigrationservice#AccessDeniedFault":
      response = {
        ...(await deserializeAws_json1_1AccessDeniedFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StartReplicationTaskAssessmentCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskAssessmentCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StartReplicationTaskAssessmentCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StartReplicationTaskAssessmentResponse(
    data,
    context
  );
  const response: StartReplicationTaskAssessmentCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StartReplicationTaskAssessmentResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StartReplicationTaskAssessmentCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StartReplicationTaskAssessmentCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1StopReplicationTaskCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopReplicationTaskCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1StopReplicationTaskCommandError(
      output,
      context
    );
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1StopReplicationTaskResponse(data, context);
  const response: StopReplicationTaskCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "StopReplicationTaskResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1StopReplicationTaskCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<StopReplicationTaskCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

export const deserializeAws_json1_1TestConnectionCommand = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestConnectionCommandOutput> => {
  if (output.statusCode >= 400) {
    return deserializeAws_json1_1TestConnectionCommandError(output, context);
  }
  const data: any = await parseBody(output.body, context);
  let contents: any = {};
  contents = deserializeAws_json1_1TestConnectionResponse(data, context);
  const response: TestConnectionCommandOutput = {
    $metadata: deserializeMetadata(output),
    __type: "TestConnectionResponse",
    ...contents
  };
  return Promise.resolve(response);
};

const deserializeAws_json1_1TestConnectionCommandError = async (
  output: __HttpResponse,
  context: __SerdeContext
): Promise<TestConnectionCommandOutput> => {
  const parsedOutput: any = {
    ...output,
    body: await parseBody(output.body, context)
  };
  let response: __SmithyException & __MetadataBearer & { [key: string]: any };
  let errorCode: string = "UnknownError";
  const errorTypeParts: String = parsedOutput.body["__type"].split("#");
  errorCode =
    errorTypeParts[1] === undefined ? errorTypeParts[0] : errorTypeParts[1];
  switch (errorCode) {
    case "InvalidResourceStateFault":
    case "com.amazonaws.databasemigrationservice#InvalidResourceStateFault":
      response = {
        ...(await deserializeAws_json1_1InvalidResourceStateFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "KMSKeyNotAccessibleFault":
    case "com.amazonaws.databasemigrationservice#KMSKeyNotAccessibleFault":
      response = {
        ...(await deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceNotFoundFault":
    case "com.amazonaws.databasemigrationservice#ResourceNotFoundFault":
      response = {
        ...(await deserializeAws_json1_1ResourceNotFoundFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    case "ResourceQuotaExceededFault":
    case "com.amazonaws.databasemigrationservice#ResourceQuotaExceededFault":
      response = {
        ...(await deserializeAws_json1_1ResourceQuotaExceededFaultResponse(
          parsedOutput,
          context
        )),
        name: errorCode,
        $metadata: deserializeMetadata(output)
      };
      break;
    default:
      const parsedBody = parsedOutput.body;
      errorCode = parsedBody.code || parsedBody.Code || errorCode;
      response = {
        ...parsedBody,
        name: `${errorCode}`,
        message: parsedBody.message || parsedBody.Message || errorCode,
        $fault: "client",
        $metadata: deserializeMetadata(output)
      } as any;
  }
  const message = response.message || response.Message || errorCode;
  response.message = message;
  delete response.Message;
  return Promise.reject(Object.assign(new Error(message), response));
};

const deserializeAws_json1_1AccessDeniedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<AccessDeniedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1AccessDeniedFault(
    body,
    context
  );
  const contents: AccessDeniedFault = {
    name: "AccessDeniedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InsufficientResourceCapacityFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InsufficientResourceCapacityFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InsufficientResourceCapacityFault(
    body,
    context
  );
  const contents: InsufficientResourceCapacityFault = {
    name: "InsufficientResourceCapacityFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidCertificateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidCertificateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidCertificateFault(
    body,
    context
  );
  const contents: InvalidCertificateFault = {
    name: "InvalidCertificateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidResourceStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidResourceStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidResourceStateFault(
    body,
    context
  );
  const contents: InvalidResourceStateFault = {
    name: "InvalidResourceStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1InvalidSubnetResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<InvalidSubnet> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1InvalidSubnet(body, context);
  const contents: InvalidSubnet = {
    name: "InvalidSubnet",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSAccessDeniedFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSAccessDeniedFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSAccessDeniedFault(
    body,
    context
  );
  const contents: KMSAccessDeniedFault = {
    name: "KMSAccessDeniedFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSDisabledFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSDisabledFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSDisabledFault(
    body,
    context
  );
  const contents: KMSDisabledFault = {
    name: "KMSDisabledFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSInvalidStateFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSInvalidStateFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSInvalidStateFault(
    body,
    context
  );
  const contents: KMSInvalidStateFault = {
    name: "KMSInvalidStateFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSKeyNotAccessibleFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSKeyNotAccessibleFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSKeyNotAccessibleFault(
    body,
    context
  );
  const contents: KMSKeyNotAccessibleFault = {
    name: "KMSKeyNotAccessibleFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSNotFoundFault(
    body,
    context
  );
  const contents: KMSNotFoundFault = {
    name: "KMSNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1KMSThrottlingFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<KMSThrottlingFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1KMSThrottlingFault(
    body,
    context
  );
  const contents: KMSThrottlingFault = {
    name: "KMSThrottlingFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZsResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ReplicationSubnetGroupDoesNotCoverEnoughAZs> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZs(
    body,
    context
  );
  const contents: ReplicationSubnetGroupDoesNotCoverEnoughAZs = {
    name: "ReplicationSubnetGroupDoesNotCoverEnoughAZs",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceAlreadyExistsFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceAlreadyExistsFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceAlreadyExistsFault(
    body,
    context
  );
  const contents: ResourceAlreadyExistsFault = {
    name: "ResourceAlreadyExistsFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceNotFoundFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceNotFoundFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceNotFoundFault(
    body,
    context
  );
  const contents: ResourceNotFoundFault = {
    name: "ResourceNotFoundFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1ResourceQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<ResourceQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1ResourceQuotaExceededFault(
    body,
    context
  );
  const contents: ResourceQuotaExceededFault = {
    name: "ResourceQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SNSInvalidTopicFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SNSInvalidTopicFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SNSInvalidTopicFault(
    body,
    context
  );
  const contents: SNSInvalidTopicFault = {
    name: "SNSInvalidTopicFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SNSNoAuthorizationFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SNSNoAuthorizationFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SNSNoAuthorizationFault(
    body,
    context
  );
  const contents: SNSNoAuthorizationFault = {
    name: "SNSNoAuthorizationFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1StorageQuotaExceededFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<StorageQuotaExceededFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1StorageQuotaExceededFault(
    body,
    context
  );
  const contents: StorageQuotaExceededFault = {
    name: "StorageQuotaExceededFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1SubnetAlreadyInUseResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<SubnetAlreadyInUse> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1SubnetAlreadyInUse(
    body,
    context
  );
  const contents: SubnetAlreadyInUse = {
    name: "SubnetAlreadyInUse",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const deserializeAws_json1_1UpgradeDependencyFailureFaultResponse = async (
  parsedOutput: any,
  context: __SerdeContext
): Promise<UpgradeDependencyFailureFault> => {
  const body = parsedOutput.body;
  const deserialized: any = deserializeAws_json1_1UpgradeDependencyFailureFault(
    body,
    context
  );
  const contents: UpgradeDependencyFailureFault = {
    name: "UpgradeDependencyFailureFault",
    $fault: "client",
    $metadata: deserializeMetadata(parsedOutput),
    ...deserialized
  };
  return contents;
};

const serializeAws_json1_1AddTagsToResourceMessage = (
  input: AddTagsToResourceMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
    ...(input.Tags !== undefined && {
      Tags: serializeAws_json1_1TagList(input.Tags, context)
    })
  };
};

const serializeAws_json1_1ApplyPendingMaintenanceActionMessage = (
  input: ApplyPendingMaintenanceActionMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ApplyAction !== undefined && { ApplyAction: input.ApplyAction }),
    ...(input.OptInType !== undefined && { OptInType: input.OptInType }),
    ...(input.ReplicationInstanceArn !== undefined && {
      ReplicationInstanceArn: input.ReplicationInstanceArn
    })
  };
};

const serializeAws_json1_1CreateEndpointMessage = (
  input: CreateEndpointMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.CertificateArn !== undefined && {
      CertificateArn: input.CertificateArn
    }),
    ...(input.DatabaseName !== undefined && {
      DatabaseName: input.DatabaseName
    }),
    ...(input.DmsTransferSettings !== undefined && {
      DmsTransferSettings: serializeAws_json1_1DmsTransferSettings(
        input.DmsTransferSettings,
        context
      )
    }),
    ...(input.DynamoDbSettings !== undefined && {
      DynamoDbSettings: serializeAws_json1_1DynamoDbSettings(
        input.DynamoDbSettings,
        context
      )
    }),
    ...(input.ElasticsearchSettings !== undefined && {
      ElasticsearchSettings: serializeAws_json1_1ElasticsearchSettings(
        input.ElasticsearchSettings,
        context
      )
    }),
    ...(input.EndpointIdentifier !== undefined && {
      EndpointIdentifier: input.EndpointIdentifier
    }),
    ...(input.EndpointType !== undefined && {
      EndpointType: input.EndpointType
    }),
    ...(input.EngineName !== undefined && { EngineName: input.EngineName }),
    ...(input.ExternalTableDefinition !== undefined && {
      ExternalTableDefinition: input.ExternalTableDefinition
    }),
    ...(input.ExtraConnectionAttributes !== undefined && {
      ExtraConnectionAttributes: input.ExtraConnectionAttributes
    }),
    ...(input.KinesisSettings !== undefined && {
      KinesisSettings: serializeAws_json1_1KinesisSettings(
        input.KinesisSettings,
        context
      )
    }),
    ...(input.KmsKeyId !== undefined && { KmsKeyId: input.KmsKeyId }),
    ...(input.MongoDbSettings !== undefined && {
      MongoDbSettings: serializeAws_json1_1MongoDbSettings(
        input.MongoDbSettings,
        context
      )
    }),
    ...(input.Password !== undefined && { Password: input.Password }),
    ...(input.Port !== undefined && { Port: input.Port }),
    ...(input.RedshiftSettings !== undefined && {
      RedshiftSettings: serializeAws_json1_1RedshiftSettings(
        input.RedshiftSettings,
        context
      )
    }),
    ...(input.S3Settings !== undefined && {
      S3Settings: serializeAws_json1_1S3Settings(input.S3Settings, context)
    }),
    ...(input.ServerName !== undefined && { ServerName: input.ServerName }),
    ...(input.ServiceAccessRoleArn !== undefined && {
      ServiceAccessRoleArn: input.ServiceAccessRoleArn
    }),
    ...(input.SslMode !== undefined && { SslMode: input.SslMode }),
    ...(input.Tags !== undefined && {
      Tags: serializeAws_json1_1TagList(input.Tags, context)
    }),
    ...(input.Username !== undefined && { Username: input.Username })
  };
};

const serializeAws_json1_1CreateEventSubscriptionMessage = (
  input: CreateEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Enabled !== undefined && { Enabled: input.Enabled }),
    ...(input.EventCategories !== undefined && {
      EventCategories: serializeAws_json1_1EventCategoriesList(
        input.EventCategories,
        context
      )
    }),
    ...(input.SnsTopicArn !== undefined && { SnsTopicArn: input.SnsTopicArn }),
    ...(input.SourceIds !== undefined && {
      SourceIds: serializeAws_json1_1SourceIdsList(input.SourceIds, context)
    }),
    ...(input.SourceType !== undefined && { SourceType: input.SourceType }),
    ...(input.SubscriptionName !== undefined && {
      SubscriptionName: input.SubscriptionName
    }),
    ...(input.Tags !== undefined && {
      Tags: serializeAws_json1_1TagList(input.Tags, context)
    })
  };
};

const serializeAws_json1_1CreateReplicationInstanceMessage = (
  input: CreateReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.AllocatedStorage !== undefined && {
      AllocatedStorage: input.AllocatedStorage
    }),
    ...(input.AutoMinorVersionUpgrade !== undefined && {
      AutoMinorVersionUpgrade: input.AutoMinorVersionUpgrade
    }),
    ...(input.AvailabilityZone !== undefined && {
      AvailabilityZone: input.AvailabilityZone
    }),
    ...(input.DnsNameServers !== undefined && {
      DnsNameServers: input.DnsNameServers
    }),
    ...(input.EngineVersion !== undefined && {
      EngineVersion: input.EngineVersion
    }),
    ...(input.KmsKeyId !== undefined && { KmsKeyId: input.KmsKeyId }),
    ...(input.MultiAZ !== undefined && { MultiAZ: input.MultiAZ }),
    ...(input.PreferredMaintenanceWindow !== undefined && {
      PreferredMaintenanceWindow: input.PreferredMaintenanceWindow
    }),
    ...(input.PubliclyAccessible !== undefined && {
      PubliclyAccessible: input.PubliclyAccessible
    }),
    ...(input.ReplicationInstanceClass !== undefined && {
      ReplicationInstanceClass: input.ReplicationInstanceClass
    }),
    ...(input.ReplicationInstanceIdentifier !== undefined && {
      ReplicationInstanceIdentifier: input.ReplicationInstanceIdentifier
    }),
    ...(input.ReplicationSubnetGroupIdentifier !== undefined && {
      ReplicationSubnetGroupIdentifier: input.ReplicationSubnetGroupIdentifier
    }),
    ...(input.Tags !== undefined && {
      Tags: serializeAws_json1_1TagList(input.Tags, context)
    }),
    ...(input.VpcSecurityGroupIds !== undefined && {
      VpcSecurityGroupIds: serializeAws_json1_1VpcSecurityGroupIdList(
        input.VpcSecurityGroupIds,
        context
      )
    })
  };
};

const serializeAws_json1_1CreateReplicationSubnetGroupMessage = (
  input: CreateReplicationSubnetGroupMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ReplicationSubnetGroupDescription !== undefined && {
      ReplicationSubnetGroupDescription: input.ReplicationSubnetGroupDescription
    }),
    ...(input.ReplicationSubnetGroupIdentifier !== undefined && {
      ReplicationSubnetGroupIdentifier: input.ReplicationSubnetGroupIdentifier
    }),
    ...(input.SubnetIds !== undefined && {
      SubnetIds: serializeAws_json1_1SubnetIdentifierList(
        input.SubnetIds,
        context
      )
    }),
    ...(input.Tags !== undefined && {
      Tags: serializeAws_json1_1TagList(input.Tags, context)
    })
  };
};

const serializeAws_json1_1CreateReplicationTaskMessage = (
  input: CreateReplicationTaskMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.CdcStartPosition !== undefined && {
      CdcStartPosition: input.CdcStartPosition
    }),
    ...(input.CdcStartTime !== undefined && {
      CdcStartTime: Math.round(input.CdcStartTime.getTime() / 1000)
    }),
    ...(input.CdcStopPosition !== undefined && {
      CdcStopPosition: input.CdcStopPosition
    }),
    ...(input.MigrationType !== undefined && {
      MigrationType: input.MigrationType
    }),
    ...(input.ReplicationInstanceArn !== undefined && {
      ReplicationInstanceArn: input.ReplicationInstanceArn
    }),
    ...(input.ReplicationTaskIdentifier !== undefined && {
      ReplicationTaskIdentifier: input.ReplicationTaskIdentifier
    }),
    ...(input.ReplicationTaskSettings !== undefined && {
      ReplicationTaskSettings: input.ReplicationTaskSettings
    }),
    ...(input.SourceEndpointArn !== undefined && {
      SourceEndpointArn: input.SourceEndpointArn
    }),
    ...(input.TableMappings !== undefined && {
      TableMappings: input.TableMappings
    }),
    ...(input.Tags !== undefined && {
      Tags: serializeAws_json1_1TagList(input.Tags, context)
    }),
    ...(input.TargetEndpointArn !== undefined && {
      TargetEndpointArn: input.TargetEndpointArn
    })
  };
};

const serializeAws_json1_1DeleteCertificateMessage = (
  input: DeleteCertificateMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.CertificateArn !== undefined && {
      CertificateArn: input.CertificateArn
    })
  };
};

const serializeAws_json1_1DeleteConnectionMessage = (
  input: DeleteConnectionMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn }),
    ...(input.ReplicationInstanceArn !== undefined && {
      ReplicationInstanceArn: input.ReplicationInstanceArn
    })
  };
};

const serializeAws_json1_1DeleteEndpointMessage = (
  input: DeleteEndpointMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn })
  };
};

const serializeAws_json1_1DeleteEventSubscriptionMessage = (
  input: DeleteEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.SubscriptionName !== undefined && {
      SubscriptionName: input.SubscriptionName
    })
  };
};

const serializeAws_json1_1DeleteReplicationInstanceMessage = (
  input: DeleteReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ReplicationInstanceArn !== undefined && {
      ReplicationInstanceArn: input.ReplicationInstanceArn
    })
  };
};

const serializeAws_json1_1DeleteReplicationSubnetGroupMessage = (
  input: DeleteReplicationSubnetGroupMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ReplicationSubnetGroupIdentifier !== undefined && {
      ReplicationSubnetGroupIdentifier: input.ReplicationSubnetGroupIdentifier
    })
  };
};

const serializeAws_json1_1DeleteReplicationTaskMessage = (
  input: DeleteReplicationTaskMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ReplicationTaskArn !== undefined && {
      ReplicationTaskArn: input.ReplicationTaskArn
    })
  };
};

const serializeAws_json1_1DescribeAccountAttributesMessage = (
  input: DescribeAccountAttributesMessage,
  context: __SerdeContext
): any => {
  return {};
};

const serializeAws_json1_1DescribeCertificatesMessage = (
  input: DescribeCertificatesMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords })
  };
};

const serializeAws_json1_1DescribeConnectionsMessage = (
  input: DescribeConnectionsMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords })
  };
};

const serializeAws_json1_1DescribeEndpointsMessage = (
  input: DescribeEndpointsMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords })
  };
};

const serializeAws_json1_1DescribeEndpointTypesMessage = (
  input: DescribeEndpointTypesMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords })
  };
};

const serializeAws_json1_1DescribeEventCategoriesMessage = (
  input: DescribeEventCategoriesMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.SourceType !== undefined && { SourceType: input.SourceType })
  };
};

const serializeAws_json1_1DescribeEventsMessage = (
  input: DescribeEventsMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Duration !== undefined && { Duration: input.Duration }),
    ...(input.EndTime !== undefined && {
      EndTime: Math.round(input.EndTime.getTime() / 1000)
    }),
    ...(input.EventCategories !== undefined && {
      EventCategories: serializeAws_json1_1EventCategoriesList(
        input.EventCategories,
        context
      )
    }),
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords }),
    ...(input.SourceIdentifier !== undefined && {
      SourceIdentifier: input.SourceIdentifier
    }),
    ...(input.SourceType !== undefined && { SourceType: input.SourceType }),
    ...(input.StartTime !== undefined && {
      StartTime: Math.round(input.StartTime.getTime() / 1000)
    })
  };
};

const serializeAws_json1_1DescribeEventSubscriptionsMessage = (
  input: DescribeEventSubscriptionsMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords }),
    ...(input.SubscriptionName !== undefined && {
      SubscriptionName: input.SubscriptionName
    })
  };
};

const serializeAws_json1_1DescribeOrderableReplicationInstancesMessage = (
  input: DescribeOrderableReplicationInstancesMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords })
  };
};

const serializeAws_json1_1DescribePendingMaintenanceActionsMessage = (
  input: DescribePendingMaintenanceActionsMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords }),
    ...(input.ReplicationInstanceArn !== undefined && {
      ReplicationInstanceArn: input.ReplicationInstanceArn
    })
  };
};

const serializeAws_json1_1DescribeRefreshSchemasStatusMessage = (
  input: DescribeRefreshSchemasStatusMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn })
  };
};

const serializeAws_json1_1DescribeReplicationInstancesMessage = (
  input: DescribeReplicationInstancesMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords })
  };
};

const serializeAws_json1_1DescribeReplicationInstanceTaskLogsMessage = (
  input: DescribeReplicationInstanceTaskLogsMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords }),
    ...(input.ReplicationInstanceArn !== undefined && {
      ReplicationInstanceArn: input.ReplicationInstanceArn
    })
  };
};

const serializeAws_json1_1DescribeReplicationSubnetGroupsMessage = (
  input: DescribeReplicationSubnetGroupsMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords })
  };
};

const serializeAws_json1_1DescribeReplicationTaskAssessmentResultsMessage = (
  input: DescribeReplicationTaskAssessmentResultsMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords }),
    ...(input.ReplicationTaskArn !== undefined && {
      ReplicationTaskArn: input.ReplicationTaskArn
    })
  };
};

const serializeAws_json1_1DescribeReplicationTasksMessage = (
  input: DescribeReplicationTasksMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords }),
    ...(input.WithoutSettings !== undefined && {
      WithoutSettings: input.WithoutSettings
    })
  };
};

const serializeAws_json1_1DescribeSchemasMessage = (
  input: DescribeSchemasMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords })
  };
};

const serializeAws_json1_1DescribeTableStatisticsMessage = (
  input: DescribeTableStatisticsMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Filters !== undefined && {
      Filters: serializeAws_json1_1FilterList(input.Filters, context)
    }),
    ...(input.Marker !== undefined && { Marker: input.Marker }),
    ...(input.MaxRecords !== undefined && { MaxRecords: input.MaxRecords }),
    ...(input.ReplicationTaskArn !== undefined && {
      ReplicationTaskArn: input.ReplicationTaskArn
    })
  };
};

const serializeAws_json1_1DmsTransferSettings = (
  input: DmsTransferSettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.BucketName !== undefined && { BucketName: input.BucketName }),
    ...(input.ServiceAccessRoleArn !== undefined && {
      ServiceAccessRoleArn: input.ServiceAccessRoleArn
    })
  };
};

const serializeAws_json1_1DynamoDbSettings = (
  input: DynamoDbSettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.ServiceAccessRoleArn !== undefined && {
      ServiceAccessRoleArn: input.ServiceAccessRoleArn
    })
  };
};

const serializeAws_json1_1ElasticsearchSettings = (
  input: ElasticsearchSettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.EndpointUri !== undefined && { EndpointUri: input.EndpointUri }),
    ...(input.ErrorRetryDuration !== undefined && {
      ErrorRetryDuration: input.ErrorRetryDuration
    }),
    ...(input.FullLoadErrorPercentage !== undefined && {
      FullLoadErrorPercentage: input.FullLoadErrorPercentage
    }),
    ...(input.ServiceAccessRoleArn !== undefined && {
      ServiceAccessRoleArn: input.ServiceAccessRoleArn
    })
  };
};

const serializeAws_json1_1EventCategoriesList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const serializeAws_json1_1Filter = (
  input: Filter,
  context: __SerdeContext
): any => {
  return {
    ...(input.Name !== undefined && { Name: input.Name }),
    ...(input.Values !== undefined && {
      Values: serializeAws_json1_1FilterValueList(input.Values, context)
    })
  };
};

const serializeAws_json1_1FilterList = (
  input: Filter[],
  context: __SerdeContext
): any => {
  return input.map(entry => serializeAws_json1_1Filter(entry, context));
};

const serializeAws_json1_1FilterValueList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const serializeAws_json1_1ImportCertificateMessage = (
  input: ImportCertificateMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.CertificateIdentifier !== undefined && {
      CertificateIdentifier: input.CertificateIdentifier
    }),
    ...(input.CertificatePem !== undefined && {
      CertificatePem: input.CertificatePem
    }),
    ...(input.CertificateWallet !== undefined && {
      CertificateWallet: context.base64Encoder(input.CertificateWallet)
    }),
    ...(input.Tags !== undefined && {
      Tags: serializeAws_json1_1TagList(input.Tags, context)
    })
  };
};

const serializeAws_json1_1KeyList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const serializeAws_json1_1KinesisSettings = (
  input: KinesisSettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.MessageFormat !== undefined && {
      MessageFormat: input.MessageFormat
    }),
    ...(input.ServiceAccessRoleArn !== undefined && {
      ServiceAccessRoleArn: input.ServiceAccessRoleArn
    }),
    ...(input.StreamArn !== undefined && { StreamArn: input.StreamArn })
  };
};

const serializeAws_json1_1ListTagsForResourceMessage = (
  input: ListTagsForResourceMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn })
  };
};

const serializeAws_json1_1ModifyEndpointMessage = (
  input: ModifyEndpointMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.CertificateArn !== undefined && {
      CertificateArn: input.CertificateArn
    }),
    ...(input.DatabaseName !== undefined && {
      DatabaseName: input.DatabaseName
    }),
    ...(input.DmsTransferSettings !== undefined && {
      DmsTransferSettings: serializeAws_json1_1DmsTransferSettings(
        input.DmsTransferSettings,
        context
      )
    }),
    ...(input.DynamoDbSettings !== undefined && {
      DynamoDbSettings: serializeAws_json1_1DynamoDbSettings(
        input.DynamoDbSettings,
        context
      )
    }),
    ...(input.ElasticsearchSettings !== undefined && {
      ElasticsearchSettings: serializeAws_json1_1ElasticsearchSettings(
        input.ElasticsearchSettings,
        context
      )
    }),
    ...(input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn }),
    ...(input.EndpointIdentifier !== undefined && {
      EndpointIdentifier: input.EndpointIdentifier
    }),
    ...(input.EndpointType !== undefined && {
      EndpointType: input.EndpointType
    }),
    ...(input.EngineName !== undefined && { EngineName: input.EngineName }),
    ...(input.ExternalTableDefinition !== undefined && {
      ExternalTableDefinition: input.ExternalTableDefinition
    }),
    ...(input.ExtraConnectionAttributes !== undefined && {
      ExtraConnectionAttributes: input.ExtraConnectionAttributes
    }),
    ...(input.KinesisSettings !== undefined && {
      KinesisSettings: serializeAws_json1_1KinesisSettings(
        input.KinesisSettings,
        context
      )
    }),
    ...(input.MongoDbSettings !== undefined && {
      MongoDbSettings: serializeAws_json1_1MongoDbSettings(
        input.MongoDbSettings,
        context
      )
    }),
    ...(input.Password !== undefined && { Password: input.Password }),
    ...(input.Port !== undefined && { Port: input.Port }),
    ...(input.RedshiftSettings !== undefined && {
      RedshiftSettings: serializeAws_json1_1RedshiftSettings(
        input.RedshiftSettings,
        context
      )
    }),
    ...(input.S3Settings !== undefined && {
      S3Settings: serializeAws_json1_1S3Settings(input.S3Settings, context)
    }),
    ...(input.ServerName !== undefined && { ServerName: input.ServerName }),
    ...(input.ServiceAccessRoleArn !== undefined && {
      ServiceAccessRoleArn: input.ServiceAccessRoleArn
    }),
    ...(input.SslMode !== undefined && { SslMode: input.SslMode }),
    ...(input.Username !== undefined && { Username: input.Username })
  };
};

const serializeAws_json1_1ModifyEventSubscriptionMessage = (
  input: ModifyEventSubscriptionMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.Enabled !== undefined && { Enabled: input.Enabled }),
    ...(input.EventCategories !== undefined && {
      EventCategories: serializeAws_json1_1EventCategoriesList(
        input.EventCategories,
        context
      )
    }),
    ...(input.SnsTopicArn !== undefined && { SnsTopicArn: input.SnsTopicArn }),
    ...(input.SourceType !== undefined && { SourceType: input.SourceType }),
    ...(input.SubscriptionName !== undefined && {
      SubscriptionName: input.SubscriptionName
    })
  };
};

const serializeAws_json1_1ModifyReplicationInstanceMessage = (
  input: ModifyReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.AllocatedStorage !== undefined && {
      AllocatedStorage: input.AllocatedStorage
    }),
    ...(input.AllowMajorVersionUpgrade !== undefined && {
      AllowMajorVersionUpgrade: input.AllowMajorVersionUpgrade
    }),
    ...(input.ApplyImmediately !== undefined && {
      ApplyImmediately: input.ApplyImmediately
    }),
    ...(input.AutoMinorVersionUpgrade !== undefined && {
      AutoMinorVersionUpgrade: input.AutoMinorVersionUpgrade
    }),
    ...(input.EngineVersion !== undefined && {
      EngineVersion: input.EngineVersion
    }),
    ...(input.MultiAZ !== undefined && { MultiAZ: input.MultiAZ }),
    ...(input.PreferredMaintenanceWindow !== undefined && {
      PreferredMaintenanceWindow: input.PreferredMaintenanceWindow
    }),
    ...(input.ReplicationInstanceArn !== undefined && {
      ReplicationInstanceArn: input.ReplicationInstanceArn
    }),
    ...(input.ReplicationInstanceClass !== undefined && {
      ReplicationInstanceClass: input.ReplicationInstanceClass
    }),
    ...(input.ReplicationInstanceIdentifier !== undefined && {
      ReplicationInstanceIdentifier: input.ReplicationInstanceIdentifier
    }),
    ...(input.VpcSecurityGroupIds !== undefined && {
      VpcSecurityGroupIds: serializeAws_json1_1VpcSecurityGroupIdList(
        input.VpcSecurityGroupIds,
        context
      )
    })
  };
};

const serializeAws_json1_1ModifyReplicationSubnetGroupMessage = (
  input: ModifyReplicationSubnetGroupMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ReplicationSubnetGroupDescription !== undefined && {
      ReplicationSubnetGroupDescription: input.ReplicationSubnetGroupDescription
    }),
    ...(input.ReplicationSubnetGroupIdentifier !== undefined && {
      ReplicationSubnetGroupIdentifier: input.ReplicationSubnetGroupIdentifier
    }),
    ...(input.SubnetIds !== undefined && {
      SubnetIds: serializeAws_json1_1SubnetIdentifierList(
        input.SubnetIds,
        context
      )
    })
  };
};

const serializeAws_json1_1ModifyReplicationTaskMessage = (
  input: ModifyReplicationTaskMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.CdcStartPosition !== undefined && {
      CdcStartPosition: input.CdcStartPosition
    }),
    ...(input.CdcStartTime !== undefined && {
      CdcStartTime: Math.round(input.CdcStartTime.getTime() / 1000)
    }),
    ...(input.CdcStopPosition !== undefined && {
      CdcStopPosition: input.CdcStopPosition
    }),
    ...(input.MigrationType !== undefined && {
      MigrationType: input.MigrationType
    }),
    ...(input.ReplicationTaskArn !== undefined && {
      ReplicationTaskArn: input.ReplicationTaskArn
    }),
    ...(input.ReplicationTaskIdentifier !== undefined && {
      ReplicationTaskIdentifier: input.ReplicationTaskIdentifier
    }),
    ...(input.ReplicationTaskSettings !== undefined && {
      ReplicationTaskSettings: input.ReplicationTaskSettings
    }),
    ...(input.TableMappings !== undefined && {
      TableMappings: input.TableMappings
    })
  };
};

const serializeAws_json1_1MongoDbSettings = (
  input: MongoDbSettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.AuthMechanism !== undefined && {
      AuthMechanism: input.AuthMechanism
    }),
    ...(input.AuthSource !== undefined && { AuthSource: input.AuthSource }),
    ...(input.AuthType !== undefined && { AuthType: input.AuthType }),
    ...(input.DatabaseName !== undefined && {
      DatabaseName: input.DatabaseName
    }),
    ...(input.DocsToInvestigate !== undefined && {
      DocsToInvestigate: input.DocsToInvestigate
    }),
    ...(input.ExtractDocId !== undefined && {
      ExtractDocId: input.ExtractDocId
    }),
    ...(input.KmsKeyId !== undefined && { KmsKeyId: input.KmsKeyId }),
    ...(input.NestingLevel !== undefined && {
      NestingLevel: input.NestingLevel
    }),
    ...(input.Password !== undefined && { Password: input.Password }),
    ...(input.Port !== undefined && { Port: input.Port }),
    ...(input.ServerName !== undefined && { ServerName: input.ServerName }),
    ...(input.Username !== undefined && { Username: input.Username })
  };
};

const serializeAws_json1_1RebootReplicationInstanceMessage = (
  input: RebootReplicationInstanceMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ForceFailover !== undefined && {
      ForceFailover: input.ForceFailover
    }),
    ...(input.ReplicationInstanceArn !== undefined && {
      ReplicationInstanceArn: input.ReplicationInstanceArn
    })
  };
};

const serializeAws_json1_1RedshiftSettings = (
  input: RedshiftSettings,
  context: __SerdeContext
): any => {
  return {
    ...(input.AcceptAnyDate !== undefined && {
      AcceptAnyDate: input.AcceptAnyDate
    }),
    ...(input.AfterConnectScript !== undefined && {
      AfterConnectScript: input.AfterConnectScript
    }),
    ...(input.BucketFolder !== undefined && {
      BucketFolder: input.BucketFolder
    }),
    ...(input.BucketName !== undefined && { BucketName: input.BucketName }),
    ...(input.ConnectionTimeout !== undefined && {
      ConnectionTimeout: input.ConnectionTimeout
    }),
    ...(input.DatabaseName !== undefined && {
      DatabaseName: input.DatabaseName
    }),
    ...(input.DateFormat !== undefined && { DateFormat: input.DateFormat }),
    ...(input.EmptyAsNull !== undefined && { EmptyAsNull: input.EmptyAsNull }),
    ...(input.EncryptionMode !== undefined && {
      EncryptionMode: input.EncryptionMode
    }),
    ...(input.FileTransferUploadStreams !== undefined && {
      FileTransferUploadStreams: input.FileTransferUploadStreams
    }),
    ...(input.LoadTimeout !== undefined && { LoadTimeout: input.LoadTimeout }),
    ...(input.MaxFileSize !== undefined && { MaxFileSize: input.MaxFileSize }),
    ...(input.Password !== undefined && { Password: input.Password }),
    ...(input.Port !== undefined && { Port: input.Port }),
    ...(input.RemoveQuotes !== undefined && {
      RemoveQuotes: input.RemoveQuotes
    }),
    ...(input.ReplaceChars !== undefined && {
      ReplaceChars: input.ReplaceChars
    }),
    ...(input.ReplaceInvalidChars !== undefined && {
      ReplaceInvalidChars: input.ReplaceInvalidChars
    }),
    ...(input.ServerName !== undefined && { ServerName: input.ServerName }),
    ...(input.ServerSideEncryptionKmsKeyId !== undefined && {
      ServerSideEncryptionKmsKeyId: input.ServerSideEncryptionKmsKeyId
    }),
    ...(input.ServiceAccessRoleArn !== undefined && {
      ServiceAccessRoleArn: input.ServiceAccessRoleArn
    }),
    ...(input.TimeFormat !== undefined && { TimeFormat: input.TimeFormat }),
    ...(input.TrimBlanks !== undefined && { TrimBlanks: input.TrimBlanks }),
    ...(input.TruncateColumns !== undefined && {
      TruncateColumns: input.TruncateColumns
    }),
    ...(input.Username !== undefined && { Username: input.Username }),
    ...(input.WriteBufferSize !== undefined && {
      WriteBufferSize: input.WriteBufferSize
    })
  };
};

const serializeAws_json1_1RefreshSchemasMessage = (
  input: RefreshSchemasMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn }),
    ...(input.ReplicationInstanceArn !== undefined && {
      ReplicationInstanceArn: input.ReplicationInstanceArn
    })
  };
};

const serializeAws_json1_1ReloadTablesMessage = (
  input: ReloadTablesMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ReloadOption !== undefined && {
      ReloadOption: input.ReloadOption
    }),
    ...(input.ReplicationTaskArn !== undefined && {
      ReplicationTaskArn: input.ReplicationTaskArn
    }),
    ...(input.TablesToReload !== undefined && {
      TablesToReload: serializeAws_json1_1TableListToReload(
        input.TablesToReload,
        context
      )
    })
  };
};

const serializeAws_json1_1RemoveTagsFromResourceMessage = (
  input: RemoveTagsFromResourceMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ResourceArn !== undefined && { ResourceArn: input.ResourceArn }),
    ...(input.TagKeys !== undefined && {
      TagKeys: serializeAws_json1_1KeyList(input.TagKeys, context)
    })
  };
};

const serializeAws_json1_1S3Settings = (
  input: S3Settings,
  context: __SerdeContext
): any => {
  return {
    ...(input.BucketFolder !== undefined && {
      BucketFolder: input.BucketFolder
    }),
    ...(input.BucketName !== undefined && { BucketName: input.BucketName }),
    ...(input.CdcInsertsOnly !== undefined && {
      CdcInsertsOnly: input.CdcInsertsOnly
    }),
    ...(input.CompressionType !== undefined && {
      CompressionType: input.CompressionType
    }),
    ...(input.CsvDelimiter !== undefined && {
      CsvDelimiter: input.CsvDelimiter
    }),
    ...(input.CsvRowDelimiter !== undefined && {
      CsvRowDelimiter: input.CsvRowDelimiter
    }),
    ...(input.DataFormat !== undefined && { DataFormat: input.DataFormat }),
    ...(input.DataPageSize !== undefined && {
      DataPageSize: input.DataPageSize
    }),
    ...(input.DictPageSizeLimit !== undefined && {
      DictPageSizeLimit: input.DictPageSizeLimit
    }),
    ...(input.EnableStatistics !== undefined && {
      EnableStatistics: input.EnableStatistics
    }),
    ...(input.EncodingType !== undefined && {
      EncodingType: input.EncodingType
    }),
    ...(input.EncryptionMode !== undefined && {
      EncryptionMode: input.EncryptionMode
    }),
    ...(input.ExternalTableDefinition !== undefined && {
      ExternalTableDefinition: input.ExternalTableDefinition
    }),
    ...(input.IncludeOpForFullLoad !== undefined && {
      IncludeOpForFullLoad: input.IncludeOpForFullLoad
    }),
    ...(input.ParquetTimestampInMillisecond !== undefined && {
      ParquetTimestampInMillisecond: input.ParquetTimestampInMillisecond
    }),
    ...(input.ParquetVersion !== undefined && {
      ParquetVersion: input.ParquetVersion
    }),
    ...(input.RowGroupLength !== undefined && {
      RowGroupLength: input.RowGroupLength
    }),
    ...(input.ServerSideEncryptionKmsKeyId !== undefined && {
      ServerSideEncryptionKmsKeyId: input.ServerSideEncryptionKmsKeyId
    }),
    ...(input.ServiceAccessRoleArn !== undefined && {
      ServiceAccessRoleArn: input.ServiceAccessRoleArn
    }),
    ...(input.TimestampColumnName !== undefined && {
      TimestampColumnName: input.TimestampColumnName
    })
  };
};

const serializeAws_json1_1SourceIdsList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const serializeAws_json1_1StartReplicationTaskAssessmentMessage = (
  input: StartReplicationTaskAssessmentMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ReplicationTaskArn !== undefined && {
      ReplicationTaskArn: input.ReplicationTaskArn
    })
  };
};

const serializeAws_json1_1StartReplicationTaskMessage = (
  input: StartReplicationTaskMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.CdcStartPosition !== undefined && {
      CdcStartPosition: input.CdcStartPosition
    }),
    ...(input.CdcStartTime !== undefined && {
      CdcStartTime: Math.round(input.CdcStartTime.getTime() / 1000)
    }),
    ...(input.CdcStopPosition !== undefined && {
      CdcStopPosition: input.CdcStopPosition
    }),
    ...(input.ReplicationTaskArn !== undefined && {
      ReplicationTaskArn: input.ReplicationTaskArn
    }),
    ...(input.StartReplicationTaskType !== undefined && {
      StartReplicationTaskType: input.StartReplicationTaskType
    })
  };
};

const serializeAws_json1_1StopReplicationTaskMessage = (
  input: StopReplicationTaskMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.ReplicationTaskArn !== undefined && {
      ReplicationTaskArn: input.ReplicationTaskArn
    })
  };
};

const serializeAws_json1_1SubnetIdentifierList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const serializeAws_json1_1TableListToReload = (
  input: TableToReload[],
  context: __SerdeContext
): any => {
  return input.map(entry => serializeAws_json1_1TableToReload(entry, context));
};

const serializeAws_json1_1TableToReload = (
  input: TableToReload,
  context: __SerdeContext
): any => {
  return {
    ...(input.SchemaName !== undefined && { SchemaName: input.SchemaName }),
    ...(input.TableName !== undefined && { TableName: input.TableName })
  };
};

const serializeAws_json1_1Tag = (input: Tag, context: __SerdeContext): any => {
  return {
    ...(input.Key !== undefined && { Key: input.Key }),
    ...(input.Value !== undefined && { Value: input.Value })
  };
};

const serializeAws_json1_1TagList = (
  input: Tag[],
  context: __SerdeContext
): any => {
  return input.map(entry => serializeAws_json1_1Tag(entry, context));
};

const serializeAws_json1_1TestConnectionMessage = (
  input: TestConnectionMessage,
  context: __SerdeContext
): any => {
  return {
    ...(input.EndpointArn !== undefined && { EndpointArn: input.EndpointArn }),
    ...(input.ReplicationInstanceArn !== undefined && {
      ReplicationInstanceArn: input.ReplicationInstanceArn
    })
  };
};

const serializeAws_json1_1VpcSecurityGroupIdList = (
  input: string[],
  context: __SerdeContext
): any => {
  return input.map(entry => entry);
};

const deserializeAws_json1_1AccessDeniedFault = (
  output: any,
  context: __SerdeContext
): AccessDeniedFault => {
  return {
    __type: "AccessDeniedFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1AccountQuota = (
  output: any,
  context: __SerdeContext
): AccountQuota => {
  return {
    __type: "AccountQuota",
    AccountQuotaName:
      output.AccountQuotaName !== undefined && output.AccountQuotaName !== null
        ? output.AccountQuotaName
        : undefined,
    Max:
      output.Max !== undefined && output.Max !== null ? output.Max : undefined,
    Used:
      output.Used !== undefined && output.Used !== null
        ? output.Used
        : undefined
  } as any;
};

const deserializeAws_json1_1AccountQuotaList = (
  output: any,
  context: __SerdeContext
): AccountQuota[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1AccountQuota(entry, context)
  );
};

const deserializeAws_json1_1AddTagsToResourceResponse = (
  output: any,
  context: __SerdeContext
): AddTagsToResourceResponse => {
  return {
    __type: "AddTagsToResourceResponse"
  } as any;
};

const deserializeAws_json1_1ApplyPendingMaintenanceActionResponse = (
  output: any,
  context: __SerdeContext
): ApplyPendingMaintenanceActionResponse => {
  return {
    __type: "ApplyPendingMaintenanceActionResponse",
    ResourcePendingMaintenanceActions:
      output.ResourcePendingMaintenanceActions !== undefined &&
      output.ResourcePendingMaintenanceActions !== null
        ? deserializeAws_json1_1ResourcePendingMaintenanceActions(
            output.ResourcePendingMaintenanceActions,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1AvailabilityZone = (
  output: any,
  context: __SerdeContext
): AvailabilityZone => {
  return {
    __type: "AvailabilityZone",
    Name:
      output.Name !== undefined && output.Name !== null
        ? output.Name
        : undefined
  } as any;
};

const deserializeAws_json1_1AvailabilityZonesList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1Certificate = (
  output: any,
  context: __SerdeContext
): Certificate => {
  return {
    __type: "Certificate",
    CertificateArn:
      output.CertificateArn !== undefined && output.CertificateArn !== null
        ? output.CertificateArn
        : undefined,
    CertificateCreationDate:
      output.CertificateCreationDate !== undefined &&
      output.CertificateCreationDate !== null
        ? new Date(Math.round(output.CertificateCreationDate * 1000))
        : undefined,
    CertificateIdentifier:
      output.CertificateIdentifier !== undefined &&
      output.CertificateIdentifier !== null
        ? output.CertificateIdentifier
        : undefined,
    CertificateOwner:
      output.CertificateOwner !== undefined && output.CertificateOwner !== null
        ? output.CertificateOwner
        : undefined,
    CertificatePem:
      output.CertificatePem !== undefined && output.CertificatePem !== null
        ? output.CertificatePem
        : undefined,
    CertificateWallet:
      output.CertificateWallet !== undefined &&
      output.CertificateWallet !== null
        ? context.base64Decoder(output.CertificateWallet)
        : undefined,
    KeyLength:
      output.KeyLength !== undefined && output.KeyLength !== null
        ? output.KeyLength
        : undefined,
    SigningAlgorithm:
      output.SigningAlgorithm !== undefined && output.SigningAlgorithm !== null
        ? output.SigningAlgorithm
        : undefined,
    ValidFromDate:
      output.ValidFromDate !== undefined && output.ValidFromDate !== null
        ? new Date(Math.round(output.ValidFromDate * 1000))
        : undefined,
    ValidToDate:
      output.ValidToDate !== undefined && output.ValidToDate !== null
        ? new Date(Math.round(output.ValidToDate * 1000))
        : undefined
  } as any;
};

const deserializeAws_json1_1CertificateList = (
  output: any,
  context: __SerdeContext
): Certificate[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Certificate(entry, context)
  );
};

const deserializeAws_json1_1Connection = (
  output: any,
  context: __SerdeContext
): Connection => {
  return {
    __type: "Connection",
    EndpointArn:
      output.EndpointArn !== undefined && output.EndpointArn !== null
        ? output.EndpointArn
        : undefined,
    EndpointIdentifier:
      output.EndpointIdentifier !== undefined &&
      output.EndpointIdentifier !== null
        ? output.EndpointIdentifier
        : undefined,
    LastFailureMessage:
      output.LastFailureMessage !== undefined &&
      output.LastFailureMessage !== null
        ? output.LastFailureMessage
        : undefined,
    ReplicationInstanceArn:
      output.ReplicationInstanceArn !== undefined &&
      output.ReplicationInstanceArn !== null
        ? output.ReplicationInstanceArn
        : undefined,
    ReplicationInstanceIdentifier:
      output.ReplicationInstanceIdentifier !== undefined &&
      output.ReplicationInstanceIdentifier !== null
        ? output.ReplicationInstanceIdentifier
        : undefined,
    Status:
      output.Status !== undefined && output.Status !== null
        ? output.Status
        : undefined
  } as any;
};

const deserializeAws_json1_1ConnectionList = (
  output: any,
  context: __SerdeContext
): Connection[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Connection(entry, context)
  );
};

const deserializeAws_json1_1CreateEndpointResponse = (
  output: any,
  context: __SerdeContext
): CreateEndpointResponse => {
  return {
    __type: "CreateEndpointResponse",
    Endpoint:
      output.Endpoint !== undefined && output.Endpoint !== null
        ? deserializeAws_json1_1Endpoint(output.Endpoint, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1CreateEventSubscriptionResponse = (
  output: any,
  context: __SerdeContext
): CreateEventSubscriptionResponse => {
  return {
    __type: "CreateEventSubscriptionResponse",
    EventSubscription:
      output.EventSubscription !== undefined &&
      output.EventSubscription !== null
        ? deserializeAws_json1_1EventSubscription(
            output.EventSubscription,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1CreateReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): CreateReplicationInstanceResponse => {
  return {
    __type: "CreateReplicationInstanceResponse",
    ReplicationInstance:
      output.ReplicationInstance !== undefined &&
      output.ReplicationInstance !== null
        ? deserializeAws_json1_1ReplicationInstance(
            output.ReplicationInstance,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1CreateReplicationSubnetGroupResponse = (
  output: any,
  context: __SerdeContext
): CreateReplicationSubnetGroupResponse => {
  return {
    __type: "CreateReplicationSubnetGroupResponse",
    ReplicationSubnetGroup:
      output.ReplicationSubnetGroup !== undefined &&
      output.ReplicationSubnetGroup !== null
        ? deserializeAws_json1_1ReplicationSubnetGroup(
            output.ReplicationSubnetGroup,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1CreateReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): CreateReplicationTaskResponse => {
  return {
    __type: "CreateReplicationTaskResponse",
    ReplicationTask:
      output.ReplicationTask !== undefined && output.ReplicationTask !== null
        ? deserializeAws_json1_1ReplicationTask(output.ReplicationTask, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DeleteCertificateResponse = (
  output: any,
  context: __SerdeContext
): DeleteCertificateResponse => {
  return {
    __type: "DeleteCertificateResponse",
    Certificate:
      output.Certificate !== undefined && output.Certificate !== null
        ? deserializeAws_json1_1Certificate(output.Certificate, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DeleteConnectionResponse = (
  output: any,
  context: __SerdeContext
): DeleteConnectionResponse => {
  return {
    __type: "DeleteConnectionResponse",
    Connection:
      output.Connection !== undefined && output.Connection !== null
        ? deserializeAws_json1_1Connection(output.Connection, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DeleteEndpointResponse = (
  output: any,
  context: __SerdeContext
): DeleteEndpointResponse => {
  return {
    __type: "DeleteEndpointResponse",
    Endpoint:
      output.Endpoint !== undefined && output.Endpoint !== null
        ? deserializeAws_json1_1Endpoint(output.Endpoint, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DeleteEventSubscriptionResponse = (
  output: any,
  context: __SerdeContext
): DeleteEventSubscriptionResponse => {
  return {
    __type: "DeleteEventSubscriptionResponse",
    EventSubscription:
      output.EventSubscription !== undefined &&
      output.EventSubscription !== null
        ? deserializeAws_json1_1EventSubscription(
            output.EventSubscription,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DeleteReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): DeleteReplicationInstanceResponse => {
  return {
    __type: "DeleteReplicationInstanceResponse",
    ReplicationInstance:
      output.ReplicationInstance !== undefined &&
      output.ReplicationInstance !== null
        ? deserializeAws_json1_1ReplicationInstance(
            output.ReplicationInstance,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DeleteReplicationSubnetGroupResponse = (
  output: any,
  context: __SerdeContext
): DeleteReplicationSubnetGroupResponse => {
  return {
    __type: "DeleteReplicationSubnetGroupResponse"
  } as any;
};

const deserializeAws_json1_1DeleteReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): DeleteReplicationTaskResponse => {
  return {
    __type: "DeleteReplicationTaskResponse",
    ReplicationTask:
      output.ReplicationTask !== undefined && output.ReplicationTask !== null
        ? deserializeAws_json1_1ReplicationTask(output.ReplicationTask, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeAccountAttributesResponse = (
  output: any,
  context: __SerdeContext
): DescribeAccountAttributesResponse => {
  return {
    __type: "DescribeAccountAttributesResponse",
    AccountQuotas:
      output.AccountQuotas !== undefined && output.AccountQuotas !== null
        ? deserializeAws_json1_1AccountQuotaList(output.AccountQuotas, context)
        : undefined,
    UniqueAccountIdentifier:
      output.UniqueAccountIdentifier !== undefined &&
      output.UniqueAccountIdentifier !== null
        ? output.UniqueAccountIdentifier
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeCertificatesResponse = (
  output: any,
  context: __SerdeContext
): DescribeCertificatesResponse => {
  return {
    __type: "DescribeCertificatesResponse",
    Certificates:
      output.Certificates !== undefined && output.Certificates !== null
        ? deserializeAws_json1_1CertificateList(output.Certificates, context)
        : undefined,
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeConnectionsResponse = (
  output: any,
  context: __SerdeContext
): DescribeConnectionsResponse => {
  return {
    __type: "DescribeConnectionsResponse",
    Connections:
      output.Connections !== undefined && output.Connections !== null
        ? deserializeAws_json1_1ConnectionList(output.Connections, context)
        : undefined,
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeEndpointsResponse = (
  output: any,
  context: __SerdeContext
): DescribeEndpointsResponse => {
  return {
    __type: "DescribeEndpointsResponse",
    Endpoints:
      output.Endpoints !== undefined && output.Endpoints !== null
        ? deserializeAws_json1_1EndpointList(output.Endpoints, context)
        : undefined,
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeEndpointTypesResponse = (
  output: any,
  context: __SerdeContext
): DescribeEndpointTypesResponse => {
  return {
    __type: "DescribeEndpointTypesResponse",
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined,
    SupportedEndpointTypes:
      output.SupportedEndpointTypes !== undefined &&
      output.SupportedEndpointTypes !== null
        ? deserializeAws_json1_1SupportedEndpointTypeList(
            output.SupportedEndpointTypes,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeEventCategoriesResponse = (
  output: any,
  context: __SerdeContext
): DescribeEventCategoriesResponse => {
  return {
    __type: "DescribeEventCategoriesResponse",
    EventCategoryGroupList:
      output.EventCategoryGroupList !== undefined &&
      output.EventCategoryGroupList !== null
        ? deserializeAws_json1_1EventCategoryGroupList(
            output.EventCategoryGroupList,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeEventsResponse = (
  output: any,
  context: __SerdeContext
): DescribeEventsResponse => {
  return {
    __type: "DescribeEventsResponse",
    Events:
      output.Events !== undefined && output.Events !== null
        ? deserializeAws_json1_1EventList(output.Events, context)
        : undefined,
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeEventSubscriptionsResponse = (
  output: any,
  context: __SerdeContext
): DescribeEventSubscriptionsResponse => {
  return {
    __type: "DescribeEventSubscriptionsResponse",
    EventSubscriptionsList:
      output.EventSubscriptionsList !== undefined &&
      output.EventSubscriptionsList !== null
        ? deserializeAws_json1_1EventSubscriptionsList(
            output.EventSubscriptionsList,
            context
          )
        : undefined,
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeOrderableReplicationInstancesResponse = (
  output: any,
  context: __SerdeContext
): DescribeOrderableReplicationInstancesResponse => {
  return {
    __type: "DescribeOrderableReplicationInstancesResponse",
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined,
    OrderableReplicationInstances:
      output.OrderableReplicationInstances !== undefined &&
      output.OrderableReplicationInstances !== null
        ? deserializeAws_json1_1OrderableReplicationInstanceList(
            output.OrderableReplicationInstances,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribePendingMaintenanceActionsResponse = (
  output: any,
  context: __SerdeContext
): DescribePendingMaintenanceActionsResponse => {
  return {
    __type: "DescribePendingMaintenanceActionsResponse",
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined,
    PendingMaintenanceActions:
      output.PendingMaintenanceActions !== undefined &&
      output.PendingMaintenanceActions !== null
        ? deserializeAws_json1_1PendingMaintenanceActions(
            output.PendingMaintenanceActions,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeRefreshSchemasStatusResponse = (
  output: any,
  context: __SerdeContext
): DescribeRefreshSchemasStatusResponse => {
  return {
    __type: "DescribeRefreshSchemasStatusResponse",
    RefreshSchemasStatus:
      output.RefreshSchemasStatus !== undefined &&
      output.RefreshSchemasStatus !== null
        ? deserializeAws_json1_1RefreshSchemasStatus(
            output.RefreshSchemasStatus,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeReplicationInstancesResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationInstancesResponse => {
  return {
    __type: "DescribeReplicationInstancesResponse",
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined,
    ReplicationInstances:
      output.ReplicationInstances !== undefined &&
      output.ReplicationInstances !== null
        ? deserializeAws_json1_1ReplicationInstanceList(
            output.ReplicationInstances,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeReplicationInstanceTaskLogsResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationInstanceTaskLogsResponse => {
  return {
    __type: "DescribeReplicationInstanceTaskLogsResponse",
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined,
    ReplicationInstanceArn:
      output.ReplicationInstanceArn !== undefined &&
      output.ReplicationInstanceArn !== null
        ? output.ReplicationInstanceArn
        : undefined,
    ReplicationInstanceTaskLogs:
      output.ReplicationInstanceTaskLogs !== undefined &&
      output.ReplicationInstanceTaskLogs !== null
        ? deserializeAws_json1_1ReplicationInstanceTaskLogsList(
            output.ReplicationInstanceTaskLogs,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeReplicationSubnetGroupsResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationSubnetGroupsResponse => {
  return {
    __type: "DescribeReplicationSubnetGroupsResponse",
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined,
    ReplicationSubnetGroups:
      output.ReplicationSubnetGroups !== undefined &&
      output.ReplicationSubnetGroups !== null
        ? deserializeAws_json1_1ReplicationSubnetGroups(
            output.ReplicationSubnetGroups,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeReplicationTaskAssessmentResultsResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationTaskAssessmentResultsResponse => {
  return {
    __type: "DescribeReplicationTaskAssessmentResultsResponse",
    BucketName:
      output.BucketName !== undefined && output.BucketName !== null
        ? output.BucketName
        : undefined,
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined,
    ReplicationTaskAssessmentResults:
      output.ReplicationTaskAssessmentResults !== undefined &&
      output.ReplicationTaskAssessmentResults !== null
        ? deserializeAws_json1_1ReplicationTaskAssessmentResultList(
            output.ReplicationTaskAssessmentResults,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeReplicationTasksResponse = (
  output: any,
  context: __SerdeContext
): DescribeReplicationTasksResponse => {
  return {
    __type: "DescribeReplicationTasksResponse",
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined,
    ReplicationTasks:
      output.ReplicationTasks !== undefined && output.ReplicationTasks !== null
        ? deserializeAws_json1_1ReplicationTaskList(
            output.ReplicationTasks,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeSchemasResponse = (
  output: any,
  context: __SerdeContext
): DescribeSchemasResponse => {
  return {
    __type: "DescribeSchemasResponse",
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined,
    Schemas:
      output.Schemas !== undefined && output.Schemas !== null
        ? deserializeAws_json1_1SchemaList(output.Schemas, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1DescribeTableStatisticsResponse = (
  output: any,
  context: __SerdeContext
): DescribeTableStatisticsResponse => {
  return {
    __type: "DescribeTableStatisticsResponse",
    Marker:
      output.Marker !== undefined && output.Marker !== null
        ? output.Marker
        : undefined,
    ReplicationTaskArn:
      output.ReplicationTaskArn !== undefined &&
      output.ReplicationTaskArn !== null
        ? output.ReplicationTaskArn
        : undefined,
    TableStatistics:
      output.TableStatistics !== undefined && output.TableStatistics !== null
        ? deserializeAws_json1_1TableStatisticsList(
            output.TableStatistics,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1DmsTransferSettings = (
  output: any,
  context: __SerdeContext
): DmsTransferSettings => {
  return {
    __type: "DmsTransferSettings",
    BucketName:
      output.BucketName !== undefined && output.BucketName !== null
        ? output.BucketName
        : undefined,
    ServiceAccessRoleArn:
      output.ServiceAccessRoleArn !== undefined &&
      output.ServiceAccessRoleArn !== null
        ? output.ServiceAccessRoleArn
        : undefined
  } as any;
};

const deserializeAws_json1_1DynamoDbSettings = (
  output: any,
  context: __SerdeContext
): DynamoDbSettings => {
  return {
    __type: "DynamoDbSettings",
    ServiceAccessRoleArn:
      output.ServiceAccessRoleArn !== undefined &&
      output.ServiceAccessRoleArn !== null
        ? output.ServiceAccessRoleArn
        : undefined
  } as any;
};

const deserializeAws_json1_1ElasticsearchSettings = (
  output: any,
  context: __SerdeContext
): ElasticsearchSettings => {
  return {
    __type: "ElasticsearchSettings",
    EndpointUri:
      output.EndpointUri !== undefined && output.EndpointUri !== null
        ? output.EndpointUri
        : undefined,
    ErrorRetryDuration:
      output.ErrorRetryDuration !== undefined &&
      output.ErrorRetryDuration !== null
        ? output.ErrorRetryDuration
        : undefined,
    FullLoadErrorPercentage:
      output.FullLoadErrorPercentage !== undefined &&
      output.FullLoadErrorPercentage !== null
        ? output.FullLoadErrorPercentage
        : undefined,
    ServiceAccessRoleArn:
      output.ServiceAccessRoleArn !== undefined &&
      output.ServiceAccessRoleArn !== null
        ? output.ServiceAccessRoleArn
        : undefined
  } as any;
};

const deserializeAws_json1_1Endpoint = (
  output: any,
  context: __SerdeContext
): Endpoint => {
  return {
    __type: "Endpoint",
    CertificateArn:
      output.CertificateArn !== undefined && output.CertificateArn !== null
        ? output.CertificateArn
        : undefined,
    DatabaseName:
      output.DatabaseName !== undefined && output.DatabaseName !== null
        ? output.DatabaseName
        : undefined,
    DmsTransferSettings:
      output.DmsTransferSettings !== undefined &&
      output.DmsTransferSettings !== null
        ? deserializeAws_json1_1DmsTransferSettings(
            output.DmsTransferSettings,
            context
          )
        : undefined,
    DynamoDbSettings:
      output.DynamoDbSettings !== undefined && output.DynamoDbSettings !== null
        ? deserializeAws_json1_1DynamoDbSettings(
            output.DynamoDbSettings,
            context
          )
        : undefined,
    ElasticsearchSettings:
      output.ElasticsearchSettings !== undefined &&
      output.ElasticsearchSettings !== null
        ? deserializeAws_json1_1ElasticsearchSettings(
            output.ElasticsearchSettings,
            context
          )
        : undefined,
    EndpointArn:
      output.EndpointArn !== undefined && output.EndpointArn !== null
        ? output.EndpointArn
        : undefined,
    EndpointIdentifier:
      output.EndpointIdentifier !== undefined &&
      output.EndpointIdentifier !== null
        ? output.EndpointIdentifier
        : undefined,
    EndpointType:
      output.EndpointType !== undefined && output.EndpointType !== null
        ? output.EndpointType
        : undefined,
    EngineDisplayName:
      output.EngineDisplayName !== undefined &&
      output.EngineDisplayName !== null
        ? output.EngineDisplayName
        : undefined,
    EngineName:
      output.EngineName !== undefined && output.EngineName !== null
        ? output.EngineName
        : undefined,
    ExternalId:
      output.ExternalId !== undefined && output.ExternalId !== null
        ? output.ExternalId
        : undefined,
    ExternalTableDefinition:
      output.ExternalTableDefinition !== undefined &&
      output.ExternalTableDefinition !== null
        ? output.ExternalTableDefinition
        : undefined,
    ExtraConnectionAttributes:
      output.ExtraConnectionAttributes !== undefined &&
      output.ExtraConnectionAttributes !== null
        ? output.ExtraConnectionAttributes
        : undefined,
    KinesisSettings:
      output.KinesisSettings !== undefined && output.KinesisSettings !== null
        ? deserializeAws_json1_1KinesisSettings(output.KinesisSettings, context)
        : undefined,
    KmsKeyId:
      output.KmsKeyId !== undefined && output.KmsKeyId !== null
        ? output.KmsKeyId
        : undefined,
    MongoDbSettings:
      output.MongoDbSettings !== undefined && output.MongoDbSettings !== null
        ? deserializeAws_json1_1MongoDbSettings(output.MongoDbSettings, context)
        : undefined,
    Port:
      output.Port !== undefined && output.Port !== null
        ? output.Port
        : undefined,
    RedshiftSettings:
      output.RedshiftSettings !== undefined && output.RedshiftSettings !== null
        ? deserializeAws_json1_1RedshiftSettings(
            output.RedshiftSettings,
            context
          )
        : undefined,
    S3Settings:
      output.S3Settings !== undefined && output.S3Settings !== null
        ? deserializeAws_json1_1S3Settings(output.S3Settings, context)
        : undefined,
    ServerName:
      output.ServerName !== undefined && output.ServerName !== null
        ? output.ServerName
        : undefined,
    ServiceAccessRoleArn:
      output.ServiceAccessRoleArn !== undefined &&
      output.ServiceAccessRoleArn !== null
        ? output.ServiceAccessRoleArn
        : undefined,
    SslMode:
      output.SslMode !== undefined && output.SslMode !== null
        ? output.SslMode
        : undefined,
    Status:
      output.Status !== undefined && output.Status !== null
        ? output.Status
        : undefined,
    Username:
      output.Username !== undefined && output.Username !== null
        ? output.Username
        : undefined
  } as any;
};

const deserializeAws_json1_1EndpointList = (
  output: any,
  context: __SerdeContext
): Endpoint[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Endpoint(entry, context)
  );
};

const deserializeAws_json1_1Event = (
  output: any,
  context: __SerdeContext
): Event => {
  return {
    __type: "Event",
    Date:
      output.Date !== undefined && output.Date !== null
        ? new Date(Math.round(output.Date * 1000))
        : undefined,
    EventCategories:
      output.EventCategories !== undefined && output.EventCategories !== null
        ? deserializeAws_json1_1EventCategoriesList(
            output.EventCategories,
            context
          )
        : undefined,
    Message:
      output.Message !== undefined && output.Message !== null
        ? output.Message
        : undefined,
    SourceIdentifier:
      output.SourceIdentifier !== undefined && output.SourceIdentifier !== null
        ? output.SourceIdentifier
        : undefined,
    SourceType:
      output.SourceType !== undefined && output.SourceType !== null
        ? output.SourceType
        : undefined
  } as any;
};

const deserializeAws_json1_1EventCategoriesList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1EventCategoryGroup = (
  output: any,
  context: __SerdeContext
): EventCategoryGroup => {
  return {
    __type: "EventCategoryGroup",
    EventCategories:
      output.EventCategories !== undefined && output.EventCategories !== null
        ? deserializeAws_json1_1EventCategoriesList(
            output.EventCategories,
            context
          )
        : undefined,
    SourceType:
      output.SourceType !== undefined && output.SourceType !== null
        ? output.SourceType
        : undefined
  } as any;
};

const deserializeAws_json1_1EventCategoryGroupList = (
  output: any,
  context: __SerdeContext
): EventCategoryGroup[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EventCategoryGroup(entry, context)
  );
};

const deserializeAws_json1_1EventList = (
  output: any,
  context: __SerdeContext
): Event[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Event(entry, context)
  );
};

const deserializeAws_json1_1EventSubscription = (
  output: any,
  context: __SerdeContext
): EventSubscription => {
  return {
    __type: "EventSubscription",
    CustSubscriptionId:
      output.CustSubscriptionId !== undefined &&
      output.CustSubscriptionId !== null
        ? output.CustSubscriptionId
        : undefined,
    CustomerAwsId:
      output.CustomerAwsId !== undefined && output.CustomerAwsId !== null
        ? output.CustomerAwsId
        : undefined,
    Enabled:
      output.Enabled !== undefined && output.Enabled !== null
        ? output.Enabled
        : undefined,
    EventCategoriesList:
      output.EventCategoriesList !== undefined &&
      output.EventCategoriesList !== null
        ? deserializeAws_json1_1EventCategoriesList(
            output.EventCategoriesList,
            context
          )
        : undefined,
    SnsTopicArn:
      output.SnsTopicArn !== undefined && output.SnsTopicArn !== null
        ? output.SnsTopicArn
        : undefined,
    SourceIdsList:
      output.SourceIdsList !== undefined && output.SourceIdsList !== null
        ? deserializeAws_json1_1SourceIdsList(output.SourceIdsList, context)
        : undefined,
    SourceType:
      output.SourceType !== undefined && output.SourceType !== null
        ? output.SourceType
        : undefined,
    Status:
      output.Status !== undefined && output.Status !== null
        ? output.Status
        : undefined,
    SubscriptionCreationTime:
      output.SubscriptionCreationTime !== undefined &&
      output.SubscriptionCreationTime !== null
        ? output.SubscriptionCreationTime
        : undefined
  } as any;
};

const deserializeAws_json1_1EventSubscriptionsList = (
  output: any,
  context: __SerdeContext
): EventSubscription[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1EventSubscription(entry, context)
  );
};

const deserializeAws_json1_1ImportCertificateResponse = (
  output: any,
  context: __SerdeContext
): ImportCertificateResponse => {
  return {
    __type: "ImportCertificateResponse",
    Certificate:
      output.Certificate !== undefined && output.Certificate !== null
        ? deserializeAws_json1_1Certificate(output.Certificate, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1InsufficientResourceCapacityFault = (
  output: any,
  context: __SerdeContext
): InsufficientResourceCapacityFault => {
  return {
    __type: "InsufficientResourceCapacityFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1InvalidCertificateFault = (
  output: any,
  context: __SerdeContext
): InvalidCertificateFault => {
  return {
    __type: "InvalidCertificateFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1InvalidResourceStateFault = (
  output: any,
  context: __SerdeContext
): InvalidResourceStateFault => {
  return {
    __type: "InvalidResourceStateFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1InvalidSubnet = (
  output: any,
  context: __SerdeContext
): InvalidSubnet => {
  return {
    __type: "InvalidSubnet",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1KinesisSettings = (
  output: any,
  context: __SerdeContext
): KinesisSettings => {
  return {
    __type: "KinesisSettings",
    MessageFormat:
      output.MessageFormat !== undefined && output.MessageFormat !== null
        ? output.MessageFormat
        : undefined,
    ServiceAccessRoleArn:
      output.ServiceAccessRoleArn !== undefined &&
      output.ServiceAccessRoleArn !== null
        ? output.ServiceAccessRoleArn
        : undefined,
    StreamArn:
      output.StreamArn !== undefined && output.StreamArn !== null
        ? output.StreamArn
        : undefined
  } as any;
};

const deserializeAws_json1_1KMSAccessDeniedFault = (
  output: any,
  context: __SerdeContext
): KMSAccessDeniedFault => {
  return {
    __type: "KMSAccessDeniedFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1KMSDisabledFault = (
  output: any,
  context: __SerdeContext
): KMSDisabledFault => {
  return {
    __type: "KMSDisabledFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1KMSInvalidStateFault = (
  output: any,
  context: __SerdeContext
): KMSInvalidStateFault => {
  return {
    __type: "KMSInvalidStateFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1KMSKeyNotAccessibleFault = (
  output: any,
  context: __SerdeContext
): KMSKeyNotAccessibleFault => {
  return {
    __type: "KMSKeyNotAccessibleFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1KMSNotFoundFault = (
  output: any,
  context: __SerdeContext
): KMSNotFoundFault => {
  return {
    __type: "KMSNotFoundFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1KMSThrottlingFault = (
  output: any,
  context: __SerdeContext
): KMSThrottlingFault => {
  return {
    __type: "KMSThrottlingFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1ListTagsForResourceResponse = (
  output: any,
  context: __SerdeContext
): ListTagsForResourceResponse => {
  return {
    __type: "ListTagsForResourceResponse",
    TagList:
      output.TagList !== undefined && output.TagList !== null
        ? deserializeAws_json1_1TagList(output.TagList, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1ModifyEndpointResponse = (
  output: any,
  context: __SerdeContext
): ModifyEndpointResponse => {
  return {
    __type: "ModifyEndpointResponse",
    Endpoint:
      output.Endpoint !== undefined && output.Endpoint !== null
        ? deserializeAws_json1_1Endpoint(output.Endpoint, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1ModifyEventSubscriptionResponse = (
  output: any,
  context: __SerdeContext
): ModifyEventSubscriptionResponse => {
  return {
    __type: "ModifyEventSubscriptionResponse",
    EventSubscription:
      output.EventSubscription !== undefined &&
      output.EventSubscription !== null
        ? deserializeAws_json1_1EventSubscription(
            output.EventSubscription,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1ModifyReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): ModifyReplicationInstanceResponse => {
  return {
    __type: "ModifyReplicationInstanceResponse",
    ReplicationInstance:
      output.ReplicationInstance !== undefined &&
      output.ReplicationInstance !== null
        ? deserializeAws_json1_1ReplicationInstance(
            output.ReplicationInstance,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1ModifyReplicationSubnetGroupResponse = (
  output: any,
  context: __SerdeContext
): ModifyReplicationSubnetGroupResponse => {
  return {
    __type: "ModifyReplicationSubnetGroupResponse",
    ReplicationSubnetGroup:
      output.ReplicationSubnetGroup !== undefined &&
      output.ReplicationSubnetGroup !== null
        ? deserializeAws_json1_1ReplicationSubnetGroup(
            output.ReplicationSubnetGroup,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1ModifyReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): ModifyReplicationTaskResponse => {
  return {
    __type: "ModifyReplicationTaskResponse",
    ReplicationTask:
      output.ReplicationTask !== undefined && output.ReplicationTask !== null
        ? deserializeAws_json1_1ReplicationTask(output.ReplicationTask, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1MongoDbSettings = (
  output: any,
  context: __SerdeContext
): MongoDbSettings => {
  return {
    __type: "MongoDbSettings",
    AuthMechanism:
      output.AuthMechanism !== undefined && output.AuthMechanism !== null
        ? output.AuthMechanism
        : undefined,
    AuthSource:
      output.AuthSource !== undefined && output.AuthSource !== null
        ? output.AuthSource
        : undefined,
    AuthType:
      output.AuthType !== undefined && output.AuthType !== null
        ? output.AuthType
        : undefined,
    DatabaseName:
      output.DatabaseName !== undefined && output.DatabaseName !== null
        ? output.DatabaseName
        : undefined,
    DocsToInvestigate:
      output.DocsToInvestigate !== undefined &&
      output.DocsToInvestigate !== null
        ? output.DocsToInvestigate
        : undefined,
    ExtractDocId:
      output.ExtractDocId !== undefined && output.ExtractDocId !== null
        ? output.ExtractDocId
        : undefined,
    KmsKeyId:
      output.KmsKeyId !== undefined && output.KmsKeyId !== null
        ? output.KmsKeyId
        : undefined,
    NestingLevel:
      output.NestingLevel !== undefined && output.NestingLevel !== null
        ? output.NestingLevel
        : undefined,
    Password:
      output.Password !== undefined && output.Password !== null
        ? output.Password
        : undefined,
    Port:
      output.Port !== undefined && output.Port !== null
        ? output.Port
        : undefined,
    ServerName:
      output.ServerName !== undefined && output.ServerName !== null
        ? output.ServerName
        : undefined,
    Username:
      output.Username !== undefined && output.Username !== null
        ? output.Username
        : undefined
  } as any;
};

const deserializeAws_json1_1OrderableReplicationInstance = (
  output: any,
  context: __SerdeContext
): OrderableReplicationInstance => {
  return {
    __type: "OrderableReplicationInstance",
    AvailabilityZones:
      output.AvailabilityZones !== undefined &&
      output.AvailabilityZones !== null
        ? deserializeAws_json1_1AvailabilityZonesList(
            output.AvailabilityZones,
            context
          )
        : undefined,
    DefaultAllocatedStorage:
      output.DefaultAllocatedStorage !== undefined &&
      output.DefaultAllocatedStorage !== null
        ? output.DefaultAllocatedStorage
        : undefined,
    EngineVersion:
      output.EngineVersion !== undefined && output.EngineVersion !== null
        ? output.EngineVersion
        : undefined,
    IncludedAllocatedStorage:
      output.IncludedAllocatedStorage !== undefined &&
      output.IncludedAllocatedStorage !== null
        ? output.IncludedAllocatedStorage
        : undefined,
    MaxAllocatedStorage:
      output.MaxAllocatedStorage !== undefined &&
      output.MaxAllocatedStorage !== null
        ? output.MaxAllocatedStorage
        : undefined,
    MinAllocatedStorage:
      output.MinAllocatedStorage !== undefined &&
      output.MinAllocatedStorage !== null
        ? output.MinAllocatedStorage
        : undefined,
    ReleaseStatus:
      output.ReleaseStatus !== undefined && output.ReleaseStatus !== null
        ? output.ReleaseStatus
        : undefined,
    ReplicationInstanceClass:
      output.ReplicationInstanceClass !== undefined &&
      output.ReplicationInstanceClass !== null
        ? output.ReplicationInstanceClass
        : undefined,
    StorageType:
      output.StorageType !== undefined && output.StorageType !== null
        ? output.StorageType
        : undefined
  } as any;
};

const deserializeAws_json1_1OrderableReplicationInstanceList = (
  output: any,
  context: __SerdeContext
): OrderableReplicationInstance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1OrderableReplicationInstance(entry, context)
  );
};

const deserializeAws_json1_1PendingMaintenanceAction = (
  output: any,
  context: __SerdeContext
): PendingMaintenanceAction => {
  return {
    __type: "PendingMaintenanceAction",
    Action:
      output.Action !== undefined && output.Action !== null
        ? output.Action
        : undefined,
    AutoAppliedAfterDate:
      output.AutoAppliedAfterDate !== undefined &&
      output.AutoAppliedAfterDate !== null
        ? new Date(Math.round(output.AutoAppliedAfterDate * 1000))
        : undefined,
    CurrentApplyDate:
      output.CurrentApplyDate !== undefined && output.CurrentApplyDate !== null
        ? new Date(Math.round(output.CurrentApplyDate * 1000))
        : undefined,
    Description:
      output.Description !== undefined && output.Description !== null
        ? output.Description
        : undefined,
    ForcedApplyDate:
      output.ForcedApplyDate !== undefined && output.ForcedApplyDate !== null
        ? new Date(Math.round(output.ForcedApplyDate * 1000))
        : undefined,
    OptInStatus:
      output.OptInStatus !== undefined && output.OptInStatus !== null
        ? output.OptInStatus
        : undefined
  } as any;
};

const deserializeAws_json1_1PendingMaintenanceActionDetails = (
  output: any,
  context: __SerdeContext
): PendingMaintenanceAction[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1PendingMaintenanceAction(entry, context)
  );
};

const deserializeAws_json1_1PendingMaintenanceActions = (
  output: any,
  context: __SerdeContext
): ResourcePendingMaintenanceActions[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ResourcePendingMaintenanceActions(entry, context)
  );
};

const deserializeAws_json1_1RebootReplicationInstanceResponse = (
  output: any,
  context: __SerdeContext
): RebootReplicationInstanceResponse => {
  return {
    __type: "RebootReplicationInstanceResponse",
    ReplicationInstance:
      output.ReplicationInstance !== undefined &&
      output.ReplicationInstance !== null
        ? deserializeAws_json1_1ReplicationInstance(
            output.ReplicationInstance,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1RedshiftSettings = (
  output: any,
  context: __SerdeContext
): RedshiftSettings => {
  return {
    __type: "RedshiftSettings",
    AcceptAnyDate:
      output.AcceptAnyDate !== undefined && output.AcceptAnyDate !== null
        ? output.AcceptAnyDate
        : undefined,
    AfterConnectScript:
      output.AfterConnectScript !== undefined &&
      output.AfterConnectScript !== null
        ? output.AfterConnectScript
        : undefined,
    BucketFolder:
      output.BucketFolder !== undefined && output.BucketFolder !== null
        ? output.BucketFolder
        : undefined,
    BucketName:
      output.BucketName !== undefined && output.BucketName !== null
        ? output.BucketName
        : undefined,
    ConnectionTimeout:
      output.ConnectionTimeout !== undefined &&
      output.ConnectionTimeout !== null
        ? output.ConnectionTimeout
        : undefined,
    DatabaseName:
      output.DatabaseName !== undefined && output.DatabaseName !== null
        ? output.DatabaseName
        : undefined,
    DateFormat:
      output.DateFormat !== undefined && output.DateFormat !== null
        ? output.DateFormat
        : undefined,
    EmptyAsNull:
      output.EmptyAsNull !== undefined && output.EmptyAsNull !== null
        ? output.EmptyAsNull
        : undefined,
    EncryptionMode:
      output.EncryptionMode !== undefined && output.EncryptionMode !== null
        ? output.EncryptionMode
        : undefined,
    FileTransferUploadStreams:
      output.FileTransferUploadStreams !== undefined &&
      output.FileTransferUploadStreams !== null
        ? output.FileTransferUploadStreams
        : undefined,
    LoadTimeout:
      output.LoadTimeout !== undefined && output.LoadTimeout !== null
        ? output.LoadTimeout
        : undefined,
    MaxFileSize:
      output.MaxFileSize !== undefined && output.MaxFileSize !== null
        ? output.MaxFileSize
        : undefined,
    Password:
      output.Password !== undefined && output.Password !== null
        ? output.Password
        : undefined,
    Port:
      output.Port !== undefined && output.Port !== null
        ? output.Port
        : undefined,
    RemoveQuotes:
      output.RemoveQuotes !== undefined && output.RemoveQuotes !== null
        ? output.RemoveQuotes
        : undefined,
    ReplaceChars:
      output.ReplaceChars !== undefined && output.ReplaceChars !== null
        ? output.ReplaceChars
        : undefined,
    ReplaceInvalidChars:
      output.ReplaceInvalidChars !== undefined &&
      output.ReplaceInvalidChars !== null
        ? output.ReplaceInvalidChars
        : undefined,
    ServerName:
      output.ServerName !== undefined && output.ServerName !== null
        ? output.ServerName
        : undefined,
    ServerSideEncryptionKmsKeyId:
      output.ServerSideEncryptionKmsKeyId !== undefined &&
      output.ServerSideEncryptionKmsKeyId !== null
        ? output.ServerSideEncryptionKmsKeyId
        : undefined,
    ServiceAccessRoleArn:
      output.ServiceAccessRoleArn !== undefined &&
      output.ServiceAccessRoleArn !== null
        ? output.ServiceAccessRoleArn
        : undefined,
    TimeFormat:
      output.TimeFormat !== undefined && output.TimeFormat !== null
        ? output.TimeFormat
        : undefined,
    TrimBlanks:
      output.TrimBlanks !== undefined && output.TrimBlanks !== null
        ? output.TrimBlanks
        : undefined,
    TruncateColumns:
      output.TruncateColumns !== undefined && output.TruncateColumns !== null
        ? output.TruncateColumns
        : undefined,
    Username:
      output.Username !== undefined && output.Username !== null
        ? output.Username
        : undefined,
    WriteBufferSize:
      output.WriteBufferSize !== undefined && output.WriteBufferSize !== null
        ? output.WriteBufferSize
        : undefined
  } as any;
};

const deserializeAws_json1_1RefreshSchemasResponse = (
  output: any,
  context: __SerdeContext
): RefreshSchemasResponse => {
  return {
    __type: "RefreshSchemasResponse",
    RefreshSchemasStatus:
      output.RefreshSchemasStatus !== undefined &&
      output.RefreshSchemasStatus !== null
        ? deserializeAws_json1_1RefreshSchemasStatus(
            output.RefreshSchemasStatus,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1RefreshSchemasStatus = (
  output: any,
  context: __SerdeContext
): RefreshSchemasStatus => {
  return {
    __type: "RefreshSchemasStatus",
    EndpointArn:
      output.EndpointArn !== undefined && output.EndpointArn !== null
        ? output.EndpointArn
        : undefined,
    LastFailureMessage:
      output.LastFailureMessage !== undefined &&
      output.LastFailureMessage !== null
        ? output.LastFailureMessage
        : undefined,
    LastRefreshDate:
      output.LastRefreshDate !== undefined && output.LastRefreshDate !== null
        ? new Date(Math.round(output.LastRefreshDate * 1000))
        : undefined,
    ReplicationInstanceArn:
      output.ReplicationInstanceArn !== undefined &&
      output.ReplicationInstanceArn !== null
        ? output.ReplicationInstanceArn
        : undefined,
    Status:
      output.Status !== undefined && output.Status !== null
        ? output.Status
        : undefined
  } as any;
};

const deserializeAws_json1_1ReloadTablesResponse = (
  output: any,
  context: __SerdeContext
): ReloadTablesResponse => {
  return {
    __type: "ReloadTablesResponse",
    ReplicationTaskArn:
      output.ReplicationTaskArn !== undefined &&
      output.ReplicationTaskArn !== null
        ? output.ReplicationTaskArn
        : undefined
  } as any;
};

const deserializeAws_json1_1RemoveTagsFromResourceResponse = (
  output: any,
  context: __SerdeContext
): RemoveTagsFromResourceResponse => {
  return {
    __type: "RemoveTagsFromResourceResponse"
  } as any;
};

const deserializeAws_json1_1ReplicationInstance = (
  output: any,
  context: __SerdeContext
): ReplicationInstance => {
  return {
    __type: "ReplicationInstance",
    AllocatedStorage:
      output.AllocatedStorage !== undefined && output.AllocatedStorage !== null
        ? output.AllocatedStorage
        : undefined,
    AutoMinorVersionUpgrade:
      output.AutoMinorVersionUpgrade !== undefined &&
      output.AutoMinorVersionUpgrade !== null
        ? output.AutoMinorVersionUpgrade
        : undefined,
    AvailabilityZone:
      output.AvailabilityZone !== undefined && output.AvailabilityZone !== null
        ? output.AvailabilityZone
        : undefined,
    DnsNameServers:
      output.DnsNameServers !== undefined && output.DnsNameServers !== null
        ? output.DnsNameServers
        : undefined,
    EngineVersion:
      output.EngineVersion !== undefined && output.EngineVersion !== null
        ? output.EngineVersion
        : undefined,
    FreeUntil:
      output.FreeUntil !== undefined && output.FreeUntil !== null
        ? new Date(Math.round(output.FreeUntil * 1000))
        : undefined,
    InstanceCreateTime:
      output.InstanceCreateTime !== undefined &&
      output.InstanceCreateTime !== null
        ? new Date(Math.round(output.InstanceCreateTime * 1000))
        : undefined,
    KmsKeyId:
      output.KmsKeyId !== undefined && output.KmsKeyId !== null
        ? output.KmsKeyId
        : undefined,
    MultiAZ:
      output.MultiAZ !== undefined && output.MultiAZ !== null
        ? output.MultiAZ
        : undefined,
    PendingModifiedValues:
      output.PendingModifiedValues !== undefined &&
      output.PendingModifiedValues !== null
        ? deserializeAws_json1_1ReplicationPendingModifiedValues(
            output.PendingModifiedValues,
            context
          )
        : undefined,
    PreferredMaintenanceWindow:
      output.PreferredMaintenanceWindow !== undefined &&
      output.PreferredMaintenanceWindow !== null
        ? output.PreferredMaintenanceWindow
        : undefined,
    PubliclyAccessible:
      output.PubliclyAccessible !== undefined &&
      output.PubliclyAccessible !== null
        ? output.PubliclyAccessible
        : undefined,
    ReplicationInstanceArn:
      output.ReplicationInstanceArn !== undefined &&
      output.ReplicationInstanceArn !== null
        ? output.ReplicationInstanceArn
        : undefined,
    ReplicationInstanceClass:
      output.ReplicationInstanceClass !== undefined &&
      output.ReplicationInstanceClass !== null
        ? output.ReplicationInstanceClass
        : undefined,
    ReplicationInstanceIdentifier:
      output.ReplicationInstanceIdentifier !== undefined &&
      output.ReplicationInstanceIdentifier !== null
        ? output.ReplicationInstanceIdentifier
        : undefined,
    ReplicationInstancePrivateIpAddress:
      output.ReplicationInstancePrivateIpAddress !== undefined &&
      output.ReplicationInstancePrivateIpAddress !== null
        ? output.ReplicationInstancePrivateIpAddress
        : undefined,
    ReplicationInstancePrivateIpAddresses:
      output.ReplicationInstancePrivateIpAddresses !== undefined &&
      output.ReplicationInstancePrivateIpAddresses !== null
        ? deserializeAws_json1_1ReplicationInstancePrivateIpAddressList(
            output.ReplicationInstancePrivateIpAddresses,
            context
          )
        : undefined,
    ReplicationInstancePublicIpAddress:
      output.ReplicationInstancePublicIpAddress !== undefined &&
      output.ReplicationInstancePublicIpAddress !== null
        ? output.ReplicationInstancePublicIpAddress
        : undefined,
    ReplicationInstancePublicIpAddresses:
      output.ReplicationInstancePublicIpAddresses !== undefined &&
      output.ReplicationInstancePublicIpAddresses !== null
        ? deserializeAws_json1_1ReplicationInstancePublicIpAddressList(
            output.ReplicationInstancePublicIpAddresses,
            context
          )
        : undefined,
    ReplicationInstanceStatus:
      output.ReplicationInstanceStatus !== undefined &&
      output.ReplicationInstanceStatus !== null
        ? output.ReplicationInstanceStatus
        : undefined,
    ReplicationSubnetGroup:
      output.ReplicationSubnetGroup !== undefined &&
      output.ReplicationSubnetGroup !== null
        ? deserializeAws_json1_1ReplicationSubnetGroup(
            output.ReplicationSubnetGroup,
            context
          )
        : undefined,
    SecondaryAvailabilityZone:
      output.SecondaryAvailabilityZone !== undefined &&
      output.SecondaryAvailabilityZone !== null
        ? output.SecondaryAvailabilityZone
        : undefined,
    VpcSecurityGroups:
      output.VpcSecurityGroups !== undefined &&
      output.VpcSecurityGroups !== null
        ? deserializeAws_json1_1VpcSecurityGroupMembershipList(
            output.VpcSecurityGroups,
            context
          )
        : undefined
  } as any;
};

const deserializeAws_json1_1ReplicationInstanceList = (
  output: any,
  context: __SerdeContext
): ReplicationInstance[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationInstance(entry, context)
  );
};

const deserializeAws_json1_1ReplicationInstancePrivateIpAddressList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ReplicationInstancePublicIpAddressList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1ReplicationInstanceTaskLog = (
  output: any,
  context: __SerdeContext
): ReplicationInstanceTaskLog => {
  return {
    __type: "ReplicationInstanceTaskLog",
    ReplicationInstanceTaskLogSize:
      output.ReplicationInstanceTaskLogSize !== undefined &&
      output.ReplicationInstanceTaskLogSize !== null
        ? output.ReplicationInstanceTaskLogSize
        : undefined,
    ReplicationTaskArn:
      output.ReplicationTaskArn !== undefined &&
      output.ReplicationTaskArn !== null
        ? output.ReplicationTaskArn
        : undefined,
    ReplicationTaskName:
      output.ReplicationTaskName !== undefined &&
      output.ReplicationTaskName !== null
        ? output.ReplicationTaskName
        : undefined
  } as any;
};

const deserializeAws_json1_1ReplicationInstanceTaskLogsList = (
  output: any,
  context: __SerdeContext
): ReplicationInstanceTaskLog[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationInstanceTaskLog(entry, context)
  );
};

const deserializeAws_json1_1ReplicationPendingModifiedValues = (
  output: any,
  context: __SerdeContext
): ReplicationPendingModifiedValues => {
  return {
    __type: "ReplicationPendingModifiedValues",
    AllocatedStorage:
      output.AllocatedStorage !== undefined && output.AllocatedStorage !== null
        ? output.AllocatedStorage
        : undefined,
    EngineVersion:
      output.EngineVersion !== undefined && output.EngineVersion !== null
        ? output.EngineVersion
        : undefined,
    MultiAZ:
      output.MultiAZ !== undefined && output.MultiAZ !== null
        ? output.MultiAZ
        : undefined,
    ReplicationInstanceClass:
      output.ReplicationInstanceClass !== undefined &&
      output.ReplicationInstanceClass !== null
        ? output.ReplicationInstanceClass
        : undefined
  } as any;
};

const deserializeAws_json1_1ReplicationSubnetGroup = (
  output: any,
  context: __SerdeContext
): ReplicationSubnetGroup => {
  return {
    __type: "ReplicationSubnetGroup",
    ReplicationSubnetGroupDescription:
      output.ReplicationSubnetGroupDescription !== undefined &&
      output.ReplicationSubnetGroupDescription !== null
        ? output.ReplicationSubnetGroupDescription
        : undefined,
    ReplicationSubnetGroupIdentifier:
      output.ReplicationSubnetGroupIdentifier !== undefined &&
      output.ReplicationSubnetGroupIdentifier !== null
        ? output.ReplicationSubnetGroupIdentifier
        : undefined,
    SubnetGroupStatus:
      output.SubnetGroupStatus !== undefined &&
      output.SubnetGroupStatus !== null
        ? output.SubnetGroupStatus
        : undefined,
    Subnets:
      output.Subnets !== undefined && output.Subnets !== null
        ? deserializeAws_json1_1SubnetList(output.Subnets, context)
        : undefined,
    VpcId:
      output.VpcId !== undefined && output.VpcId !== null
        ? output.VpcId
        : undefined
  } as any;
};

const deserializeAws_json1_1ReplicationSubnetGroupDoesNotCoverEnoughAZs = (
  output: any,
  context: __SerdeContext
): ReplicationSubnetGroupDoesNotCoverEnoughAZs => {
  return {
    __type: "ReplicationSubnetGroupDoesNotCoverEnoughAZs",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1ReplicationSubnetGroups = (
  output: any,
  context: __SerdeContext
): ReplicationSubnetGroup[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationSubnetGroup(entry, context)
  );
};

const deserializeAws_json1_1ReplicationTask = (
  output: any,
  context: __SerdeContext
): ReplicationTask => {
  return {
    __type: "ReplicationTask",
    CdcStartPosition:
      output.CdcStartPosition !== undefined && output.CdcStartPosition !== null
        ? output.CdcStartPosition
        : undefined,
    CdcStopPosition:
      output.CdcStopPosition !== undefined && output.CdcStopPosition !== null
        ? output.CdcStopPosition
        : undefined,
    LastFailureMessage:
      output.LastFailureMessage !== undefined &&
      output.LastFailureMessage !== null
        ? output.LastFailureMessage
        : undefined,
    MigrationType:
      output.MigrationType !== undefined && output.MigrationType !== null
        ? output.MigrationType
        : undefined,
    RecoveryCheckpoint:
      output.RecoveryCheckpoint !== undefined &&
      output.RecoveryCheckpoint !== null
        ? output.RecoveryCheckpoint
        : undefined,
    ReplicationInstanceArn:
      output.ReplicationInstanceArn !== undefined &&
      output.ReplicationInstanceArn !== null
        ? output.ReplicationInstanceArn
        : undefined,
    ReplicationTaskArn:
      output.ReplicationTaskArn !== undefined &&
      output.ReplicationTaskArn !== null
        ? output.ReplicationTaskArn
        : undefined,
    ReplicationTaskCreationDate:
      output.ReplicationTaskCreationDate !== undefined &&
      output.ReplicationTaskCreationDate !== null
        ? new Date(Math.round(output.ReplicationTaskCreationDate * 1000))
        : undefined,
    ReplicationTaskIdentifier:
      output.ReplicationTaskIdentifier !== undefined &&
      output.ReplicationTaskIdentifier !== null
        ? output.ReplicationTaskIdentifier
        : undefined,
    ReplicationTaskSettings:
      output.ReplicationTaskSettings !== undefined &&
      output.ReplicationTaskSettings !== null
        ? output.ReplicationTaskSettings
        : undefined,
    ReplicationTaskStartDate:
      output.ReplicationTaskStartDate !== undefined &&
      output.ReplicationTaskStartDate !== null
        ? new Date(Math.round(output.ReplicationTaskStartDate * 1000))
        : undefined,
    ReplicationTaskStats:
      output.ReplicationTaskStats !== undefined &&
      output.ReplicationTaskStats !== null
        ? deserializeAws_json1_1ReplicationTaskStats(
            output.ReplicationTaskStats,
            context
          )
        : undefined,
    SourceEndpointArn:
      output.SourceEndpointArn !== undefined &&
      output.SourceEndpointArn !== null
        ? output.SourceEndpointArn
        : undefined,
    Status:
      output.Status !== undefined && output.Status !== null
        ? output.Status
        : undefined,
    StopReason:
      output.StopReason !== undefined && output.StopReason !== null
        ? output.StopReason
        : undefined,
    TableMappings:
      output.TableMappings !== undefined && output.TableMappings !== null
        ? output.TableMappings
        : undefined,
    TargetEndpointArn:
      output.TargetEndpointArn !== undefined &&
      output.TargetEndpointArn !== null
        ? output.TargetEndpointArn
        : undefined
  } as any;
};

const deserializeAws_json1_1ReplicationTaskAssessmentResult = (
  output: any,
  context: __SerdeContext
): ReplicationTaskAssessmentResult => {
  return {
    __type: "ReplicationTaskAssessmentResult",
    AssessmentResults:
      output.AssessmentResults !== undefined &&
      output.AssessmentResults !== null
        ? output.AssessmentResults
        : undefined,
    AssessmentResultsFile:
      output.AssessmentResultsFile !== undefined &&
      output.AssessmentResultsFile !== null
        ? output.AssessmentResultsFile
        : undefined,
    AssessmentStatus:
      output.AssessmentStatus !== undefined && output.AssessmentStatus !== null
        ? output.AssessmentStatus
        : undefined,
    ReplicationTaskArn:
      output.ReplicationTaskArn !== undefined &&
      output.ReplicationTaskArn !== null
        ? output.ReplicationTaskArn
        : undefined,
    ReplicationTaskIdentifier:
      output.ReplicationTaskIdentifier !== undefined &&
      output.ReplicationTaskIdentifier !== null
        ? output.ReplicationTaskIdentifier
        : undefined,
    ReplicationTaskLastAssessmentDate:
      output.ReplicationTaskLastAssessmentDate !== undefined &&
      output.ReplicationTaskLastAssessmentDate !== null
        ? new Date(Math.round(output.ReplicationTaskLastAssessmentDate * 1000))
        : undefined,
    S3ObjectUrl:
      output.S3ObjectUrl !== undefined && output.S3ObjectUrl !== null
        ? output.S3ObjectUrl
        : undefined
  } as any;
};

const deserializeAws_json1_1ReplicationTaskAssessmentResultList = (
  output: any,
  context: __SerdeContext
): ReplicationTaskAssessmentResult[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationTaskAssessmentResult(entry, context)
  );
};

const deserializeAws_json1_1ReplicationTaskList = (
  output: any,
  context: __SerdeContext
): ReplicationTask[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1ReplicationTask(entry, context)
  );
};

const deserializeAws_json1_1ReplicationTaskStats = (
  output: any,
  context: __SerdeContext
): ReplicationTaskStats => {
  return {
    __type: "ReplicationTaskStats",
    ElapsedTimeMillis:
      output.ElapsedTimeMillis !== undefined &&
      output.ElapsedTimeMillis !== null
        ? output.ElapsedTimeMillis
        : undefined,
    FreshStartDate:
      output.FreshStartDate !== undefined && output.FreshStartDate !== null
        ? new Date(Math.round(output.FreshStartDate * 1000))
        : undefined,
    FullLoadFinishDate:
      output.FullLoadFinishDate !== undefined &&
      output.FullLoadFinishDate !== null
        ? new Date(Math.round(output.FullLoadFinishDate * 1000))
        : undefined,
    FullLoadProgressPercent:
      output.FullLoadProgressPercent !== undefined &&
      output.FullLoadProgressPercent !== null
        ? output.FullLoadProgressPercent
        : undefined,
    FullLoadStartDate:
      output.FullLoadStartDate !== undefined &&
      output.FullLoadStartDate !== null
        ? new Date(Math.round(output.FullLoadStartDate * 1000))
        : undefined,
    StartDate:
      output.StartDate !== undefined && output.StartDate !== null
        ? new Date(Math.round(output.StartDate * 1000))
        : undefined,
    StopDate:
      output.StopDate !== undefined && output.StopDate !== null
        ? new Date(Math.round(output.StopDate * 1000))
        : undefined,
    TablesErrored:
      output.TablesErrored !== undefined && output.TablesErrored !== null
        ? output.TablesErrored
        : undefined,
    TablesLoaded:
      output.TablesLoaded !== undefined && output.TablesLoaded !== null
        ? output.TablesLoaded
        : undefined,
    TablesLoading:
      output.TablesLoading !== undefined && output.TablesLoading !== null
        ? output.TablesLoading
        : undefined,
    TablesQueued:
      output.TablesQueued !== undefined && output.TablesQueued !== null
        ? output.TablesQueued
        : undefined
  } as any;
};

const deserializeAws_json1_1ResourceAlreadyExistsFault = (
  output: any,
  context: __SerdeContext
): ResourceAlreadyExistsFault => {
  return {
    __type: "ResourceAlreadyExistsFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined,
    resourceArn:
      output.resourceArn !== undefined && output.resourceArn !== null
        ? output.resourceArn
        : undefined
  } as any;
};

const deserializeAws_json1_1ResourceNotFoundFault = (
  output: any,
  context: __SerdeContext
): ResourceNotFoundFault => {
  return {
    __type: "ResourceNotFoundFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1ResourcePendingMaintenanceActions = (
  output: any,
  context: __SerdeContext
): ResourcePendingMaintenanceActions => {
  return {
    __type: "ResourcePendingMaintenanceActions",
    PendingMaintenanceActionDetails:
      output.PendingMaintenanceActionDetails !== undefined &&
      output.PendingMaintenanceActionDetails !== null
        ? deserializeAws_json1_1PendingMaintenanceActionDetails(
            output.PendingMaintenanceActionDetails,
            context
          )
        : undefined,
    ResourceIdentifier:
      output.ResourceIdentifier !== undefined &&
      output.ResourceIdentifier !== null
        ? output.ResourceIdentifier
        : undefined
  } as any;
};

const deserializeAws_json1_1ResourceQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): ResourceQuotaExceededFault => {
  return {
    __type: "ResourceQuotaExceededFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1S3Settings = (
  output: any,
  context: __SerdeContext
): S3Settings => {
  return {
    __type: "S3Settings",
    BucketFolder:
      output.BucketFolder !== undefined && output.BucketFolder !== null
        ? output.BucketFolder
        : undefined,
    BucketName:
      output.BucketName !== undefined && output.BucketName !== null
        ? output.BucketName
        : undefined,
    CdcInsertsOnly:
      output.CdcInsertsOnly !== undefined && output.CdcInsertsOnly !== null
        ? output.CdcInsertsOnly
        : undefined,
    CompressionType:
      output.CompressionType !== undefined && output.CompressionType !== null
        ? output.CompressionType
        : undefined,
    CsvDelimiter:
      output.CsvDelimiter !== undefined && output.CsvDelimiter !== null
        ? output.CsvDelimiter
        : undefined,
    CsvRowDelimiter:
      output.CsvRowDelimiter !== undefined && output.CsvRowDelimiter !== null
        ? output.CsvRowDelimiter
        : undefined,
    DataFormat:
      output.DataFormat !== undefined && output.DataFormat !== null
        ? output.DataFormat
        : undefined,
    DataPageSize:
      output.DataPageSize !== undefined && output.DataPageSize !== null
        ? output.DataPageSize
        : undefined,
    DictPageSizeLimit:
      output.DictPageSizeLimit !== undefined &&
      output.DictPageSizeLimit !== null
        ? output.DictPageSizeLimit
        : undefined,
    EnableStatistics:
      output.EnableStatistics !== undefined && output.EnableStatistics !== null
        ? output.EnableStatistics
        : undefined,
    EncodingType:
      output.EncodingType !== undefined && output.EncodingType !== null
        ? output.EncodingType
        : undefined,
    EncryptionMode:
      output.EncryptionMode !== undefined && output.EncryptionMode !== null
        ? output.EncryptionMode
        : undefined,
    ExternalTableDefinition:
      output.ExternalTableDefinition !== undefined &&
      output.ExternalTableDefinition !== null
        ? output.ExternalTableDefinition
        : undefined,
    IncludeOpForFullLoad:
      output.IncludeOpForFullLoad !== undefined &&
      output.IncludeOpForFullLoad !== null
        ? output.IncludeOpForFullLoad
        : undefined,
    ParquetTimestampInMillisecond:
      output.ParquetTimestampInMillisecond !== undefined &&
      output.ParquetTimestampInMillisecond !== null
        ? output.ParquetTimestampInMillisecond
        : undefined,
    ParquetVersion:
      output.ParquetVersion !== undefined && output.ParquetVersion !== null
        ? output.ParquetVersion
        : undefined,
    RowGroupLength:
      output.RowGroupLength !== undefined && output.RowGroupLength !== null
        ? output.RowGroupLength
        : undefined,
    ServerSideEncryptionKmsKeyId:
      output.ServerSideEncryptionKmsKeyId !== undefined &&
      output.ServerSideEncryptionKmsKeyId !== null
        ? output.ServerSideEncryptionKmsKeyId
        : undefined,
    ServiceAccessRoleArn:
      output.ServiceAccessRoleArn !== undefined &&
      output.ServiceAccessRoleArn !== null
        ? output.ServiceAccessRoleArn
        : undefined,
    TimestampColumnName:
      output.TimestampColumnName !== undefined &&
      output.TimestampColumnName !== null
        ? output.TimestampColumnName
        : undefined
  } as any;
};

const deserializeAws_json1_1SchemaList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1SNSInvalidTopicFault = (
  output: any,
  context: __SerdeContext
): SNSInvalidTopicFault => {
  return {
    __type: "SNSInvalidTopicFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1SNSNoAuthorizationFault = (
  output: any,
  context: __SerdeContext
): SNSNoAuthorizationFault => {
  return {
    __type: "SNSNoAuthorizationFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1SourceIdsList = (
  output: any,
  context: __SerdeContext
): string[] => {
  return (output || []).map((entry: any) => entry);
};

const deserializeAws_json1_1StartReplicationTaskAssessmentResponse = (
  output: any,
  context: __SerdeContext
): StartReplicationTaskAssessmentResponse => {
  return {
    __type: "StartReplicationTaskAssessmentResponse",
    ReplicationTask:
      output.ReplicationTask !== undefined && output.ReplicationTask !== null
        ? deserializeAws_json1_1ReplicationTask(output.ReplicationTask, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1StartReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): StartReplicationTaskResponse => {
  return {
    __type: "StartReplicationTaskResponse",
    ReplicationTask:
      output.ReplicationTask !== undefined && output.ReplicationTask !== null
        ? deserializeAws_json1_1ReplicationTask(output.ReplicationTask, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1StopReplicationTaskResponse = (
  output: any,
  context: __SerdeContext
): StopReplicationTaskResponse => {
  return {
    __type: "StopReplicationTaskResponse",
    ReplicationTask:
      output.ReplicationTask !== undefined && output.ReplicationTask !== null
        ? deserializeAws_json1_1ReplicationTask(output.ReplicationTask, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1StorageQuotaExceededFault = (
  output: any,
  context: __SerdeContext
): StorageQuotaExceededFault => {
  return {
    __type: "StorageQuotaExceededFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1Subnet = (
  output: any,
  context: __SerdeContext
): Subnet => {
  return {
    __type: "Subnet",
    SubnetAvailabilityZone:
      output.SubnetAvailabilityZone !== undefined &&
      output.SubnetAvailabilityZone !== null
        ? deserializeAws_json1_1AvailabilityZone(
            output.SubnetAvailabilityZone,
            context
          )
        : undefined,
    SubnetIdentifier:
      output.SubnetIdentifier !== undefined && output.SubnetIdentifier !== null
        ? output.SubnetIdentifier
        : undefined,
    SubnetStatus:
      output.SubnetStatus !== undefined && output.SubnetStatus !== null
        ? output.SubnetStatus
        : undefined
  } as any;
};

const deserializeAws_json1_1SubnetAlreadyInUse = (
  output: any,
  context: __SerdeContext
): SubnetAlreadyInUse => {
  return {
    __type: "SubnetAlreadyInUse",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1SubnetList = (
  output: any,
  context: __SerdeContext
): Subnet[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Subnet(entry, context)
  );
};

const deserializeAws_json1_1SupportedEndpointType = (
  output: any,
  context: __SerdeContext
): SupportedEndpointType => {
  return {
    __type: "SupportedEndpointType",
    EndpointType:
      output.EndpointType !== undefined && output.EndpointType !== null
        ? output.EndpointType
        : undefined,
    EngineDisplayName:
      output.EngineDisplayName !== undefined &&
      output.EngineDisplayName !== null
        ? output.EngineDisplayName
        : undefined,
    EngineName:
      output.EngineName !== undefined && output.EngineName !== null
        ? output.EngineName
        : undefined,
    SupportsCDC:
      output.SupportsCDC !== undefined && output.SupportsCDC !== null
        ? output.SupportsCDC
        : undefined
  } as any;
};

const deserializeAws_json1_1SupportedEndpointTypeList = (
  output: any,
  context: __SerdeContext
): SupportedEndpointType[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1SupportedEndpointType(entry, context)
  );
};

const deserializeAws_json1_1TableStatistics = (
  output: any,
  context: __SerdeContext
): TableStatistics => {
  return {
    __type: "TableStatistics",
    Ddls:
      output.Ddls !== undefined && output.Ddls !== null
        ? output.Ddls
        : undefined,
    Deletes:
      output.Deletes !== undefined && output.Deletes !== null
        ? output.Deletes
        : undefined,
    FullLoadCondtnlChkFailedRows:
      output.FullLoadCondtnlChkFailedRows !== undefined &&
      output.FullLoadCondtnlChkFailedRows !== null
        ? output.FullLoadCondtnlChkFailedRows
        : undefined,
    FullLoadErrorRows:
      output.FullLoadErrorRows !== undefined &&
      output.FullLoadErrorRows !== null
        ? output.FullLoadErrorRows
        : undefined,
    FullLoadRows:
      output.FullLoadRows !== undefined && output.FullLoadRows !== null
        ? output.FullLoadRows
        : undefined,
    Inserts:
      output.Inserts !== undefined && output.Inserts !== null
        ? output.Inserts
        : undefined,
    LastUpdateTime:
      output.LastUpdateTime !== undefined && output.LastUpdateTime !== null
        ? new Date(Math.round(output.LastUpdateTime * 1000))
        : undefined,
    SchemaName:
      output.SchemaName !== undefined && output.SchemaName !== null
        ? output.SchemaName
        : undefined,
    TableName:
      output.TableName !== undefined && output.TableName !== null
        ? output.TableName
        : undefined,
    TableState:
      output.TableState !== undefined && output.TableState !== null
        ? output.TableState
        : undefined,
    Updates:
      output.Updates !== undefined && output.Updates !== null
        ? output.Updates
        : undefined,
    ValidationFailedRecords:
      output.ValidationFailedRecords !== undefined &&
      output.ValidationFailedRecords !== null
        ? output.ValidationFailedRecords
        : undefined,
    ValidationPendingRecords:
      output.ValidationPendingRecords !== undefined &&
      output.ValidationPendingRecords !== null
        ? output.ValidationPendingRecords
        : undefined,
    ValidationState:
      output.ValidationState !== undefined && output.ValidationState !== null
        ? output.ValidationState
        : undefined,
    ValidationStateDetails:
      output.ValidationStateDetails !== undefined &&
      output.ValidationStateDetails !== null
        ? output.ValidationStateDetails
        : undefined,
    ValidationSuspendedRecords:
      output.ValidationSuspendedRecords !== undefined &&
      output.ValidationSuspendedRecords !== null
        ? output.ValidationSuspendedRecords
        : undefined
  } as any;
};

const deserializeAws_json1_1TableStatisticsList = (
  output: any,
  context: __SerdeContext
): TableStatistics[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1TableStatistics(entry, context)
  );
};

const deserializeAws_json1_1Tag = (
  output: any,
  context: __SerdeContext
): Tag => {
  return {
    __type: "Tag",
    Key:
      output.Key !== undefined && output.Key !== null ? output.Key : undefined,
    Value:
      output.Value !== undefined && output.Value !== null
        ? output.Value
        : undefined
  } as any;
};

const deserializeAws_json1_1TagList = (
  output: any,
  context: __SerdeContext
): Tag[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1Tag(entry, context)
  );
};

const deserializeAws_json1_1TestConnectionResponse = (
  output: any,
  context: __SerdeContext
): TestConnectionResponse => {
  return {
    __type: "TestConnectionResponse",
    Connection:
      output.Connection !== undefined && output.Connection !== null
        ? deserializeAws_json1_1Connection(output.Connection, context)
        : undefined
  } as any;
};

const deserializeAws_json1_1UpgradeDependencyFailureFault = (
  output: any,
  context: __SerdeContext
): UpgradeDependencyFailureFault => {
  return {
    __type: "UpgradeDependencyFailureFault",
    message:
      output.message !== undefined && output.message !== null
        ? output.message
        : undefined
  } as any;
};

const deserializeAws_json1_1VpcSecurityGroupMembership = (
  output: any,
  context: __SerdeContext
): VpcSecurityGroupMembership => {
  return {
    __type: "VpcSecurityGroupMembership",
    Status:
      output.Status !== undefined && output.Status !== null
        ? output.Status
        : undefined,
    VpcSecurityGroupId:
      output.VpcSecurityGroupId !== undefined &&
      output.VpcSecurityGroupId !== null
        ? output.VpcSecurityGroupId
        : undefined
  } as any;
};

const deserializeAws_json1_1VpcSecurityGroupMembershipList = (
  output: any,
  context: __SerdeContext
): VpcSecurityGroupMembership[] => {
  return (output || []).map((entry: any) =>
    deserializeAws_json1_1VpcSecurityGroupMembership(entry, context)
  );
};

const deserializeMetadata = (output: __HttpResponse): __ResponseMetadata => ({
  httpStatusCode: output.statusCode,
  httpHeaders: output.headers,
  requestId: output.headers["x-amzn-requestid"]
});

// Collect low-level response body stream to Uint8Array.
const collectBody = (
  streamBody: any = new Uint8Array(),
  context: __SerdeContext
): Promise<Uint8Array> => {
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return (
    context.streamCollector(streamBody) || Promise.resolve(new Uint8Array())
  );
};

// Encode Uint8Array data into string with utf-8.
const collectBodyString = (
  streamBody: any,
  context: __SerdeContext
): Promise<string> =>
  collectBody(streamBody, context).then(body => context.utf8Encoder(body));

const buildHttpRpcRequest = async (
  context: __SerdeContext,
  headers: __HeaderBag,
  path: string,
  resolvedHostname: string | undefined,
  body: any
): Promise<__HttpRequest> => {
  const { hostname, protocol = "https", port } = await context.endpoint();
  const contents: any = {
    protocol,
    hostname,
    port,
    method: "POST",
    path,
    headers
  };
  if (resolvedHostname !== undefined) {
    contents.hostname = resolvedHostname;
  }
  if (body !== undefined) {
    contents.body = body;
  }
  return new __HttpRequest(contents);
};

const parseBody = (streamBody: any, context: __SerdeContext): any =>
  collectBodyString(streamBody, context).then(encoded => {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
